"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jointjs";
exports.ids = ["vendor-chunks/jointjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/jointjs/src/V/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/jointjs/src/V/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/index.mjs\");\n// Vectorizer.\n// -----------\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nconst V = function() {\n    var hasSvg =  false && 0;\n    // SVG support is required.\n    if (!hasSvg) {\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error(\"SVG is required to use Vectorizer.\");\n        };\n    }\n    // XML namespaces.\n    var ns = {\n        svg: \"http://www.w3.org/2000/svg\",\n        xmlns: \"http://www.w3.org/2000/xmlns/\",\n        xml: \"http://www.w3.org/XML/1998/namespace\",\n        xlink: \"http://www.w3.org/1999/xlink\",\n        xhtml: \"http://www.w3.org/1999/xhtml\"\n    };\n    var SVGVersion = \"1.1\";\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n    var V = function(el, attrs, children) {\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n        if (!el) return;\n        if (V.isV(el)) {\n            el = el.node;\n        }\n        attrs = attrs || {};\n        if (V.isString(el)) {\n            el = el.trim();\n            if (el.toLowerCase() === \"svg\") {\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n            } else if (el[0] === \"<\") {\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n                var svgDoc = V.createSvgDocument(el);\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n                    for(i = 0, len = svgDoc.childNodes.length; i < len; i++){\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n                    return arrayOfVels;\n                }\n                el = document.importNode(svgDoc.firstChild, true);\n            } else {\n                el = document.createElementNS(ns.svg, el);\n            }\n            V.ensureId(el);\n        }\n        this.node = el;\n        this.setAttributes(attrs);\n        if (children) {\n            this.append(children);\n        }\n        return this;\n    };\n    var VPrototype = V.prototype;\n    Object.defineProperty(VPrototype, \"id\", {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */ VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */ VPrototype.transform = function(matrix, opt) {\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr(\"transform\"));\n        }\n        if (opt && opt.absolute) {\n            return this.attr(\"transform\", V.matrixToTransformString(matrix));\n        }\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n    VPrototype.translate = function(tx, ty, opt) {\n        opt = opt || {};\n        ty = ty || 0;\n        var transformAttr = this.attr(\"transform\") || \"\";\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, \"\").trim();\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = \"translate(\" + newTx + \",\" + newTy + \")\";\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr(\"transform\", (newTranslate + \" \" + transformAttr).trim());\n        return this;\n    };\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n        opt = opt || {};\n        var transformAttr = this.attr(\"transform\") || \"\";\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, \"\").trim();\n        angle %= 360;\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = cx !== undefined && cy !== undefined ? \",\" + cx + \",\" + cy : \"\";\n        var newRotate = \"rotate(\" + newAngle + newOrigin + \")\";\n        this.attr(\"transform\", (transformAttr + \" \" + newRotate).trim());\n        return this;\n    };\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n        sy = V.isUndefined(sy) ? sx : sy;\n        var transformAttr = this.attr(\"transform\") || \"\";\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, \"\").trim();\n        var newScale = \"scale(\" + sx + \",\" + sy + \")\";\n        this.attr(\"transform\", (transformAttr + \" \" + newScale).trim());\n        return this;\n    };\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n        try {\n            box = node.getBBox();\n        } catch (e) {\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n        if (withoutTransformations) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(box);\n        }\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n        return V.transformRect(box, matrix);\n    };\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n        var options = {};\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n        if (opt) {\n            if (opt.target) {\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else {\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n            var children = this.children();\n            var n = children.length;\n            if (n === 0) {\n                return this.getBBox({\n                    target: options.target,\n                    recursive: false\n                });\n            }\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n            for(var i = 0; i < n; i++){\n                var currentChild = children[i];\n                var childBBox;\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({\n                        target: options.target,\n                        recursive: false\n                    });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({\n                        target: options.target,\n                        recursive: true\n                    });\n                }\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n            return outputBBox;\n        }\n    };\n    // Text() helpers\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V(\"textPath\");\n        var d = attrs.d;\n        if (d && attrs[\"xlink:href\"] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V(\"path\").attr(\"d\", d).appendTo(vel.defs());\n            textPathElement.attr(\"xlink:href\", \"#\" + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for(var j = 0; j <= lastJ; j++){\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V(\"tspan\", annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs[\"class\"];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr(\"annotations\", annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs[\"font-size\"]);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || \" \");\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = maxFontSize * 1.2;\n        }\n        return fontMetrics;\n    }\n    var emRegex = /em$/;\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for(var i = 1; i < n; i++){\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch(alignment){\n            case \"middle\":\n                dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n                break;\n            case \"bottom\":\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            default:\n            case \"top\":\n                dy = 0.8 * flMaxFont;\n                break;\n        }\n        return dy;\n    }\n    VPrototype.text = function(content, opt) {\n        if (content && typeof content !== \"string\") throw new Error(\"Vectorizer: text() expects the first argument to be a string.\");\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = verticalAnchor === \"middle\" || verticalAnchor === \"bottom\" || verticalAnchor === \"top\";\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr(\"x\") || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [\n            annotations\n        ];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = defaultLineHeight === \"auto\";\n        var lineHeight = autoLineHeight ? \"1.5em\" : defaultLineHeight || \"1em\";\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            \"xml:space\": \"preserve\",\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            \"display\": content || displayEmpty ? null : \"none\"\n        });\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr(\"font-size\"));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr(\"font-size\", fontSize);\n        }\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === \"string\") textPath = {\n                d: textPath\n            };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split(\"\\n\");\n        var linesMetrics = [];\n        var annotatedY;\n        for(var i = 0, lastI = lines.length - 1; i <= lastI; i++){\n            var dy = lineHeight;\n            var lineClassName = \"v-line\";\n            var lineNode = doc.createElementNS(ns.svg, \"tspan\");\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: i !== lastI && eol,\n                        lineHeight: autoLineHeight ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = \"-\";\n                lineClassName += \" v-empty-line\";\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for(let j = lineAnnotations.length; j > 0; j--){\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !(\"font-size\" in attrs)) continue;\n                        const fs = parseFloat(attrs[\"font-size\"]);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute(\"font-size\", lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute(\"dy\", dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute(\"x\", x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1; // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === \"top\") {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = \"0.8em\";\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch(verticalAnchor){\n                    case \"middle\":\n                        dy = 0.3 - rh / 2 + \"em\";\n                        break;\n                    case \"bottom\":\n                        dy = -rh - 0.3 + \"em\";\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = \"0em\";\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr(\"y\") === null) this.attr(\"y\", annotatedY || \"0.8em\");\n            }\n        }\n        containerNode.firstChild.setAttribute(\"dy\", dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */ VPrototype.removeAttr = function(name) {\n        const trueName = attributeNames[name];\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n    VPrototype.attr = function(name, value) {\n        if (V.isUndefined(name)) {\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n            for(var i = 0; i < attributes.length; i++){\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n            return attrs;\n        }\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n        if (typeof name === \"object\") {\n            for(var attrName in name){\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n        } else {\n            this.setAttribute(name, value);\n        }\n        return this;\n    };\n    VPrototype.normalizePath = function() {\n        var tagName = this.tagName();\n        if (tagName === \"PATH\") {\n            this.attr(\"d\", V.normalizePathData(this.attr(\"d\")));\n        }\n        return this;\n    };\n    VPrototype.remove = function() {\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n        return this;\n    };\n    VPrototype.empty = function() {\n        while(this.node.firstChild){\n            this.node.removeChild(this.node.firstChild);\n        }\n        return this;\n    };\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */ VPrototype.setAttributes = function(attrs) {\n        for(var key in attrs){\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n        return this;\n    };\n    VPrototype.append = function(els) {\n        if (!V.isArray(els)) {\n            els = [\n                els\n            ];\n        }\n        for(var i = 0, len = els.length; i < len; i++){\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n        return this;\n    };\n    VPrototype.prepend = function(els) {\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n    VPrototype.before = function(els) {\n        var node = this.node;\n        var parent = node.parentNode;\n        if (parent) {\n            if (!V.isArray(els)) {\n                els = [\n                    els\n                ];\n            }\n            for(var i = 0, len = els.length; i < len; i++){\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n        return this;\n    };\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n    VPrototype.svg = function() {\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n    VPrototype.tagName = function() {\n        return this.node.tagName.toUpperCase();\n    };\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName(\"defs\")[0];\n        if (defsNode) return V(defsNode);\n        return V(\"defs\").appendTo(context);\n    };\n    VPrototype.clone = function() {\n        var clone = V(this.node.cloneNode(true));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n    VPrototype.findOne = function(selector) {\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n    VPrototype.find = function(selector) {\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n        if (nodes) {\n            // Map DOM elements to `V`s.\n            for(var i = 0; i < nodes.length; i++){\n                vels.push(V(nodes[i]));\n            }\n        }\n        return vels;\n    };\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n        var children = this.node.childNodes;\n        var outputArray = [];\n        for(var i = 0; i < children.length; i++){\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    }, // Find an index of an element inside its container.\n    VPrototype.index = function() {\n        var index = 0;\n        var node = this.node.previousSibling;\n        while(node){\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n        return index;\n    };\n    VPrototype.findParentByClass = function(className, terminator) {\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n        while(node && node !== terminator && node !== ownerSVGElement){\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n            node = node.parentNode;\n        }\n        return null;\n    };\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n    };\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n        var svg = this.svg().node;\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        try {\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n    VPrototype.translateCenterToPoint = function(p) {\n        var bbox = this.getBBox({\n            target: this.svg()\n        });\n        var center = bbox.center();\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n        position = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(position);\n        reference = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(reference);\n        target || (target = this.svg());\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr(\"transform\", \"\");\n        var bbox = this.getBBox({\n            target: target\n        }).scale(scale.sx, scale.sy);\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n        this.attr(\"transform\", V.matrixToTransformString(transform.matrix));\n        return this;\n    };\n    VPrototype.animateAlongPath = function(attrs, path) {\n        path = V.toNode(path);\n        var id = V.ensureId(path);\n        var animateMotion = V(\"animateMotion\", attrs);\n        var mpath = V(\"mpath\", {\n            \"xlink:href\": \"#\" + id\n        });\n        animateMotion.append(mpath);\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute(\"smiling\") === \"fake\") {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */ // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n                var animationID = animation.getAttribute(\"id\");\n                if (animationID) id2anim[animationID] = animation;\n                var targets = getTargets(animation);\n                for(var i = 0, len = targets.length; i < len; i++){\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for(let i = 0; i < tokens.length; i++){\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while(distance < length){\n            sample = node.getPointAtLength(distance);\n            samples.push({\n                x: sample.x,\n                y: sample.y,\n                distance: distance\n            });\n            distance += interval;\n        }\n        return samples;\n    };\n    VPrototype.convertToPath = function() {\n        var path = V(\"path\");\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr(\"d\", d);\n        }\n        return path;\n    };\n    VPrototype.convertToPathData = function() {\n        var tagName = this.tagName();\n        switch(tagName){\n            case \"PATH\":\n                return this.attr(\"d\");\n            case \"LINE\":\n                return V.convertLineToPathData(this.node);\n            case \"POLYGON\":\n                return V.convertPolygonToPathData(this.node);\n            case \"POLYLINE\":\n                return V.convertPolylineToPathData(this.node);\n            case \"ELLIPSE\":\n                return V.convertEllipseToPathData(this.node);\n            case \"CIRCLE\":\n                return V.convertCircleToPathData(this.node);\n            case \"RECT\":\n                return V.convertRectToPathData(this.node);\n        }\n        throw new Error(tagName + \" cannot be converted to PATH.\");\n    };\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch(this.tagName()){\n            case \"RECT\":\n                x = parseFloat(this.attr(\"x\")) || 0;\n                y = parseFloat(this.attr(\"y\")) || 0;\n                width = parseFloat(this.attr(\"width\")) || 0;\n                height = parseFloat(this.attr(\"height\")) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, width, height);\n            case \"CIRCLE\":\n                cx = parseFloat(this.attr(\"cx\")) || 0;\n                cy = parseFloat(this.attr(\"cy\")) || 0;\n                r = parseFloat(this.attr(\"r\")) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({\n                    x: cx,\n                    y: cy\n                }, r, r);\n            case \"ELLIPSE\":\n                cx = parseFloat(this.attr(\"cx\")) || 0;\n                cy = parseFloat(this.attr(\"cy\")) || 0;\n                rx = parseFloat(this.attr(\"rx\")) || 0;\n                ry = parseFloat(this.attr(\"ry\")) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({\n                    x: cx,\n                    y: cy\n                }, rx, ry);\n            case \"POLYLINE\":\n                points = V.getPointsFromSvgNode(this);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n            case \"POLYGON\":\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n            case \"PATH\":\n                d = this.attr(\"d\");\n                if (!_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path(d);\n            case \"LINE\":\n                x1 = parseFloat(this.attr(\"x1\")) || 0;\n                y1 = parseFloat(this.attr(\"y1\")) || 0;\n                x2 = parseFloat(this.attr(\"x2\")) || 0;\n                y2 = parseFloat(this.attr(\"y2\")) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line({\n                    x: x1,\n                    y: y1\n                }, {\n                    x: x2,\n                    y: y2\n                });\n        }\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({\n            target: target\n        });\n        var center = bbox.center();\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n        var spot;\n        var tagName = this.tagName();\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === \"RECT\") {\n            var gRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(parseFloat(this.attr(\"x\") || 0), parseFloat(this.attr(\"y\") || 0), parseFloat(this.attr(\"width\")), parseFloat(this.attr(\"height\")));\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n        } else if (tagName === \"PATH\" || tagName === \"POLYGON\" || tagName === \"POLYLINE\" || tagName === \"CIRCLE\" || tagName === \"ELLIPSE\") {\n            var pathNode = tagName === \"PATH\" ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n            var i, sample, gp, centerDistance, refDistance, distance;\n            for(i = 0; i < samples.length; i++){\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [\n                        {\n                            sample: sample,\n                            refDistance: refDistance\n                        }\n                    ];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({\n                        sample: sample,\n                        refDistance: refDistance\n                    });\n                }\n            }\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n        return spot;\n    };\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */ VPrototype.setAttribute = function(name, value) {\n        const el = this.node;\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n        const trueName = attributeNames[name];\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === \"id\") {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n        return this;\n    };\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, {\n                async: false\n            });\n            return documentElement;\n        }\n        const svg = document.createElementNS(ns.svg, \"svg\");\n        svg.setAttributeNS(ns.xmlns, \"xmlns:xlink\", ns.xlink);\n        svg.setAttribute(\"version\", SVGVersion);\n        return svg;\n    };\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V(\"style\", {\n            type: \"text/css\"\n        }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    }, V.createCDATASection = function(data = \"\") {\n        const xml = document.implementation.createDocument(null, \"xml\", null);\n        return xml.createCDATASection(data);\n    };\n    V.idCounter = 0;\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n        return \"v-\" + ++V.idCounter;\n    };\n    V.toNode = function(el) {\n        return V.isV(el) ? el.node : el.nodeName && el || el[0];\n    };\n    V.ensureId = function(node) {\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n        return (text || \"\").replace(/ /g, \"\\xa0\");\n    };\n    V.isUndefined = function(value) {\n        return typeof value === \"undefined\";\n    };\n    V.isString = function(value) {\n        return typeof value === \"string\";\n    };\n    V.isObject = function(value) {\n        return value && typeof value === \"object\";\n    };\n    V.isArray = Array.isArray;\n    V.parseXML = function(data, opt) {\n        opt = opt || {};\n        var xml;\n        try {\n            var parser = new DOMParser();\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n            xml = parser.parseFromString(data, \"text/xml\");\n        } catch (error) {\n            xml = undefined;\n        }\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n            throw new Error(\"Invalid XML: \" + data);\n        }\n        return xml;\n    };\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        \"baseFrequency\",\n        \"baseProfile\",\n        \"clipPathUnits\",\n        \"contentScriptType\",\n        \"contentStyleType\",\n        \"diffuseConstant\",\n        \"edgeMode\",\n        \"externalResourcesRequired\",\n        \"filterRes\",\n        \"filterUnits\",\n        \"gradientTransform\",\n        \"gradientUnits\",\n        \"kernelMatrix\",\n        \"kernelUnitLength\",\n        \"keyPoints\",\n        \"lengthAdjust\",\n        \"limitingConeAngle\",\n        \"markerHeight\",\n        \"markerUnits\",\n        \"markerWidth\",\n        \"maskContentUnits\",\n        \"maskUnits\",\n        \"numOctaves\",\n        \"pathLength\",\n        \"patternContentUnits\",\n        \"patternTransform\",\n        \"patternUnits\",\n        \"pointsAtX\",\n        \"pointsAtY\",\n        \"pointsAtZ\",\n        \"preserveAlpha\",\n        \"preserveAspectRatio\",\n        \"primitiveUnits\",\n        \"refX\",\n        \"refY\",\n        \"requiredExtensions\",\n        \"requiredFeatures\",\n        \"specularConstant\",\n        \"specularExponent\",\n        \"spreadMethod\",\n        \"startOffset\",\n        \"stdDeviation\",\n        \"stitchTiles\",\n        \"surfaceScale\",\n        \"systemLanguage\",\n        \"tableValues\",\n        \"targetX\",\n        \"targetY\",\n        \"textLength\",\n        \"viewBox\",\n        \"viewTarget\",\n        \"xChannelSelector\",\n        \"yChannelSelector\",\n        \"zoomAndPan\" // deprecated\n    ].forEach((name)=>_attributeNames[name] = name);\n    const attributeNames = new Proxy(_attributeNames, {\n        get (cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return cache[name] = name.replace(/[A-Z]/g, \"-$&\").toLowerCase();\n        }\n    });\n    // Note: The `attributeNames` and `supportCamelCaseAttributes` properties are not enumerable\n    // in this version to avoid breaking changes. They will be made enumerable in the next major version.\n    // Dictionary of attribute names\n    Object.defineProperty(V, \"attributeNames\", {\n        value: attributeNames,\n        writable: false\n    });\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, \"supportCamelCaseAttributes\", {\n        value: false,\n        writable: true\n    });\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */ V.qualifyAttr = function(name) {\n        if (name.indexOf(\":\") !== -1) {\n            var combinedKey = name.split(\":\");\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n        return {\n            ns: null,\n            local: name\n        };\n    };\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n    V.transformStringToMatrix = function(transform) {\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n        const numMatches = transformMatches.length;\n        for(let i = 0; i < numMatches; i++){\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch(transformFunction){\n                    case \"scale\":\n                        sx = parseFloat(args[0]);\n                        sy = args[1] === undefined ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n                    case \"translate\":\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n                    case \"rotate\":\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n                    case \"skewx\":\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n                    case \"skewy\":\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n                    case \"matrix\":\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n                    default:\n                        continue;\n                }\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n        }\n        return transformationMatrix;\n    };\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n        return \"matrix(\" + (matrix.a !== undefined ? matrix.a : 1) + \",\" + (matrix.b !== undefined ? matrix.b : 0) + \",\" + (matrix.c !== undefined ? matrix.c : 0) + \",\" + (matrix.d !== undefined ? matrix.d : 1) + \",\" + (matrix.e !== undefined ? matrix.e : 0) + \",\" + (matrix.f !== undefined ? matrix.f : 0) + \")\";\n    };\n    V.parseTransformString = function(transform) {\n        var translate, rotate, scale;\n        if (transform) {\n            var separator = V.transformSeparatorRegex;\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf(\"matrix\") >= 0) {\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [\n                    decomposedMatrix.translateX,\n                    decomposedMatrix.translateY\n                ];\n                scale = [\n                    decomposedMatrix.scaleX,\n                    decomposedMatrix.scaleY\n                ];\n                rotate = [\n                    decomposedMatrix.rotation\n                ];\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push(\"translate(\" + translate + \")\");\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push(\"scale(\" + scale + \")\");\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push(\"rotate(\" + rotate + \")\");\n                }\n                transform = transformations.join(\" \");\n            } else {\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n        var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n        return {\n            value: transform,\n            translate: {\n                tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n                ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n                cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n                cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n    V.deltaTransformPoint = function(matrix, point) {\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return {\n            x: dx,\n            y: dy\n        };\n    };\n    V.decomposeMatrix = function(matrix) {\n        // @see https://gist.github.com/2052247\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, {\n            x: 0,\n            y: 1\n        });\n        var py = V.deltaTransformPoint(matrix, {\n            x: 1,\n            y: 0\n        });\n        // calculate skew\n        var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n        var skewY = 180 / PI * atan2(py.y, py.x);\n        return {\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n        var p = {\n            x: 0,\n            y: 1\n        };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n        return {\n            angle: _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeAngle(_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n        return {\n            tx: matrix && matrix.e || 0,\n            ty: matrix && matrix.f || 0\n        };\n    };\n    V.isV = function(object) {\n        return object instanceof V;\n    };\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === \"function\";\n    };\n    var svgDocument = V(\"svg\").node;\n    V.createSVGMatrix = function(matrix) {\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for(var component in matrix){\n            svgMatrix[component] = matrix[component];\n        }\n        return svgMatrix;\n    };\n    V.createSVGTransform = function(matrix) {\n        if (!V.isUndefined(matrix)) {\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n        return svgDocument.createSVGTransform();\n    };\n    V.createSVGPoint = function(x, y) {\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n    V.transformRect = function(r, matrix) {\n        var p = svgDocument.createSVGPoint();\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n    V.transformPoint = function(p, matrix) {\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n    V.transformLine = function(l, matrix) {\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n    };\n    V.transformPolyline = function(p, matrix) {\n        var inPoints = p instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for(var i = 0, n = inPoints.length; i < n; i++)outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(outPoints);\n    };\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(\";\");\n        for(var i = 0; i < styles.length; i++){\n            var style = styles[i];\n            var pair = style.split(\"=\");\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? \"0\" : \"1\";\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n        return da >= svgArcMax ? r0 ? \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"M0,\" + r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + -r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0 + \"Z\" : \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"Z\" : r0 ? \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L\" + r0 * c1 + \",\" + r0 * s1 + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0 + \"Z\" : \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L0,0\" + \"Z\";\n    };\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n        for(var attr in b){\n            if (attr === \"class\") {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + \" \" + b[attr] : b[attr];\n            } else if (attr === \"style\") {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n        return a;\n    };\n    V.annotateString = function(t, annotations, opt) {\n        annotations = annotations || [];\n        opt = opt || {};\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n        for(var i = 0; i < t.length; i++){\n            item = ret[i] = t[i];\n            for(var j = 0; j < annotations.length; j++){\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = {\n                            t: t[i],\n                            attrs: annotation.attrs\n                        };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n            prev = ret[i - 1];\n            if (!prev) {\n                batch = item;\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || \"\") + item;\n            }\n        }\n        if (batch) {\n            compacted.push(batch);\n        }\n        return compacted;\n    };\n    V.findAnnotationsAtIndex = function(annotations, index) {\n        var found = [];\n        if (annotations) {\n            annotations.forEach(function(annotation) {\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n        return found;\n    };\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n        var found = [];\n        if (annotations) {\n            annotations.forEach(function(annotation) {\n                if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {\n                    found.push(annotation);\n                }\n            });\n        }\n        return found;\n    };\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n        if (annotations) {\n            annotations.forEach(function(annotation) {\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n        return annotations;\n    };\n    V.convertLineToPathData = function(line) {\n        line = V(line);\n        var d = [\n            \"M\",\n            line.attr(\"x1\"),\n            line.attr(\"y1\"),\n            \"L\",\n            line.attr(\"x2\"),\n            line.attr(\"y2\")\n        ].join(\" \");\n        return d;\n    };\n    V.convertPolygonToPathData = function(polygon) {\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n        return V.svgPointsToPath(points) + \" Z\";\n    };\n    V.convertPolylineToPathData = function(polyline) {\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n        return V.svgPointsToPath(points);\n    };\n    V.svgPointsToPath = function(points) {\n        for(var i = 0, n = points.length; i < n; i++){\n            points[i] = points[i].x + \" \" + points[i].y;\n        }\n        return \"M \" + points.join(\" L\");\n    };\n    V.getPointsFromSvgNode = function(node) {\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for(var i = 0, n = nodePoints.numberOfItems; i < n; i++){\n                points.push(nodePoints.getItem(i));\n            }\n        }\n        return points;\n    };\n    V.KAPPA = 0.551784;\n    V.convertCircleToPathData = function(circle) {\n        circle = V(circle);\n        var cx = parseFloat(circle.attr(\"cx\")) || 0;\n        var cy = parseFloat(circle.attr(\"cy\")) || 0;\n        var r = parseFloat(circle.attr(\"r\"));\n        var cd = r * V.KAPPA; // Control distance.\n        var d = [\n            \"M\",\n            cx,\n            cy - r,\n            \"C\",\n            cx + cd,\n            cy - r,\n            cx + r,\n            cy - cd,\n            cx + r,\n            cy,\n            \"C\",\n            cx + r,\n            cy + cd,\n            cx + cd,\n            cy + r,\n            cx,\n            cy + r,\n            \"C\",\n            cx - cd,\n            cy + r,\n            cx - r,\n            cy + cd,\n            cx - r,\n            cy,\n            \"C\",\n            cx - r,\n            cy - cd,\n            cx - cd,\n            cy - r,\n            cx,\n            cy - r,\n            \"Z\"\n        ].join(\" \");\n        return d;\n    };\n    V.convertEllipseToPathData = function(ellipse) {\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr(\"cx\")) || 0;\n        var cy = parseFloat(ellipse.attr(\"cy\")) || 0;\n        var rx = parseFloat(ellipse.attr(\"rx\"));\n        var ry = parseFloat(ellipse.attr(\"ry\")) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n        var d = [\n            \"M\",\n            cx,\n            cy - ry,\n            \"C\",\n            cx + cdx,\n            cy - ry,\n            cx + rx,\n            cy - cdy,\n            cx + rx,\n            cy,\n            \"C\",\n            cx + rx,\n            cy + cdy,\n            cx + cdx,\n            cy + ry,\n            cx,\n            cy + ry,\n            \"C\",\n            cx - cdx,\n            cy + ry,\n            cx - rx,\n            cy + cdy,\n            cx - rx,\n            cy,\n            \"C\",\n            cx - rx,\n            cy - cdy,\n            cx - cdx,\n            cy - ry,\n            cx,\n            cy - ry,\n            \"Z\"\n        ].join(\" \");\n        return d;\n    };\n    V.convertRectToPathData = function(rect) {\n        rect = V(rect);\n        return V.rectToPath({\n            x: parseFloat(rect.attr(\"x\")) || 0,\n            y: parseFloat(rect.attr(\"y\")) || 0,\n            width: parseFloat(rect.attr(\"width\")) || 0,\n            height: parseFloat(rect.attr(\"height\")) || 0,\n            rx: parseFloat(rect.attr(\"rx\")) || 0,\n            ry: parseFloat(rect.attr(\"ry\")) || 0\n        });\n    };\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r[\"top-rx\"] || 0, width / 2);\n        var bottomRx = min(r.rx || r[\"bottom-rx\"] || 0, width / 2);\n        var topRy = min(r.ry || r[\"top-ry\"] || 0, height / 2);\n        var bottomRy = min(r.ry || r[\"bottom-ry\"] || 0, height / 2);\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                \"M\",\n                x,\n                y + topRy,\n                \"v\",\n                height - topRy - bottomRy,\n                \"a\",\n                bottomRx,\n                bottomRy,\n                0,\n                0,\n                0,\n                bottomRx,\n                bottomRy,\n                \"h\",\n                width - 2 * bottomRx,\n                \"a\",\n                bottomRx,\n                bottomRy,\n                0,\n                0,\n                0,\n                bottomRx,\n                -bottomRy,\n                \"v\",\n                -(height - bottomRy - topRy),\n                \"a\",\n                topRx,\n                topRy,\n                0,\n                0,\n                0,\n                -topRx,\n                -topRy,\n                \"h\",\n                -(width - 2 * topRx),\n                \"a\",\n                topRx,\n                topRy,\n                0,\n                0,\n                0,\n                -topRx,\n                topRy,\n                \"Z\"\n            ];\n        } else {\n            d = [\n                \"M\",\n                x,\n                y,\n                \"H\",\n                x + width,\n                \"V\",\n                y + height,\n                \"H\",\n                x,\n                \"V\",\n                y,\n                \"Z\"\n            ];\n        }\n        return d.join(\" \");\n    };\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Adapted from Rappid normalizePath polyfill\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = function() {\n        var spaces = \"\t\\n\\v\\f\\r \\xa0\\u2028\\u2029\";\n        var pathCommand = new RegExp(\"([a-z])[\" + spaces + \",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[\" + spaces + \"]*,?[\" + spaces + \"]*)+)\", \"ig\");\n        var pathValues = new RegExp(\"(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[\" + spaces + \"]*,?[\" + spaces + \"]*\", \"ig\");\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n        function q2c(x1, y1, ax, ay, x2, y2) {\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n        }\n        function rotate(x, y, rad) {\n            var X = x * cos(rad) - y * sin(rad);\n            var Y = x * sin(rad) + y * cos(rad);\n            return {\n                x: X,\n                y: Y\n            };\n        }\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = PI * 120 / 180;\n            var rad = PI / 180 * (+angle || 0);\n            var res = [];\n            var xy;\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = x * x / (rx * rx) + y * y / (ry * ry);\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n                var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n                var cx = k * rx * y / ry + (x1 + x2) / 2;\n                var cy = k * -ry * x / rx + (y1 + y2) / 2;\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n                f1 = x1 < cx ? PI - f1 : f1;\n                f2 = x2 < cx ? PI - f2 : f2;\n                if (f1 < 0) f1 = PI * 2 + f1;\n                if (f2 < 0) f2 = PI * 2 + f2;\n                if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n                if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n                x2 = cx + rx * cos(f2);\n                y2 = cy + ry * sin(f2);\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n                    f2,\n                    f2old,\n                    cx,\n                    cy\n                ]);\n            }\n            df = f2 - f1;\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = 4 / 3 * (rx * t);\n            var hy = 4 / 3 * (ry * t);\n            var m1 = [\n                x1,\n                y1\n            ];\n            var m2 = [\n                x1 + hx * s1,\n                y1 - hy * c1\n            ];\n            var m3 = [\n                x2 + hx * s2,\n                y2 - hy * c2\n            ];\n            var m4 = [\n                x2,\n                y2\n            ];\n            m2[0] = 2 * m1[0] - m2[0];\n            m2[1] = 2 * m1[1] - m2[1];\n            if (recursive) {\n                return [\n                    m2,\n                    m3,\n                    m4\n                ].concat(res);\n            } else {\n                res = [\n                    m2,\n                    m3,\n                    m4\n                ].concat(res).join().split(\",\");\n                var newres = [];\n                var ii = res.length;\n                for(var i = 0; i < ii; i++){\n                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n        function parsePathString(pathString) {\n            if (!pathString) return null;\n            var paramCounts = {\n                a: 7,\n                c: 6,\n                h: 1,\n                l: 2,\n                m: 2,\n                q: 4,\n                s: 4,\n                t: 2,\n                v: 1,\n                z: 0\n            };\n            var data = [];\n            String(pathString).replace(pathCommand, function(a, b, c) {\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n                if (name === \"m\" && params.length > 2) {\n                    data.push([\n                        b\n                    ].concat(params.splice(0, 2)));\n                    name = \"l\";\n                    b = b === \"m\" ? \"l\" : \"L\";\n                }\n                while(params.length >= paramCounts[name]){\n                    data.push([\n                        b\n                    ].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n            return data;\n        }\n        function pathToAbsolute(pathArray) {\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {\n                pathArray = parsePathString(pathArray);\n            }\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [\n                [\n                    \"M\",\n                    0,\n                    0\n                ]\n            ];\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n            var ii = pathArray.length;\n            for(var i = start; i < ii; i++){\n                var r = [];\n                res.push(r);\n                var pa = pathArray[i];\n                pa0 = pa[0];\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n                    var jj;\n                    var j;\n                    switch(r[0]){\n                        case \"A\":\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n                        case \"V\":\n                            r[1] = +pa[1] + y;\n                            break;\n                        case \"H\":\n                            r[1] = +pa[1] + x;\n                            break;\n                        case \"M\":\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n                            jj = pa.length;\n                            for(j = 1; j < jj; j++){\n                                r[j] = +pa[j] + (j % 2 ? x : y);\n                            }\n                            break;\n                        default:\n                            jj = pa.length;\n                            for(j = 1; j < jj; j++){\n                                r[j] = +pa[j] + (j % 2 ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for(var k = 0; k < kk; k++){\n                        r[k] = pa[k];\n                    }\n                }\n                switch(r[0]){\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n            return res;\n        }\n        function normalize(path) {\n            var p = pathToAbsolute(path);\n            var attrs = {\n                x: 0,\n                y: 0,\n                bx: 0,\n                by: 0,\n                X: 0,\n                Y: 0,\n                qx: null,\n                qy: null\n            };\n            function processPath(path, d, pcom) {\n                var nx, ny;\n                if (!path) return [\n                    \"C\",\n                    d.x,\n                    d.y,\n                    d.x,\n                    d.y,\n                    d.x,\n                    d.y\n                ];\n                if (!(path[0] in {\n                    T: 1,\n                    Q: 1\n                })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n                switch(path[0]){\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = [\n                                \"L\",\n                                path[6],\n                                path[7]\n                            ];\n                        } else {\n                            path = [\n                                \"C\"\n                            ].concat(a2c.apply(0, [\n                                d.x,\n                                d.y\n                            ].concat(path.slice(1))));\n                        }\n                        break;\n                    case \"S\":\n                        if (pcom === \"C\" || pcom === \"S\") {\n                            nx = d.x * 2 - d.bx; // And reflect the previous\n                            ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                        } else {\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\n                            \"C\",\n                            nx,\n                            ny\n                        ].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom === \"Q\" || pcom === \"T\") {\n                            d.qx = d.x * 2 - d.qx; // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy; // to case 'S'.\n                        } else {\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\n                            \"C\"\n                        ].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\n                            \"C\"\n                        ].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"H\":\n                        path = [\n                            \"L\"\n                        ].concat(path[1], d.y);\n                        break;\n                    case \"V\":\n                        path = [\n                            \"L\"\n                        ].concat(d.x, path[1]);\n                        break;\n                    case \"L\":\n                        break;\n                    case \"Z\":\n                        break;\n                }\n                return path;\n            }\n            function fixArc(pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while(pi.length){\n                        pcoms[i] = \"A\"; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, [\n                            \"C\"\n                        ].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n            var pcoms = []; // path commands of original path p\n            var pfirst = \"\"; // temporary holder for original path command\n            var pcom = \"\"; // holder for previous path command of original path\n            var ii = p.length;\n            for(var i = 0; i < ii; i++){\n                if (p[i]) pfirst = p[i][0]; // save current path command\n                if (pfirst !== \"C\") {\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n                if (pcoms[i] !== \"A\" && pfirst === \"C\") pcoms[i] = \"C\"; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n                var seg = p[i];\n                var seglen = seg.length;\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== \"M\") {\n                p.unshift([\n                    \"M\",\n                    0,\n                    0\n                ]);\n            }\n            return p;\n        }\n        return function(pathData) {\n            return normalize(pathData).join(\",\").split(\",\").join(\" \");\n        };\n    }();\n    V.namespace = ns;\n    V.g = _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__;\n    return V;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (V);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvVi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsY0FBYztBQUNkLGNBQWM7QUFFZCxvRUFBb0U7QUFDcEUsMERBQTBEO0FBRXRCO0FBRXBDLE1BQU1DLElBQUk7SUFFTixJQUFJQyxTQUFTLE1BQWtCLElBQVksQ0FBaUI7SUFFNUQsMkJBQTJCO0lBQzNCLElBQUksQ0FBQ0EsUUFBUTtRQUVULDBEQUEwRDtRQUMxRCxPQUFPO1lBQ0gsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCO0lBQ0o7SUFFQSxrQkFBa0I7SUFDbEIsSUFBSUMsS0FBSztRQUNMQyxLQUFLO1FBQ0xDLE9BQU87UUFDUEMsS0FBSztRQUNMQyxPQUFPO1FBQ1BDLE9BQU87SUFDWDtJQUVBLElBQUlDLGFBQWE7SUFFakIsc0RBQXNEO0lBQ3RELElBQUlDLE9BQU9DO0lBQ1gsSUFBSUMsS0FBS0YsS0FBS0UsRUFBRTtJQUNoQixJQUFJQyxRQUFRSCxLQUFLRyxLQUFLO0lBQ3RCLElBQUlDLE9BQU9KLEtBQUtJLElBQUk7SUFDcEIsSUFBSUMsTUFBTUwsS0FBS0ssR0FBRztJQUNsQixJQUFJQyxNQUFNTixLQUFLTSxHQUFHO0lBQ2xCLElBQUlDLE1BQU1QLEtBQUtPLEdBQUc7SUFDbEIsSUFBSUMsTUFBTVIsS0FBS1EsR0FBRztJQUVsQixJQUFJcEIsSUFBSSxTQUFTcUIsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLFFBQVE7UUFFaEMsaURBQWlEO1FBQ2pELElBQUksQ0FBRSxLQUFJLFlBQVl2QixDQUFBQSxHQUFJO1lBQ3RCLE9BQU9BLEVBQUV3QixLQUFLLENBQUNDLE9BQU9DLE1BQU0sQ0FBQzFCLEVBQUUyQixTQUFTLEdBQUdDO1FBQy9DO1FBRUEsSUFBSSxDQUFDUCxJQUFJO1FBRVQsSUFBSXJCLEVBQUU2QixHQUFHLENBQUNSLEtBQUs7WUFDWEEsS0FBS0EsR0FBR1MsSUFBSTtRQUNoQjtRQUVBUixRQUFRQSxTQUFTLENB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QUcsQ0FBQ0MsU0FBUyxFQUFFO2dCQUN6QnhpQixNQUFNdUYsQ0FBQyxHQUFHZ2QsR0FBRyxDQUFDQyxTQUFTLEVBQUU7Z0JBRXpCeGlCLE1BQU1zaEIsRUFBRSxHQUFHcFosV0FBV3FhLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLEtBQUt4aUIsTUFBTXFGLENBQUM7Z0JBQ2pEckYsTUFBTXVoQixFQUFFLEdBQUdyWixXQUFXcWEsR0FBRyxDQUFDQyxTQUFTLEVBQUUsS0FBS3hpQixNQUFNdUYsQ0FBQztZQUNyRDtZQUVBLGlFQUFpRTtZQUNqRSxJQUFJLENBQUMwSixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssS0FBSztnQkFDN0JBLEVBQUV3VCxPQUFPLENBQUM7b0JBQUM7b0JBQUs7b0JBQUc7aUJBQUU7WUFDekI7WUFFQSxPQUFPeFQ7UUFDWDtRQUVBLE9BQU8sU0FBU3lULFFBQVE7WUFDcEIsT0FBT3JCLFVBQVVxQixVQUFVeEssSUFBSSxDQUFDLEtBQUt6TixLQUFLLENBQUMsS0FBS3lOLElBQUksQ0FBQztRQUN6RDtJQUNKO0lBRUF4WixFQUFFaWtCLFNBQVMsR0FBRzVqQjtJQUVkTCxFQUFFRCxDQUFDLEdBQUdBLHlDQUFDQTtJQUVQLE9BQU9DO0FBRVg7QUFFQSxpRUFBZUEsQ0FBQ0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL1YvaW5kZXgubWpzPzQxZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVmVjdG9yaXplci5cbi8vIC0tLS0tLS0tLS0tXG5cbi8vIEEgdGlueSBsaWJyYXJ5IGZvciBtYWtpbmcgeW91ciBsaWZlIGVhc2llciB3aGVuIGRlYWxpbmcgd2l0aCBTVkcuXG4vLyBUaGUgb25seSBWZWN0b3JpemVyIGRlcGVuZGVuY3kgaXMgdGhlIEdlb21ldHJ5IGxpYnJhcnkuXG5cbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBWID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGhhc1N2ZyA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICEhd2luZG93LlNWR0FuZ2xlO1xuXG4gICAgLy8gU1ZHIHN1cHBvcnQgaXMgcmVxdWlyZWQuXG4gICAgaWYgKCFoYXNTdmcpIHtcblxuICAgICAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHRocm93cyBhbiBlcnJvciB3aGVuIGl0IGlzIHVzZWQuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU1ZHIGlzIHJlcXVpcmVkIHRvIHVzZSBWZWN0b3JpemVyLicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFhNTCBuYW1lc3BhY2VzLlxuICAgIHZhciBucyA9IHtcbiAgICAgICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyxcbiAgICAgICAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyxcbiAgICAgICAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAgICAgeGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJ1xuICAgIH07XG5cbiAgICB2YXIgU1ZHVmVyc2lvbiA9ICcxLjEnO1xuXG4gICAgLy8gRGVjbGFyZSBzaG9ydGhhbmRzIHRvIHRoZSBtb3N0IHVzZWQgbWF0aCBmdW5jdGlvbnMuXG4gICAgdmFyIG1hdGggPSBNYXRoO1xuICAgIHZhciBQSSA9IG1hdGguUEk7XG4gICAgdmFyIGF0YW4yID0gbWF0aC5hdGFuMjtcbiAgICB2YXIgc3FydCA9IG1hdGguc3FydDtcbiAgICB2YXIgbWluID0gbWF0aC5taW47XG4gICAgdmFyIG1heCA9IG1hdGgubWF4O1xuICAgIHZhciBjb3MgPSBtYXRoLmNvcztcbiAgICB2YXIgc2luID0gbWF0aC5zaW47XG5cbiAgICB2YXIgViA9IGZ1bmN0aW9uKGVsLCBhdHRycywgY2hpbGRyZW4pIHtcblxuICAgICAgICAvLyBUaGlzIGFsbG93cyB1c2luZyBWKCkgd2l0aG91dCB0aGUgbmV3IGtleXdvcmQuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWKSkge1xuICAgICAgICAgICAgcmV0dXJuIFYuYXBwbHkoT2JqZWN0LmNyZWF0ZShWLnByb3RvdHlwZSksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKFYuaXNWKGVsKSkge1xuICAgICAgICAgICAgZWwgPSBlbC5ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcblxuICAgICAgICBpZiAoVi5pc1N0cmluZyhlbCkpIHtcblxuICAgICAgICAgICAgZWwgPSBlbC50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChlbC50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFNWRyBjYW52YXMuXG4gICAgICAgICAgICAgICAgZWwgPSBWLmNyZWF0ZVN2Z0RvY3VtZW50KCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxbMF0gPT09ICc8Jykge1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVsZW1lbnQgZnJvbSBhbiBTVkcgc3RyaW5nLlxuICAgICAgICAgICAgICAgIC8vIEFsbG93cyBjb25zdHJ1Y3RzIG9mIHR5cGU6IGBkb2N1bWVudC5hcHBlbmRDaGlsZChWKCc8cmVjdD48L3JlY3Q+Jykubm9kZSlgLlxuXG4gICAgICAgICAgICAgICAgdmFyIHN2Z0RvYyA9IFYuY3JlYXRlU3ZnRG9jdW1lbnQoZWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGBWKClgIG1pZ2h0IGFsc28gcmV0dXJuIGFuIGFycmF5IHNob3VsZCB0aGUgU1ZHIHN0cmluZyBwYXNzZWQgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgYXJndW1lbnQgY29udGFpbiBtb3JlIHRoYW4gb25lIHJvb3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoc3ZnRG9jLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcCBjaGlsZCBub2RlcyB0byBgVmBzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlPZlZlbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGxlbjtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdmdEb2MuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gc3ZnRG9jLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9mVmVscy5wdXNoKG5ldyBWKGRvY3VtZW50LmltcG9ydE5vZGUoY2hpbGROb2RlLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5T2ZWZWxzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShzdmdEb2MuZmlyc3RDaGlsZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsIGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVi5lbnN1cmVJZChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGUgPSBlbDtcblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cnMpO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoY2hpbGRyZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBWUHJvdG90eXBlID0gVi5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVlByb3RvdHlwZSwgJ2lkJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U1ZHR0VsZW1lbnR9IHRvRWxlbVxuICAgICAqIEByZXR1cm5zIHtTVkdNYXRyaXh9XG4gICAgICovXG4gICAgVlByb3RvdHlwZS5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmIChWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkgJiYgVi5pc1NWR0dyYXBoaWNzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldENUTSA9IFYudG9Ob2RlKHRhcmdldCkuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICB2YXIgbm9kZUNUTSA9IG5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q1RNICYmIG5vZGVDVE0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q1RNLmludmVyc2UoKS5tdWx0aXBseShub2RlQ1RNKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb3VsZCBub3QgZ2V0IGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U1ZHTWF0cml4fSBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG9wdFxuICAgICAqIEByZXR1cm5zIHtWZWN0b3JpemVyfFNWR01hdHJpeH0gU2V0dGVyIC8gR2V0dGVyXG4gICAgICovXG4gICAgVlByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihtYXRyaXgsIG9wdCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoVi5pc1VuZGVmaW5lZChtYXRyaXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gVi50cmFuc2Zvcm1TdHJpbmdUb01hdHJpeCh0aGlzLmF0dHIoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQgJiYgb3B0LmFic29sdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKG1hdHJpeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN2Z1RyYW5zZm9ybSA9IFYuY3JlYXRlU1ZHVHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgIG5vZGUudHJhbnNmb3JtLmJhc2VWYWwuYXBwZW5kSXRlbShzdmdUcmFuc2Zvcm0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih0eCwgdHksIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdHkgPSB0eSB8fCAwO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm1BdHRyID0gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFYucGFyc2VUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtQXR0cik7XG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm0udmFsdWU7XG4gICAgICAgIC8vIElzIGl0IGEgZ2V0dGVyP1xuICAgICAgICBpZiAoVi5pc1VuZGVmaW5lZCh0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybUF0dHIucmVwbGFjZSgvdHJhbnNsYXRlXFwoW14pXSpcXCkvZywgJycpLnRyaW0oKTtcblxuICAgICAgICB2YXIgbmV3VHggPSBvcHQuYWJzb2x1dGUgPyB0eCA6IHRyYW5zZm9ybS50cmFuc2xhdGUudHggKyB0eDtcbiAgICAgICAgdmFyIG5ld1R5ID0gb3B0LmFic29sdXRlID8gdHkgOiB0cmFuc2Zvcm0udHJhbnNsYXRlLnR5ICsgdHk7XG4gICAgICAgIHZhciBuZXdUcmFuc2xhdGUgPSAndHJhbnNsYXRlKCcgKyBuZXdUeCArICcsJyArIG5ld1R5ICsgJyknO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBgdHJhbnNsYXRlKClgIGlzIGFsd2F5cyB0aGUgZmlyc3QgdHJhbnNmb3JtYXRpb24uIFRoaXMgaXNcbiAgICAgICAgLy8gdXN1YWxseSB0aGUgZGVzaXJlZCBjYXNlLlxuICAgICAgICB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIChuZXdUcmFuc2xhdGUgKyAnICcgKyB0cmFuc2Zvcm1BdHRyKS50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgY3gsIGN5LCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybUF0dHIgPSB0aGlzLmF0dHIoJ3RyYW5zZm9ybScpIHx8ICcnO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1BdHRyKTtcbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybS52YWx1ZTtcblxuICAgICAgICAvLyBJcyBpdCBhIGdldHRlcj9cbiAgICAgICAgaWYgKFYuaXNVbmRlZmluZWQoYW5nbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnJvdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm1BdHRyLnJlcGxhY2UoL3JvdGF0ZVxcKFteKV0qXFwpL2csICcnKS50cmltKCk7XG5cbiAgICAgICAgYW5nbGUgJT0gMzYwO1xuXG4gICAgICAgIHZhciBuZXdBbmdsZSA9IG9wdC5hYnNvbHV0ZSA/IGFuZ2xlIDogdHJhbnNmb3JtLnJvdGF0ZS5hbmdsZSArIGFuZ2xlO1xuICAgICAgICB2YXIgbmV3T3JpZ2luID0gKGN4ICE9PSB1bmRlZmluZWQgJiYgY3kgIT09IHVuZGVmaW5lZCkgPyAnLCcgKyBjeCArICcsJyArIGN5IDogJyc7XG4gICAgICAgIHZhciBuZXdSb3RhdGUgPSAncm90YXRlKCcgKyBuZXdBbmdsZSArIG5ld09yaWdpbiArICcpJztcblxuICAgICAgICB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsICh0cmFuc2Zvcm1BdHRyICsgJyAnICsgbmV3Um90YXRlKS50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gTm90ZSB0aGF0IGBzY2FsZWAgYXMgdGhlIG9ubHkgdHJhbnNmb3JtYXRpb24gZG9lcyBub3QgY29tYmluZSB3aXRoIHByZXZpb3VzIHZhbHVlcy5cbiAgICBWUHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oc3gsIHN5KSB7XG5cbiAgICAgICAgc3kgPSBWLmlzVW5kZWZpbmVkKHN5KSA/IHN4IDogc3k7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybUF0dHIgPSB0aGlzLmF0dHIoJ3RyYW5zZm9ybScpIHx8ICcnO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1BdHRyKTtcbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybS52YWx1ZTtcblxuICAgICAgICAvLyBJcyBpdCBhIGdldHRlcj9cbiAgICAgICAgaWYgKFYuaXNVbmRlZmluZWQoc3gpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybUF0dHIucmVwbGFjZSgvc2NhbGVcXChbXildKlxcKS9nLCAnJykudHJpbSgpO1xuXG4gICAgICAgIHZhciBuZXdTY2FsZSA9ICdzY2FsZSgnICsgc3ggKyAnLCcgKyBzeSArICcpJztcblxuICAgICAgICB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsICh0cmFuc2Zvcm1BdHRyICsgJyAnICsgbmV3U2NhbGUpLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBHZXQgU1ZHUmVjdCB0aGF0IGNvbnRhaW5zIGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb24gb2YgdGhlIHJlYWwgYm91bmRpbmcgYm94LFxuICAgIC8vIGkuZS4gYWZ0ZXIgdHJhbnNmb3JtYXRpb25zIGFyZSBhcHBsaWVkLlxuICAgIC8vIElmIGB0YXJnZXRgIGlzIHNwZWNpZmllZCwgYm91bmRpbmcgYm94IHdpbGwgYmUgY29tcHV0ZWQgcmVsYXRpdmVseSB0byBgdGFyZ2V0YCBlbGVtZW50LlxuICAgIFZQcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKHdpdGhvdXRUcmFuc2Zvcm1hdGlvbnMsIHRhcmdldCkge1xuXG4gICAgICAgIHZhciBib3g7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICB2YXIgb3duZXJTVkdFbGVtZW50ID0gbm9kZS5vd25lclNWR0VsZW1lbnQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGluIHRoZSBsaXZlIERPTSwgaXQgZG9lcyBub3QgaGF2ZSBhIGJvdW5kaW5nIGJveCBkZWZpbmVkIGFuZFxuICAgICAgICAvLyBzbyBmYWxsIGJhY2sgdG8gJ3plcm8nIGRpbWVuc2lvbiBlbGVtZW50LlxuICAgICAgICBpZiAoIW93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBib3ggPSBub2RlLmdldEJCb3goKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBJRS5cbiAgICAgICAgICAgIGJveCA9IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLmNsaWVudExlZnQsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5jbGllbnRUb3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aXRob3V0VHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGcuUmVjdChib3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHRhcmdldCB8fCBvd25lclNWR0VsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3QoYm94LCBtYXRyaXgpO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGFuIFNWR1JlY3QgdGhhdCBjb250YWlucyBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucyBvZiB0aGUgcmVhbCBib3VuZGluZyBib3gsXG4gICAgLy8gaS5lLiBhZnRlciB0cmFuc2Zvcm1hdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAgLy8gRml4ZXMgYSBicm93c2VyIGltcGxlbWVudGF0aW9uIGJ1ZyB0aGF0IHJldHVybnMgaW5jb3JyZWN0IGJvdW5kaW5nIGJveGVzIGZvciBncm91cHMgb2Ygc3ZnIGVsZW1lbnRzLlxuICAgIC8vIFRha2VzIGFuIChPYmplY3QpIGBvcHRgIGFyZ3VtZW50IChvcHRpb25hbCkgd2l0aCB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAgLy8gKE9iamVjdCkgYHRhcmdldGAgKG9wdGlvbmFsKTogaWYgbm90IHVuZGVmaW5lZCwgdHJhbnNmb3JtIGJvdW5kaW5nIGJveGVzIHJlbGF0aXZlIHRvIGB0YXJnZXRgOyBpZiB1bmRlZmluZWQsIHRyYW5zZm9ybSByZWxhdGl2ZSB0byB0aGlzXG4gICAgLy8gKEJvb2xlYW4pIGByZWN1cnNpdmVgIChvcHRpb25hbCk6IGlmIHRydWUsIHJlY3Vyc2l2ZWx5IGVudGVyIGFsbCBncm91cHMgYW5kIGdldCBhIHVuaW9uIG9mIGVsZW1lbnQgYm91bmRpbmcgYm94ZXMgKHN2ZyBiYm94IGZpeCk7IGlmIGZhbHNlIG9yIHVuZGVmaW5lZCwgcmV0dXJuIHJlc3VsdCBvZiBuYXRpdmUgZnVuY3Rpb24gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICBWUHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIHZhciBvdXRwdXRCQm94O1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIG93bmVyU1ZHRWxlbWVudCA9IG5vZGUub3duZXJTVkdFbGVtZW50O1xuXG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBpbiB0aGUgbGl2ZSBET00sIGl0IGRvZXMgbm90IGhhdmUgYSBib3VuZGluZyBib3ggZGVmaW5lZCBhbmRcbiAgICAgICAgLy8gc28gZmFsbCBiYWNrIHRvICd6ZXJvJyBkaW1lbnNpb24gZWxlbWVudC5cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGFuIFNWR0dyYXBoaWNzRWxlbWVudCwgd2UgY291bGQgbm90IG1lYXN1cmUgdGhlIGJvdW5kaW5nIGJveCBlaXRoZXJcbiAgICAgICAgaWYgKCFvd25lclNWR0VsZW1lbnQgfHwgIVYuaXNTVkdHcmFwaGljc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZy5SZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgaWYgKG9wdC50YXJnZXQpIHsgLy8gY2hlY2sgaWYgdGFyZ2V0IGV4aXN0c1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gVi50b05vZGUob3B0LnRhcmdldCk7IC8vIHdvcmtzIGZvciBWIG9iamVjdHMsIGpxdWVyeSBvYmplY3RzLCBhbmQgbm9kZSBvYmplY3RzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LnJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVjdXJzaXZlID0gb3B0LnJlY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QkJveCA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBJRS5cbiAgICAgICAgICAgICAgICBvdXRwdXRCQm94ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBub2RlLmNsaWVudExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IG5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gbGlrZSB0aGlzICh0aGF0IGlzLCBub3QgYXQgYWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5SZWN0KG91dHB1dEJCb3gpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gbGlrZSB0YXJnZXRcbiAgICAgICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3Qob3V0cHV0QkJveCwgbWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gaWYgd2Ugd2FudCB0byBjYWxjdWxhdGUgdGhlIGJib3ggcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIC8vIGJyb3dzZXJzIHJlcG9ydCBjb3JyZWN0IGJib3ggYXJvdW5kIHN2ZyBlbGVtZW50cyAob25lIHRoYXQgZW52ZWxvcHMgdGhlIHBhdGggbGluZXMgdGlnaHRseSlcbiAgICAgICAgICAgIC8vIGJ1dCBzb21lIGJyb3dzZXJzIGZhaWwgdG8gcmVwb3J0IHRoZSBzYW1lIGJib3ggd2hlbiB0aGUgZWxlbWVudHMgYXJlIGluIGEgZ3JvdXAgKHJldHVybmluZyBhIGxvb3NlciBiYm94IHRoYXQgYWxzbyBpbmNsdWRlcyBjb250cm9sIHBvaW50cywgbGlrZSBub2RlLmdldENsaWVudFJlY3QoKSlcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBldmVuIGlmIHdlIHdyYXAgYSBzaW5nbGUgc3ZnIGVsZW1lbnQgaW50byBhIGdyb3VwIVxuICAgICAgICAgICAgLy8gdGhpcyBvcHRpb24gc2V0dGluZyBtYWtlcyB0aGUgZnVuY3Rpb24gcmVjdXJzaXZlbHkgZW50ZXIgYWxsIHRoZSBncm91cHMgZnJvbSB0aGlzIGFuZCBkZWVwZXIsIGdldCBiYm94ZXMgb2YgdGhlIGVsZW1lbnRzIGluc2lkZSwgdGhlbiByZXR1cm4gYSB1bmlvbiBvZiB0aG9zZSBiYm94ZXNcblxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QkJveCh7IHRhcmdldDogb3B0aW9ucy50YXJnZXQsIHJlY3Vyc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2lvbidzIGluaXRpYWwgcGFzcy10aHJvdWdoIHNldHRpbmc6XG4gICAgICAgICAgICAvLyByZWN1cnNpdmUgcGFzc2VzLXRocm91Z2gganVzdCBrZWVwIHRoZSB0YXJnZXQgYXMgd2hhdGV2ZXIgd2FzIHNldCB1cCBoZXJlIGR1cmluZyB0aGUgaW5pdGlhbCBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gY2hpbGRyZW4vZGVzY2VuZGFudHMgbGlrZSB0aGlzICh0aGVpciBwYXJlbnQvYW5jZXN0b3IpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgfSAvLyBlbHNlIHRyYW5zZm9ybSBjaGlsZHJlbi9kZXNjZW5kYW50cyBsaWtlIHRhcmdldFxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZEJCb3g7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50Q2hpbGQgaXMgbm90IGEgZ3JvdXAgZWxlbWVudCwgZ2V0IGl0cyBiYm94IHdpdGggYSBub25yZWN1cnNpdmUgY2FsbFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hpbGQuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gY3VycmVudENoaWxkLmdldEJCb3goeyB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LCByZWN1cnNpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRDaGlsZCBpcyBhIGdyb3VwIGVsZW1lbnQgKGRldGVybWluZWQgYnkgY2hlY2tpbmcgdGhlIG51bWJlciBvZiBjaGlsZHJlbiksIGVudGVyIGl0IHdpdGggYSByZWN1cnNpdmUgY2FsbFxuICAgICAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBjdXJyZW50Q2hpbGQuZ2V0QkJveCh7IHRhcmdldDogb3B0aW9ucy50YXJnZXQsIHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW91dHB1dEJCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEJCb3ggPSBjaGlsZEJCb3g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIG5ldyBib3VuZGluZyBib3ggcmVjdGFuZ2xlIHRoYXQgY29udGFpbnMgdGhpcyBjaGlsZCdzIGJvdW5kaW5nIGJveCBhbmQgcHJldmlvdXMgYm91bmRpbmcgYm94XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEJCb3ggPSBvdXRwdXRCQm94LnVuaW9uKGNoaWxkQkJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QkJveDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUZXh0KCkgaGVscGVyc1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGV4dFBhdGhOb2RlKGF0dHJzLCB2ZWwpIHtcbiAgICAgICAgYXR0cnMgfHwgKGF0dHJzID0ge30pO1xuICAgICAgICB2YXIgdGV4dFBhdGhFbGVtZW50ID0gVigndGV4dFBhdGgnKTtcbiAgICAgICAgdmFyIGQgPSBhdHRycy5kO1xuICAgICAgICBpZiAoZCAmJiBhdHRyc1sneGxpbms6aHJlZiddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIElmIGBvcHQuYXR0cnNgIGlzIGEgcGxhaW4gc3RyaW5nLCBjb25zaWRlciBpdCB0byBiZSBkaXJlY3RseSB0aGVcbiAgICAgICAgICAgIC8vIFNWRyBwYXRoIGRhdGEgZm9yIHRoZSB0ZXh0IHRvIGdvIGFsb25nICh0aGlzIGlzIGEgc2hvcnRjdXQpLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIGl0IGlzIGFuIG9iamVjdCBhbmQgY29udGFpbnMgdGhlIGBkYCBwcm9wZXJ0eSwgdGhlbiB0aGlzIGlzIG91ciBwYXRoLlxuICAgICAgICAgICAgLy8gV3JhcCB0aGUgdGV4dCBpbiB0aGUgU1ZHIDx0ZXh0UGF0aD4gZWxlbWVudCB0aGF0IHBvaW50c1xuICAgICAgICAgICAgLy8gdG8gYSBwYXRoIGRlZmluZWQgYnkgYG9wdC5hdHRyc2AgaW5zaWRlIHRoZSBgPGRlZnM+YCBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIGxpbmtlZFBhdGggPSBWKCdwYXRoJykuYXR0cignZCcsIGQpLmFwcGVuZFRvKHZlbC5kZWZzKCkpO1xuICAgICAgICAgICAgdGV4dFBhdGhFbGVtZW50LmF0dHIoJ3hsaW5rOmhyZWYnLCAnIycgKyBsaW5rZWRQYXRoLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVi5pc09iamVjdChhdHRycykpIHtcbiAgICAgICAgICAgIC8vIFNldCBhdHRyaWJ1dGVzIG9uIHRoZSBgPHRleHRQYXRoPmAuIFRoZSBtb3N0IGltcG9ydGFudCBvbmVcbiAgICAgICAgICAgIC8vIGlzIHRoZSBgeGxpbms6aHJlZmAgdGhhdCBwb2ludHMgdG8gb3VyIG5ld2x5IGNyZWF0ZWQgYDxwYXRoLz5gIGVsZW1lbnQgaW4gYDxkZWZzLz5gLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFsc28gYWxsb3cgdGhlIGZvbGxvd2luZyBjb25zdHJ1Y3Q6XG4gICAgICAgICAgICAvLyBgdC50ZXh0KCdteSB0ZXh0JywgeyB0ZXh0UGF0aDogeyAneGxpbms6aHJlZic6ICcjbXktb3RoZXItcGF0aCcgfSB9KWAuXG4gICAgICAgICAgICAvLyBJbiBvdGhlciB3b3Jkcywgb25lIGNhbiBjb21wbGV0ZWx5IHNraXAgdGhlIGF1dG8tY3JlYXRpb24gb2YgdGhlIHBhdGhcbiAgICAgICAgICAgIC8vIGFuZCB1c2UgYW55IG90aGVyIGFyYml0cmFyeSBwYXRoIHRoYXQgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgdGV4dFBhdGhFbGVtZW50LmF0dHIoYXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0UGF0aEVsZW1lbnQubm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbm5vdGF0ZVRleHRMaW5lKGxpbmVOb2RlLCBsaW5lQW5ub3RhdGlvbnMsIG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgdmFyIGluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlcyA9IG9wdC5pbmNsdWRlQW5ub3RhdGlvbkluZGljZXM7XG4gICAgICAgIHZhciBlb2wgPSBvcHQuZW9sO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IG9wdC5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgYmFzZVNpemUgPSBvcHQuYmFzZVNpemU7XG4gICAgICAgIHZhciBtYXhGb250U2l6ZSA9IDA7XG4gICAgICAgIHZhciBmb250TWV0cmljcyA9IHt9O1xuICAgICAgICB2YXIgbGFzdEogPSBsaW5lQW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gbGFzdEo7IGorKykge1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBsaW5lQW5ub3RhdGlvbnNbal07XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKFYuaXNPYmplY3QoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkF0dHJzID0gYW5ub3RhdGlvbi5hdHRycztcbiAgICAgICAgICAgICAgICB2YXIgdlRTcGFuID0gVigndHNwYW4nLCBhbm5vdGF0aW9uQXR0cnMpO1xuICAgICAgICAgICAgICAgIHZhciB0c3Bhbk5vZGUgPSB2VFNwYW4ubm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGFubm90YXRpb24udDtcbiAgICAgICAgICAgICAgICBpZiAoZW9sICYmIGogPT09IGxhc3RKKSB0ICs9IGVvbDtcbiAgICAgICAgICAgICAgICB0c3Bhbk5vZGUudGV4dENvbnRlbnQgPSB0O1xuICAgICAgICAgICAgICAgIC8vIFBlciBhbm5vdGF0aW9uIGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQ2xhc3MgPSBhbm5vdGF0aW9uQXR0cnNbJ2NsYXNzJ107XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25DbGFzcykgdlRTcGFuLmFkZENsYXNzKGFubm90YXRpb25DbGFzcyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYG9wdC5pbmNsdWRlQW5ub3RhdGlvbkluZGljZXNgIGlzIGB0cnVlYCxcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGxpc3Qgb2YgaW5kaWNlcyBvZiBhbGwgdGhlIGFwcGxpZWQgYW5ub3RhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgYGFubm90YXRpb25zYCBhdHRyaWJ1dGUuIFRoaXMgbGlzdCBpcyBhIGNvbW1hXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVkIGxpc3Qgb2YgaW5kaWNlcy5cbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUFubm90YXRpb25JbmRpY2VzKSB2VFNwYW4uYXR0cignYW5ub3RhdGlvbnMnLCBhbm5vdGF0aW9uLmFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbWF4IGZvbnQgc2l6ZVxuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gcGFyc2VGbG9hdChhbm5vdGF0aW9uQXR0cnNbJ2ZvbnQtc2l6ZSddKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGZvbnRTaXplKSkgZm9udFNpemUgPSBiYXNlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemUgJiYgZm9udFNpemUgPiBtYXhGb250U2l6ZSkgbWF4Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVvbCAmJiBqID09PSBsYXN0SikgYW5ub3RhdGlvbiArPSBlb2w7XG4gICAgICAgICAgICAgICAgdHNwYW5Ob2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYW5ub3RhdGlvbiB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlU2l6ZSAmJiBiYXNlU2l6ZSA+IG1heEZvbnRTaXplKSBtYXhGb250U2l6ZSA9IGJhc2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU5vZGUuYXBwZW5kQ2hpbGQodHNwYW5Ob2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhGb250U2l6ZSkgZm9udE1ldHJpY3MubWF4Rm9udFNpemUgPSBtYXhGb250U2l6ZTtcbiAgICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgIGZvbnRNZXRyaWNzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKG1heEZvbnRTaXplKSB7XG4gICAgICAgICAgICBmb250TWV0cmljcy5saW5lSGVpZ2h0ID0gKG1heEZvbnRTaXplICogMS4yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udE1ldHJpY3M7XG4gICAgfVxuXG4gICAgdmFyIGVtUmVnZXggPSAvZW0kLztcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRFbVRvUHgoZW0sIGZvbnRTaXplKSB7XG4gICAgICAgIHZhciBudW1lcmljYWwgPSBwYXJzZUZsb2F0KGVtKTtcbiAgICAgICAgaWYgKGVtUmVnZXgudGVzdChlbSkpIHJldHVybiBudW1lcmljYWwgKiBmb250U2l6ZTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWNhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVEWShhbGlnbm1lbnQsIGxpbmVzTWV0cmljcywgYmFzZVNpemVQeCwgbGluZUhlaWdodCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGluZXNNZXRyaWNzKSkgcmV0dXJuIDA7XG4gICAgICAgIHZhciBuID0gbGluZXNNZXRyaWNzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFuKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGxpbmVNZXRyaWNzID0gbGluZXNNZXRyaWNzWzBdO1xuICAgICAgICB2YXIgZmxNYXhGb250ID0gY29udmVydEVtVG9QeChsaW5lTWV0cmljcy5tYXhGb250U2l6ZSwgYmFzZVNpemVQeCkgfHwgYmFzZVNpemVQeDtcbiAgICAgICAgdmFyIHJMaW5lSGVpZ2h0cyA9IDA7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0UHggPSBjb252ZXJ0RW1Ub1B4KGxpbmVIZWlnaHQsIGJhc2VTaXplUHgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGluZU1ldHJpY3MgPSBsaW5lc01ldHJpY3NbaV07XG4gICAgICAgICAgICB2YXIgaUxpbmVIZWlnaHQgPSBjb252ZXJ0RW1Ub1B4KGxpbmVNZXRyaWNzLmxpbmVIZWlnaHQsIGJhc2VTaXplUHgpIHx8IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgIHJMaW5lSGVpZ2h0cyArPSBpTGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGxNYXhGb250ID0gY29udmVydEVtVG9QeChsaW5lTWV0cmljcy5tYXhGb250U2l6ZSwgYmFzZVNpemVQeCkgfHwgYmFzZVNpemVQeDtcbiAgICAgICAgdmFyIGR5O1xuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBkeSA9IChmbE1heEZvbnQgLyAyKSAtICgwLjE1ICogbGxNYXhGb250KSAtIChyTGluZUhlaWdodHMgLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgZHkgPSAtKDAuMjUgKiBsbE1heEZvbnQpIC0gckxpbmVIZWlnaHRzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgZHkgPSAoMC44ICogZmxNYXhGb250KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHk7XG4gICAgfVxuXG4gICAgVlByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24oY29udGVudCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKGNvbnRlbnQgJiYgdHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ1ZlY3Rvcml6ZXI6IHRleHQoKSBleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIHN0cmluZy4nKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBzcGFjZXMgd2l0aCB0aGUgVW5pY29kZSBOby1icmVhayBzcGFjZSAoaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vaW5mby91bmljb2RlL2NoYXIvYTAvaW5kZXguaHRtKS5cbiAgICAgICAgLy8gSUUgd291bGQgb3RoZXJ3aXNlIGNvbGxhcHNlIGFsbCBzcGFjZXMgaW50byBvbmUuXG4gICAgICAgIGNvbnRlbnQgPSBWLnNhbml0aXplVGV4dChjb250ZW50KTtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIC8vIFNob3VsZCB3ZSBhbGxvdyB0aGUgdGV4dCB0byBiZSBzZWxlY3RlZD9cbiAgICAgICAgdmFyIGRpc3BsYXlFbXB0eSA9IG9wdC5kaXNwbGF5RW1wdHk7XG4gICAgICAgIC8vIEVuZCBvZiBMaW5lIGNoYXJhY3RlclxuICAgICAgICB2YXIgZW9sID0gb3B0LmVvbDtcbiAgICAgICAgLy8gVGV4dCBhbG9uZyBwYXRoXG4gICAgICAgIHZhciB0ZXh0UGF0aCA9IG9wdC50ZXh0UGF0aDtcbiAgICAgICAgLy8gVmVydGljYWwgc2hpZnRcbiAgICAgICAgdmFyIHZlcnRpY2FsQW5jaG9yID0gb3B0LnRleHRWZXJ0aWNhbEFuY2hvcjtcbiAgICAgICAgdmFyIG5hbWVkVmVydGljYWxBbmNob3IgPSAodmVydGljYWxBbmNob3IgPT09ICdtaWRkbGUnIHx8IHZlcnRpY2FsQW5jaG9yID09PSAnYm90dG9tJyB8fCB2ZXJ0aWNhbEFuY2hvciA9PT0gJ3RvcCcpO1xuICAgICAgICAvLyBIb3Jpem9udGFsIHNoaWZ0IGFwcGxpZWQgdG8gYWxsIHRoZSBsaW5lcyBidXQgdGhlIGZpcnN0LlxuICAgICAgICB2YXIgeCA9IG9wdC54O1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gdGhpcy5hdHRyKCd4JykgfHwgMDtcbiAgICAgICAgLy8gQW5ub3RhdGlvbnNcbiAgICAgICAgdmFyIGlhaSA9IG9wdC5pbmNsdWRlQW5ub3RhdGlvbkluZGljZXM7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IG9wdC5hbm5vdGF0aW9ucztcbiAgICAgICAgaWYgKGFubm90YXRpb25zICYmICFWLmlzQXJyYXkoYW5ub3RhdGlvbnMpKSBhbm5vdGF0aW9ucyA9IFthbm5vdGF0aW9uc107XG4gICAgICAgIC8vIFNoaWZ0IGFsbCB0aGUgPHRzcGFuPiBidXQgZmlyc3QgYnkgb25lIGxpbmUgKGAxZW1gKVxuICAgICAgICB2YXIgZGVmYXVsdExpbmVIZWlnaHQgPSBvcHQubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGF1dG9MaW5lSGVpZ2h0ID0gKGRlZmF1bHRMaW5lSGVpZ2h0ID09PSAnYXV0bycpO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IChhdXRvTGluZUhlaWdodCkgPyAnMS41ZW0nIDogKGRlZmF1bHRMaW5lSGVpZ2h0IHx8ICcxZW0nKTtcbiAgICAgICAgLy8gQ2xlYXJpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5lbXB0eSgpO1xuICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgc3BhY2VzLiBJbiBvdGhlciB3b3Jkcywgd2UgZG8gbm90IHdhbnQgY29uc2VjdXRpdmUgc3BhY2VzIHRvIGdldCBjb2xsYXBzZWQgdG8gb25lLlxuICAgICAgICAgICAgJ3htbDpzcGFjZSc6ICdwcmVzZXJ2ZScsXG4gICAgICAgICAgICAvLyBBbiBlbXB0eSB0ZXh0IGdldHMgcmVuZGVyZWQgaW50byB0aGUgRE9NIGluIHdlYmtpdC1iYXNlZCBicm93c2Vycy5cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHVuaWZ5IHRoaXMgYmVoYXZpb3VyIGFjcm9zcyBhbGwgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHdlIHJhdGhlciBoaWRlIHRoZSB0ZXh0IGVsZW1lbnQgd2hlbiBpdCdzIGVtcHR5LlxuICAgICAgICAgICAgJ2Rpc3BsYXknOiAoY29udGVudCB8fCBkaXNwbGF5RW1wdHkpID8gbnVsbCA6ICdub25lJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCBmb250LXNpemUgaWYgbm9uZVxuICAgICAgICB2YXIgZm9udFNpemUgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignZm9udC1zaXplJykpO1xuICAgICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgICAgICBmb250U2l6ZSA9IDE2O1xuICAgICAgICAgICAgaWYgKG5hbWVkVmVydGljYWxBbmNob3IgfHwgYW5ub3RhdGlvbnMpIHRoaXMuYXR0cignZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICAgICAgICB2YXIgY29udGFpbmVyTm9kZTtcbiAgICAgICAgaWYgKHRleHRQYXRoKSB7XG4gICAgICAgICAgICAvLyBOb3cgYWxsIHRoZSBgPHRzcGFuPmBzIHdpbGwgYmUgaW5zaWRlIHRoZSBgPHRleHRQYXRoPmAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHRQYXRoID09PSAnc3RyaW5nJykgdGV4dFBhdGggPSB7IGQ6IHRleHRQYXRoIH07XG4gICAgICAgICAgICBjb250YWluZXJOb2RlID0gY3JlYXRlVGV4dFBhdGhOb2RlKHRleHRQYXRoLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lck5vZGUgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIGxpbmVzTWV0cmljcyA9IFtdO1xuICAgICAgICB2YXIgYW5ub3RhdGVkWTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxhc3RJID0gbGluZXMubGVuZ3RoIC0gMTsgaSA8PSBsYXN0STsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHkgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGxpbmVDbGFzc05hbWUgPSAndi1saW5lJztcbiAgICAgICAgICAgIHZhciBsaW5lTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLCAndHNwYW4nKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICB2YXIgbGluZU1ldHJpY3M7XG4gICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSAqY29tcGFjdGVkKiBhbm5vdGF0aW9ucyBmb3IgdGhpcyBsaW5lLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUFubm90YXRpb25zID0gVi5hbm5vdGF0ZVN0cmluZyhsaW5lLCBhbm5vdGF0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAtb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUFubm90YXRpb25JbmRpY2VzOiBpYWlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVNZXRyaWNzID0gYW5ub3RhdGVUZXh0TGluZShsaW5lTm9kZSwgbGluZUFubm90YXRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlQW5ub3RhdGlvbkluZGljZXM6IGlhaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvbDogKGkgIT09IGxhc3RJICYmIGVvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAoYXV0b0xpbmVIZWlnaHQpID8gbnVsbCA6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2l6ZTogZm9udFNpemVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGJpZ2dlc3QgZm9udCBzaXplIGluIHRoZSBhbm5vdGF0aW9ucyBmb3IgdGhpcyBsaW5lLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaUxpbmVIZWlnaHQgPSBsaW5lTWV0cmljcy5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaUxpbmVIZWlnaHQgJiYgYXV0b0xpbmVIZWlnaHQgJiYgaSAhPT0gMCkgZHkgPSBpTGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGFubm90YXRlZFkgPSBsaW5lTWV0cmljcy5tYXhGb250U2l6ZSAqIDAuODtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9sICYmIGkgIT09IGxhc3RJKSBsaW5lICs9IGVvbDtcbiAgICAgICAgICAgICAgICAgICAgbGluZU5vZGUudGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0ZXh0Q29udGVudCBpcyBuZXZlciBlbXB0eS4gSWYgaXQgaXMsIGFkZCBhIGR1bW15XG4gICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGFuZCBtYWtlIGl0IGludmlzaWJsZSwgbWFraW5nIHRoZSBmb2xsb3dpbmcgbGluZXMgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gcmVsYXRpdmVseSBwb3NpdGlvbmVkLiBgZHk9MWVtYCB3b24ndCB3b3JrIHdpdGggZW1wdHkgbGluZXMgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLnRleHRDb250ZW50ID0gJy0nO1xuICAgICAgICAgICAgICAgIGxpbmVDbGFzc05hbWUgKz0gJyB2LWVtcHR5LWxpbmUnO1xuICAgICAgICAgICAgICAgIC8vICdvcGFjaXR5JyBuZWVkcyB0byBiZSBzcGVjaWZpZWQgd2l0aCBmaWxsLCBzdHJva2UuIE9wYWNpdHkgd2l0aG91dCBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IGFwcGxpZWQgaW4gRmlyZWZveFxuICAgICAgICAgICAgICAgIHZhciBsaW5lTm9kZVN0eWxlID0gbGluZU5vZGUuc3R5bGU7XG4gICAgICAgICAgICAgICAgbGluZU5vZGVTdHlsZS5maWxsT3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgbGluZU5vZGVTdHlsZS5zdHJva2VPcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgbGluZSB3aXRoIGFubm90YXRpb25zLlxuICAgICAgICAgICAgICAgICAgICBsaW5lTWV0cmljcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBsaW5lQW5ub3RhdGlvbnMgPSBWLmZpbmRBbm5vdGF0aW9uc0F0SW5kZXgoYW5ub3RhdGlvbnMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lRm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBhbm5vdGF0aW9ucyBvdmVycmlkZXMgdGhlIGZvbnQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGxpbmVBbm5vdGF0aW9ucy5sZW5ndGg7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gbGluZUFubm90YXRpb25zW2ogLSAxXS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXR0cnMgfHwgISgnZm9udC1zaXplJyBpbiBhdHRycykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSBwYXJzZUZsb2F0KGF0dHJzWydmb250LXNpemUnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUZvbnRTaXplID0gZnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9MaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSA9IGxpbmVGb250U2l6ZSAqIDEuMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkWSA9IGxpbmVGb250U2l6ZSAqIDAuODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9udCBzaXplIGlzIGltcG9ydGFudCBmb3IgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gYm94IGhlaWdodC5cbiAgICAgICAgICAgICAgICAgICAgbGluZU5vZGUuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBsaW5lRm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lTWV0cmljcy5tYXhGb250U2l6ZSA9IGxpbmVGb250U2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZU1ldHJpY3MpIGxpbmVzTWV0cmljcy5wdXNoKGxpbmVNZXRyaWNzKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkgbGluZU5vZGUuc2V0QXR0cmlidXRlKCdkeScsIGR5KTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgJ3gnIHRvIGJlIHNldCBvbiB0aGUgZmlyc3QgbGluZSB3aGVuIGluc2lkZSBhIHRleHQgcGF0aFxuICAgICAgICAgICAgaWYgKGkgPiAwIHx8IHRleHRQYXRoKSBsaW5lTm9kZS5zZXRBdHRyaWJ1dGUoJ3gnLCB4KTtcbiAgICAgICAgICAgIGxpbmVOb2RlLmNsYXNzTmFtZS5iYXNlVmFsID0gbGluZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQobGluZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxpbmUubGVuZ3RoICsgMTsgICAgICAvLyArIDEgPSBuZXdsaW5lIGNoYXJhY3Rlci5cbiAgICAgICAgfVxuICAgICAgICAvLyBZIEFsaWdubWVudCBjYWxjdWxhdGlvblxuICAgICAgICBpZiAobmFtZWRWZXJ0aWNhbEFuY2hvcikge1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZHkgPSBjYWxjdWxhdGVEWSh2ZXJ0aWNhbEFuY2hvciwgbGluZXNNZXRyaWNzLCBmb250U2l6ZSwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZlcnRpY2FsQW5jaG9yID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIC8vIEEgc2hvcnRjdXQgZm9yIHRvcCBhbGlnbm1lbnQuIEl0IGRvZXMgbm90IGRlcGVuZCBvbiBmb250LXNpemUgbm9yIGxpbmUtaGVpZ2h0XG4gICAgICAgICAgICAgICAgZHkgPSAnMC44ZW0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmg7IC8vIHJlbWFpbmluZyBoZWlnaHRcbiAgICAgICAgICAgICAgICBpZiAobGFzdEkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJoID0gcGFyc2VGbG9hdChsaW5lSGVpZ2h0KSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICByaCAqPSBsYXN0STtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbVJlZ2V4LnRlc3QobGluZUhlaWdodCkpIHJoIC89IGZvbnRTaXplO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmdsZS1saW5lIHRleHRcbiAgICAgICAgICAgICAgICAgICAgcmggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9ICgwLjMgLSAocmggLyAyKSkgKyAnZW0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9ICgtcmggLSAwLjMpICsgJ2VtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbEFuY2hvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGR5ID0gJzBlbSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZlcnRpY2FsQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2ZXJ0aWNhbEFuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gdmVydGljYWwgYW5jaG9yIGlzIGRlZmluZWRcbiAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSB3ZSBjaGFuZ2UgdGhlIGB5YCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBgZHlgLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHIoJ3knKSA9PT0gbnVsbCkgdGhpcy5hdHRyKCd5JywgYW5ub3RhdGVkWSB8fCAnMC44ZW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXJOb2RlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCdkeScsIGR5KTtcbiAgICAgICAgLy8gQXBwZW5kaW5nIGxpbmVzIHRvIHRoZSBlbGVtZW50LlxuICAgICAgICB0aGlzLmFwcGVuZChjb250YWluZXJOb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtWZWN0b3JpemVyfVxuICAgICAqL1xuICAgIFZQcm90b3R5cGUucmVtb3ZlQXR0ciA9IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICBjb25zdCB0cnVlTmFtZSA9IGF0dHJpYnV0ZU5hbWVzW25hbWVdO1xuXG4gICAgICAgIGNvbnN0IHsgbnMsIGxvY2FsIH0gPSBWLnF1YWxpZnlBdHRyKHRydWVOYW1lKTtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLm5vZGU7XG5cbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlTlMobnMsIGxvY2FsKSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBsb2NhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWwuaGFzQXR0cmlidXRlKHRydWVOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKHRydWVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoVi5pc1VuZGVmaW5lZChuYW1lKSkge1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJpYnV0ZXNbaV0ubmFtZV0gPSBhdHRyaWJ1dGVzW2ldLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVi5pc1N0cmluZyhuYW1lKSAmJiBWLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZXNbbmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyTmFtZSBpbiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuYW1lW2F0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMudGFnTmFtZSgpO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ1BBVEgnKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoJ2QnLCBWLm5vcm1hbGl6ZVBhdGhEYXRhKHRoaXMuYXR0cignZCcpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyc1xuICAgICAqIEByZXR1cm5zIHtWZWN0b3JpemVyfVxuICAgICAqL1xuICAgIFZQcm90b3R5cGUuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihlbHMpIHtcblxuICAgICAgICBpZiAoIVYuaXNBcnJheShlbHMpKSB7XG4gICAgICAgICAgICBlbHMgPSBbZWxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChWLnRvTm9kZShlbHNbaV0pKTsgLy8gbGd0bSBbanMveHNzLXRocm91Z2gtZG9tXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGVscykge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMubm9kZS5maXJzdENoaWxkO1xuICAgICAgICByZXR1cm4gY2hpbGQgPyBWKGNoaWxkKS5iZWZvcmUoZWxzKSA6IHRoaXMuYXBwZW5kKGVscyk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24oZWxzKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuXG4gICAgICAgICAgICBpZiAoIVYuaXNBcnJheShlbHMpKSB7XG4gICAgICAgICAgICAgICAgZWxzID0gW2Vsc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKFYudG9Ob2RlKGVsc1tpXSksIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIFYudG9Ob2RlKG5vZGUpLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7IC8vIGxndG0gW2pzL3hzcy10aHJvdWdoLWRvbV1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdTVkdFbGVtZW50ID8gdGhpcyA6IFYodGhpcy5ub2RlLm93bmVyU1ZHRWxlbWVudCk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmRlZnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnN2ZygpIHx8IHRoaXM7XG4gICAgICAgIHZhciBkZWZzTm9kZSA9IGNvbnRleHQubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGVmcycpWzBdO1xuICAgICAgICBpZiAoZGVmc05vZGUpIHJldHVybiBWKGRlZnNOb2RlKTtcbiAgICAgICAgcmV0dXJuIFYoJ2RlZnMnKS5hcHBlbmRUbyhjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbG9uZSA9IFYodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlLyogZGVlcCAqLykpO1xuICAgICAgICAvLyBOb3RlIHRoYXQgY2xvbmUgaW5oZXJpdHMgYWxzbyBJRC4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNoYW5nZSBpdCBoZXJlLlxuICAgICAgICBjbG9uZS5ub2RlLmlkID0gVi51bmlxdWVJZCgpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cbiAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZm91bmQgPyBWKGZvdW5kKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblxuICAgICAgICB2YXIgdmVscyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKG5vZGVzKSB7XG5cbiAgICAgICAgICAgIC8vIE1hcCBET00gZWxlbWVudHMgdG8gYFZgcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZWxzLnB1c2goVihub2Rlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlbHM7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgViBlbGVtZW50cyBtYWRlIGZyb20gY2hpbGRyZW4gb2YgdGhpcy5ub2RlLlxuICAgIFZQcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICB2YXIgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goVihjaGlsZHJlbltpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgViBlbGVtZW50IGZyb20gcGFyZW50Tm9kZSBvZiB0aGlzLm5vZGUuXG4gICAgVlByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFYodGhpcy5ub2RlLnBhcmVudE5vZGUpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYW4gaW5kZXggb2YgYW4gZWxlbWVudCBpbnNpZGUgaXRzIGNvbnRhaW5lci5cbiAgICBWUHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAvLyBub2RlVHlwZSAxIGZvciBFTEVNRU5UX05PREVcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSBpbmRleCsrO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmZpbmRQYXJlbnRCeUNsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lLCB0ZXJtaW5hdG9yKSB7XG5cbiAgICAgICAgdmFyIG93bmVyU1ZHRWxlbWVudCA9IHRoaXMubm9kZS5vd25lclNWR0VsZW1lbnQ7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gdGVybWluYXRvciAmJiBub2RlICE9PSBvd25lclNWR0VsZW1lbnQpIHtcblxuICAgICAgICAgICAgdmFyIHZlbCA9IFYobm9kZSk7XG4gICAgICAgICAgICBpZiAodmVsLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9nZXQtY29tbW9uLXBhcmVudFxuICAgIFZQcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgIHZhciBhID0gdGhpcy5ub2RlO1xuICAgICAgICB2YXIgYiA9IFYudG9Ob2RlKGVsKTtcbiAgICAgICAgdmFyIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXG4gICAgICAgIHJldHVybiAoYSA9PT0gYnVwKSB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNikpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0IGdsb2JhbCBwb2ludCBpbnRvIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgZWxlbWVudC5cbiAgICBWUHJvdG90eXBlLnRvTG9jYWxQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICB2YXIgc3ZnID0gdGhpcy5zdmcoKS5ub2RlO1xuXG4gICAgICAgIHZhciBwID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgIHAueCA9IHg7XG4gICAgICAgIHAueSA9IHk7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgdmFyIGdsb2JhbFBvaW50ID0gcC5tYXRyaXhUcmFuc2Zvcm0oc3ZnLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsVG9Mb2NhbE1hdHJpeCA9IHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHN2ZykuaW52ZXJzZSgpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFOSB0aHJvd3MgYW4gZXhjZXB0aW9uIGluIG9kZCBjYXNlcy4gKGBVbmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc2ApXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1ha2UgZG8gd2l0aCB0aGUgb3JpZ2luYWwgY29vcmRpYW5hdGVzLlxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsUG9pbnQubWF0cml4VHJhbnNmb3JtKGdsb2JhbFRvTG9jYWxNYXRyaXgpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnRyYW5zbGF0ZUNlbnRlclRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goeyB0YXJnZXQ6IHRoaXMuc3ZnKCkgfSk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBiYm94LmNlbnRlcigpO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKHAueCAtIGNlbnRlci54LCBwLnkgLSBjZW50ZXIueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBFZmZpY2llbnRseSBhdXRvLW9yaWVudCBhbiBlbGVtZW50LiBUaGlzIGJhc2ljYWxseSBpbXBsZW1lbnRzIHRoZSBvcmllbnQ9YXV0byBhdHRyaWJ1dGVcbiAgICAvLyBvZiBtYXJrZXJzLiBUaGUgZWFzaWVzdCB3YXkgb2YgdW5kZXJzdGFuZGluZyBvbiB3aGF0IHRoaXMgZG9lcyBpcyB0byBpbWFnaW5lIHRoZSBlbGVtZW50IGlzIGFuXG4gICAgLy8gYXJyb3doZWFkLiBDYWxsaW5nIHRoaXMgbWV0aG9kIG9uIHRoZSBhcnJvd2hlYWQgbWFrZXMgaXQgcG9pbnQgdG8gdGhlIGBwb3NpdGlvbmAgcG9pbnQgd2hpbGVcbiAgICAvLyBiZWluZyBhdXRvLW9yaWVudGVkIChwcm9wZXJseSByb3RhdGVkKSB0b3dhcmRzIHRoZSBgcmVmZXJlbmNlYCBwb2ludC5cbiAgICAvLyBgdGFyZ2V0YCBpcyB0aGUgZWxlbWVudCByZWxhdGl2ZSB0byB3aGljaCB0aGUgdHJhbnNmb3JtYXRpb25zIGFyZSBhcHBsaWVkLiBVc3VhbGx5IGEgdmlld3BvcnQuXG4gICAgVlByb3RvdHlwZS50cmFuc2xhdGVBbmRBdXRvT3JpZW50ID0gZnVuY3Rpb24ocG9zaXRpb24sIHJlZmVyZW5jZSwgdGFyZ2V0KSB7XG5cbiAgICAgICAgcG9zaXRpb24gPSBuZXcgZy5Qb2ludChwb3NpdGlvbik7XG4gICAgICAgIHJlZmVyZW5jZSA9ICBuZXcgZy5Qb2ludChyZWZlcmVuY2UpO1xuICAgICAgICB0YXJnZXQgfHwgKHRhcmdldCA9IHRoaXMuc3ZnKCkpO1xuXG4gICAgICAgIC8vIENsZWFuLXVwIHByZXZpb3VzbHkgc2V0IHRyYW5zZm9ybWF0aW9ucyBleGNlcHQgdGhlIHNjYWxlLiBJZiB3ZSBkaWRuJ3QgY2xlYW4gdXAgdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIHRyYW5zZm9ybWF0aW9ucyB0aGVuIHRoZXknZCBhZGQgdXAgd2l0aCB0aGUgb2xkIG9uZXMuIFNjYWxlIGlzIGFuIGV4Y2VwdGlvbiBhc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IGFkZCB1cCwgY29uc2lkZXI6IGB0aGlzLnNjYWxlKDIpLnNjYWxlKDIpLnNjYWxlKDIpYC4gVGhlIHJlc3VsdCBpcyB0aGF0IHRoZVxuICAgICAgICAvLyBlbGVtZW50IGlzIHNjYWxlZCBieSB0aGUgZmFjdG9yIDIsIG5vdCA4LlxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKCk7XG4gICAgICAgIHRoaXMuYXR0cigndHJhbnNmb3JtJywgJycpO1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCh7IHRhcmdldDogdGFyZ2V0IH0pLnNjYWxlKHNjYWxlLnN4LCBzY2FsZS5zeSk7XG5cbiAgICAgICAgLy8gMS4gVHJhbnNsYXRlIHRvIG9yaWdpbi5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZVRvT3JpZ2luID0gVi5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgICAgICAgdHJhbnNsYXRlVG9PcmlnaW4uc2V0VHJhbnNsYXRlKC1iYm94LnggLSBiYm94LndpZHRoIC8gMiwgLWJib3gueSAtIGJib3guaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgLy8gMi4gUm90YXRlIGFyb3VuZCBvcmlnaW4uXG4gICAgICAgIHZhciByb3RhdGVBcm91bmRPcmlnaW4gPSBWLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICB2YXIgYW5nbGUgPSBwb3NpdGlvbi5hbmdsZUJldHdlZW4ocmVmZXJlbmNlLCBwb3NpdGlvbi5jbG9uZSgpLm9mZnNldCgxLCAwKSk7XG4gICAgICAgIGlmIChhbmdsZSkgcm90YXRlQXJvdW5kT3JpZ2luLnNldFJvdGF0ZShhbmdsZSwgMCwgMCk7XG5cbiAgICAgICAgLy8gMy4gVHJhbnNsYXRlIHRvIHRoZSBgcG9zaXRpb25gICsgdGhlIG9mZnNldCAoaGFsZiBteSB3aWR0aCkgdG93YXJkcyB0aGUgYHJlZmVyZW5jZWAgcG9pbnQuXG4gICAgICAgIHZhciB0cmFuc2xhdGVGcm9tT3JpZ2luID0gVi5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIGZpbmFsUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpLm1vdmUocmVmZXJlbmNlLCBiYm94LndpZHRoIC8gMik7XG4gICAgICAgIHRyYW5zbGF0ZUZyb21PcmlnaW4uc2V0VHJhbnNsYXRlKDIgKiBwb3NpdGlvbi54IC0gZmluYWxQb3NpdGlvbi54LCAyICogcG9zaXRpb24ueSAtIGZpbmFsUG9zaXRpb24ueSk7XG5cbiAgICAgICAgLy8gNC4gR2V0IHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGlzIG5vZGVcbiAgICAgICAgdmFyIGN0bSA9IHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHRhcmdldCk7XG5cbiAgICAgICAgLy8gNS4gQXBwbHkgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGUgc2NhbGVcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFYuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgIHRyYW5zZm9ybS5zZXRNYXRyaXgoXG4gICAgICAgICAgICB0cmFuc2xhdGVGcm9tT3JpZ2luLm1hdHJpeC5tdWx0aXBseShcbiAgICAgICAgICAgICAgICByb3RhdGVBcm91bmRPcmlnaW4ubWF0cml4Lm11bHRpcGx5KFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVUb09yaWdpbi5tYXRyaXgubXVsdGlwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdG0uc2NhbGUoc2NhbGUuc3gsIHNjYWxlLnN5KSkpKSk7XG5cbiAgICAgICAgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybS5tYXRyaXgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5hbmltYXRlQWxvbmdQYXRoID0gZnVuY3Rpb24oYXR0cnMsIHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gVi50b05vZGUocGF0aCk7XG5cbiAgICAgICAgdmFyIGlkID0gVi5lbnN1cmVJZChwYXRoKTtcbiAgICAgICAgdmFyIGFuaW1hdGVNb3Rpb24gPSBWKCdhbmltYXRlTW90aW9uJywgYXR0cnMpO1xuICAgICAgICB2YXIgbXBhdGggPSBWKCdtcGF0aCcsIHsgJ3hsaW5rOmhyZWYnOiAnIycgKyBpZCB9KTtcblxuICAgICAgICBhbmltYXRlTW90aW9uLmFwcGVuZChtcGF0aCk7XG5cbiAgICAgICAgdGhpcy5hcHBlbmQoYW5pbWF0ZU1vdGlvbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhbmltYXRlTW90aW9uLm5vZGUuYmVnaW5FbGVtZW50KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBJRSA5LlxuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbmltYXRpb24gcHJvZ3JhbW1hdGljYWxseSBpZiBGYWtlU21pbGUgKGBodHRwOi8vbGV1bmVuLm1lL2Zha2VzbWlsZS9gKSBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnc21pbGluZycpID09PSAnZmFrZScpIHtcbiAgICAgICAgICAgICAgICAvKiBnbG9iYWwgZ2V0VGFyZ2V0czp0cnVlLCBBbmltYXRvcjp0cnVlLCBhbmltYXRvcnM6dHJ1ZSBpZDJhbmltOnRydWUgKi9cbiAgICAgICAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgYW5pbWF0aW9uLiAoU2VlIGBodHRwczovL2Fuc3dlcnMubGF1bmNocGFkLm5ldC9zbWlsLytxdWVzdGlvbi8yMDMzMzNgKVxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRlTW90aW9uLm5vZGU7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmFuaW1hdG9ycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbklEID0gYW5pbWF0aW9uLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSUQpIGlkMmFuaW1bYW5pbWF0aW9uSURdID0gYW5pbWF0aW9uO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBnZXRUYXJnZXRzKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb24sIHRhcmdldCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmFuaW1hdG9yc1tpXSA9IGFuaW1hdG9yO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRvci5yZWdpc3RlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cbiAgICAvLyBTcGxpdCBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktd2hpdGVzcGFjZVxuICAgIGNvbnN0IG5vSFRNTFdoaXRlc3BhY2VSZWdleCA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcbiAgICBmdW5jdGlvbiBnZXRUb2tlbkxpc3Qoc3RyKSB7XG4gICAgICAgIGlmICghVi5pc1N0cmluZyhzdHIpKSByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBzdHIudHJpbSgpLm1hdGNoKG5vSFRNTFdoaXRlc3BhY2VSZWdleCkgfHwgW107XG4gICAgfVxuXG4gICAgVlByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoIVYuaXNTdHJpbmcoY2xhc3NOYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUudHJpbSgpKTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCguLi5nZXRUb2tlbkxpc3QoY2xhc3NOYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QucmVtb3ZlKC4uLmdldFRva2VuTGlzdChjbGFzc05hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUsIHRvQWRkKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuTGlzdChjbGFzc05hbWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC50b2dnbGUodG9rZW5zW2ldLCB0b0FkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEludGVycG9sYXRlIHBhdGggYnkgZGlzY3JldGUgcG9pbnRzLiBUaGUgcHJlY2lzaW9uIG9mIHRoZSBzYW1wbGluZ1xuICAgIC8vIGlzIGNvbnRyb2xsZWQgYnkgYGludGVydmFsYC4gSW4gb3RoZXIgd29yZHMsIGBzYW1wbGUoKWAgd2lsbCBnZW5lcmF0ZVxuICAgIC8vIGEgcG9pbnQgb24gdGhlIHBhdGggc3RhcnRpbmcgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCBnb2luZyB0byB0aGUgZW5kXG4gICAgLy8gZXZlcnkgYGludGVydmFsYCBwaXhlbHMuXG4gICAgLy8gVGhlIHNhbXBsZXIgY2FuIGJlIHZlcnkgdXNlZnVsIGZvciBlLmcuIGZpbmRpbmcgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvXG4gICAgLy8gcGF0aHMgKGZpbmRpbmcgdGhlIHR3byBjbG9zZXN0IHBvaW50cyBmcm9tIHR3byBzYW1wbGVzKS5cbiAgICBWUHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG5cbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAxO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdmFyIHNhbXBsZXMgPSBbXTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIHNhbXBsZTtcbiAgICAgICAgd2hpbGUgKGRpc3RhbmNlIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzYW1wbGUgPSBub2RlLmdldFBvaW50QXRMZW5ndGgoZGlzdGFuY2UpO1xuICAgICAgICAgICAgc2FtcGxlcy5wdXNoKHsgeDogc2FtcGxlLngsIHk6IHNhbXBsZS55LCBkaXN0YW5jZTogZGlzdGFuY2UgfSk7XG4gICAgICAgICAgICBkaXN0YW5jZSArPSBpbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5jb252ZXJ0VG9QYXRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSBWKCdwYXRoJyk7XG4gICAgICAgIHBhdGguYXR0cih0aGlzLmF0dHIoKSk7XG4gICAgICAgIHZhciBkID0gdGhpcy5jb252ZXJ0VG9QYXRoRGF0YSgpO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgcGF0aC5hdHRyKCdkJywgZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuY29udmVydFRvUGF0aERhdGEgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMudGFnTmFtZSgpO1xuXG4gICAgICAgIHN3aXRjaCAodGFnTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnUEFUSCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcpO1xuICAgICAgICAgICAgY2FzZSAnTElORSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydExpbmVUb1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjYXNlICdQT0xZR09OJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0UG9seWdvblRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ1BPTFlMSU5FJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0UG9seWxpbmVUb1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjYXNlICdFTExJUFNFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0RWxsaXBzZVRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ0NJUkNMRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydENpcmNsZVRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ1JFQ1QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRSZWN0VG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRhZ05hbWUgKyAnIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gUEFUSC4nKTtcbiAgICB9O1xuXG4gICAgVi5wcm90b3R5cGUudG9HZW9tZXRyeVNoYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjeCwgY3ksIHIsIHJ4LCByeSwgcG9pbnRzLCBkLCB4MSwgeDIsIHkxLCB5MjtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRhZ05hbWUoKSkge1xuXG4gICAgICAgICAgICBjYXNlICdSRUNUJzpcbiAgICAgICAgICAgICAgICB4ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3gnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICB5ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3knKSkgfHwgMDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd3aWR0aCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdoZWlnaHQnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgY2FzZSAnQ0lSQ0xFJzpcbiAgICAgICAgICAgICAgICBjeCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdjeCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGN5ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2N5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdyJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLkVsbGlwc2UoeyB4OiBjeCwgeTogY3kgfSwgciwgcik7XG5cbiAgICAgICAgICAgIGNhc2UgJ0VMTElQU0UnOlxuICAgICAgICAgICAgICAgIGN4ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2N4JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY3kgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignY3knKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByeCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdyeCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJ5ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3J5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLkVsbGlwc2UoeyB4OiBjeCwgeTogY3kgfSwgcngsIHJ5KTtcblxuICAgICAgICAgICAgY2FzZSAnUE9MWUxJTkUnOlxuICAgICAgICAgICAgICAgIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlBvbHlsaW5lKHBvaW50cyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1BPTFlHT04nOlxuICAgICAgICAgICAgICAgIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5Qb2x5bGluZShwb2ludHMpO1xuXG4gICAgICAgICAgICBjYXNlICdQQVRIJzpcbiAgICAgICAgICAgICAgICBkID0gdGhpcy5hdHRyKCdkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFnLlBhdGguaXNEYXRhU3VwcG9ydGVkKGQpKSBkID0gVi5ub3JtYWxpemVQYXRoRGF0YShkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuUGF0aChkKTtcblxuICAgICAgICAgICAgY2FzZSAnTElORSc6XG4gICAgICAgICAgICAgICAgeDEgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneDEnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICB5MSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd5MScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHgyID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3gyJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgeTIgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneTInKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuTGluZSh7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYSByZWN0YW5nbGVcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpO1xuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gb2YgYSBsaW5lIHN0YXJ0aW5nIGluIHRoZSBjZW50ZXJcbiAgICAvLyBvZiB0aGUgU1ZHIGBub2RlYCBlbmRpbmcgaW4gdGhlIHBvaW50IGByZWZgLlxuICAgIC8vIGB0YXJnZXRgIGlzIGFuIFNWRyBlbGVtZW50IHRvIHdoaWNoIGBub2RlYHMgdHJhbnNmb3JtYXRpb25zIGFyZSByZWxhdGl2ZSB0by5cbiAgICAvLyBOb3RlIHRoYXQgYHJlZmAgcG9pbnQgbXVzdCBiZSBpbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGB0YXJnZXRgIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgLy8gUmV0dXJucyBhIHBvaW50IGluIHRoZSBgdGFyZ2V0YCBjb29yZGluYXRlIHN5c3RlbSAodGhlIHNhbWUgc3lzdGVtIGFzIGByZWZgIGlzIGluKSBpZlxuICAgIC8vIGFuIGludGVyc2VjdGlvbiBpcyBmb3VuZC4gUmV0dXJucyBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAgVlByb3RvdHlwZS5maW5kSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocmVmLCB0YXJnZXQpIHtcblxuICAgICAgICB2YXIgc3ZnID0gdGhpcy5zdmcoKS5ub2RlO1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgc3ZnO1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCh7IHRhcmdldDogdGFyZ2V0IH0pO1xuICAgICAgICB2YXIgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcblxuICAgICAgICBpZiAoIWJib3guaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludChyZWYpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBzcG90O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMudGFnTmFtZSgpO1xuXG4gICAgICAgIC8vIExpdHRsZSBzcGVlZCB1cCBvcHRpbWl6YXRpb24gZm9yIGA8cmVjdD5gIGVsZW1lbnQuIFdlIGRvIG5vdCBkbyBjb252ZXJzaW9uXG4gICAgICAgIC8vIHRvIHBhdGggZWxlbWVudCBhbmQgc2FtcGxpbmcgYnV0IGRpcmVjdGx5IGNhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHRocm91Z2hcbiAgICAgICAgLy8gYSB0cmFuc2Zvcm1lZCBnZW9tZXRyaWNhbCByZWN0YW5nbGUuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnUkVDVCcpIHtcblxuICAgICAgICAgICAgdmFyIGdSZWN0ID0gbmV3IGcuUmVjdChcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMuYXR0cigneCcpIHx8IDApLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5hdHRyKCd5JykgfHwgMCksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3dpZHRoJykpLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5hdHRyKCdoZWlnaHQnKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlY3QgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGggcmVnYXJkcyB0byB0aGUgU1ZHIGRvY3VtZW50LlxuICAgICAgICAgICAgdmFyIHJlY3RNYXRyaXggPSB0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICAgICAgLy8gRGVjb21wb3NlIHRoZSBtYXRyaXggdG8gZmluZCB0aGUgcm90YXRpb24gYW5nbGUuXG4gICAgICAgICAgICB2YXIgcmVjdE1hdHJpeENvbXBvbmVudHMgPSBWLmRlY29tcG9zZU1hdHJpeChyZWN0TWF0cml4KTtcbiAgICAgICAgICAgIC8vIE5vdyB3ZSB3YW50IHRvIHJvdGF0ZSB0aGUgcmVjdGFuZ2xlIGJhY2sgc28gdGhhdCB3ZVxuICAgICAgICAgICAgLy8gY2FuIHVzZSBgaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludCgpYCBwYXNzaW5nIHRoZSBhbmdsZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAgICAgICAgdmFyIHJlc2V0Um90YXRpb24gPSBzdmcuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICByZXNldFJvdGF0aW9uLnNldFJvdGF0ZSgtcmVjdE1hdHJpeENvbXBvbmVudHMucm90YXRpb24sIGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFYudHJhbnNmb3JtUmVjdChnUmVjdCwgcmVzZXRSb3RhdGlvbi5tYXRyaXgubXVsdGlwbHkocmVjdE1hdHJpeCkpO1xuICAgICAgICAgICAgc3BvdCA9IChuZXcgZy5SZWN0KHJlY3QpKS5pbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50KHJlZiwgcmVjdE1hdHJpeENvbXBvbmVudHMucm90YXRpb24pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1BBVEgnIHx8IHRhZ05hbWUgPT09ICdQT0xZR09OJyB8fCB0YWdOYW1lID09PSAnUE9MWUxJTkUnIHx8IHRhZ05hbWUgPT09ICdDSVJDTEUnIHx8IHRhZ05hbWUgPT09ICdFTExJUFNFJykge1xuXG4gICAgICAgICAgICB2YXIgcGF0aE5vZGUgPSAodGFnTmFtZSA9PT0gJ1BBVEgnKSA/IHRoaXMgOiB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcbiAgICAgICAgICAgIHZhciBzYW1wbGVzID0gcGF0aE5vZGUuc2FtcGxlKCk7XG4gICAgICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0U2FtcGxlcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgaSwgc2FtcGxlLCBncCwgY2VudGVyRGlzdGFuY2UsIHJlZkRpc3RhbmNlLCBkaXN0YW5jZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc2FtcGxlIHBvaW50IGluIHRoZSBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgICAgICAgIGdwID0gVi5jcmVhdGVTVkdQb2ludChzYW1wbGUueCwgc2FtcGxlLnkpO1xuICAgICAgICAgICAgICAgIGdwID0gZ3AubWF0cml4VHJhbnNmb3JtKHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHNhbXBsZSA9IG5ldyBnLlBvaW50KGdwKTtcbiAgICAgICAgICAgICAgICBjZW50ZXJEaXN0YW5jZSA9IHNhbXBsZS5kaXN0YW5jZShjZW50ZXIpO1xuICAgICAgICAgICAgICAgIC8vIFBlbmFsaXplIGEgaGlnaGVyIGRpc3RhbmNlIHRvIHRoZSByZWZlcmVuY2UgcG9pbnQgYnkgMTAlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMuIFRoaXMgaXMgZHVlIHRvXG4gICAgICAgICAgICAgICAgLy8gaW5hY2N1cmFjaWVzIGludHJvZHVjZWQgYnkgcm91bmRpbmcgZXJyb3JzIGFuZCBnZXRQb2ludEF0TGVuZ3RoKCkgcmV0dXJucy5cbiAgICAgICAgICAgICAgICByZWZEaXN0YW5jZSA9IHNhbXBsZS5kaXN0YW5jZShyZWYpICogMS4xO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gY2VudGVyRGlzdGFuY2UgKyByZWZEaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGVzID0gW3sgc2FtcGxlOiBzYW1wbGUsIHJlZkRpc3RhbmNlOiByZWZEaXN0YW5jZSB9XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGVzLnB1c2goeyBzYW1wbGU6IHNhbXBsZSwgcmVmRGlzdGFuY2U6IHJlZkRpc3RhbmNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvc2VzdFNhbXBsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmVmRGlzdGFuY2UgLSBiLnJlZkRpc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjbG9zZXN0U2FtcGxlc1swXSkge1xuICAgICAgICAgICAgICAgIHNwb3QgPSBjbG9zZXN0U2FtcGxlc1swXS5zYW1wbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BvdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtWZWN0b3JpemVyfVxuICAgICAqL1xuICAgIFZQcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblxuICAgICAgICBjb25zdCBlbCA9IHRoaXMubm9kZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cihuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJ1ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tuYW1lXTtcblxuICAgICAgICBjb25zdCB7IG5zIH0gPSBWLnF1YWxpZnlBdHRyKHRydWVOYW1lKTtcbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGJlIG5hbWVzcGFjZWQuIEUuZy4gYGltYWdlYCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaGF2ZSBhIGB4bGluazpocmVmYCBhdHRyaWJ1dGUgdG8gc2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlLlxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMobnMsIHRydWVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJ1ZU5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIGVsLmlkID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUodHJ1ZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYW4gU1ZHIGRvY3VtZW50IGVsZW1lbnQuXG4gICAgLy8gSWYgYGNvbnRlbnRgIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBTVkcgY29udGVudCBvZiB0aGUgYDxzdmc+YCByb290IGVsZW1lbnQuXG4gICAgVi5jcmVhdGVTdmdEb2N1bWVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblxuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgWE1MU3RyaW5nID0gYDxzdmcgeG1sbnM9XCIke25zLnN2Z31cIiB4bWxuczp4bGluaz1cIiR7bnMueGxpbmt9XCIgdmVyc2lvbj1cIiR7U1ZHVmVyc2lvbn1cIj4ke2NvbnRlbnR9PC9zdmc+YDtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnRFbGVtZW50IH0gPSBWLnBhcnNlWE1MKFhNTFN0cmluZywgeyBhc3luYzogZmFsc2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgJ3N2ZycpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlTlMobnMueG1sbnMsICd4bWxuczp4bGluaycsIG5zLnhsaW5rKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsIFNWR1ZlcnNpb24pO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG5cbiAgICBWLmNyZWF0ZVNWR1N0eWxlID0gZnVuY3Rpb24oc3R5bGVzaGVldCkge1xuICAgICAgICBjb25zdCB7IG5vZGUgfSA9IFYoJ3N0eWxlJywgeyB0eXBlOiAndGV4dC9jc3MnIH0sIFtcbiAgICAgICAgICAgIFYuY3JlYXRlQ0RBVEFTZWN0aW9uKHN0eWxlc2hlZXQpXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgVi5jcmVhdGVDREFUQVNlY3Rpb24gPSBmdW5jdGlvbihkYXRhID0gJycpIHtcbiAgICAgICAgY29uc3QgeG1sID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQobnVsbCwgJ3htbCcsIG51bGwpO1xuICAgICAgICByZXR1cm4geG1sLmNyZWF0ZUNEQVRBU2VjdGlvbihkYXRhKTtcbiAgICB9O1xuXG4gICAgVi5pZENvdW50ZXIgPSAwO1xuXG4gICAgLy8gQSBmdW5jdGlvbiByZXR1cm5pbmcgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBjbGllbnQgc2Vzc2lvbiB3aXRoIGV2ZXJ5IGNhbGwuXG4gICAgVi51bmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAndi0nICsgKCsrVi5pZENvdW50ZXIpO1xuICAgIH07XG5cbiAgICBWLnRvTm9kZSA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgcmV0dXJuIFYuaXNWKGVsKSA/IGVsLm5vZGUgOiAoZWwubm9kZU5hbWUgJiYgZWwgfHwgZWxbMF0pO1xuICAgIH07XG5cbiAgICBWLmVuc3VyZUlkID0gZnVuY3Rpb24obm9kZSkge1xuXG4gICAgICAgIG5vZGUgPSBWLnRvTm9kZShub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuaWQgfHwgKG5vZGUuaWQgPSBWLnVuaXF1ZUlkKCkpO1xuICAgIH07XG5cbiAgICAvLyBSZXBsYWNlIGFsbCBzcGFjZXMgd2l0aCB0aGUgVW5pY29kZSBOby1icmVhayBzcGFjZSAoaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vaW5mby91bmljb2RlL2NoYXIvYTAvaW5kZXguaHRtKS5cbiAgICAvLyBJRSB3b3VsZCBvdGhlcndpc2UgY29sbGFwc2UgYWxsIHNwYWNlcyBpbnRvIG9uZS4gVGhpcyBpcyB1c2VkIGluIHRoZSB0ZXh0KCkgbWV0aG9kIGJ1dCBpdCBpc1xuICAgIC8vIGFsc28gZXhwb3NlZCBzbyB0aGF0IHRoZSBwcm9ncmFtbWVyIGNhbiB1c2UgaXQgaW4gY2FzZSBoZSBuZWVkcyB0by4gVGhpcyBpcyB1c2VmdWwgZS5nLiBpbiB0ZXN0c1xuICAgIC8vIHdoZW4geW91IHdhbnQgdG8gY29tcGFyZSB0aGUgYWN0dWFsIERPTSB0ZXh0IGNvbnRlbnQgd2l0aG91dCBoYXZpbmcgdG8gYWRkIHRoZSB1bmljb2RlIGNoYXJhY3RlciBpblxuICAgIC8vIHRoZSBwbGFjZSBvZiBhbGwgc3BhY2VzLlxuICAgIFYuc2FuaXRpemVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuXG4gICAgICAgIHJldHVybiAodGV4dCB8fCAnJykucmVwbGFjZSgvIC9nLCAnXFx1MDBBMCcpO1xuICAgIH07XG5cbiAgICBWLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgICB9O1xuXG4gICAgVi5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfTtcblxuICAgIFYuaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG4gICAgfTtcblxuICAgIFYuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICBWLnBhcnNlWE1MID0gZnVuY3Rpb24oZGF0YSwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciB4bWw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cbiAgICAgICAgICAgIGlmICghVi5pc1VuZGVmaW5lZChvcHQuYXN5bmMpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFzeW5jID0gb3B0LmFzeW5jO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4bWwgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGRhdGEsICd0ZXh0L3htbCcpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgeG1sID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFhNTDogJyArIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhtbDtcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGFuIGVtcHR5IG9iamVjdCB3aGljaCBkb2VzIG5vdCBpbmhlcml0IGFueSBwcm9wZXJ0aWVzIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgIC8vIFRoaXMgaXMgdXNlZnVsIHdoZW4gd2Ugd2FudCB0byB1c2UgYW4gb2JqZWN0IGFzIGEgZGljdGlvbmFyeSB3aXRob3V0IGhhdmluZyB0b1xuICAgIC8vIHdvcnJ5IGFib3V0IGluaGVyaXRlZCBwcm9wZXJ0aWVzIHN1Y2ggYXMgYHRvU3RyaW5nYCwgYHZhbHVlT2ZgIGV0Yy5cbiAgICBjb25zdCBfYXR0cmlidXRlTmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gTGlzdCBvZiBhdHRyaWJ1dGVzIGZvciB3aGljaCBub3QgdG8gc3BsaXQgY2FtZWwgY2FzZSB3b3Jkcy5cbiAgICAvLyBJdCBjb250YWlucyBrbm93biBTVkcgYXR0cmlidXRlIG5hbWVzIGFuZCBtYXkgYmUgZXh0ZW5kZWQgd2l0aCB1c2VyLWRlZmluZWQgYXR0cmlidXRlIG5hbWVzLlxuICAgIFtcbiAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuICAgICAgICAnYmFzZVByb2ZpbGUnLFxuICAgICAgICAnY2xpcFBhdGhVbml0cycsXG4gICAgICAgICdjb250ZW50U2NyaXB0VHlwZScsXG4gICAgICAgICdjb250ZW50U3R5bGVUeXBlJyxcbiAgICAgICAgJ2RpZmZ1c2VDb25zdGFudCcsXG4gICAgICAgICdlZGdlTW9kZScsXG4gICAgICAgICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICAgICAgJ2ZpbHRlclJlcycsIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgJ2ZpbHRlclVuaXRzJyxcbiAgICAgICAgJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgICAgICAgJ2dyYWRpZW50VW5pdHMnLFxuICAgICAgICAna2VybmVsTWF0cml4JyxcbiAgICAgICAgJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICAgICAgICAna2V5UG9pbnRzJyxcbiAgICAgICAgJ2xlbmd0aEFkanVzdCcsXG4gICAgICAgICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gICAgICAgICdtYXJrZXJIZWlnaHQnLFxuICAgICAgICAnbWFya2VyVW5pdHMnLFxuICAgICAgICAnbWFya2VyV2lkdGgnLFxuICAgICAgICAnbWFza0NvbnRlbnRVbml0cycsXG4gICAgICAgICdtYXNrVW5pdHMnLFxuICAgICAgICAnbnVtT2N0YXZlcycsXG4gICAgICAgICdwYXRoTGVuZ3RoJyxcbiAgICAgICAgJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgICAgICAncGF0dGVyblRyYW5zZm9ybScsXG4gICAgICAgICdwYXR0ZXJuVW5pdHMnLFxuICAgICAgICAncG9pbnRzQXRYJyxcbiAgICAgICAgJ3BvaW50c0F0WScsXG4gICAgICAgICdwb2ludHNBdFonLFxuICAgICAgICAncHJlc2VydmVBbHBoYScsXG4gICAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgICAgICAgJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgICAgICAgJ3JlZlgnLFxuICAgICAgICAncmVmWScsXG4gICAgICAgICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICAgICAgICAncmVxdWlyZWRGZWF0dXJlcycsXG4gICAgICAgICdzcGVjdWxhckNvbnN0YW50JyxcbiAgICAgICAgJ3NwZWN1bGFyRXhwb25lbnQnLFxuICAgICAgICAnc3ByZWFkTWV0aG9kJyxcbiAgICAgICAgJ3N0YXJ0T2Zmc2V0JyxcbiAgICAgICAgJ3N0ZERldmlhdGlvbicsXG4gICAgICAgICdzdGl0Y2hUaWxlcycsXG4gICAgICAgICdzdXJmYWNlU2NhbGUnLFxuICAgICAgICAnc3lzdGVtTGFuZ3VhZ2UnLFxuICAgICAgICAndGFibGVWYWx1ZXMnLFxuICAgICAgICAndGFyZ2V0WCcsXG4gICAgICAgICd0YXJnZXRZJyxcbiAgICAgICAgJ3RleHRMZW5ndGgnLFxuICAgICAgICAndmlld0JveCcsXG4gICAgICAgICd2aWV3VGFyZ2V0JywgLy8gZGVwcmVjYXRlZFxuICAgICAgICAneENoYW5uZWxTZWxlY3RvcicsXG4gICAgICAgICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgICAgICAgJ3pvb21BbmRQYW4nIC8vIGRlcHJlY2F0ZWRcbiAgICBdLmZvckVhY2goKG5hbWUpID0+IF9hdHRyaWJ1dGVOYW1lc1tuYW1lXSA9IG5hbWUpO1xuXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBuZXcgUHJveHkoX2F0dHJpYnV0ZU5hbWVzLCB7XG4gICAgICAgIGdldChjYWNoZSwgbmFtZSkge1xuICAgICAgICAgICAgLy8gVGhlIGNhY2hlIGlzIGEgZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGUgbmFtZXMuIFNlZSBgX2F0dHJpYnV0ZU5hbWVzYCBhYm92ZS5cbiAgICAgICAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgbmFtZSBpcyBub3QgaW4gdGhlIGNhY2hlLCBpdCBtZWFucyB0aGF0IGl0IGlzIG5vdFxuICAgICAgICAgICAgLy8gYSBjYW1lbC1jYXNlIGF0dHJpYnV0ZSBuYW1lLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gY29udmVydFxuICAgICAgICAgICAgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lIHRvIGRhc2gtc2VwYXJhdGVkIHdvcmRzLlxuICAgICAgICAgICAgaWYgKCFWLnN1cHBvcnRDYW1lbENhc2VBdHRyaWJ1dGVzKSByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udmVydCBjYW1lbCBjYXNlIHRvIGRhc2gtc2VwYXJhdGVkIHdvcmRzLlxuICAgICAgICAgICAgcmV0dXJuIChjYWNoZVtuYW1lXSA9IG5hbWUucmVwbGFjZSgvW0EtWl0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBUaGUgYGF0dHJpYnV0ZU5hbWVzYCBhbmQgYHN1cHBvcnRDYW1lbENhc2VBdHRyaWJ1dGVzYCBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZVxuICAgIC8vIGluIHRoaXMgdmVyc2lvbiB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzLiBUaGV5IHdpbGwgYmUgbWFkZSBlbnVtZXJhYmxlIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG5cbiAgICAvLyBEaWN0aW9uYXJ5IG9mIGF0dHJpYnV0ZSBuYW1lc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWLCAnYXR0cmlidXRlTmFtZXMnLCB7XG4gICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgLy8gU2hvdWxkIGNhbWVsIGNhc2UgYXR0cmlidXRlcyBiZSBzdXBwb3J0ZWQ/XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFYsICdzdXBwb3J0Q2FtZWxDYXNlQXR0cmlidXRlcycsIHtcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge3tuczogc3RyaW5nfG51bGwsIGxvY2FsOiBzdHJpbmd9fSBuYW1lc3BhY2UgYW5kIGF0dHJpYnV0ZSBuYW1lXG4gICAgICovXG4gICAgVi5xdWFsaWZ5QXR0ciA9IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY29tYmluZWRLZXkgPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5zOiBuc1tjb21iaW5lZEtleVswXV0sXG4gICAgICAgICAgICAgICAgbG9jYWw6IGNvbWJpbmVkS2V5WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5zOiBudWxsLFxuICAgICAgICAgICAgbG9jYWw6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gTm90ZTogVGhpcyByZWdleCBhbGxvd3MgbXVsdGlwbGUgY29tbWFzIGFzIHNlcGFyYXRvciB3aGljaCBpcyBpbmNvcnJlY3QgaW4gU1ZHXG4gICAgLy8gVGhpcyByZWdleCBpcyB1c2VkIGJ5IGBzcGxpdCgpYCwgc28gaXQgZG9lc24ndCBuZWVkIHRvIHVzZSAvZ1xuICAgIFYudHJhbnNmb3JtU2VwYXJhdG9yUmVnZXggPSAvWyAsXSsvO1xuICAgIC8vIE5vdGU6IEFsbCBmb2xsb3dpbmcgcmVnZXhlcyBhcmUgbW9yZSByZXN0cmljdGl2ZSB0aGFuIFNWRyBzcGVjaWZpY2F0aW9uXG4gICAgLy8gUmVEb1MgbWl0aWdhdGlvbjogVXNlIGFuIGFuY2hvciBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYXRjaFxuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IEF2b2lkIGJhY2t0cmFja2luZyAodXNlcyBgW14oKV0rYCBpbnN0ZWFkIG9mIGAuKj9gKVxuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IERvbid0IG1hdGNoIGluaXRpYWwgYChgIGluc2lkZSByZXBlYXRlZCBwYXJ0XG4gICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBuZWVkcyB0byB1c2UgL2cgKD0gY2Fubm90IHVzZSBjYXB0dXJpbmcgZ3JvdXBzKVxuICAgIFYudHJhbnNmb3JtUmVnZXggPSAvXFxiXFx3K1xcKFteKCldK1xcKS9nO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXhlcyBuZWVkIHRvIHVzZSBjYXB0dXJpbmcgZ3JvdXBzICg9IGNhbm5vdCB1c2UgL2cpXG4gICAgVi50cmFuc2Zvcm1GdW5jdGlvblJlZ2V4ID0gL1xcYihcXHcrKVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVRyYW5zbGF0ZVJlZ2V4ID0gL1xcYnRyYW5zbGF0ZVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVJvdGF0ZVJlZ2V4ID0gL1xcYnJvdGF0ZVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVNjYWxlUmVnZXggPSAvXFxic2NhbGVcXCgoW14oKV0rKVxcKS87XG5cbiAgICBWLnRyYW5zZm9ybVN0cmluZ1RvTWF0cml4ID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSByZXN1bHQgbWF0cml4IGFzIGlkZW50aXR5IG1hdHJpeFxuICAgICAgICBsZXQgdHJhbnNmb3JtYXRpb25NYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IE11bHRpcGxlIHRyYW5zZm9ybSBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgaW4gYHRyYW5zZm9ybWAgc3RyaW5nXG4gICAgICAgIC8vIGBtYXRjaCgpYCByZXR1cm5zIGBudWxsYCBpZiBub25lIGZvdW5kXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdGNoZXMgPSB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLm1hdGNoKFYudHJhbnNmb3JtUmVnZXgpO1xuICAgICAgICBpZiAoIXRyYW5zZm9ybU1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBpZGVudGl0eSBtYXRyaXhcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbk1hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG51bU1hdGNoZXMgPSB0cmFuc2Zvcm1NYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NYXRjaGVzOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtTWF0Y2ggPSB0cmFuc2Zvcm1NYXRjaGVzW2ldO1xuICAgICAgICAgICAgLy8gVXNlIHNhbWUgcmVnZXggYXMgYWJvdmUsIGJ1dCB3aXRoIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgIC8vIGBtYXRjaCgpYCByZXR1cm5zIHZhbHVlcyBvZiBjYXB0dXJpbmcgZ3JvdXBzIGFzIGBbMV1gLCBgWzJdYFxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtRnVuY3Rpb25NYXRjaCA9IHRyYW5zZm9ybU1hdGNoLm1hdGNoKFYudHJhbnNmb3JtRnVuY3Rpb25SZWdleCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtRnVuY3Rpb25NYXRjaCkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHN4LCBzeSwgdHgsIHR5LCBhbmdsZTtcbiAgICAgICAgICAgICAgICBsZXQgY3RtID0gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IHRyYW5zZm9ybUZ1bmN0aW9uTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdHJhbnNmb3JtRnVuY3Rpb25NYXRjaFsyXS5zcGxpdChWLnRyYW5zZm9ybVNlcGFyYXRvclJlZ2V4KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybUZ1bmN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSAoYXJnc1sxXSA9PT0gdW5kZWZpbmVkKSA/IHN4IDogcGFyc2VGbG9hdChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5zY2FsZU5vblVuaWZvcm0oc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9IHBhcnNlRmxvYXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0udHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBwYXJzZUZsb2F0KGFyZ3NbMV0pIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9IHBhcnNlRmxvYXQoYXJnc1syXSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eCAhPT0gMCB8fCB0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS50cmFuc2xhdGUodHgsIHR5KS5yb3RhdGUoYW5nbGUpLnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2tld3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtID0gY3RtLnNrZXdYKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NrZXd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5za2V3WShhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmEgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmIgPSBwYXJzZUZsb2F0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmMgPSBwYXJzZUZsb2F0KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmQgPSBwYXJzZUZsb2F0KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmUgPSBwYXJzZUZsb2F0KGFyZ3NbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmYgPSBwYXJzZUZsb2F0KGFyZ3NbNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gaW50byByZXN1bHQgbWF0cml4XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB0cmFuc2Zvcm1hdGlvbk1hdHJpeC5tdWx0aXBseShjdG0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uTWF0cml4O1xuICAgIH07XG5cbiAgICBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArXG4gICAgICAgICAgICAobWF0cml4LmEgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5hIDogMSkgKyAnLCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5iICE9PSB1bmRlZmluZWQgPyBtYXRyaXguYiA6IDApICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguYyAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmMgOiAwKSArICcsJyArXG4gICAgICAgICAgICAobWF0cml4LmQgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5kIDogMSkgKyAnLCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5lICE9PSB1bmRlZmluZWQgPyBtYXRyaXguZSA6IDApICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguZiAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmYgOiAwKSArXG4gICAgICAgICAgICAnKSc7XG4gICAgfTtcblxuICAgIFYucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcblxuICAgICAgICB2YXIgdHJhbnNsYXRlLCByb3RhdGUsIHNjYWxlO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcblxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFYudHJhbnNmb3JtU2VwYXJhdG9yUmVnZXg7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGB0cmFuc2Zvcm1gIHdpdGggb25lIG9yIG1vcmUgbWF0cml4IGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybS50cmltKCkuaW5kZXhPZignbWF0cml4JykgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBFVkVSWVRISU5HIGluIGB0cmFuc2Zvcm1gIHN0cmluZyB0byBhIG1hdHJpeFxuICAgICAgICAgICAgICAgIC8vIFdpbGwgY29tYmluZSBBTEwgbWF0cml4ZXMgKiBBTEwgdHJhbnNsYXRlcyAqIEFMTCBzY2FsZXMgKiBBTEwgcm90YXRlc1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IEluIG5vbi1tYXRyaXggY2FzZSwgd2Ugb25seSB0YWtlIGZpcnN0IG9uZSBvZiBlYWNoIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IFYudHJhbnNmb3JtU3RyaW5nVG9NYXRyaXgodHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb21wb3NlZE1hdHJpeCA9IFYuZGVjb21wb3NlTWF0cml4KG1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGB0cmFuc2xhdGVgLCBgc2NhbGVgLCBgcm90YXRlYCBmcm9tIG1hdHJpeFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA9IFtkZWNvbXBvc2VkTWF0cml4LnRyYW5zbGF0ZVgsIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWV07XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBbZGVjb21wb3NlZE1hdHJpeC5zY2FsZVgsIGRlY29tcG9zZWRNYXRyaXguc2NhbGVZXTtcbiAgICAgICAgICAgICAgICByb3RhdGUgPSBbZGVjb21wb3NlZE1hdHJpeC5yb3RhdGlvbl07XG5cbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIGB0cmFuc2Zvcm1gIHN0cmluZyBpbiBgdHJhbnNsYXRlIHNjYWxlIHJvdGF0ZWAgZm9ybWF0XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGVbMF0gIT09IDAgfHwgdHJhbnNsYXRlWzFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKCd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2FsZVswXSAhPT0gMSB8fCBzY2FsZVsxXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaCgnc2NhbGUoJyArIHNjYWxlICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0ZVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaCgncm90YXRlKCcgKyByb3RhdGUgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1hdGlvbnMuam9pbignICcpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBgdHJhbnNsYXRlYCwgYHJvdGF0ZWAsIGBzY2FsZWAgZnVuY3Rpb25zIGZyb20gYHRyYW5zZm9ybWAgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2Ugb25seSBkZXRlY3QgdGhlIGZpcnN0IG1hdGNoIG9mIGVhY2ggKGlmIGFueSlcbiAgICAgICAgICAgICAgICAvLyBgbWF0Y2goKWAgcmV0dXJucyB2YWx1ZSBvZiBjYXB0dXJpbmcgZ3JvdXAgYXMgYFsxXWBcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVNYXRjaCA9IHRyYW5zZm9ybS5tYXRjaChWLnRyYW5zZm9ybVRyYW5zbGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlID0gdHJhbnNsYXRlTWF0Y2hbMV0uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm90YXRlTWF0Y2ggPSB0cmFuc2Zvcm0ubWF0Y2goVi50cmFuc2Zvcm1Sb3RhdGVSZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IHJvdGF0ZU1hdGNoWzFdLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlTWF0Y2ggPSB0cmFuc2Zvcm0ubWF0Y2goVi50cmFuc2Zvcm1TY2FsZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlTWF0Y2hbMV0uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ggPSAoc2NhbGUgJiYgc2NhbGVbMF0pID8gcGFyc2VGbG9hdChzY2FsZVswXSkgOiAxO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgICAgICAgICAgdHg6ICh0cmFuc2xhdGUgJiYgdHJhbnNsYXRlWzBdKSA/IHBhcnNlSW50KHRyYW5zbGF0ZVswXSwgMTApIDogMCxcbiAgICAgICAgICAgICAgICB0eTogKHRyYW5zbGF0ZSAmJiB0cmFuc2xhdGVbMV0pID8gcGFyc2VJbnQodHJhbnNsYXRlWzFdLCAxMCkgOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm90YXRlOiB7XG4gICAgICAgICAgICAgICAgYW5nbGU6IChyb3RhdGUgJiYgcm90YXRlWzBdKSA/IHBhcnNlSW50KHJvdGF0ZVswXSwgMTApIDogMCxcbiAgICAgICAgICAgICAgICBjeDogKHJvdGF0ZSAmJiByb3RhdGVbMV0pID8gcGFyc2VJbnQocm90YXRlWzFdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY3k6IChyb3RhdGUgJiYgcm90YXRlWzJdKSA/IHBhcnNlSW50KHJvdGF0ZVsyXSwgMTApIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICAgICAgc3k6IChzY2FsZSAmJiBzY2FsZVsxXSkgPyBwYXJzZUZsb2F0KHNjYWxlWzFdKSA6IHN4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFYuZGVsdGFUcmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKG1hdHJpeCwgcG9pbnQpIHtcblxuICAgICAgICB2YXIgZHggPSBwb2ludC54ICogbWF0cml4LmEgKyBwb2ludC55ICogbWF0cml4LmMgKyAwO1xuICAgICAgICB2YXIgZHkgPSBwb2ludC54ICogbWF0cml4LmIgKyBwb2ludC55ICogbWF0cml4LmQgKyAwO1xuICAgICAgICByZXR1cm4geyB4OiBkeCwgeTogZHkgfTtcbiAgICB9O1xuXG4gICAgVi5kZWNvbXBvc2VNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzIwNTIyNDdcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEgdHJhbnNmb3JtIHBvaW50XG4gICAgICAgIHZhciBweCA9IFYuZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHsgeDogMCwgeTogMSB9KTtcbiAgICAgICAgdmFyIHB5ID0gVi5kZWx0YVRyYW5zZm9ybVBvaW50KG1hdHJpeCwgeyB4OiAxLCB5OiAwIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBza2V3XG4gICAgICAgIHZhciBza2V3WCA9ICgoMTgwIC8gUEkpICogYXRhbjIocHgueSwgcHgueCkgLSA5MCk7XG4gICAgICAgIHZhciBza2V3WSA9ICgoMTgwIC8gUEkpICogYXRhbjIocHkueSwgcHkueCkpO1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG1hdHJpeC5lLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbWF0cml4LmYsXG4gICAgICAgICAgICBzY2FsZVg6IHNxcnQobWF0cml4LmEgKiBtYXRyaXguYSArIG1hdHJpeC5iICogbWF0cml4LmIpLFxuICAgICAgICAgICAgc2NhbGVZOiBzcXJ0KG1hdHJpeC5jICogbWF0cml4LmMgKyBtYXRyaXguZCAqIG1hdHJpeC5kKSxcbiAgICAgICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiBza2V3WSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBza2V3WCAvLyByb3RhdGlvbiBpcyB0aGUgc2FtZSBhcyBza2V3IHhcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBgc2NhbGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvU2NhbGUgPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgICAgICB2YXIgYSwgYiwgYywgZDtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgYSA9IFYuaXNVbmRlZmluZWQobWF0cml4LmEpID8gMSA6IG1hdHJpeC5hO1xuICAgICAgICAgICAgZCA9IFYuaXNVbmRlZmluZWQobWF0cml4LmQpID8gMSA6IG1hdHJpeC5kO1xuICAgICAgICAgICAgYiA9IG1hdHJpeC5iO1xuICAgICAgICAgICAgYyA9IG1hdHJpeC5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYSA9IGQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzeDogYiA/IHNxcnQoYSAqIGEgKyBiICogYikgOiBhLFxuICAgICAgICAgICAgc3k6IGMgPyBzcXJ0KGMgKiBjICsgZCAqIGQpIDogZFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGByb3RhdGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvUm90YXRlID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgdmFyIHAgPSB7IHg6IDAsIHk6IDEgfTtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgcCA9IFYuZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuZ2xlOiBnLm5vcm1hbGl6ZUFuZ2xlKGcudG9EZWcoYXRhbjIocC55LCBwLngpKSAtIDkwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGB0cmFuc2xhdGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvVHJhbnNsYXRlID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4OiAobWF0cml4ICYmIG1hdHJpeC5lKSB8fCAwLFxuICAgICAgICAgICAgdHk6IChtYXRyaXggJiYgbWF0cml4LmYpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgVi5pc1YgPSBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgVjtcbiAgICB9O1xuXG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuICAgIFYuaXNWRWxlbWVudCA9IFYuaXNWO1xuXG4gICAgLy8gRWxlbWVudCBpbXBsZW1lbnRzIGBnZXRCQm94KClgLCBgZ2V0Q1RNKClgIGFuZCBgZ2V0U2NyZWVuQ1RNKClgXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dyYXBoaWNzRWxlbWVudFxuICAgIFYuaXNTVkdHcmFwaGljc0VsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBub2RlID0gVi50b05vZGUobm9kZSk7XG4gICAgICAgIC8vIElFL0VkZ2UgZG9lcyBub3QgaW1wbGVtZW50IFNWR0dyYXBoaWNzRWxlbWVudCBpbnRlcmZhY2UsIHRodXMgY2hlY2sgZm9yIGBnZXRTY3JlZW5DVE1gIGJlbG93XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiB0eXBlb2Ygbm9kZS5nZXRTY3JlZW5DVE0gPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHZhciBzdmdEb2N1bWVudCA9IFYoJ3N2ZycpLm5vZGU7XG5cbiAgICBWLmNyZWF0ZVNWR01hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgICAgIHZhciBzdmdNYXRyaXggPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgY29tcG9uZW50IGluIG1hdHJpeCkge1xuICAgICAgICAgICAgc3ZnTWF0cml4W2NvbXBvbmVudF0gPSBtYXRyaXhbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdmdNYXRyaXg7XG4gICAgfTtcblxuICAgIFYuY3JlYXRlU1ZHVHJhbnNmb3JtID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgaWYgKCFWLmlzVW5kZWZpbmVkKG1hdHJpeCkpIHtcblxuICAgICAgICAgICAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgU1ZHTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdmdEb2N1bWVudC5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgfTtcblxuICAgIFYuY3JlYXRlU1ZHUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgdmFyIHAgPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICBwLnggPSB4O1xuICAgICAgICBwLnkgPSB5O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgVi50cmFuc2Zvcm1SZWN0ID0gZnVuY3Rpb24ociwgbWF0cml4KSB7XG5cbiAgICAgICAgdmFyIHAgPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXG4gICAgICAgIHAueCA9IHIueDtcbiAgICAgICAgcC55ID0gci55O1xuICAgICAgICB2YXIgY29ybmVyMSA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgcC54ID0gci54ICsgci53aWR0aDtcbiAgICAgICAgcC55ID0gci55O1xuICAgICAgICB2YXIgY29ybmVyMiA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgcC54ID0gci54ICsgci53aWR0aDtcbiAgICAgICAgcC55ID0gci55ICsgci5oZWlnaHQ7XG4gICAgICAgIHZhciBjb3JuZXIzID0gcC5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgICBwLnggPSByLng7XG4gICAgICAgIHAueSA9IHIueSArIHIuaGVpZ2h0O1xuICAgICAgICB2YXIgY29ybmVyNCA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgdmFyIG1pblggPSBtaW4oY29ybmVyMS54LCBjb3JuZXIyLngsIGNvcm5lcjMueCwgY29ybmVyNC54KTtcbiAgICAgICAgdmFyIG1heFggPSBtYXgoY29ybmVyMS54LCBjb3JuZXIyLngsIGNvcm5lcjMueCwgY29ybmVyNC54KTtcbiAgICAgICAgdmFyIG1pblkgPSBtaW4oY29ybmVyMS55LCBjb3JuZXIyLnksIGNvcm5lcjMueSwgY29ybmVyNC55KTtcbiAgICAgICAgdmFyIG1heFkgPSBtYXgoY29ybmVyMS55LCBjb3JuZXIyLnksIGNvcm5lcjMueSwgY29ybmVyNC55KTtcblxuICAgICAgICByZXR1cm4gbmV3IGcuUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH07XG5cbiAgICBWLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24ocCwgbWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBnLlBvaW50KFYuY3JlYXRlU1ZHUG9pbnQocC54LCBwLnkpLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpKTtcbiAgICB9O1xuXG4gICAgVi50cmFuc2Zvcm1MaW5lID0gZnVuY3Rpb24obCwgbWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBnLkxpbmUoXG4gICAgICAgICAgICBWLnRyYW5zZm9ybVBvaW50KGwuc3RhcnQsIG1hdHJpeCksXG4gICAgICAgICAgICBWLnRyYW5zZm9ybVBvaW50KGwuZW5kLCBtYXRyaXgpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFYudHJhbnNmb3JtUG9seWxpbmUgPSBmdW5jdGlvbihwLCBtYXRyaXgpIHtcblxuICAgICAgICB2YXIgaW5Qb2ludHMgPSAocCBpbnN0YW5jZW9mIGcuUG9seWxpbmUpID8gcC5wb2ludHMgOiBwO1xuICAgICAgICBpZiAoIVYuaXNBcnJheShpblBvaW50cykpIGluUG9pbnRzID0gW107XG4gICAgICAgIHZhciBvdXRQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpblBvaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIG91dFBvaW50c1tpXSA9IFYudHJhbnNmb3JtUG9pbnQoaW5Qb2ludHNbaV0sIG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2x5bGluZShvdXRQb2ludHMpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0IGEgc3R5bGUgcmVwcmVzZW50ZWQgYXMgc3RyaW5nIChlLmcuIGAnZmlsbD1cImJsdWVcIjsgc3Ryb2tlPVwicmVkXCInYCkgdG9cbiAgICAvLyBhbiBvYmplY3QgKGB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAncmVkJyB9YCkuXG4gICAgVi5zdHlsZVRvT2JqZWN0ID0gZnVuY3Rpb24oc3R5bGVTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICB2YXIgc3R5bGVzID0gc3R5bGVTdHJpbmcuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgIHZhciBwYWlyID0gc3R5bGUuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHJldFtwYWlyWzBdLnRyaW0oKV0gPSBwYWlyWzFdLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvLyBJbnNwaXJlZCBieSBkMy5qcyBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvYmxvYi9tYXN0ZXIvc3JjL3N2Zy9hcmMuanNcbiAgICBWLmNyZWF0ZVNsaWNlUGF0aERhdGEgPSBmdW5jdGlvbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG5cbiAgICAgICAgdmFyIHN2Z0FyY01heCA9IDIgKiBQSSAtIDFlLTY7XG4gICAgICAgIHZhciByMCA9IGlubmVyUmFkaXVzO1xuICAgICAgICB2YXIgcjEgPSBvdXRlclJhZGl1cztcbiAgICAgICAgdmFyIGEwID0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIGExID0gZW5kQW5nbGU7XG4gICAgICAgIHZhciBkYSA9IChhMSA8IGEwICYmIChkYSA9IGEwLCBhMCA9IGExLCBhMSA9IGRhKSwgYTEgLSBhMCk7XG4gICAgICAgIHZhciBkZiA9IGRhIDwgUEkgPyAnMCcgOiAnMSc7XG4gICAgICAgIHZhciBjMCA9IGNvcyhhMCk7XG4gICAgICAgIHZhciBzMCA9IHNpbihhMCk7XG4gICAgICAgIHZhciBjMSA9IGNvcyhhMSk7XG4gICAgICAgIHZhciBzMSA9IHNpbihhMSk7XG5cbiAgICAgICAgcmV0dXJuIChkYSA+PSBzdmdBcmNNYXgpXG4gICAgICAgICAgICA/IChyMFxuICAgICAgICAgICAgICAgID8gJ00wLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAxLDEgMCwnICsgKC1yMSlcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArIHIxXG4gICAgICAgICAgICAgICAgKyAnTTAsJyArIHIwXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMCArICcsJyArIHIwICsgJyAwIDEsMCAwLCcgKyAoLXIwKVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjAgKyAnLCcgKyByMCArICcgMCAxLDAgMCwnICsgcjBcbiAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgIDogJ00wLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAxLDEgMCwnICsgKC1yMSlcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArIHIxXG4gICAgICAgICAgICAgICAgKyAnWicpXG4gICAgICAgICAgICA6IChyMFxuICAgICAgICAgICAgICAgID8gJ00nICsgcjEgKiBjMCArICcsJyArIHIxICogczBcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgJyArIGRmICsgJywxICcgKyByMSAqIGMxICsgJywnICsgcjEgKiBzMVxuICAgICAgICAgICAgICAgICsgJ0wnICsgcjAgKiBjMSArICcsJyArIHIwICogczFcbiAgICAgICAgICAgICAgICArICdBJyArIHIwICsgJywnICsgcjAgKyAnIDAgJyArIGRmICsgJywwICcgKyByMCAqIGMwICsgJywnICsgcjAgKiBzMFxuICAgICAgICAgICAgICAgICsgJ1onXG4gICAgICAgICAgICAgICAgOiAnTScgKyByMSAqIGMwICsgJywnICsgcjEgKiBzMFxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAnICsgZGYgKyAnLDEgJyArIHIxICogYzEgKyAnLCcgKyByMSAqIHMxXG4gICAgICAgICAgICAgICAgKyAnTDAsMCdcbiAgICAgICAgICAgICAgICArICdaJyk7XG4gICAgfTtcblxuICAgIC8vIE1lcmdlIGF0dHJpYnV0ZXMgZnJvbSBvYmplY3QgYGJgIHdpdGggYXR0cmlidXRlcyBpbiBvYmplY3QgYGFgLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVzIHRoZSBvYmplY3QgYGFgLlxuICAgIC8vIEFsc28gaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYnV0IENTUyBjbGFzc2VzIGFyZSBjb25jYXRlbmF0ZWQuXG4gICAgVi5tZXJnZUF0dHJzID0gZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYikge1xuXG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIC8vIENvbmNhdGVuYXRlIGNsYXNzZXMuXG4gICAgICAgICAgICAgICAgYVthdHRyXSA9IGFbYXR0cl0gPyBhW2F0dHJdICsgJyAnICsgYlthdHRyXSA6IGJbYXR0cl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSBjYW4gYmUgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIGlmIChWLmlzT2JqZWN0KGFbYXR0cl0pICYmIFYuaXNPYmplY3QoYlthdHRyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBzdG9yZWQgaW4gYGFgIGlzIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgYVthdHRyXSA9IFYubWVyZ2VBdHRycyhhW2F0dHJdLCBiW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QoYVthdHRyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBpbiBgYWAgaXMgYW4gb2JqZWN0IGJ1dCBpdCdzIGEgc3RyaW5nIGluIGBiYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3R5bGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgdG8gYW4gb2JqZWN0IGluIGBiYC5cbiAgICAgICAgICAgICAgICAgICAgYVthdHRyXSA9IFYubWVyZ2VBdHRycyhhW2F0dHJdLCBWLnN0eWxlVG9PYmplY3QoYlthdHRyXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVi5pc09iamVjdChiW2F0dHJdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3R5bGVgIGluIGBhYCBpcyBhIHN0cmluZywgaW4gYGJgIGl0J3MgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBhW2F0dHJdID0gVi5tZXJnZUF0dHJzKFYuc3R5bGVUb09iamVjdChhW2F0dHJdKSwgYlthdHRyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBzdHlsZXMgYXJlIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBWLm1lcmdlQXR0cnMoVi5zdHlsZVRvT2JqZWN0KGFbYXR0cl0pLCBWLnN0eWxlVG9PYmplY3QoYlthdHRyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVthdHRyXSA9IGJbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgVi5hbm5vdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHQsIGFubm90YXRpb25zLCBvcHQpIHtcblxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zIHx8IFtdO1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IG9wdC5vZmZzZXQgfHwgMDtcbiAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuICAgICAgICB2YXIgYmF0Y2g7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHZhciBwcmV2O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBpdGVtID0gcmV0W2ldID0gdFtpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGorKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBhbm5vdGF0aW9uLnN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBhbm5vdGF0aW9uLmVuZCArIG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlmIChpID49IHN0YXJ0ICYmIGkgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5ub3RhdGlvbiBhcHBsaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoVi5pc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBhbm5vdGF0aW9uIHRvIGJlIGFwcGxpZWQgPT4gTWVyZ2UgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cnMgPSBWLm1lcmdlQXR0cnMoVi5tZXJnZUF0dHJzKHt9LCBpdGVtLmF0dHJzKSwgYW5ub3RhdGlvbi5hdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gcmV0W2ldID0geyB0OiB0W2ldLCBhdHRyczogYW5ub3RhdGlvbi5hdHRycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaW5jbHVkZUFubm90YXRpb25JbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbS5hbm5vdGF0aW9ucyB8fCAoaXRlbS5hbm5vdGF0aW9ucyA9IFtdKSkucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IHJldFtpIC0gMV07XG5cbiAgICAgICAgICAgIGlmICghcHJldikge1xuXG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QoaXRlbSkgJiYgVi5pc09iamVjdChwcmV2KSkge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggcHJldmlvdXMgaXRlbSBhbmQgdGhlIGN1cnJlbnQgb25lIGFyZSBhbm5vdGF0aW9ucy4gSWYgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBkaWRuJ3QgY2hhbmdlLCBtZXJnZSB0aGUgdGV4dC5cbiAgICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoaXRlbS5hdHRycykgPT09IEpTT04uc3RyaW5naWZ5KHByZXYuYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnQgKz0gaXRlbS50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChWLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmlvdXMgaXRlbSB3YXMgYSBzdHJpbmcsIGN1cnJlbnQgaXRlbSBpcyBhbiBhbm5vdGF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgICAgICBiYXRjaCA9IGl0ZW07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVi5pc09iamVjdChwcmV2KSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIGl0ZW0gd2FzIGFuIGFubm90YXRpb24sIGN1cnJlbnQgaXRlbSBpcyBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggcHJldmlvdXMgYW5kIGN1cnJlbnQgaXRlbSBhcmUgc3RyaW5ncy5cbiAgICAgICAgICAgICAgICBiYXRjaCA9IChiYXRjaCB8fCAnJykgKyBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGFjdGVkO1xuICAgIH07XG5cbiAgICBWLmZpbmRBbm5vdGF0aW9uc0F0SW5kZXggPSBmdW5jdGlvbihhbm5vdGF0aW9ucywgaW5kZXgpIHtcblxuICAgICAgICB2YXIgZm91bmQgPSBbXTtcblxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcblxuICAgICAgICAgICAgYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbm5vdGF0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5zdGFydCA8IGluZGV4ICYmIGluZGV4IDw9IGFubm90YXRpb24uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIFYuZmluZEFubm90YXRpb25zQmV0d2VlbkluZGV4ZXMgPSBmdW5jdGlvbihhbm5vdGF0aW9ucywgc3RhcnQsIGVuZCkge1xuXG4gICAgICAgIHZhciBmb3VuZCA9IFtdO1xuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuXG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFubm90YXRpb24pIHtcblxuICAgICAgICAgICAgICAgIGlmICgoc3RhcnQgPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBzdGFydCA8IGFubm90YXRpb24uZW5kKSB8fCAoZW5kID4gYW5ub3RhdGlvbi5zdGFydCAmJiBlbmQgPD0gYW5ub3RhdGlvbi5lbmQpIHx8IChhbm5vdGF0aW9uLnN0YXJ0ID49IHN0YXJ0ICYmIGFubm90YXRpb24uZW5kIDwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICAvLyBTaGlmdCBhbGwgdGhlIHRleHQgYW5ub3RhdGlvbnMgYWZ0ZXIgY2hhcmFjdGVyIGBpbmRleGAgYnkgYG9mZnNldGAgcG9zaXRpb25zLlxuICAgIFYuc2hpZnRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubm90YXRpb25zLCBpbmRleCwgb2Zmc2V0KSB7XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG5cbiAgICAgICAgICAgIGFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24oYW5ub3RhdGlvbikge1xuXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPCBpbmRleCAmJiBhbm5vdGF0aW9uLmVuZCA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmVuZCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbm5vdGF0aW9uLnN0YXJ0ID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb24uc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmVuZCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcblxuICAgIFYuY29udmVydExpbmVUb1BhdGhEYXRhID0gZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIGxpbmUgPSBWKGxpbmUpO1xuICAgICAgICB2YXIgZCA9IFtcbiAgICAgICAgICAgICdNJywgbGluZS5hdHRyKCd4MScpLCBsaW5lLmF0dHIoJ3kxJyksXG4gICAgICAgICAgICAnTCcsIGxpbmUuYXR0cigneDInKSwgbGluZS5hdHRyKCd5MicpXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgVi5jb252ZXJ0UG9seWdvblRvUGF0aERhdGEgPSBmdW5jdGlvbihwb2x5Z29uKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUocG9seWdvbik7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gVi5zdmdQb2ludHNUb1BhdGgocG9pbnRzKSArICcgWic7XG4gICAgfTtcblxuICAgIFYuY29udmVydFBvbHlsaW5lVG9QYXRoRGF0YSA9IGZ1bmN0aW9uKHBvbHlsaW5lKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUocG9seWxpbmUpO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIFYuc3ZnUG9pbnRzVG9QYXRoKHBvaW50cyk7XG4gICAgfTtcblxuICAgIFYuc3ZnUG9pbnRzVG9QYXRoID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaV0ueCArICcgJyArIHBvaW50c1tpXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdNICcgKyBwb2ludHMuam9pbignIEwnKTtcbiAgICB9O1xuXG4gICAgVi5nZXRQb2ludHNGcm9tU3ZnTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICBub2RlID0gVi50b05vZGUobm9kZSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVQb2ludHMgPSBub2RlLnBvaW50cztcbiAgICAgICAgaWYgKG5vZGVQb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZVBvaW50cy5udW1iZXJPZkl0ZW1zOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobm9kZVBvaW50cy5nZXRJdGVtKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcblxuICAgIFYuS0FQUEEgPSAwLjU1MTc4NDtcblxuICAgIFYuY29udmVydENpcmNsZVRvUGF0aERhdGEgPSBmdW5jdGlvbihjaXJjbGUpIHtcblxuICAgICAgICBjaXJjbGUgPSBWKGNpcmNsZSk7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlRmxvYXQoY2lyY2xlLmF0dHIoJ2N4JykpIHx8IDA7XG4gICAgICAgIHZhciBjeSA9IHBhcnNlRmxvYXQoY2lyY2xlLmF0dHIoJ2N5JykpIHx8IDA7XG4gICAgICAgIHZhciByID0gcGFyc2VGbG9hdChjaXJjbGUuYXR0cigncicpKTtcbiAgICAgICAgdmFyIGNkID0gciAqIFYuS0FQUEE7IC8vIENvbnRyb2wgZGlzdGFuY2UuXG5cbiAgICAgICAgdmFyIGQgPSBbXG4gICAgICAgICAgICAnTScsIGN4LCBjeSAtIHIsICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IHBvaW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIGNkLCBjeSAtIHIsIGN4ICsgciwgY3kgLSBjZCwgY3ggKyByLCBjeSwgLy8gSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4ICsgciwgY3kgKyBjZCwgY3ggKyBjZCwgY3kgKyByLCBjeCwgY3kgKyByLCAvLyBJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gY2QsIGN5ICsgciwgY3ggLSByLCBjeSArIGNkLCBjeCAtIHIsIGN5LCAvLyBJSUkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCAtIHIsIGN5IC0gY2QsIGN4IC0gY2QsIGN5IC0gciwgY3gsIGN5IC0gciwgLy8gSVYuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ1onXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgVi5jb252ZXJ0RWxsaXBzZVRvUGF0aERhdGEgPSBmdW5jdGlvbihlbGxpcHNlKSB7XG5cbiAgICAgICAgZWxsaXBzZSA9IFYoZWxsaXBzZSk7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlRmxvYXQoZWxsaXBzZS5hdHRyKCdjeCcpKSB8fCAwO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUZsb2F0KGVsbGlwc2UuYXR0cignY3knKSkgfHwgMDtcbiAgICAgICAgdmFyIHJ4ID0gcGFyc2VGbG9hdChlbGxpcHNlLmF0dHIoJ3J4JykpO1xuICAgICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KGVsbGlwc2UuYXR0cigncnknKSkgfHwgcng7XG4gICAgICAgIHZhciBjZHggPSByeCAqIFYuS0FQUEE7IC8vIENvbnRyb2wgZGlzdGFuY2UgeC5cbiAgICAgICAgdmFyIGNkeSA9IHJ5ICogVi5LQVBQQTsgLy8gQ29udHJvbCBkaXN0YW5jZSB5LlxuXG4gICAgICAgIHZhciBkID0gW1xuICAgICAgICAgICAgJ00nLCBjeCwgY3kgLSByeSwgICAgLy8gTW92ZSB0byB0aGUgZmlyc3QgcG9pbnQuXG4gICAgICAgICAgICAnQycsIGN4ICsgY2R4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSAtIGNkeSwgY3ggKyByeCwgY3ksIC8vIEkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIHJ4LCBjeSArIGNkeSwgY3ggKyBjZHgsIGN5ICsgcnksIGN4LCBjeSArIHJ5LCAvLyBJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gY2R4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIGNkeSwgY3ggLSByeCwgY3ksIC8vIElJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gcngsIGN5IC0gY2R5LCBjeCAtIGNkeCwgY3kgLSByeSwgY3gsIGN5IC0gcnksIC8vIElWLiBRdWFkcmFudC5cbiAgICAgICAgICAgICdaJ1xuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIFYuY29udmVydFJlY3RUb1BhdGhEYXRhID0gZnVuY3Rpb24ocmVjdCkge1xuXG4gICAgICAgIHJlY3QgPSBWKHJlY3QpO1xuXG4gICAgICAgIHJldHVybiBWLnJlY3RUb1BhdGgoe1xuICAgICAgICAgICAgeDogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3gnKSkgfHwgMCxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCd5JykpIHx8IDAsXG4gICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3dpZHRoJykpIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCdoZWlnaHQnKSkgfHwgMCxcbiAgICAgICAgICAgIHJ4OiBwYXJzZUZsb2F0KHJlY3QuYXR0cigncngnKSkgfHwgMCxcbiAgICAgICAgICAgIHJ5OiBwYXJzZUZsb2F0KHJlY3QuYXR0cigncnknKSkgfHwgMFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQ29udmVydCBhIHJlY3RhbmdsZSB0byBTVkcgcGF0aCBjb21tYW5kcy4gYHJgIGlzIGFuIG9iamVjdCBvZiB0aGUgZm9ybTpcbiAgICAvLyBgeyB4OiBbbnVtYmVyXSwgeTogW251bWJlcl0sIHdpZHRoOiBbbnVtYmVyXSwgaGVpZ2h0OiBbbnVtYmVyXSwgdG9wLXJ5OiBbbnVtYmVyXSwgdG9wLXJ5OiBbbnVtYmVyXSwgYm90dG9tLXJ4OiBbbnVtYmVyXSwgYm90dG9tLXJ5OiBbbnVtYmVyXSB9YCxcbiAgICAvLyB3aGVyZSBgeCwgeSwgd2lkdGgsIGhlaWdodGAgYXJlIHRoZSB1c3VhbCByZWN0YW5nbGUgYXR0cmlidXRlcyBhbmQgW3RvcC0vYm90dG9tLV1yeC9yeSBhbGxvd3MgZm9yXG4gICAgLy8gc3BlY2lmeWluZyByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSBmb3IgYWxsIGl0cyBzaWRlcyAoYXMgb3Bwb3NlZCB0byB0aGUgYnVpbHQtaW4gU1ZHIHJlY3RhbmdsZVxuICAgIC8vIHRoYXQgaGFzIG9ubHkgYHJ4YCBhbmQgYHJ5YCBhdHRyaWJ1dGVzKS5cbiAgICBWLnJlY3RUb1BhdGggPSBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciB4ID0gci54O1xuICAgICAgICB2YXIgeSA9IHIueTtcbiAgICAgICAgdmFyIHdpZHRoID0gci53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHIuaGVpZ2h0O1xuICAgICAgICB2YXIgdG9wUnggPSBtaW4oci5yeCB8fCByWyd0b3AtcngnXSB8fCAwLCB3aWR0aCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tUnggPSBtaW4oci5yeCB8fCByWydib3R0b20tcngnXSB8fCAwLCB3aWR0aCAvIDIpO1xuICAgICAgICB2YXIgdG9wUnkgPSBtaW4oci5yeSB8fCByWyd0b3AtcnknXSB8fCAwLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIGJvdHRvbVJ5ID0gbWluKHIucnkgfHwgclsnYm90dG9tLXJ5J10gfHwgMCwgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgaWYgKHRvcFJ4IHx8IGJvdHRvbVJ4IHx8IHRvcFJ5IHx8IGJvdHRvbVJ5KSB7XG4gICAgICAgICAgICBkID0gW1xuICAgICAgICAgICAgICAgICdNJywgeCwgeSArIHRvcFJ5LFxuICAgICAgICAgICAgICAgICd2JywgaGVpZ2h0IC0gdG9wUnkgLSBib3R0b21SeSxcbiAgICAgICAgICAgICAgICAnYScsIGJvdHRvbVJ4LCBib3R0b21SeSwgMCwgMCwgMCwgYm90dG9tUngsIGJvdHRvbVJ5LFxuICAgICAgICAgICAgICAgICdoJywgd2lkdGggLSAyICogYm90dG9tUngsXG4gICAgICAgICAgICAgICAgJ2EnLCBib3R0b21SeCwgYm90dG9tUnksIDAsIDAsIDAsIGJvdHRvbVJ4LCAtYm90dG9tUnksXG4gICAgICAgICAgICAgICAgJ3YnLCAtKGhlaWdodCAtIGJvdHRvbVJ5IC0gdG9wUnkpLFxuICAgICAgICAgICAgICAgICdhJywgdG9wUngsIHRvcFJ5LCAwLCAwLCAwLCAtdG9wUngsIC10b3BSeSxcbiAgICAgICAgICAgICAgICAnaCcsIC0od2lkdGggLSAyICogdG9wUngpLFxuICAgICAgICAgICAgICAgICdhJywgdG9wUngsIHRvcFJ5LCAwLCAwLCAwLCAtdG9wUngsIHRvcFJ5LFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBbXG4gICAgICAgICAgICAgICAgJ00nLCB4LCB5LFxuICAgICAgICAgICAgICAgICdIJywgeCArIHdpZHRoLFxuICAgICAgICAgICAgICAgICdWJywgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAnSCcsIHgsXG4gICAgICAgICAgICAgICAgJ1YnLCB5LFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gVGFrZSBhIHBhdGggZGF0YSBzdHJpbmdcbiAgICAvLyBSZXR1cm4gYSBub3JtYWxpemVkIHBhdGggZGF0YSBzdHJpbmdcbiAgICAvLyBJZiBkYXRhIGNhbm5vdCBiZSBwYXJzZWQsIHJldHVybiAnTSAwIDAnXG4gICAgLy8gQWRhcHRlZCBmcm9tIFJhcHBpZCBub3JtYWxpemVQYXRoIHBvbHlmaWxsXG4gICAgLy8gSGlnaGx5IGluc3BpcmVkIGJ5IFJhcGhhZWwgTGlicmFyeSAod3d3LnJhcGhhZWwuY29tKVxuICAgIFYubm9ybWFsaXplUGF0aERhdGEgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNwYWNlcyA9ICdcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOSc7XG4gICAgICAgIHZhciBwYXRoQ29tbWFuZCA9IG5ldyBSZWdFeHAoJyhbYS16XSlbJyArIHNwYWNlcyArICcsXSooKC0/XFxcXGQqXFxcXC4/XFxcXGQqKD86ZVtcXFxcLStdP1xcXFxkKyk/WycgKyBzcGFjZXMgKyAnXSosP1snICsgc3BhY2VzICsgJ10qKSspJywgJ2lnJyk7XG4gICAgICAgIHZhciBwYXRoVmFsdWVzID0gbmV3IFJlZ0V4cCgnKC0/XFxcXGQqXFxcXC4/XFxcXGQqKD86ZVtcXFxcLStdP1xcXFxkKyk/KVsnICsgc3BhY2VzICsgJ10qLD9bJyArIHNwYWNlcyArICddKicsICdpZycpO1xuXG4gICAgICAgIHZhciBtYXRoID0gTWF0aDtcbiAgICAgICAgdmFyIFBJID0gbWF0aC5QSTtcbiAgICAgICAgdmFyIHNpbiA9IG1hdGguc2luO1xuICAgICAgICB2YXIgY29zID0gbWF0aC5jb3M7XG4gICAgICAgIHZhciB0YW4gPSBtYXRoLnRhbjtcbiAgICAgICAgdmFyIGFzaW4gPSBtYXRoLmFzaW47XG4gICAgICAgIHZhciBzcXJ0ID0gbWF0aC5zcXJ0O1xuICAgICAgICB2YXIgYWJzID0gbWF0aC5hYnM7XG5cbiAgICAgICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcblxuICAgICAgICAgICAgdmFyIF8xMyA9IDEgLyAzO1xuICAgICAgICAgICAgdmFyIF8yMyA9IDIgLyAzO1xuICAgICAgICAgICAgcmV0dXJuIFsoXzEzICogeDEpICsgKF8yMyAqIGF4KSwgKF8xMyAqIHkxKSArIChfMjMgKiBheSksIChfMTMgKiB4MikgKyAoXzIzICogYXgpLCAoXzEzICogeTIpICsgKF8yMyAqIGF5KSwgeDIsIHkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCByYWQpIHtcblxuICAgICAgICAgICAgdmFyIFggPSAoeCAqIGNvcyhyYWQpKSAtICh5ICogc2luKHJhZCkpO1xuICAgICAgICAgICAgdmFyIFkgPSAoeCAqIHNpbihyYWQpKSArICh5ICogY29zKHJhZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogWCwgeTogWSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAvLyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB0aGlzIG1hdGggY2FtZSBmcm9tIHZpc2l0OlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICB2YXIgXzEyMCA9IChQSSAqIDEyMCkgLyAxODA7XG4gICAgICAgICAgICB2YXIgcmFkID0gKFBJIC8gMTgwKSAqICgrYW5nbGUgfHwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICB2YXIgeHk7XG5cbiAgICAgICAgICAgIGlmICghcmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgICAgICB4MSA9IHh5Lng7XG4gICAgICAgICAgICAgICAgeTEgPSB4eS55O1xuXG4gICAgICAgICAgICAgICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICAgICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICAgICAgeTIgPSB4eS55O1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSAoeDEgLSB4MikgLyAyO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9ICgoeCAqIHgpIC8gKHJ4ICogcngpKSArICgoeSAqIHkpIC8gKHJ5ICogcnkpKTtcblxuICAgICAgICAgICAgICAgIGlmIChoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBoID0gc3FydChoKTtcbiAgICAgICAgICAgICAgICAgICAgcnggPSBoICogcng7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByeDIgPSByeCAqIHJ4O1xuICAgICAgICAgICAgICAgIHZhciByeTIgPSByeSAqIHJ5O1xuXG4gICAgICAgICAgICAgICAgdmFyIGsgPSAoKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcpID8gLTEgOiAxKSAqIHNxcnQoYWJzKCgocngyICogcnkyKSAtIChyeDIgKiB5ICogeSkgLSAocnkyICogeCAqIHgpKSAvICgocngyICogeSAqIHkpICsgKHJ5MiAqIHggKiB4KSkpKTtcblxuICAgICAgICAgICAgICAgIHZhciBjeCA9ICgoayAqIHJ4ICogeSkgLyByeSkgKyAoKHgxICsgeDIpIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gKChrICogLXJ5ICogeCkgLyByeCkgKyAoKHkxICsgeTIpIC8gMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgZjEgPSBhc2luKCgoeTEgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG4gICAgICAgICAgICAgICAgdmFyIGYyID0gYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuXG4gICAgICAgICAgICAgICAgZjEgPSAoKHgxIDwgY3gpID8gKFBJIC0gZjEpIDogZjEpO1xuICAgICAgICAgICAgICAgIGYyID0gKCh4MiA8IGN4KSA/IChQSSAtIGYyKSA6IGYyKTtcblxuICAgICAgICAgICAgICAgIGlmIChmMSA8IDApIGYxID0gKFBJICogMikgKyBmMTtcbiAgICAgICAgICAgICAgICBpZiAoZjIgPCAwKSBmMiA9IChQSSAqIDIpICsgZjI7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3dlZXBfZmxhZyAmJiAoZjEgPiBmMikpIGYxID0gZjEgLSAoUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgKGYyID4gZjEpKSBmMiA9IGYyIC0gKFBJICogMik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgICAgICAgICAgICAgZjIgPSByZWN1cnNpdmVbMV07XG4gICAgICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICAgICAgY3kgPSByZWN1cnNpdmVbM107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZiA9IGYyIC0gZjE7XG4gICAgICAgICAgICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgICAgICAgICB2YXIgZjJvbGQgPSBmMjtcbiAgICAgICAgICAgICAgICB2YXIgeDJvbGQgPSB4MjtcbiAgICAgICAgICAgICAgICB2YXIgeTJvbGQgPSB5MjtcbiAgICAgICAgICAgICAgICBmMiA9IGYxICsgKF8xMjAgKiAoKHN3ZWVwX2ZsYWcgJiYgKGYyID4gZjEpKSA/IDEgOiAtMSkpO1xuICAgICAgICAgICAgICAgIHgyID0gY3ggKyAocnggKiBjb3MoZjIpKTtcbiAgICAgICAgICAgICAgICB5MiA9IGN5ICsgKHJ5ICogc2luKGYyKSk7XG4gICAgICAgICAgICAgICAgcmVzID0gYTJjKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGYgPSBmMiAtIGYxO1xuXG4gICAgICAgICAgICB2YXIgYzEgPSBjb3MoZjEpO1xuICAgICAgICAgICAgdmFyIHMxID0gc2luKGYxKTtcbiAgICAgICAgICAgIHZhciBjMiA9IGNvcyhmMik7XG4gICAgICAgICAgICB2YXIgczIgPSBzaW4oZjIpO1xuICAgICAgICAgICAgdmFyIHQgPSB0YW4oZGYgLyA0KTtcbiAgICAgICAgICAgIHZhciBoeCA9ICg0IC8gMykgKiAocnggKiB0KTtcbiAgICAgICAgICAgIHZhciBoeSA9ICg0IC8gMykgKiAocnkgKiB0KTtcbiAgICAgICAgICAgIHZhciBtMSA9IFt4MSwgeTFdO1xuICAgICAgICAgICAgdmFyIG0yID0gW3gxICsgKGh4ICogczEpLCB5MSAtIChoeSAqIGMxKV07XG4gICAgICAgICAgICB2YXIgbTMgPSBbeDIgKyAoaHggKiBzMiksIHkyIC0gKGh5ICogYzIpXTtcbiAgICAgICAgICAgIHZhciBtNCA9IFt4MiwgeTJdO1xuXG4gICAgICAgICAgICBtMlswXSA9ICgyICogbTFbMF0pIC0gbTJbMF07XG4gICAgICAgICAgICBtMlsxXSA9ICgyICogbTFbMV0pIC0gbTJbMV07XG5cbiAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcykuam9pbigpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld3JlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBpaSA9IHJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IChpICUgMikgPyByb3RhdGUocmVzW2kgLSAxXSwgcmVzW2ldLCByYWQpLnkgOiByb3RhdGUocmVzW2ldLCByZXNbaSArIDFdLCByYWQpLng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVBhdGhTdHJpbmcocGF0aFN0cmluZykge1xuXG4gICAgICAgICAgICBpZiAoIXBhdGhTdHJpbmcpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1Db3VudHMgPSB7IGE6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDAgfTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XG5cbiAgICAgICAgICAgIFN0cmluZyhwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbihhLCBiLCBjKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICgobmFtZSA9PT0gJ20nKSAmJiAocGFyYW1zLmxlbmd0aCA+IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgYiA9ICgoYiA9PT0gJ20nKSA/ICdsJyA6ICdMJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbUNvdW50c1tuYW1lXSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGF0aFRvQWJzb2x1dGUocGF0aEFycmF5KSB7XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRoQXJyYXkpIHx8ICFBcnJheS5pc0FycmF5KHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0pKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgICAgICAgICBwYXRoQXJyYXkgPSBwYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaW52YWxpZCBzdHJpbmcsIHJldHVybiAnTSAwIDAnXG4gICAgICAgICAgICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkgcmV0dXJuIFtbJ00nLCAwLCAwXV07XG5cbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgIHZhciBteCA9IDA7XG4gICAgICAgICAgICB2YXIgbXkgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHZhciBwYTA7XG5cbiAgICAgICAgICAgIHZhciBpaSA9IHBhdGhBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBpaTsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhID0gcGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIHBhMCA9IHBhWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICByWzBdID0gcGEwLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGpqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArcGFbN10gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteSA9ICtwYVsyXSArIHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqaiA9IHBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gK3BhW2pdICsgKChqICUgMikgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpqID0gcGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoKGogJSAyKSA/IHggOiB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2sgPSBwYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcblxuICAgICAgICAgICAgdmFyIHAgPSBwYXRoVG9BYnNvbHV0ZShwYXRoKTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHsgeDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGwgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1BhdGgocGF0aCwgZCwgcGNvbSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG54LCBueTtcblxuICAgICAgICAgICAgICAgIGlmICghcGF0aCkgcmV0dXJuIFsnQycsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEocGF0aFswXSBpbiB7IFQ6IDEsIFE6IDEgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5xeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGQucXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChwYXRoWzFdKSA9PT0gMCB8fCBwYXJzZUZsb2F0KHBhdGhbMl0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI0FyY091dE9mUmFuZ2VQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiBlaXRoZXIgcnggb3IgcnkgaXMgMCwgdGhlbiB0aGlzIGFyYyBpcyB0cmVhdGVkIGFzIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lIHNlZ21lbnQgKGEgXCJsaW5ldG9cIikgam9pbmluZyB0aGUgZW5kcG9pbnRzLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnTCcsIHBhdGhbNl0sIHBhdGhbN11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGEyYy5hcHBseSgwLCBbZC54LCBkLnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PT0gJ0MnIHx8IHBjb20gPT09ICdTJykgeyAvLyBJbiAnUycgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSAoZC54ICogMikgLSBkLmJ4OyAgICAgICAgICAvLyBBbmQgcmVmbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IChkLnkgKiAyKSAtIGQuYnk7ICAgICAgICAgIC8vIGNvbW1hbmQncyBjb250cm9sIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0MnLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjb20gPT09ICdRJyB8fCBwY29tID09PSAnVCcpIHsgLy8gSW4gJ1QnIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSAoZC54ICogMikgLSBkLnF4OyAgICAgICAgLy8gQW5kIG1ha2UgYSByZWZsZWN0aW9uIHNpbWlsYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gKGQueSAqIDIpIC0gZC5xeTsgICAgICAgIC8vIHRvIGNhc2UgJ1MnLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZXRoaW5nIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQocTJjKGQueCwgZC55LCBkLnF4LCBkLnF5LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydMJ10uY29uY2F0KHBhdGhbMV0sIGQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0wnXS5jb25jYXQoZC54LCBwYXRoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZml4QXJjKHBwLCBpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuXG4gICAgICAgICAgICAgICAgICAgIHBwW2ldLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IHBwW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwaS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjb21zW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlICdDJ3MsIHRoZWlyIG9yaWdpbmFsIHNlZyBpcyBzYXZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgWydDJ10uY29uY2F0KHBpLnNwbGljZSgwLCA2KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IHAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBjb21zID0gW107IC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICB2YXIgcGZpcnN0ID0gJyc7IC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuICAgICAgICAgICAgdmFyIHBjb20gPSAnJzsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuXG4gICAgICAgICAgICB2YXIgaWkgPSBwLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwW2ldKSBwZmlyc3QgPSBwW2ldWzBdOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9PSAnQycpIHsgLy8gQyBpcyBub3Qgc2F2ZWQgeWV0LCBiZWNhdXNlIGl0IG1heSBiZSByZXN1bHQgb2YgY29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICBwY29tc1tpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHBjb20gPSBwY29tc1tpIC0gMV07IC8vIEdldCBwcmV2aW91cyBwYXRoIGNvbW1hbmQgcGNvbVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zW2ldICE9PSAnQScgJiYgcGZpcnN0ID09PSAnQycpIHBjb21zW2ldID0gJ0MnOyAvLyAnQScgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1heSBwcm9kdWNlIG11bHRpcGxlICdDJ3NcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0ICdDJyBpcyBhbHNvICdDJyBpbiBvcmlnaW5hbCBwYXRoXG5cbiAgICAgICAgICAgICAgICBmaXhBcmMocCwgaSk7IC8vIGZpeEFyYyBhZGRzIGFsc28gdGhlIHJpZ2h0IGFtb3VudCBvZiAnQSdzIHRvIHBjb21zXG5cbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gcFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbGVuID0gc2VnLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGF0dHJzLnggPSBzZWdbc2VnbGVuIC0gMl07XG4gICAgICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcblxuICAgICAgICAgICAgICAgIGF0dHJzLmJ4ID0gcGFyc2VGbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICAgICAgYXR0cnMuYnkgPSBwYXJzZUZsb2F0KHNlZ1tzZWdsZW4gLSAzXSkgfHwgYXR0cnMueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vcm1hbGl6ZWQgcGF0aCBkYXRhIHN0cmluZyBzdGFydHMgd2l0aCBhbiBNIHNlZ21lbnRcbiAgICAgICAgICAgIGlmICghcFswXVswXSB8fCBwWzBdWzBdICE9PSAnTScpIHtcbiAgICAgICAgICAgICAgICBwLnVuc2hpZnQoWydNJywgMCwgMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShwYXRoRGF0YSkuam9pbignLCcpLnNwbGl0KCcsJykuam9pbignICcpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBWLm5hbWVzcGFjZSA9IG5zO1xuXG4gICAgVi5nID0gZztcblxuICAgIHJldHVybiBWO1xuXG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBWO1xuIl0sIm5hbWVzIjpbImciLCJWIiwiaGFzU3ZnIiwid2luZG93IiwiU1ZHQW5nbGUiLCJFcnJvciIsIm5zIiwic3ZnIiwieG1sbnMiLCJ4bWwiLCJ4bGluayIsInhodG1sIiwiU1ZHVmVyc2lvbiIsIm1hdGgiLCJNYXRoIiwiUEkiLCJhdGFuMiIsInNxcnQiLCJtaW4iLCJtYXgiLCJjb3MiLCJzaW4iLCJlbCIsImF0dHJzIiwiY2hpbGRyZW4iLCJhcHBseSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsImlzViIsIm5vZGUiLCJpc1N0cmluZyIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZVN2Z0RvY3VtZW50Iiwic3ZnRG9jIiwiY2hpbGROb2RlcyIsImxlbmd0aCIsImFycmF5T2ZWZWxzIiwiaSIsImxlbiIsImNoaWxkTm9kZSIsInB1c2giLCJkb2N1bWVudCIsImltcG9ydE5vZGUiLCJmaXJzdENoaWxkIiwiY3JlYXRlRWxlbWVudE5TIiwiZW5zdXJlSWQiLCJzZXRBdHRyaWJ1dGVzIiwiYXBwZW5kIiwiVlByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlkIiwic2V0IiwiZ2V0VHJhbnNmb3JtVG9FbGVtZW50IiwidGFyZ2V0IiwiaXNTVkdHcmFwaGljc0VsZW1lbnQiLCJ0YXJnZXRDVE0iLCJ0b05vZGUiLCJnZXRTY3JlZW5DVE0iLCJub2RlQ1RNIiwiaW52ZXJzZSIsIm11bHRpcGx5IiwiY3JlYXRlU1ZHTWF0cml4IiwidHJhbnNmb3JtIiwibWF0cml4Iiwib3B0IiwiaXNVbmRlZmluZWQiLCJ0cmFuc2Zvcm1TdHJpbmdUb01hdHJpeCIsImF0dHIiLCJhYnNvbHV0ZSIsIm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nIiwic3ZnVHJhbnNmb3JtIiwiY3JlYXRlU1ZHVHJhbnNmb3JtIiwiYmFzZVZhbCIsImFwcGVuZEl0ZW0iLCJ0cmFuc2xhdGUiLCJ0eCIsInR5IiwidHJhbnNmb3JtQXR0ciIsInBhcnNlVHJhbnNmb3JtU3RyaW5nIiwidmFsdWUiLCJyZXBsYWNlIiwibmV3VHgiLCJuZXdUeSIsIm5ld1RyYW5zbGF0ZSIsInJvdGF0ZSIsImFuZ2xlIiwiY3giLCJjeSIsIm5ld0FuZ2xlIiwibmV3T3JpZ2luIiwidW5kZWZpbmVkIiwibmV3Um90YXRlIiwic2NhbGUiLCJzeCIsInN5IiwibmV3U2NhbGUiLCJiYm94Iiwid2l0aG91dFRyYW5zZm9ybWF0aW9ucyIsImJveCIsIm93bmVyU1ZHRWxlbWVudCIsIlJlY3QiLCJnZXRCQm94IiwiZSIsIngiLCJjbGllbnRMZWZ0IiwieSIsImNsaWVudFRvcCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ0cmFuc2Zvcm1SZWN0Iiwib3B0aW9ucyIsIm91dHB1dEJCb3giLCJyZWN1cnNpdmUiLCJuIiwiY3VycmVudENoaWxkIiwiY2hpbGRCQm94IiwidW5pb24iLCJjcmVhdGVUZXh0UGF0aE5vZGUiLCJ2ZWwiLCJ0ZXh0UGF0aEVsZW1lbnQiLCJkIiwibGlua2VkUGF0aCIsImFwcGVuZFRvIiwiZGVmcyIsImlzT2JqZWN0IiwiYW5ub3RhdGVUZXh0TGluZSIsImxpbmVOb2RlIiwibGluZUFubm90YXRpb25zIiwiaW5jbHVkZUFubm90YXRpb25JbmRpY2VzIiwiZW9sIiwibGluZUhlaWdodCIsImJhc2VTaXplIiwibWF4Rm9udFNpemUiLCJmb250TWV0cmljcyIsImxhc3RKIiwiaiIsImFubm90YXRpb24iLCJmb250U2l6ZSIsImFubm90YXRpb25BdHRycyIsInZUU3BhbiIsInRzcGFuTm9kZSIsInQiLCJ0ZXh0Q29udGVudCIsImFubm90YXRpb25DbGFzcyIsImFkZENsYXNzIiwiYW5ub3RhdGlvbnMiLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJjcmVhdGVUZXh0Tm9kZSIsImFwcGVuZENoaWxkIiwiZW1SZWdleCIsImNvbnZlcnRFbVRvUHgiLCJlbSIsIm51bWVyaWNhbCIsInRlc3QiLCJjYWxjdWxhdGVEWSIsImFsaWdubWVudCIsImxpbmVzTWV0cmljcyIsImJhc2VTaXplUHgiLCJBcnJheSIsImlzQXJyYXkiLCJsaW5lTWV0cmljcyIsImZsTWF4Rm9udCIsInJMaW5lSGVpZ2h0cyIsImxpbmVIZWlnaHRQeCIsImlMaW5lSGVpZ2h0IiwibGxNYXhGb250IiwiZHkiLCJ0ZXh0IiwiY29udGVudCIsInNhbml0aXplVGV4dCIsImRpc3BsYXlFbXB0eSIsInRleHRQYXRoIiwidmVydGljYWxBbmNob3IiLCJ0ZXh0VmVydGljYWxBbmNob3IiLCJuYW1lZFZlcnRpY2FsQW5jaG9yIiwiaWFpIiwiZGVmYXVsdExpbmVIZWlnaHQiLCJhdXRvTGluZUhlaWdodCIsImVtcHR5IiwiZG9jIiwiY29udGFpbmVyTm9kZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJvZmZzZXQiLCJsaW5lcyIsInNwbGl0IiwiYW5ub3RhdGVkWSIsImxhc3RJIiwibGluZUNsYXNzTmFtZSIsImxpbmUiLCJhbm5vdGF0ZVN0cmluZyIsImxpbmVOb2RlU3R5bGUiLCJzdHlsZSIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlT3BhY2l0eSIsImZpbmRBbm5vdGF0aW9uc0F0SW5kZXgiLCJsaW5lRm9udFNpemUiLCJmcyIsInNldEF0dHJpYnV0ZSIsImNsYXNzTmFtZSIsInJoIiwicmVtb3ZlQXR0ciIsIm5hbWUiLCJ0cnVlTmFtZSIsImF0dHJpYnV0ZU5hbWVzIiwibG9jYWwiLCJxdWFsaWZ5QXR0ciIsImhhc0F0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlIiwiYXR0ck5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsIm5vcm1hbGl6ZVBhdGgiLCJ0YWdOYW1lIiwibm9ybWFsaXplUGF0aERhdGEiLCJyZW1vdmUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJrZXkiLCJlbHMiLCJwcmVwZW5kIiwiY2hpbGQiLCJiZWZvcmUiLCJwYXJlbnQiLCJpbnNlcnRCZWZvcmUiLCJTVkdTVkdFbGVtZW50IiwidG9VcHBlckNhc2UiLCJjb250ZXh0IiwiZGVmc05vZGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNsb25lIiwiY2xvbmVOb2RlIiwidW5pcXVlSWQiLCJmaW5kT25lIiwic2VsZWN0b3IiLCJmb3VuZCIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kIiwidmVscyIsIm5vZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsIm91dHB1dEFycmF5Iiwibm9kZVR5cGUiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsImZpbmRQYXJlbnRCeUNsYXNzIiwidGVybWluYXRvciIsImhhc0NsYXNzIiwiY29udGFpbnMiLCJhIiwiYiIsImJ1cCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwidG9Mb2NhbFBvaW50IiwicCIsImNyZWF0ZVNWR1BvaW50IiwiZ2xvYmFsUG9pbnQiLCJtYXRyaXhUcmFuc2Zvcm0iLCJnbG9iYWxUb0xvY2FsTWF0cml4IiwidHJhbnNsYXRlQ2VudGVyVG9Qb2ludCIsImNlbnRlciIsInRyYW5zbGF0ZUFuZEF1dG9PcmllbnQiLCJwb3NpdGlvbiIsInJlZmVyZW5jZSIsIlBvaW50IiwidHJhbnNsYXRlVG9PcmlnaW4iLCJzZXRUcmFuc2xhdGUiLCJyb3RhdGVBcm91bmRPcmlnaW4iLCJhbmdsZUJldHdlZW4iLCJzZXRSb3RhdGUiLCJ0cmFuc2xhdGVGcm9tT3JpZ2luIiwiZmluYWxQb3NpdGlvbiIsIm1vdmUiLCJjdG0iLCJzZXRNYXRyaXgiLCJhbmltYXRlQWxvbmdQYXRoIiwicGF0aCIsImFuaW1hdGVNb3Rpb24iLCJtcGF0aCIsImJlZ2luRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImFuaW1hdGlvbiIsImFuaW1hdG9ycyIsImFuaW1hdGlvbklEIiwiaWQyYW5pbSIsInRhcmdldHMiLCJnZXRUYXJnZXRzIiwiYW5pbWF0b3IiLCJBbmltYXRvciIsInJlZ2lzdGVyIiwibm9IVE1MV2hpdGVzcGFjZVJlZ2V4IiwiZ2V0VG9rZW5MaXN0Iiwic3RyIiwibWF0Y2giLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwidG9BZGQiLCJ0b2tlbnMiLCJ0b2dnbGUiLCJzYW1wbGUiLCJpbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwic2FtcGxlcyIsImRpc3RhbmNlIiwiZ2V0UG9pbnRBdExlbmd0aCIsImNvbnZlcnRUb1BhdGgiLCJjb252ZXJ0VG9QYXRoRGF0YSIsImNvbnZlcnRMaW5lVG9QYXRoRGF0YSIsImNvbnZlcnRQb2x5Z29uVG9QYXRoRGF0YSIsImNvbnZlcnRQb2x5bGluZVRvUGF0aERhdGEiLCJjb252ZXJ0RWxsaXBzZVRvUGF0aERhdGEiLCJjb252ZXJ0Q2lyY2xlVG9QYXRoRGF0YSIsImNvbnZlcnRSZWN0VG9QYXRoRGF0YSIsInRvR2VvbWV0cnlTaGFwZSIsInIiLCJyeCIsInJ5IiwicG9pbnRzIiwieDEiLCJ4MiIsInkxIiwieTIiLCJFbGxpcHNlIiwiZ2V0UG9pbnRzRnJvbVN2Z05vZGUiLCJQb2x5bGluZSIsIlBhdGgiLCJpc0RhdGFTdXBwb3J0ZWQiLCJMaW5lIiwiZmluZEludGVyc2VjdGlvbiIsInJlZiIsImludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQiLCJzcG90IiwiZ1JlY3QiLCJyZWN0TWF0cml4IiwicmVjdE1hdHJpeENvbXBvbmVudHMiLCJkZWNvbXBvc2VNYXRyaXgiLCJyZXNldFJvdGF0aW9uIiwicm90YXRpb24iLCJyZWN0IiwicGF0aE5vZGUiLCJtaW5EaXN0YW5jZSIsIkluZmluaXR5IiwiY2xvc2VzdFNhbXBsZXMiLCJncCIsImNlbnRlckRpc3RhbmNlIiwicmVmRGlzdGFuY2UiLCJzb3J0Iiwic2V0QXR0cmlidXRlTlMiLCJYTUxTdHJpbmciLCJwYXJzZVhNTCIsImFzeW5jIiwiY3JlYXRlU1ZHU3R5bGUiLCJzdHlsZXNoZWV0IiwidHlwZSIsImNyZWF0ZUNEQVRBU2VjdGlvbiIsImRhdGEiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZURvY3VtZW50IiwiaWRDb3VudGVyIiwibm9kZU5hbWUiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJlcnJvciIsIl9hdHRyaWJ1dGVOYW1lcyIsImZvckVhY2giLCJQcm94eSIsImNhY2hlIiwic3VwcG9ydENhbWVsQ2FzZUF0dHJpYnV0ZXMiLCJ3cml0YWJsZSIsImluZGV4T2YiLCJjb21iaW5lZEtleSIsInRyYW5zZm9ybVNlcGFyYXRvclJlZ2V4IiwidHJhbnNmb3JtUmVnZXgiLCJ0cmFuc2Zvcm1GdW5jdGlvblJlZ2V4IiwidHJhbnNmb3JtVHJhbnNsYXRlUmVnZXgiLCJ0cmFuc2Zvcm1Sb3RhdGVSZWdleCIsInRyYW5zZm9ybVNjYWxlUmVnZXgiLCJ0cmFuc2Zvcm1hdGlvbk1hdHJpeCIsInRyYW5zZm9ybU1hdGNoZXMiLCJudW1NYXRjaGVzIiwidHJhbnNmb3JtTWF0Y2giLCJ0cmFuc2Zvcm1GdW5jdGlvbk1hdGNoIiwidHJhbnNmb3JtRnVuY3Rpb24iLCJhcmdzIiwic2NhbGVOb25Vbmlmb3JtIiwic2tld1giLCJza2V3WSIsImMiLCJmIiwic2VwYXJhdG9yIiwiZGVjb21wb3NlZE1hdHJpeCIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwic2NhbGVYIiwic2NhbGVZIiwidHJhbnNmb3JtYXRpb25zIiwiam9pbiIsInRyYW5zbGF0ZU1hdGNoIiwicm90YXRlTWF0Y2giLCJzY2FsZU1hdGNoIiwicGFyc2VJbnQiLCJkZWx0YVRyYW5zZm9ybVBvaW50IiwicG9pbnQiLCJkeCIsInB4IiwicHkiLCJtYXRyaXhUb1NjYWxlIiwibWF0cml4VG9Sb3RhdGUiLCJub3JtYWxpemVBbmdsZSIsInRvRGVnIiwibWF0cml4VG9UcmFuc2xhdGUiLCJvYmplY3QiLCJpc1ZFbGVtZW50IiwiU1ZHRWxlbWVudCIsInN2Z0RvY3VtZW50Iiwic3ZnTWF0cml4IiwiY29tcG9uZW50IiwiU1ZHTWF0cml4IiwiY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeCIsImNvcm5lcjEiLCJjb3JuZXIyIiwiY29ybmVyMyIsImNvcm5lcjQiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwidHJhbnNmb3JtUG9pbnQiLCJ0cmFuc2Zvcm1MaW5lIiwibCIsInN0YXJ0IiwiZW5kIiwidHJhbnNmb3JtUG9seWxpbmUiLCJpblBvaW50cyIsIm91dFBvaW50cyIsInN0eWxlVG9PYmplY3QiLCJzdHlsZVN0cmluZyIsInJldCIsInN0eWxlcyIsInBhaXIiLCJjcmVhdGVTbGljZVBhdGhEYXRhIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInN2Z0FyY01heCIsInIwIiwicjEiLCJhMCIsImExIiwiZGEiLCJkZiIsImMwIiwiczAiLCJjMSIsInMxIiwibWVyZ2VBdHRycyIsImNvbXBhY3RlZCIsImJhdGNoIiwiaXRlbSIsInByZXYiLCJKU09OIiwic3RyaW5naWZ5IiwiZmluZEFubm90YXRpb25zQmV0d2VlbkluZGV4ZXMiLCJzaGlmdEFubm90YXRpb25zIiwicG9seWdvbiIsInN2Z1BvaW50c1RvUGF0aCIsInBvbHlsaW5lIiwibm9kZVBvaW50cyIsIm51bWJlck9mSXRlbXMiLCJnZXRJdGVtIiwiS0FQUEEiLCJjaXJjbGUiLCJjZCIsImVsbGlwc2UiLCJjZHgiLCJjZHkiLCJyZWN0VG9QYXRoIiwidG9wUngiLCJib3R0b21SeCIsInRvcFJ5IiwiYm90dG9tUnkiLCJzcGFjZXMiLCJwYXRoQ29tbWFuZCIsIlJlZ0V4cCIsInBhdGhWYWx1ZXMiLCJ0YW4iLCJhc2luIiwiYWJzIiwicTJjIiwiYXgiLCJheSIsIl8xMyIsIl8yMyIsInJhZCIsIlgiLCJZIiwiYTJjIiwibGFyZ2VfYXJjX2ZsYWciLCJzd2VlcF9mbGFnIiwiXzEyMCIsInJlcyIsInh5IiwiaCIsInJ4MiIsInJ5MiIsImsiLCJmMSIsInRvRml4ZWQiLCJmMiIsImYyb2xkIiwieDJvbGQiLCJ5Mm9sZCIsImMyIiwiczIiLCJoeCIsImh5IiwibTEiLCJtMiIsIm0zIiwibTQiLCJjb25jYXQiLCJuZXdyZXMiLCJpaSIsInBhcnNlUGF0aFN0cmluZyIsInBhdGhTdHJpbmciLCJwYXJhbUNvdW50cyIsIm0iLCJxIiwicyIsInYiLCJ6IiwiU3RyaW5nIiwicGFyYW1zIiwic3BsaWNlIiwicGF0aFRvQWJzb2x1dGUiLCJwYXRoQXJyYXkiLCJteCIsIm15IiwicGEwIiwicGEiLCJqaiIsImtrIiwibm9ybWFsaXplIiwiYngiLCJieSIsInF4IiwicXkiLCJwcm9jZXNzUGF0aCIsInBjb20iLCJueCIsIm55IiwiVCIsIlEiLCJzbGljZSIsImZpeEFyYyIsInBwIiwic2hpZnQiLCJwaSIsInBjb21zIiwicGZpcnN0Iiwic2VnIiwic2VnbGVuIiwidW5zaGlmdCIsInBhdGhEYXRhIiwibmFtZXNwYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/V/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/anchors/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/jointjs/src/anchors/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   bottomLeft: () => (/* binding */ bottomLeft),\n/* harmony export */   bottomRight: () => (/* binding */ bottomRight),\n/* harmony export */   center: () => (/* binding */ center),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   midSide: () => (/* binding */ midSide),\n/* harmony export */   modelCenter: () => (/* binding */ modelCenter),\n/* harmony export */   perpendicular: () => (/* binding */ perpendicular),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top),\n/* harmony export */   topLeft: () => (/* binding */ topLeft),\n/* harmony export */   topRight: () => (/* binding */ topRight)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(ssr)/./node_modules/jointjs/src/linkAnchors/index.mjs\");\n\n\n\nfunction bboxWrapper(method) {\n    return function(view, magnet, ref, opt) {\n        var rotate = !!opt.rotate;\n        var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n        return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\nfunction _perpendicular(view, magnet, refPoint, opt) {\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n    if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n        var dy = refPoint.y - anchor.y;\n        anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.y += dy;\n    } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n        var dx = refPoint.x - anchor.x;\n        anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.x += dx;\n    }\n    return anchor;\n}\nfunction _midSide(view, magnet, refPoint, opt) {\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n    if (rotate) refPoint.rotate(center, angle);\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch(side){\n        case \"left\":\n            anchor = bbox.leftMiddle();\n            break;\n        case \"right\":\n            anchor = bbox.rightMiddle();\n            break;\n        case \"top\":\n            anchor = bbox.topMiddle();\n            break;\n        case \"bottom\":\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n    return rotate ? anchor.rotate(center, -angle) : anchor;\n}\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n//joint.anchors\nconst center = bboxWrapper(\"center\");\nconst top = bboxWrapper(\"topMiddle\");\nconst bottom = bboxWrapper(\"bottomMiddle\");\nconst left = bboxWrapper(\"leftMiddle\");\nconst right = bboxWrapper(\"rightMiddle\");\nconst topLeft = bboxWrapper(\"origin\");\nconst topRight = bboxWrapper(\"topRight\");\nconst bottomLeft = bboxWrapper(\"bottomLeft\");\nconst bottomRight = bboxWrapper(\"corner\");\nconst perpendicular = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_perpendicular);\nconst midSide = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_midSide);\nconst modelCenter = _modelCenter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvYW5jaG9ycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ0g7QUFDZTtBQUV0RCxTQUFTRyxZQUFZQyxNQUFNO0lBRXZCLE9BQU8sU0FBU0MsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUVsQyxJQUFJQyxTQUFTLENBQUMsQ0FBQ0QsSUFBSUMsTUFBTTtRQUN6QixJQUFJQyxPQUFPLFNBQVdMLEtBQUtNLG9CQUFvQixDQUFDTCxVQUFVRCxLQUFLTyxXQUFXLENBQUNOO1FBQzNFLElBQUlPLFNBQVNILElBQUksQ0FBQ04sT0FBTztRQUV6QixJQUFJVSxLQUFLTixJQUFJTSxFQUFFO1FBQ2YsSUFBSUEsSUFBSTtZQUNKLElBQUlDLGVBQWVmLHlEQUFpQixDQUFDYztZQUNyQ0EsS0FBS0csV0FBV0g7WUFDaEIsSUFBSUksU0FBU0osS0FBSztnQkFDZCxJQUFJQyxjQUFjO29CQUNkRCxNQUFNO29CQUNOQSxNQUFNSixLQUFLUyxLQUFLO2dCQUNwQjtnQkFDQU4sT0FBT08sQ0FBQyxJQUFJTjtZQUNoQjtRQUNKO1FBRUEsSUFBSU8sS0FBS2IsSUFBSWEsRUFBRTtRQUNmLElBQUlBLElBQUk7WUFDSixJQUFJQyxlQUFldEIseURBQWlCLENBQUNxQjtZQUNyQ0EsS0FBS0osV0FBV0k7WUFDaEIsSUFBSUgsU0FBU0csS0FBSztnQkFDZCxJQUFJQyxjQUFjO29CQUNkRCxNQUFNO29CQUNOQSxNQUFNWCxLQUFLYSxNQUFNO2dCQUNyQjtnQkFDQVYsT0FBT1csQ0FBQyxJQUFJSDtZQUNoQjtRQUNKO1FBRUEsT0FBTyxTQUFXUixPQUFPSixNQUFNLENBQUNKLEtBQUtvQixLQUFLLENBQUNDLE9BQU8sR0FBR0MsTUFBTSxJQUFJLENBQUN0QixLQUFLb0IsS0FBSyxDQUFDRyxLQUFLLE1BQU1mO0lBQzFGO0FBQ0o7QUFFQSxTQUFTZ0IsZUFBZXhCLElB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QUFZLGFBQWE7QUFDckMsTUFBTWtELFNBQVNsRCxZQUFZLGdCQUFnQjtBQUMzQyxNQUFNbUQsT0FBT25ELFlBQVksY0FBYztBQUN2QyxNQUFNb0QsUUFBUXBELFlBQVksZUFBZTtBQUN6QyxNQUFNNEIsVUFBVTVCLFlBQVksVUFBVTtBQUN0QyxNQUFNcUQsV0FBV3JELFlBQVksWUFBWTtBQUN6QyxNQUFNc0QsYUFBYXRELFlBQVksY0FBYztBQUM3QyxNQUFNOEIsY0FBYzlCLFlBQVksVUFBVTtBQUMxQyxNQUFNdUQsZ0JBQWdCeEQsa0VBQVVBLENBQUMyQixnQkFBZ0I7QUFDakQsTUFBTThCLFVBQVV6RCxrRUFBVUEsQ0FBQ29DLFVBQVU7QUFDckMsTUFBTXNCLGNBQWNkLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9hbmNob3JzL2luZGV4Lm1qcz9hZmIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgdG9SYWQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlUmVmIH0gZnJvbSAnLi4vbGlua0FuY2hvcnMvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gYmJveFdyYXBwZXIobWV0aG9kKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odmlldywgbWFnbmV0LCByZWYsIG9wdCkge1xuXG4gICAgICAgIHZhciByb3RhdGUgPSAhIW9wdC5yb3RhdGU7XG4gICAgICAgIHZhciBiYm94ID0gKHJvdGF0ZSkgPyB2aWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KG1hZ25ldCkgOiB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBiYm94W21ldGhvZF0oKTtcblxuICAgICAgICB2YXIgZHggPSBvcHQuZHg7XG4gICAgICAgIGlmIChkeCkge1xuICAgICAgICAgICAgdmFyIGR4UGVyY2VudGFnZSA9IHV0aWwuaXNQZXJjZW50YWdlKGR4KTtcbiAgICAgICAgICAgIGR4ID0gcGFyc2VGbG9hdChkeCk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZHgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR4UGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkeCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGR4ICo9IGJib3gud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2hvci54ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR5ID0gb3B0LmR5O1xuICAgICAgICBpZiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkeVBlcmNlbnRhZ2UgPSB1dGlsLmlzUGVyY2VudGFnZShkeSk7XG4gICAgICAgICAgICBkeSA9IHBhcnNlRmxvYXQoZHkpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICAgICAgICAgIGlmIChkeVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHkgLz0gMTAwO1xuICAgICAgICAgICAgICAgICAgICBkeSAqPSBiYm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5jaG9yLnkgKz0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHJvdGF0ZSkgPyBhbmNob3Iucm90YXRlKHZpZXcubW9kZWwuZ2V0QkJveCgpLmNlbnRlcigpLCAtdmlldy5tb2RlbC5hbmdsZSgpKSA6IGFuY2hvcjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfcGVycGVuZGljdWxhcih2aWV3LCBtYWduZXQsIHJlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciBhbmdsZSA9IHZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICB2YXIgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICB2YXIgYW5jaG9yID0gYmJveC5jZW50ZXIoKTtcbiAgICB2YXIgdG9wTGVmdCA9IGJib3gub3JpZ2luKCk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gYmJveC5jb3JuZXIoKTtcblxuICAgIHZhciBwYWRkaW5nID0gb3B0LnBhZGRpbmc7XG4gICAgaWYgKCFpc0Zpbml0ZShwYWRkaW5nKSkgcGFkZGluZyA9IDA7XG5cbiAgICBpZiAoKHRvcExlZnQueSArIHBhZGRpbmcpIDw9IHJlZlBvaW50LnkgJiYgcmVmUG9pbnQueSA8PSAoYm90dG9tUmlnaHQueSAtIHBhZGRpbmcpKSB7XG4gICAgICAgIHZhciBkeSA9IChyZWZQb2ludC55IC0gYW5jaG9yLnkpO1xuICAgICAgICBhbmNob3IueCArPSAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkgPyAwIDogZHkgKiAxIC8gTWF0aC50YW4odG9SYWQoYW5nbGUpKTtcbiAgICAgICAgYW5jaG9yLnkgKz0gZHk7XG4gICAgfSBlbHNlIGlmICgodG9wTGVmdC54ICsgcGFkZGluZykgPD0gcmVmUG9pbnQueCAmJiByZWZQb2ludC54IDw9IChib3R0b21SaWdodC54IC0gcGFkZGluZykpIHtcbiAgICAgICAgdmFyIGR4ID0gKHJlZlBvaW50LnggLSBhbmNob3IueCk7XG4gICAgICAgIGFuY2hvci55ICs9IChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkgPyAwIDogZHggKiBNYXRoLnRhbih0b1JhZChhbmdsZSkpO1xuICAgICAgICBhbmNob3IueCArPSBkeDtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9yO1xufVxuXG5mdW5jdGlvbiBfbWlkU2lkZSh2aWV3LCBtYWduZXQsIHJlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciByb3RhdGUgPSAhIW9wdC5yb3RhdGU7XG4gICAgdmFyIGJib3gsIGFuZ2xlLCBjZW50ZXI7XG4gICAgaWYgKHJvdGF0ZSkge1xuICAgICAgICBiYm94ID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgICAgICBjZW50ZXIgPSB2aWV3Lm1vZGVsLmdldEJCb3goKS5jZW50ZXIoKTtcbiAgICAgICAgYW5nbGUgPSB2aWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IG9wdC5wYWRkaW5nO1xuICAgIGlmIChpc0Zpbml0ZShwYWRkaW5nKSkgYmJveC5pbmZsYXRlKHBhZGRpbmcpO1xuXG4gICAgaWYgKHJvdGF0ZSkgcmVmUG9pbnQucm90YXRlKGNlbnRlciwgYW5nbGUpO1xuXG4gICAgdmFyIHNpZGUgPSBiYm94LnNpZGVOZWFyZXN0VG9Qb2ludChyZWZQb2ludCk7XG4gICAgdmFyIGFuY2hvcjtcbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LmxlZnRNaWRkbGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LnJpZ2h0TWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGFuY2hvciA9IGJib3gudG9wTWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGFuY2hvciA9IGJib3guYm90dG9tTWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gKHJvdGF0ZSkgPyBhbmNob3Iucm90YXRlKGNlbnRlciwgLWFuZ2xlKSA6IGFuY2hvcjtcbn1cblxuLy8gQ2FuIGZpbmQgYW5jaG9yIGZyb20gbW9kZWwsIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0b3Igb3IgdGhlIGxpbmsgZW5kXG4vLyBpcyBjb25uZWN0ZWQgdG8gYSBwb3J0XG5mdW5jdGlvbiBfbW9kZWxDZW50ZXIodmlldywgX21hZ25ldCwgX3JlZlBvaW50LCBvcHQsIGVuZFR5cGUpIHtcbiAgICByZXR1cm4gdmlldy5tb2RlbC5nZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rKHRoaXMubW9kZWwsIGVuZFR5cGUpLm9mZnNldChvcHQuZHgsIG9wdC5keSk7XG59XG5cbi8vam9pbnQuYW5jaG9yc1xuZXhwb3J0IGNvbnN0IGNlbnRlciA9IGJib3hXcmFwcGVyKCdjZW50ZXInKTtcbmV4cG9ydCBjb25zdCB0b3AgPSBiYm94V3JhcHBlcigndG9wTWlkZGxlJyk7XG5leHBvcnQgY29uc3QgYm90dG9tID0gYmJveFdyYXBwZXIoJ2JvdHRvbU1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IGxlZnQgPSBiYm94V3JhcHBlcignbGVmdE1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IHJpZ2h0ID0gYmJveFdyYXBwZXIoJ3JpZ2h0TWlkZGxlJyk7XG5leHBvcnQgY29uc3QgdG9wTGVmdCA9IGJib3hXcmFwcGVyKCdvcmlnaW4nKTtcbmV4cG9ydCBjb25zdCB0b3BSaWdodCA9IGJib3hXcmFwcGVyKCd0b3BSaWdodCcpO1xuZXhwb3J0IGNvbnN0IGJvdHRvbUxlZnQgPSBiYm94V3JhcHBlcignYm90dG9tTGVmdCcpO1xuZXhwb3J0IGNvbnN0IGJvdHRvbVJpZ2h0ID0gYmJveFdyYXBwZXIoJ2Nvcm5lcicpO1xuZXhwb3J0IGNvbnN0IHBlcnBlbmRpY3VsYXIgPSByZXNvbHZlUmVmKF9wZXJwZW5kaWN1bGFyKTtcbmV4cG9ydCBjb25zdCBtaWRTaWRlID0gcmVzb2x2ZVJlZihfbWlkU2lkZSk7XG5leHBvcnQgY29uc3QgbW9kZWxDZW50ZXIgPSBfbW9kZWxDZW50ZXI7XG5cbiJdLCJuYW1lcyI6WyJ1dGlsIiwidG9SYWQiLCJyZXNvbHZlUmVmIiwiYmJveFdyYXBwZXIiLCJtZXRob2QiLCJ2aWV3IiwibWFnbmV0IiwicmVmIiwib3B0Iiwicm90YXRlIiwiYmJveCIsImdldE5vZGVVbnJvdGF0ZWRCQm94IiwiZ2V0Tm9kZUJCb3giLCJhbmNob3IiLCJkeCIsImR4UGVyY2VudGFnZSIsImlzUGVyY2VudGFnZSIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsIndpZHRoIiwieCIsImR5IiwiZHlQZXJjZW50YWdlIiwiaGVpZ2h0IiwieSIsIm1vZGVsIiwiZ2V0QkJveCIsImNlbnRlciIsImFuZ2xlIiwiX3BlcnBlbmRpY3VsYXIiLCJyZWZQb2ludCIsInRvcExlZnQiLCJvcmlnaW4iLCJib3R0b21SaWdodCIsImNvcm5lciIsInBhZGRpbmciLCJNYXRoIiwidGFuIiwiX21pZFNpZGUiLCJpbmZsYXRlIiwic2lkZSIsInNpZGVOZWFyZXN0VG9Qb2ludCIsImxlZnRNaWRkbGUiLCJyaWdodE1pZGRsZSIsInRvcE1pZGRsZSIsImJvdHRvbU1pZGRsZSIsIl9tb2RlbENlbnRlciIsIl9tYWduZXQiLCJfcmVmUG9pbnQiLCJlbmRUeXBlIiwiZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayIsIm9mZnNldCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsInBlcnBlbmRpY3VsYXIiLCJtaWRTaWRlIiwibW9kZWxDZW50ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/anchors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/config/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/jointjs/src/config/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\nconst config = {\n    // When set to `true` the cell selectors could be defined as CSS selectors.\n    // If not, only JSON Markup selectors are taken into account.\n    // export let useCSSSelectors = true;\n    useCSSSelectors: true,\n    // The class name prefix config is for advanced use only.\n    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n    // export let classNamePrefix = 'joint-';\n    // export let defaultTheme = 'default';\n    classNamePrefix: \"joint-\",\n    defaultTheme: \"default\",\n    // The maximum delay required for two consecutive touchend events to be interpreted\n    // as a double-tap.\n    doubleTapInterval: 300\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29uZmlnL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsU0FBUztJQUNsQiwyRUFBMkU7SUFDM0UsNkRBQTZEO0lBQzdELHFDQUFxQztJQUNyQ0MsaUJBQWlCO0lBQ2pCLHlEQUF5RDtJQUN6RCw0RkFBNEY7SUFDNUYseUNBQXlDO0lBQ3pDLHVDQUF1QztJQUN2Q0MsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2QsbUZBQW1GO0lBQ25GLG1CQUFtQjtJQUNuQkMsbUJBQW1CO0FBQ3ZCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9jb25maWcvaW5kZXgubWpzPzBkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgICAvLyBXaGVuIHNldCB0byBgdHJ1ZWAgdGhlIGNlbGwgc2VsZWN0b3JzIGNvdWxkIGJlIGRlZmluZWQgYXMgQ1NTIHNlbGVjdG9ycy5cbiAgICAvLyBJZiBub3QsIG9ubHkgSlNPTiBNYXJrdXAgc2VsZWN0b3JzIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgLy8gZXhwb3J0IGxldCB1c2VDU1NTZWxlY3RvcnMgPSB0cnVlO1xuICAgIHVzZUNTU1NlbGVjdG9yczogdHJ1ZSxcbiAgICAvLyBUaGUgY2xhc3MgbmFtZSBwcmVmaXggY29uZmlnIGlzIGZvciBhZHZhbmNlZCB1c2Ugb25seS5cbiAgICAvLyBCZSBhd2FyZSB0aGF0IGlmIHlvdSBjaGFuZ2UgdGhlIHByZWZpeCwgdGhlIEpvaW50SlMgQ1NTIHdpbGwgbm8gbG9uZ2VyIGZ1bmN0aW9uIHByb3Blcmx5LlxuICAgIC8vIGV4cG9ydCBsZXQgY2xhc3NOYW1lUHJlZml4ID0gJ2pvaW50LSc7XG4gICAgLy8gZXhwb3J0IGxldCBkZWZhdWx0VGhlbWUgPSAnZGVmYXVsdCc7XG4gICAgY2xhc3NOYW1lUHJlZml4OiAnam9pbnQtJyxcbiAgICBkZWZhdWx0VGhlbWU6ICdkZWZhdWx0JyxcbiAgICAvLyBUaGUgbWF4aW11bSBkZWxheSByZXF1aXJlZCBmb3IgdHdvIGNvbnNlY3V0aXZlIHRvdWNoZW5kIGV2ZW50cyB0byBiZSBpbnRlcnByZXRlZFxuICAgIC8vIGFzIGEgZG91YmxlLXRhcC5cbiAgICBkb3VibGVUYXBJbnRlcnZhbDogMzAwXG59O1xuIl0sIm5hbWVzIjpbImNvbmZpZyIsInVzZUNTU1NlbGVjdG9ycyIsImNsYXNzTmFtZVByZWZpeCIsImRlZmF1bHRUaGVtZSIsImRvdWJsZVRhcEludGVydmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/config/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectionPoints/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/jointjs/src/connectionPoints/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anchor: () => (/* binding */ anchor),\n/* harmony export */   bbox: () => (/* binding */ bbox),\n/* harmony export */   boundary: () => (/* binding */ boundary),\n/* harmony export */   rectangle: () => (/* binding */ rectangle)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n\n\n\nfunction offsetPoint(p1, p2, offset) {\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\nfunction stroke(magnet) {\n    var stroke = magnet.getAttribute(\"stroke-width\");\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch(type){\n        case \"left\":\n            coordinate = \"x\";\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case \"right\":\n            coordinate = \"x\";\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case \"top\":\n            coordinate = \"y\";\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case \"bottom\":\n            coordinate = \"y\";\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n// Connection Points\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\nfunction bboxIntersection(line, view, magnet, opt) {\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\nfunction rectangleIntersection(line, view, magnet, opt) {\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== \"string\") return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === \"G\") {\n            node = node.firstElementChild;\n        } else if (tagName === \"TITLE\") {\n            node = node.nextElementSibling;\n        } else break;\n    }while (node);\n    return node;\n}\nvar BNDR_SUBDIVISIONS = \"segmentSubdivisons\";\nvar BNDR_SHAPE_BBOX = \"shapeBBox\";\nfunction boundaryIntersection(line, view, magnet, opt) {\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n    if (typeof selector === \"string\") {\n        node = view.findBySelector(selector)[0];\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n    if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(node)) {\n        if (node === magnet || !_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n            precision: precision\n        });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n    var cp = intersection ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n    return offsetPoint(cp, line.start, cpOffset);\n}\nconst anchor = anchorConnectionPoint;\nconst bbox = bboxIntersection;\nconst rectangle = rectangleIntersection;\nconst boundary = boundaryIntersection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdGlvblBvaW50cy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDTDtBQUNXO0FBRTFDLFNBQVNHLFlBQVlDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxNQUFNO0lBQy9CLElBQUlKLDBEQUFrQixDQUFDSSxTQUFTO1FBQzVCLE1BQU0sRUFBRUUsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0g7UUFDakIsSUFBSUksU0FBU0QsSUFBSTtZQUNiLE1BQU1FLE9BQVEsSUFBSVgsOENBQU0sQ0FBQ0ssSUFBSUQ7WUFDN0IsTUFBTSxFQUFFUyxLQUFLLEVBQUVDLEdBQUcsRUFBRSxHQUFHSCxLQUFLSSxRQUFRLENBQUNOO1lBQ3JDSixLQUFLUTtZQUNMVCxLQUFLVTtRQUNUO1FBQ0FSLFNBQVNFO0lBQ2I7SUFDQSxJQUFJLENBQUNFLFNBQVNKLFNBQVMsT0FBT0Y7SUFDOUIsSUFBSVksU0FBU1osR0FBR2EsUUFBUSxDQUFDWjtJQUN6QixJQUFJQyxXQUFXLEtBQUtVLFNBQVMsR0FBRyxPQUFPWjtJQUN2QyxPQUFPQSxHQUFHYyxJQUFJLENBQUNiLElBQUksQ0FBQ2MsS0FBS0MsR0FBRyxDQUFDZCxRQUFRVSxTQUFTO0FBQ2xEO0FBRUEsU0FBU0ssT0FBT0MsTUFBTTtJQUVsQixJQUFJRCxTQUFTQyxPQUFPQyxZQUFZLENBQUM7SUFDakMsSUFBSUYsV0FBVyxNQUFNLE9BQU87SUFDNUIsT0FBT0csV0FBV0gsV0FBVztBQUNqQztBQUVBLFNBQVNJLFVBQVVkLElBQUksRUFBRWUsSUFBSSxFQUFFcEIsU0FBUyxDQUFDO0lBQ3JDLElBQUlxQixZQUFZQyxHQUFHQyxHQUFHQztJQUN0QixNQUFNLEVBQUVqQixLQUFLLEVBQUVDLEdBQUcsRUFBRSxHQUFHSDtJQUN2QixPQUFRZTtRQUNKLEtBQUs7WUFDREMsYUFBYTtZQUNiQyxJQUFJZDtZQUNKZSxJQUFJaEI7WUFDSmlCLFlB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QixDQUFDZDtRQUNsRCxPQUFPLElBQUlkLHNCQUFzQnpFLGlEQUFTLEVBQUU7WUFDeENpRSxlQUFlUSxXQUFXOEIscUNBQXFDLENBQUNoQjtRQUNwRSxPQUFPO1lBQ0h0QixlQUFlUSxXQUFXK0IsWUFBWSxDQUFDakIsVUFBVU07UUFDckQ7SUFDSjtJQUVBLElBQUlqRCxLQUFLLGVBQWlCM0Msb0RBQUNBLENBQUN3RyxjQUFjLENBQUN4QyxjQUFjZ0IsZ0JBQWdCZDtJQUN6RSxJQUFJdUMsV0FBV3hFLElBQUk1QixNQUFNLElBQUk7SUFDN0IsSUFBSTRCLElBQUliLE1BQU0sRUFBRXFGLFlBQVlyRixPQUFPb0MsUUFBUTtJQUUzQyxPQUFPdEQsWUFBWXlDLElBQUlqQyxLQUFLRSxLQUFLLEVBQUU2RjtBQUN2QztBQUVPLE1BQU12QyxTQUFTcEMsc0JBQXNCO0FBQ3JDLE1BQU1RLE9BQU9GLGlCQUFpQjtBQUM5QixNQUFNc0UsWUFBWTdELHNCQUFzQjtBQUN4QyxNQUFNOEQsV0FBVzVDLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2Nvbm5lY3Rpb25Qb2ludHMvaW5kZXgubWpzPzBkMzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gb2Zmc2V0UG9pbnQocDEsIHAyLCBvZmZzZXQpIHtcbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh5KSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9ICBuZXcgZy5MaW5lKHAyLCBwMSk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGxpbmUucGFyYWxsZWwoeSk7XG4gICAgICAgICAgICBwMiA9IHN0YXJ0O1xuICAgICAgICAgICAgcDEgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0geDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZShvZmZzZXQpKSByZXR1cm4gcDE7XG4gICAgdmFyIGxlbmd0aCA9IHAxLmRpc3RhbmNlKHAyKTtcbiAgICBpZiAob2Zmc2V0ID09PSAwICYmIGxlbmd0aCA+IDApIHJldHVybiBwMTtcbiAgICByZXR1cm4gcDEubW92ZShwMiwgLU1hdGgubWluKG9mZnNldCwgbGVuZ3RoIC0gMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJva2UobWFnbmV0KSB7XG5cbiAgICB2YXIgc3Ryb2tlID0gbWFnbmV0LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyk7XG4gICAgaWYgKHN0cm9rZSA9PT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3Ryb2tlKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBhbGlnbkxpbmUobGluZSwgdHlwZSwgb2Zmc2V0ID0gMCkge1xuICAgIGxldCBjb29yZGluYXRlLCBhLCBiLCBkaXJlY3Rpb247XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBsaW5lO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBhID0gZW5kO1xuICAgICAgICAgICAgYiA9IHN0YXJ0O1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd4JztcbiAgICAgICAgICAgIGEgPSBzdGFydDtcbiAgICAgICAgICAgIGIgPSBlbmQ7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3knO1xuICAgICAgICAgICAgYSA9IGVuZDtcbiAgICAgICAgICAgIGIgPSBzdGFydDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3knO1xuICAgICAgICAgICAgYSA9IHN0YXJ0O1xuICAgICAgICAgICAgYiA9IGVuZDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXJ0W2Nvb3JkaW5hdGVdIDwgZW5kW2Nvb3JkaW5hdGVdKSB7XG4gICAgICAgIGFbY29vcmRpbmF0ZV0gPSBiW2Nvb3JkaW5hdGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJbY29vcmRpbmF0ZV0gPSBhW2Nvb3JkaW5hdGVdO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgICBhW2Nvb3JkaW5hdGVdICs9IGRpcmVjdGlvbiAqIG9mZnNldDtcbiAgICAgICAgYltjb29yZGluYXRlXSArPSBkaXJlY3Rpb24gKiBvZmZzZXQ7XG4gICAgfVxufVxuXG4vLyBDb25uZWN0aW9uIFBvaW50c1xuXG5mdW5jdGlvbiBhbmNob3JDb25uZWN0aW9uUG9pbnQobGluZSwgX3ZpZXcsIF9tYWduZXQsIG9wdCkge1xuICAgIGxldCB7IG9mZnNldCwgYWxpZ25PZmZzZXQsIGFsaWduIH0gPSBvcHQ7XG4gICAgaWYgKGFsaWduKSBhbGlnbkxpbmUobGluZSwgYWxpZ24sIGFsaWduT2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQobGluZS5lbmQsIGxpbmUuc3RhcnQsIG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGJib3hJbnRlcnNlY3Rpb24obGluZSwgdmlldywgbWFnbmV0LCBvcHQpIHtcblxuICAgIHZhciBiYm94ID0gdmlldy5nZXROb2RlQkJveChtYWduZXQpO1xuICAgIGlmIChvcHQuc3Ryb2tlKSBiYm94LmluZmxhdGUoc3Ryb2tlKG1hZ25ldCkgLyAyKTtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IGxpbmUuaW50ZXJzZWN0KGJib3gpO1xuICAgIHZhciBjcCA9IChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA/IGxpbmUuc3RhcnQuY2hvb3NlQ2xvc2VzdChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA6IGxpbmUuZW5kO1xuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgb3B0Lm9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZUludGVyc2VjdGlvbihsaW5lLCB2aWV3LCBtYWduZXQsIG9wdCkge1xuXG4gICAgdmFyIGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmJveEludGVyc2VjdGlvbihsaW5lLCB2aWV3LCBtYWduZXQsIG9wdCk7XG4gICAgfVxuXG4gICAgdmFyIGJib3hXT1JvdGF0aW9uID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgIGlmIChvcHQuc3Ryb2tlKSBiYm94V09Sb3RhdGlvbi5pbmZsYXRlKHN0cm9rZShtYWduZXQpIC8gMik7XG4gICAgdmFyIGNlbnRlciA9IGJib3hXT1JvdGF0aW9uLmNlbnRlcigpO1xuICAgIHZhciBsaW5lV09Sb3RhdGlvbiA9IGxpbmUuY2xvbmUoKS5yb3RhdGUoY2VudGVyLCBhbmdsZSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBsaW5lV09Sb3RhdGlvbi5zZXRMZW5ndGgoMWU2KS5pbnRlcnNlY3QoYmJveFdPUm90YXRpb24pO1xuICAgIHZhciBjcCA9IChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA/IGxpbmVXT1JvdGF0aW9uLnN0YXJ0LmNob29zZUNsb3Nlc3QoaW50ZXJzZWN0aW9ucykucm90YXRlKGNlbnRlciwgLWFuZ2xlKVxuICAgICAgICA6IGxpbmUuZW5kO1xuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgb3B0Lm9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRTaGFwZU5vZGUobWFnbmV0KSB7XG4gICAgaWYgKCFtYWduZXQpIHJldHVybiBudWxsO1xuICAgIHZhciBub2RlID0gbWFnbmV0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ0cnKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnVElUTEUnKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9IHdoaWxlIChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxudmFyIEJORFJfU1VCRElWSVNJT05TID0gJ3NlZ21lbnRTdWJkaXZpc29ucyc7XG52YXIgQk5EUl9TSEFQRV9CQk9YID0gJ3NoYXBlQkJveCc7XG5cbmZ1bmN0aW9uIGJvdW5kYXJ5SW50ZXJzZWN0aW9uKGxpbmUsIHZpZXcsIG1hZ25ldCwgb3B0KSB7XG5cbiAgICB2YXIgbm9kZSwgaW50ZXJzZWN0aW9uO1xuICAgIHZhciBzZWxlY3RvciA9IG9wdC5zZWxlY3RvcjtcbiAgICB2YXIgYW5jaG9yID0gbGluZS5lbmQ7XG5cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlID0gdmlldy5maW5kQnlTZWxlY3RvcihzZWxlY3RvcilbMF07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZSA9IG1hZ25ldDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgICAgIG5vZGUgPSB1dGlsLmdldEJ5UGF0aChtYWduZXQsIHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZmluZFNoYXBlTm9kZShtYWduZXQpO1xuICAgIH1cblxuICAgIGlmICghVi5pc1NWR0dyYXBoaWNzRWxlbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gbWFnbmV0IHx8ICFWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KG1hZ25ldCkpIHJldHVybiBhbmNob3I7XG4gICAgICAgIG5vZGUgPSBtYWduZXQ7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsU2hhcGUgPSB2aWV3LmdldE5vZGVTaGFwZShub2RlKTtcbiAgICB2YXIgbWFnbmV0TWF0cml4ID0gdmlldy5nZXROb2RlTWF0cml4KG5vZGUpO1xuICAgIHZhciB0cmFuc2xhdGVNYXRyaXggPSB2aWV3LmdldFJvb3RUcmFuc2xhdGVNYXRyaXgoKTtcbiAgICB2YXIgcm90YXRlTWF0cml4ID0gdmlldy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgdmFyIHRhcmdldE1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeC5tdWx0aXBseShyb3RhdGVNYXRyaXgpLm11bHRpcGx5KG1hZ25ldE1hdHJpeCk7XG4gICAgdmFyIGxvY2FsTWF0cml4ID0gdGFyZ2V0TWF0cml4LmludmVyc2UoKTtcbiAgICB2YXIgbG9jYWxMaW5lID0gVi50cmFuc2Zvcm1MaW5lKGxpbmUsIGxvY2FsTWF0cml4KTtcbiAgICB2YXIgbG9jYWxSZWYgPSBsb2NhbExpbmUuc3RhcnQuY2xvbmUoKTtcbiAgICB2YXIgZGF0YSA9IHZpZXcuZ2V0Tm9kZURhdGEobm9kZSk7XG5cbiAgICBpZiAob3B0Lmluc2lkZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFkYXRhW0JORFJfU0hBUEVfQkJPWF0pIGRhdGFbQk5EUl9TSEFQRV9CQk9YXSA9IGxvY2FsU2hhcGUuYmJveCgpO1xuICAgICAgICB2YXIgbG9jYWxCQm94ID0gZGF0YVtCTkRSX1NIQVBFX0JCT1hdO1xuICAgICAgICBpZiAobG9jYWxCQm94LmNvbnRhaW5zUG9pbnQobG9jYWxSZWYpKSByZXR1cm4gYW5jaG9yO1xuICAgIH1cblxuICAgIC8vIENhY2hpbmcgc2VnbWVudCBzdWJkaXZpc2lvbnMgZm9yIHBhdGhzXG4gICAgdmFyIHBhdGhPcHQ7XG4gICAgaWYgKGxvY2FsU2hhcGUgaW5zdGFuY2VvZiBnLlBhdGgpIHtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IG9wdC5wcmVjaXNpb24gfHwgMjtcbiAgICAgICAgaWYgKCFkYXRhW0JORFJfU1VCRElWSVNJT05TXSkgZGF0YVtCTkRSX1NVQkRJVklTSU9OU10gPSBsb2NhbFNoYXBlLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcbiAgICAgICAgcGF0aE9wdCA9IHtcbiAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgc2VnbWVudFN1YmRpdmlzaW9uczogZGF0YVtCTkRSX1NVQkRJVklTSU9OU11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0LmV4dHJhcG9sYXRlID09PSB0cnVlKSBsb2NhbExpbmUuc2V0TGVuZ3RoKDFlNik7XG5cbiAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbExpbmUuaW50ZXJzZWN0KGxvY2FsU2hhcGUsIHBhdGhPcHQpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIG9uZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgaWYgKFYuaXNBcnJheShpbnRlcnNlY3Rpb24pKSBpbnRlcnNlY3Rpb24gPSBsb2NhbFJlZi5jaG9vc2VDbG9zZXN0KGludGVyc2VjdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHQuc3RpY2t5ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvbiwgZmluZCB0aGUgY2xvc2VzdCBwb2ludCBpbnN0ZWFkXG4gICAgICAgIGlmIChsb2NhbFNoYXBlIGluc3RhbmNlb2YgZy5SZWN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbFNoYXBlLnBvaW50TmVhcmVzdFRvUG9pbnQobG9jYWxSZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsU2hhcGUgaW5zdGFuY2VvZiBnLkVsbGlwc2UpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGxvY2FsU2hhcGUuaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludChsb2NhbFJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbFNoYXBlLmNsb3Nlc3RQb2ludChsb2NhbFJlZiwgcGF0aE9wdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3AgPSAoaW50ZXJzZWN0aW9uKSA/IFYudHJhbnNmb3JtUG9pbnQoaW50ZXJzZWN0aW9uLCB0YXJnZXRNYXRyaXgpIDogYW5jaG9yO1xuICAgIHZhciBjcE9mZnNldCA9IG9wdC5vZmZzZXQgfHwgMDtcbiAgICBpZiAob3B0LnN0cm9rZSkgY3BPZmZzZXQgKz0gc3Ryb2tlKG5vZGUpIC8gMjtcblxuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgY3BPZmZzZXQpO1xufVxuXG5leHBvcnQgY29uc3QgYW5jaG9yID0gYW5jaG9yQ29ubmVjdGlvblBvaW50O1xuZXhwb3J0IGNvbnN0IGJib3ggPSBiYm94SW50ZXJzZWN0aW9uO1xuZXhwb3J0IGNvbnN0IHJlY3RhbmdsZSA9IHJlY3RhbmdsZUludGVyc2VjdGlvbjtcbmV4cG9ydCBjb25zdCBib3VuZGFyeSA9IGJvdW5kYXJ5SW50ZXJzZWN0aW9uO1xuIl0sIm5hbWVzIjpbImciLCJWIiwidXRpbCIsIm9mZnNldFBvaW50IiwicDEiLCJwMiIsIm9mZnNldCIsImlzUGxhaW5PYmplY3QiLCJ4IiwieSIsImlzRmluaXRlIiwibGluZSIsIkxpbmUiLCJzdGFydCIsImVuZCIsInBhcmFsbGVsIiwibGVuZ3RoIiwiZGlzdGFuY2UiLCJtb3ZlIiwiTWF0aCIsIm1pbiIsInN0cm9rZSIsIm1hZ25ldCIsImdldEF0dHJpYnV0ZSIsInBhcnNlRmxvYXQiLCJhbGlnbkxpbmUiLCJ0eXBlIiwiY29vcmRpbmF0ZSIsImEiLCJiIiwiZGlyZWN0aW9uIiwiYW5jaG9yQ29ubmVjdGlvblBvaW50IiwiX3ZpZXciLCJfbWFnbmV0Iiwib3B0IiwiYWxpZ25PZmZzZXQiLCJhbGlnbiIsImJib3hJbnRlcnNlY3Rpb24iLCJ2aWV3IiwiYmJveCIsImdldE5vZGVCQm94IiwiaW5mbGF0ZSIsImludGVyc2VjdGlvbnMiLCJpbnRlcnNlY3QiLCJjcCIsImNob29zZUNsb3Nlc3QiLCJyZWN0YW5nbGVJbnRlcnNlY3Rpb24iLCJhbmdsZSIsIm1vZGVsIiwiYmJveFdPUm90YXRpb24iLCJnZXROb2RlVW5yb3RhdGVkQkJveCIsImNlbnRlciIsImxpbmVXT1JvdGF0aW9uIiwiY2xvbmUiLCJyb3RhdGUiLCJzZXRMZW5ndGgiLCJmaW5kU2hhcGVOb2RlIiwibm9kZSIsInRhZ05hbWUiLCJ0b1VwcGVyQ2FzZSIsImZpcnN0RWxlbWVudENoaWxkIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiQk5EUl9TVUJESVZJU0lPTlMiLCJCTkRSX1NIQVBFX0JCT1giLCJib3VuZGFyeUludGVyc2VjdGlvbiIsImludGVyc2VjdGlvbiIsInNlbGVjdG9yIiwiYW5jaG9yIiwiZmluZEJ5U2VsZWN0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRCeVBhdGgiLCJpc1NWR0dyYXBoaWNzRWxlbWVudCIsImxvY2FsU2hhcGUiLCJnZXROb2RlU2hhcGUiLCJtYWduZXRNYXRyaXgiLCJnZXROb2RlTWF0cml4IiwidHJhbnNsYXRlTWF0cml4IiwiZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCIsInJvdGF0ZU1hdHJpeCIsImdldFJvb3RSb3RhdGVNYXRyaXgiLCJ0YXJnZXRNYXRyaXgiLCJtdWx0aXBseSIsImxvY2FsTWF0cml4IiwiaW52ZXJzZSIsImxvY2FsTGluZSIsInRyYW5zZm9ybUxpbmUiLCJsb2NhbFJlZiIsImRhdGEiLCJnZXROb2RlRGF0YSIsImluc2lkZW91dCIsImxvY2FsQkJveCIsImNvbnRhaW5zUG9pbnQiLCJwYXRoT3B0IiwiUGF0aCIsInByZWNpc2lvbiIsImdldFNlZ21lbnRTdWJkaXZpc2lvbnMiLCJzZWdtZW50U3ViZGl2aXNpb25zIiwiZXh0cmFwb2xhdGUiLCJzdGlja3kiLCJSZWN0IiwicG9pbnROZWFyZXN0VG9Qb2ludCIsIkVsbGlwc2UiLCJpbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50IiwiY2xvc2VzdFBvaW50IiwidHJhbnNmb3JtUG9pbnQiLCJjcE9mZnNldCIsInJlY3RhbmdsZSIsImJvdW5kYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectionPoints/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/curve.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/curve.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: () => (/* binding */ curve)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/curve.mjs\");\n\nconst Directions = {\n    AUTO: \"auto\",\n    HORIZONTAL: \"horizontal\",\n    VERTICAL: \"vertical\",\n    CLOSEST_POINT: \"closest-point\",\n    OUTWARDS: \"outwards\"\n};\nconst TangentDirections = {\n    UP: \"up\",\n    DOWN: \"down\",\n    LEFT: \"left\",\n    RIGHT: \"right\",\n    AUTO: \"auto\",\n    CLOSEST_POINT: \"closest-point\",\n    OUTWARDS: \"outwards\"\n};\nconst curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === \"string\") options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === \"number\") options.sourceDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.sourceDirection);\n    else options.sourceDirection = opt.sourceDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceDirection).normalize() : null;\n    if (typeof opt.targetDirection === \"string\") options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === \"number\") options.targetDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.targetDirection);\n    else options.targetDirection = opt.targetDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetDirection).normalize() : null;\n    const completeRoute = [\n        sourcePoint,\n        ...route,\n        targetPoint\n    ].map((p)=>new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p));\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map((curve)=>catmullRomToBezier(curve, options));\n    const path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(bezierCurves).round(precision);\n    return raw ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x) sourceSide = \"right\";\n        else sourceSide = \"left\";\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n    let direction;\n    switch(sourceSide){\n        case \"left\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case \"right\":\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x) targetSide = \"left\";\n        else targetSide = \"right\";\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n    let direction;\n    switch(targetSide){\n        case \"left\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case \"right\":\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y) sourceSide = \"bottom\";\n        else sourceSide = \"top\";\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n    let direction;\n    switch(sourceSide){\n        case \"top\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case \"bottom\":\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y) targetSide = \"top\";\n        else targetSide = \"bottom\";\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n    let direction;\n    switch(targetSide){\n        case \"top\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case \"bottom\":\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n    let direction;\n    switch(sourceSide){\n        case \"top\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case \"bottom\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case \"right\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case \"left\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n    let direction;\n    switch(targetSide){\n        case \"top\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case \"bottom\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case \"right\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case \"left\":\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n    return direction;\n}\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch(options.sourceDirection){\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n    switch(direction){\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch(options.targetDirection){\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n    switch(direction){\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n    for(let i = 0; i < n; i++){\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n    // The calculation of tangents of vertices\n    for(let i = 1; i < n; i++){\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n        tangents[i] = [\n            t1,\n            t2\n        ];\n    }\n    // The building of a Catmull-Rom curve based of tangents of points\n    for(let i = 0; i < n; i++){\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n        catmullRomCurves[i] = [\n            p0,\n            points[i],\n            points[i + 1],\n            p3\n        ];\n    }\n    return catmullRomCurves;\n}\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n    const bcp1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n    const bcp2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve(points[1], bcp1, bcp2, points[2]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9jdXJ2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUVwRCxNQUFNRyxhQUFhO0lBQ2ZDLE1BQU07SUFDTkMsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsVUFBVTtBQUNkO0FBRUEsTUFBTUMsb0JBQW9CO0lBQ3RCQyxJQUFJO0lBQ0pDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BULE1BQU07SUFDTkcsZUFBZTtJQUNmQyxVQUFVO0FBQ2Q7QUFFTyxNQUFNTSxRQUFRLFNBQVNDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUUsRUFBRUMsTUFBTSxDQUFDLENBQUMsRUFBRUMsUUFBUTtJQUNsRixNQUFNQyxNQUFNQyxRQUFRSCxJQUFJRSxHQUFHO0lBQzNCLDRHQUE0RztJQUM1RyxtSEFBbUg7SUFDbkgsbURBQW1EO0lBQ25ELHVFQUF1RTtJQUN2RSxnRkFBZ0Y7SUFDaEYsdUVBQXVFO0lBQ3ZFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcEQsTUFBTSxFQUFFRSxZQUFZbkIsV0FBV0MsSUFBSSxFQUFFbUIsWUFBWSxDQUFDLEVBQUUsR0FBR0w7SUFDdkQsTUFBTU0sVUFBVTtRQUNaQyxPQUFPUCxJQUFJUSxtQkFBbUIsSUFBSTtRQUNsQ0MseUJBQXlCVCxJQUFJUyx1QkFBdUIsSUFBSTtRQUN4REMsS0FBS1YsSUFBSVcsT0FBTyxJQUFJO1FBQ3BCQyxlQUFlWixJQUFJWSxhQUFhLEdBQUcsSUFBSTdCLCtDQUFLQSxDQUFDaUIsSUFBSVksYUFBYSxJQUFJO1FBQ2xFQyxlQUFlYixJQUFJYSxhQUFhLEdBQUcsSUFBSTlCLCtDQUFLQSxDQUFDaUIsSUFBSWEsYUFBYSxJQUFJO1FBQ2xFQyxRQUFRWCxRQUFRSCxJQUFJYyxNQUFNO0lBQzlCO0lBQ0EsSUFBSSxPQUFPZCxJQUFJZSxlQUFlLEtBQUssVUFDL0JULFFBQVFTLGVBQWUsR0FBR2Ys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ckgsK0NBQUtBO0lBQ3RCcUgsS0FBS3BELENBQUMsR0FBR2dDLE1BQU0sQ0FBQyxFQUFFLENBQUNoQyxDQUFDLEdBQUcsQ0FBQ2dDLE1BQU0sQ0FBQyxFQUFFLENBQUNoQyxDQUFDLEdBQUdnQyxNQUFNLENBQUMsRUFBRSxDQUFDaEMsQ0FBQyxJQUFLLEtBQUl0QyxHQUFFO0lBQzVEMEYsS0FBS3hDLENBQUMsR0FBR29CLE1BQU0sQ0FBQyxFQUFFLENBQUNwQixDQUFDLEdBQUcsQ0FBQ29CLE1BQU0sQ0FBQyxFQUFFLENBQUNwQixDQUFDLEdBQUdvQixNQUFNLENBQUMsRUFBRSxDQUFDcEIsQ0FBQyxJQUFLLEtBQUlsRCxHQUFFO0lBQzVELE9BQU8sSUFBSTFCLCtDQUFLQSxDQUNaZ0csTUFBTSxDQUFDLEVBQUUsRUFDVG1CLE1BQ0FDLE1BQ0FwQixNQUFNLENBQUMsRUFBRTtBQUVqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2Nvbm5lY3RvcnMvY3VydmUubWpzPzQ2M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0aCwgUG9pbnQsIEN1cnZlIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBEaXJlY3Rpb25zID0ge1xuICAgIEFVVE86ICdhdXRvJyxcbiAgICBIT1JJWk9OVEFMOiAnaG9yaXpvbnRhbCcsXG4gICAgVkVSVElDQUw6ICd2ZXJ0aWNhbCcsXG4gICAgQ0xPU0VTVF9QT0lOVDogJ2Nsb3Nlc3QtcG9pbnQnLFxuICAgIE9VVFdBUkRTOiAnb3V0d2FyZHMnXG59O1xuXG5jb25zdCBUYW5nZW50RGlyZWN0aW9ucyA9IHtcbiAgICBVUDogJ3VwJyxcbiAgICBET1dOOiAnZG93bicsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIEFVVE86ICdhdXRvJyxcbiAgICBDTE9TRVNUX1BPSU5UOiAnY2xvc2VzdC1wb2ludCcsXG4gICAgT1VUV0FSRFM6ICdvdXR3YXJkcydcbn07XG5cbmV4cG9ydCBjb25zdCBjdXJ2ZSA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUgPSBbXSwgb3B0ID0ge30sIGxpbmtWaWV3KSB7XG4gICAgY29uc3QgcmF3ID0gQm9vbGVhbihvcHQucmF3KTtcbiAgICAvLyBkaXN0YW5jZUNvZWZmaWNpZW50IC0gYSBjb2VmZmljaWVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgbGVuZ3RoIHJlbGF0aXZlIHRvIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cy5cbiAgICAvLyBhbmdsZVRhbmdlbnRDb2VmZmljaWVudCAtIGEgY29lZmZpY2llbnQgb2YgdGhlIGVuZCB0YW5nZW50cyBsZW5ndGggaW4gdGhlIGNhc2Ugb2YgYW5nbGVzIGxhcmdlciB0aGFuIDQ1IGRlZ3JlZXMuXG4gICAgLy8gdGVuc2lvbiAtIGEgQ2F0bXVsbC1Sb20gY3VydmUgdGVuc2lvbiBwYXJhbWV0ZXIuXG4gICAgLy8gc291cmNlVGFuZ2VudCAtIGEgdGFuZ2VudCB2ZWN0b3IgYWxvbmcgdGhlIGN1cnZlIGF0IHRoZSBzb3VyY2VQb2ludC5cbiAgICAvLyBzb3VyY2VEaXJlY3Rpb24gLSBhIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBhbG9uZyB0aGUgY3VydmUgYXQgdGhlIHNvdXJjZVBvaW50LlxuICAgIC8vIHRhcmdldFRhbmdlbnQgLSBhIHRhbmdlbnQgdmVjdG9yIGFsb25nIHRoZSBjdXJ2ZSBhdCB0aGUgdGFyZ2V0UG9pbnQuXG4gICAgLy8gdGFyZ2V0RGlyZWN0aW9uIC0gYSB1bml0IGRpcmVjdGlvbiB2ZWN0b3IgYWxvbmcgdGhlIGN1cnZlIGF0IHRoZSB0YXJnZXRQb2ludC5cbiAgICAvLyBwcmVjaXNpb24gLSBhIHJvdW5kaW5nIHByZWNpc2lvbiBmb3IgcGF0aCB2YWx1ZXMuXG4gICAgY29uc3QgeyBkaXJlY3Rpb24gPSBEaXJlY3Rpb25zLkFVVE8sIHByZWNpc2lvbiA9IDMgfSA9IG9wdDtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBjb2VmZjogb3B0LmRpc3RhbmNlQ29lZmZpY2llbnQgfHwgMC42LFxuICAgICAgICBhbmdsZVRhbmdlbnRDb2VmZmljaWVudDogb3B0LmFuZ2xlVGFuZ2VudENvZWZmaWNpZW50IHx8IDgwLFxuICAgICAgICB0YXU6IG9wdC50ZW5zaW9uIHx8IDAuNSxcbiAgICAgICAgc291cmNlVGFuZ2VudDogb3B0LnNvdXJjZVRhbmdlbnQgPyBuZXcgUG9pbnQob3B0LnNvdXJjZVRhbmdlbnQpIDogbnVsbCxcbiAgICAgICAgdGFyZ2V0VGFuZ2VudDogb3B0LnRhcmdldFRhbmdlbnQgPyBuZXcgUG9pbnQob3B0LnRhcmdldFRhbmdlbnQpIDogbnVsbCxcbiAgICAgICAgcm90YXRlOiBCb29sZWFuKG9wdC5yb3RhdGUpXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdC5zb3VyY2VEaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG9wdC5zb3VyY2VEaXJlY3Rpb247XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdC5zb3VyY2VEaXJlY3Rpb24gPT09ICdudW1iZXInKVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKS5yb3RhdGUobnVsbCwgb3B0LnNvdXJjZURpcmVjdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG9wdC5zb3VyY2VEaXJlY3Rpb24gPyBuZXcgUG9pbnQob3B0LnNvdXJjZURpcmVjdGlvbikubm9ybWFsaXplKCkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHQudGFyZ2V0RGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBvcHQudGFyZ2V0RGlyZWN0aW9uO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHQudGFyZ2V0RGlyZWN0aW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCkucm90YXRlKG51bGwsIG9wdC50YXJnZXREaXJlY3Rpb24pO1xuICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBvcHQudGFyZ2V0RGlyZWN0aW9uID8gbmV3IFBvaW50KG9wdC50YXJnZXREaXJlY3Rpb24pLm5vcm1hbGl6ZSgpIDogbnVsbDtcblxuICAgIGNvbnN0IGNvbXBsZXRlUm91dGUgPSBbc291cmNlUG9pbnQsIC4uLnJvdXRlLCB0YXJnZXRQb2ludF0ubWFwKHAgPT4gbmV3IFBvaW50KHApKTtcblxuICAgIC8vIFRoZSBjYWxjdWxhdGlvbiBvZiBhIHNvdXJjZVRhbmdlbnRcbiAgICBsZXQgc291cmNlVGFuZ2VudDtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUYW5nZW50KSB7XG4gICAgICAgIHNvdXJjZVRhbmdlbnQgPSBvcHRpb25zLnNvdXJjZVRhbmdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlRGlyZWN0aW9uID0gZ2V0U291cmNlVGFuZ2VudERpcmVjdGlvbihsaW5rVmlldywgY29tcGxldGVSb3V0ZSwgZGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdGFuZ2VudExlbmd0aCA9IGNvbXBsZXRlUm91dGVbMF0uZGlzdGFuY2UoY29tcGxldGVSb3V0ZVsxXSkgKiBvcHRpb25zLmNvZWZmO1xuICAgICAgICBjb25zdCBwb2ludHNWZWN0b3IgPSBjb21wbGV0ZVJvdXRlWzFdLmRpZmZlcmVuY2UoY29tcGxldGVSb3V0ZVswXSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gYW5nbGVCZXR3ZWVuVmVjdG9ycyhzb3VyY2VEaXJlY3Rpb24sIHBvaW50c1ZlY3Rvcik7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyA0KSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTGVuZ3RoID0gdGFuZ2VudExlbmd0aCArIChhbmdsZSAtIE1hdGguUEkgLyA0KSAqIG9wdGlvbnMuYW5nbGVUYW5nZW50Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICBzb3VyY2VUYW5nZW50ID0gc291cmNlRGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodXBkYXRlZExlbmd0aCwgdXBkYXRlZExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VUYW5nZW50ID0gc291cmNlRGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodGFuZ2VudExlbmd0aCwgdGFuZ2VudExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgY2FsY3VsYXRpb24gb2YgYSB0YXJnZXRUYW5nZW50XG4gICAgbGV0IHRhcmdldFRhbmdlbnQ7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0VGFuZ2VudCkge1xuICAgICAgICB0YXJnZXRUYW5nZW50ID0gb3B0aW9ucy50YXJnZXRUYW5nZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERpcmVjdGlvbiA9IGdldFRhcmdldFRhbmdlbnREaXJlY3Rpb24obGlua1ZpZXcsIGNvbXBsZXRlUm91dGUsIGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBjb21wbGV0ZVJvdXRlLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHRhbmdlbnRMZW5ndGggPSBjb21wbGV0ZVJvdXRlW2xhc3QgLSAxXS5kaXN0YW5jZShjb21wbGV0ZVJvdXRlW2xhc3RdKSAqIG9wdGlvbnMuY29lZmY7XG4gICAgICAgIGNvbnN0IHBvaW50c1ZlY3RvciA9IGNvbXBsZXRlUm91dGVbbGFzdCAtIDFdLmRpZmZlcmVuY2UoY29tcGxldGVSb3V0ZVtsYXN0XSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gYW5nbGVCZXR3ZWVuVmVjdG9ycyh0YXJnZXREaXJlY3Rpb24sIHBvaW50c1ZlY3Rvcik7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyA0KSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTGVuZ3RoID0gdGFuZ2VudExlbmd0aCArIChhbmdsZSAtIE1hdGguUEkgLyA0KSAqIG9wdGlvbnMuYW5nbGVUYW5nZW50Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICB0YXJnZXRUYW5nZW50ID0gdGFyZ2V0RGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodXBkYXRlZExlbmd0aCwgdXBkYXRlZExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRUYW5nZW50ID0gdGFyZ2V0RGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodGFuZ2VudExlbmd0aCwgdGFuZ2VudExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjYXRtdWxsUm9tQ3VydmVzID0gY3JlYXRlQ2F0bXVsbFJvbUN1cnZlcyhjb21wbGV0ZVJvdXRlLCBzb3VyY2VUYW5nZW50LCB0YXJnZXRUYW5nZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCBiZXppZXJDdXJ2ZXMgPSBjYXRtdWxsUm9tQ3VydmVzLm1hcChjdXJ2ZSA9PiBjYXRtdWxsUm9tVG9CZXppZXIoY3VydmUsIG9wdGlvbnMpKTtcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgoYmV6aWVyQ3VydmVzKS5yb3VuZChwcmVjaXNpb24pO1xuXG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuY3VydmUuRGlyZWN0aW9ucyA9IERpcmVjdGlvbnM7XG5jdXJ2ZS5UYW5nZW50RGlyZWN0aW9ucyA9IFRhbmdlbnREaXJlY3Rpb25zO1xuXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc291cmNlQkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgc291cmNlU2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy5zb3VyY2VWaWV3KSB7XG4gICAgICAgIGlmIChzb3VyY2VCQm94LnggPiByb3V0ZVsxXS54KVxuICAgICAgICAgICAgc291cmNlU2lkZSA9ICdyaWdodCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAnbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy5zb3VyY2VWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnNvdXJjZVZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcuc291cmNlVmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb2ludCA9IHJvdXRlWzBdLmNsb25lKCk7XG4gICAgICAgICAgICBzb3VyY2VQb2ludC5yb3RhdGUoc291cmNlQkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgc291cmNlU2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSBzb3VyY2VCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAoc291cmNlU2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgdGFyZ2V0U2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy50YXJnZXRWaWV3KSB7XG4gICAgICAgIGlmICh0YXJnZXRCQm94LnggPiByb3V0ZVtyb3V0ZS5sZW5ndGggLSAyXS54KVxuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9ICdsZWZ0JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy50YXJnZXRWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnRhcmdldFZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcudGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLmNsb25lKCk7XG4gICAgICAgICAgICB0YXJnZXRQb2ludC5yb3RhdGUodGFyZ2V0QkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAodGFyZ2V0U2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcuc291cmNlVmlldykge1xuICAgICAgICBpZiAoc291cmNlQkJveC55ID4gcm91dGVbMV0ueSlcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAnYm90dG9tJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc291cmNlU2lkZSA9ICd0b3AnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcuc291cmNlVmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy5zb3VyY2VWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnNvdXJjZVZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSByb3V0ZVswXS5jbG9uZSgpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQucm90YXRlKHNvdXJjZUJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0VmVydGljYWxUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YXJnZXRCQm94IH0gPSBsaW5rVmlldztcblxuICAgIGxldCB0YXJnZXRTaWRlO1xuICAgIGxldCByb3RhdGlvbjtcbiAgICBpZiAoIWxpbmtWaWV3LnRhcmdldFZpZXcpIHtcbiAgICAgICAgaWYgKHRhcmdldEJCb3gueSA+IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDJdLnkpXG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gJ3RvcCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IGxpbmtWaWV3LnRhcmdldFZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB1bnJvdGF0ZWRCQm94ID0gbGlua1ZpZXcudGFyZ2V0Vmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChsaW5rVmlldy50YXJnZXRWaWV3LmVsKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvaW50ID0gcm91dGVbcm91dGUubGVuZ3RoIC0gMV0uY2xvbmUoKTtcbiAgICAgICAgICAgIHRhcmdldFBvaW50LnJvdGF0ZSh0YXJnZXRCQm94LmNlbnRlcigpLCByb3RhdGlvbik7XG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gdW5yb3RhdGVkQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQodGFyZ2V0UG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHRhcmdldFNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcuc291cmNlVmlldykge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcuc291cmNlVmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy5zb3VyY2VWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnNvdXJjZVZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSByb3V0ZVswXS5jbG9uZSgpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQucm90YXRlKHNvdXJjZUJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRBdXRvVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgdGFyZ2V0U2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy50YXJnZXRWaWV3KSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy50YXJnZXRWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnRhcmdldFZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcudGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLmNsb25lKCk7XG4gICAgICAgICAgICB0YXJnZXRQb2ludC5yb3RhdGUodGFyZ2V0QkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAodGFyZ2V0U2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDAsIC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDAsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uLnJvdGF0ZShudWxsLCAtcm90YXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcm91dGVbMV0uZGlmZmVyZW5jZShyb3V0ZVswXSkubm9ybWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQb2ludFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYXN0ID0gcm91dGUubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gcm91dGVbbGFzdCAtIDFdLmRpZmZlcmVuY2Uocm91dGVbbGFzdF0pLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRPdXR3YXJkc1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuICAgIGNvbnN0IHNvdXJjZUNlbnRlciA9IHNvdXJjZUJCb3guY2VudGVyKCk7XG4gICAgcmV0dXJuIHJvdXRlWzBdLmRpZmZlcmVuY2Uoc291cmNlQ2VudGVyKS5ub3JtYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0d2FyZHNUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YXJnZXRCQm94IH0gPSBsaW5rVmlldztcbiAgICBjb25zdCB0YXJnZXRDZW50ZXIgPSB0YXJnZXRCQm94LmNlbnRlcigpO1xuICAgIHJldHVybiByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXS5kaWZmZXJlbmNlKHRhcmdldENlbnRlcikubm9ybWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVRhbmdlbnREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24pIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnNvdXJjZURpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5VUDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDAsIC0xKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuRE9XTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDAsIDEpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5BVVRPOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBdXRvU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkNMT1NFU1RfUE9JTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5PVVRXQVJEUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3V0d2FyZHNTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlRGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkhPUklaT05UQUw6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SG9yaXpvbnRhbFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuVkVSVElDQUw6XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmVydGljYWxTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkNMT1NFU1RfUE9JTlQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdFBvaW50U291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5PVVRXQVJEUzpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXR3YXJkc1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuQVVUTzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnZXRBdXRvU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRUYW5nZW50RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy50YXJnZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuVVA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkRPV046XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC0xLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuQVVUTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDbG9zZXN0UG9pbnRUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE91dHdhcmRzVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnRhcmdldERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5IT1JJWk9OVEFMOlxuICAgICAgICAgICAgcmV0dXJuIGdldEhvcml6b250YWxUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlZFUlRJQ0FMOlxuICAgICAgICAgICAgcmV0dXJuIGdldFZlcnRpY2FsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RQb2ludFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0d2FyZHNUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkFVVE86XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcm90YXRlVmVjdG9yKHZlY3RvciwgYW5nbGUpIHtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHggPSBjb3MgKiB2ZWN0b3IueCAtIHNpbiAqIHZlY3Rvci55O1xuICAgIGNvbnN0IHkgPSBzaW4gKiB2ZWN0b3IueCArIGNvcyAqIHZlY3Rvci55O1xuICAgIHZlY3Rvci54ID0geDtcbiAgICB2ZWN0b3IueSA9IHk7XG59XG5cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlblZlY3RvcnModjEsIHYyKSB7XG4gICAgbGV0IGNvcyA9IHYxLmRvdCh2MikgLyAodjEubWFnbml0dWRlKCkgKiB2Mi5tYWduaXR1ZGUoKSk7XG4gICAgaWYgKGNvcyA8IC0xKSBjb3MgPSAtMTtcbiAgICBpZiAoY29zID4gMSkgY29zID0gMTtcbiAgICByZXR1cm4gTWF0aC5hY29zKGNvcyk7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluYW50KHYxLCB2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueSAtIHYxLnkgKiB2Mi54O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXRtdWxsUm9tQ3VydmVzKHBvaW50cywgc291cmNlVGFuZ2VudCwgdGFyZ2V0VGFuZ2VudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGF1LCBjb2VmZiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkaXN0YW5jZXMgPSBbXTtcbiAgICBjb25zdCB0YW5nZW50cyA9IFtdO1xuICAgIGNvbnN0IGNhdG11bGxSb21DdXJ2ZXMgPSBbXTtcbiAgICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBkaXN0YW5jZXNbaV0gPSBwb2ludHNbaV0uZGlzdGFuY2UocG9pbnRzW2kgKyAxXSk7XG4gICAgfVxuXG4gICAgdGFuZ2VudHNbMF0gPSBzb3VyY2VUYW5nZW50O1xuICAgIHRhbmdlbnRzW25dID0gdGFyZ2V0VGFuZ2VudDtcblxuICAgIC8vIFRoZSBjYWxjdWxhdGlvbiBvZiB0YW5nZW50cyBvZiB2ZXJ0aWNlc1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCB0cFByZXY7XG4gICAgICAgIGxldCB0cE5leHQ7XG4gICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICB0cFByZXYgPSBwb2ludHNbaSAtIDFdLmNsb25lKCkub2Zmc2V0KHRhbmdlbnRzW2kgLSAxXS54LCB0YW5nZW50c1tpIC0gMV0ueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cFByZXYgPSBwb2ludHNbaSAtIDFdLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgICAgICB0cE5leHQgPSBwb2ludHNbaSArIDFdLmNsb25lKCkub2Zmc2V0KHRhbmdlbnRzW2kgKyAxXS54LCB0YW5nZW50c1tpICsgMV0ueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cE5leHQgPSBwb2ludHNbaSArIDFdLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdjEgPSB0cFByZXYuZGlmZmVyZW5jZShwb2ludHNbaV0pLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCB2MiA9IHRwTmV4dC5kaWZmZXJlbmNlKHBvaW50c1tpXSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IHZBbmdsZSA9IGFuZ2xlQmV0d2VlblZlY3RvcnModjEsIHYyKTtcblxuICAgICAgICBsZXQgcm90ID0gKE1hdGguUEkgLSB2QW5nbGUpIC8gMjtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGNvbnN0IHZlY3RvckRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQodjEsIHYyKTtcbiAgICAgICAgbGV0IHBvaW50c0RldGVybWluYW50O1xuICAgICAgICBwb2ludHNEZXRlcm1pbmFudCA9IGRldGVybWluYW50KHBvaW50c1tpXS5kaWZmZXJlbmNlKHBvaW50c1tpICsgMV0pLCBwb2ludHNbaV0uZGlmZmVyZW5jZShwb2ludHNbaSAtIDFdKSk7XG4gICAgICAgIGlmICh2ZWN0b3JEZXRlcm1pbmFudCA8IDApIHtcbiAgICAgICAgICAgIHJvdCA9IC1yb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2QW5nbGUgPCBNYXRoLlBJIC8gMikgJiYgKChyb3QgPCAwICYmIHBvaW50c0RldGVybWluYW50IDwgMCkgfHwgKHJvdCA+IDAgJiYgcG9pbnRzRGV0ZXJtaW5hbnQgPiAwKSkpIHtcbiAgICAgICAgICAgIHJvdCA9IHJvdCAtIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHYyLmNsb25lKCk7XG4gICAgICAgIHJvdGF0ZVZlY3Rvcih0LCByb3QpO1xuXG4gICAgICAgIGNvbnN0IHQxID0gdC5jbG9uZSgpO1xuICAgICAgICBjb25zdCB0MiA9IHQuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IxID0gZGlzdGFuY2VzW2kgLSAxXSAqIGNvZWZmO1xuICAgICAgICBjb25zdCBzY2FsZUZhY3RvcjIgPSBkaXN0YW5jZXNbaV0gKiBjb2VmZjtcbiAgICAgICAgdDEuc2NhbGUoc2NhbGVGYWN0b3IxLCBzY2FsZUZhY3RvcjEpO1xuICAgICAgICB0Mi5zY2FsZShzY2FsZUZhY3RvcjIsIHNjYWxlRmFjdG9yMik7XG5cbiAgICAgICAgdGFuZ2VudHNbaV0gPSBbdDEsIHQyXTtcbiAgICB9XG5cbiAgICAvLyBUaGUgYnVpbGRpbmcgb2YgYSBDYXRtdWxsLVJvbSBjdXJ2ZSBiYXNlZCBvZiB0YW5nZW50cyBvZiBwb2ludHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgcDA7XG4gICAgICAgIGxldCBwMztcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHAwID0gcG9pbnRzW2kgKyAxXS5kaWZmZXJlbmNlKHRhbmdlbnRzW2ldLnggLyB0YXUsIHRhbmdlbnRzW2ldLnkgLyB0YXUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDAgPSBwb2ludHNbaSArIDFdLmRpZmZlcmVuY2UodGFuZ2VudHNbaV1bMV0ueCAvIHRhdSwgdGFuZ2VudHNbaV1bMV0ueSAvIHRhdSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgICAgICBwMyA9IHBvaW50c1tpXS5jbG9uZSgpLm9mZnNldCh0YW5nZW50c1tpICsgMV0ueCAvIHRhdSwgdGFuZ2VudHNbaSArIDFdLnkgLyB0YXUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDMgPSBwb2ludHNbaV0uZGlmZmVyZW5jZSh0YW5nZW50c1tpICsgMV1bMF0ueCAvIHRhdSwgdGFuZ2VudHNbaSArIDFdWzBdLnkgLyB0YXUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2F0bXVsbFJvbUN1cnZlc1tpXSA9IFtwMCwgcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwM107XG4gICAgfVxuICAgIHJldHVybiBjYXRtdWxsUm9tQ3VydmVzO1xufVxuXG4vLyBUaGUgZnVuY3Rpb24gdG8gY29udmVydCBDYXRtdWxsLVJvbSBjdXJ2ZSB0byBCZXppZXIgY3VydmUgdXNpbmcgdGhlIHRlbnNpb24gKHRhdSlcbmZ1bmN0aW9uIGNhdG11bGxSb21Ub0Jlemllcihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRhdSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJjcDEgPSBuZXcgUG9pbnQoKTtcbiAgICBiY3AxLnggPSBwb2ludHNbMV0ueCArIChwb2ludHNbMl0ueCAtIHBvaW50c1swXS54KSAvICg2ICogdGF1KTtcbiAgICBiY3AxLnkgPSBwb2ludHNbMV0ueSArIChwb2ludHNbMl0ueSAtIHBvaW50c1swXS55KSAvICg2ICogdGF1KTtcblxuICAgIGNvbnN0IGJjcDIgPSBuZXcgUG9pbnQoKTtcbiAgICBiY3AyLnggPSBwb2ludHNbMl0ueCArIChwb2ludHNbM10ueCAtIHBvaW50c1sxXS54KSAvICg2ICogdGF1KTtcbiAgICBiY3AyLnkgPSBwb2ludHNbMl0ueSArIChwb2ludHNbM10ueSAtIHBvaW50c1sxXS55KSAvICg2ICogdGF1KTtcbiAgICByZXR1cm4gbmV3IEN1cnZlKFxuICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgIGJjcDEsXG4gICAgICAgIGJjcDIsXG4gICAgICAgIHBvaW50c1syXVxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUGF0aCIsIlBvaW50IiwiQ3VydmUiLCJEaXJlY3Rpb25zIiwiQVVUTyIsIkhPUklaT05UQUwiLCJWRVJUSUNBTCIsIkNMT1NFU1RfUE9JTlQiLCJPVVRXQVJEUyIsIlRhbmdlbnREaXJlY3Rpb25zIiwiVVAiLCJET1dOIiwiTEVGVCIsIlJJR0hUIiwiY3VydmUiLCJzb3VyY2VQb2ludCIsInRhcmdldFBvaW50Iiwicm91dGUiLCJvcHQiLCJsaW5rVmlldyIsInJhdyIsIkJvb2xlYW4iLCJkaXJlY3Rpb24iLCJwcmVjaXNpb24iLCJvcHRpb25zIiwiY29lZmYiLCJkaXN0YW5jZUNvZWZmaWNpZW50IiwiYW5nbGVUYW5nZW50Q29lZmZpY2llbnQiLCJ0YXUiLCJ0ZW5zaW9uIiwic291cmNlVGFuZ2VudCIsInRhcmdldFRhbmdlbnQiLCJyb3RhdGUiLCJzb3VyY2VEaXJlY3Rpb24iLCJub3JtYWxpemUiLCJ0YXJnZXREaXJlY3Rpb24iLCJjb21wbGV0ZVJvdXRlIiwibWFwIiwicCIsImdldFNvdXJjZVRhbmdlbnREaXJlY3Rpb24iLCJ0YW5nZW50TGVuZ3RoIiwiZGlzdGFuY2UiLCJwb2ludHNWZWN0b3IiLCJkaWZmZXJlbmNlIiwiYW5nbGUiLCJhbmdsZUJldHdlZW5WZWN0b3JzIiwiTWF0aCIsIlBJIiwidXBkYXRlZExlbmd0aCIsImNsb25lIiwic2NhbGUiLCJnZXRUYXJnZXRUYW5nZW50RGlyZWN0aW9uIiwibGFzdCIsImxlbmd0aCIsImNhdG11bGxSb21DdXJ2ZXMiLCJjcmVhdGVDYXRtdWxsUm9tQ3VydmVzIiwiYmV6aWVyQ3VydmVzIiwiY2F0bXVsbFJvbVRvQmV6aWVyIiwicGF0aCIsInJvdW5kIiwic2VyaWFsaXplIiwiZ2V0SG9yaXpvbnRhbFNvdXJjZURpcmVjdGlvbiIsInNvdXJjZUJCb3giLCJzb3VyY2VTaWRlIiwicm90YXRpb24iLCJzb3VyY2VWaWV3IiwieCIsIm1vZGVsIiwidW5yb3RhdGVkQkJveCIsImdldE5vZGVVbnJvdGF0ZWRCQm94IiwiZWwiLCJjZW50ZXIiLCJzaWRlTmVhcmVzdFRvUG9pbnQiLCJnZXRIb3Jpem9udGFsVGFyZ2V0RGlyZWN0aW9uIiwidGFyZ2V0QkJveCIsInRhcmdldFNpZGUiLCJ0YXJnZXRWaWV3IiwiZ2V0VmVydGljYWxTb3VyY2VEaXJlY3Rpb24iLCJ5IiwiZ2V0VmVydGljYWxUYXJnZXREaXJlY3Rpb24iLCJnZXRBdXRvU291cmNlRGlyZWN0aW9uIiwiZ2V0QXV0b1RhcmdldERpcmVjdGlvbiIsImdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbiIsImdldENsb3Nlc3RQb2ludFRhcmdldERpcmVjdGlvbiIsImdldE91dHdhcmRzU291cmNlRGlyZWN0aW9uIiwic291cmNlQ2VudGVyIiwiZ2V0T3V0d2FyZHNUYXJnZXREaXJlY3Rpb24iLCJ0YXJnZXRDZW50ZXIiLCJyb3RhdGVWZWN0b3IiLCJ2ZWN0b3IiLCJjb3MiLCJzaW4iLCJ2MSIsInYyIiwiZG90IiwibWFnbml0dWRlIiwiYWNvcyIsImRldGVybWluYW50IiwicG9pbnRzIiwiZGlzdGFuY2VzIiwidGFuZ2VudHMiLCJuIiwiaSIsInRwUHJldiIsInRwTmV4dCIsIm9mZnNldCIsInZBbmdsZSIsInJvdCIsInQiLCJ2ZWN0b3JEZXRlcm1pbmFudCIsInBvaW50c0RldGVybWluYW50IiwidDEiLCJ0MiIsInNjYWxlRmFjdG9yMSIsInNjYWxlRmFjdG9yMiIsInAwIiwicDMiLCJiY3AxIiwiYmNwMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/curve.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: () => (/* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_5__.curve),\n/* harmony export */   jumpover: () => (/* reexport safe */ _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__.jumpover),\n/* harmony export */   normal: () => (/* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_2__.normal),\n/* harmony export */   rounded: () => (/* reexport safe */ _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__.rounded),\n/* harmony export */   smooth: () => (/* reexport safe */ _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__.smooth),\n/* harmony export */   straight: () => (/* reexport safe */ _straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/straight.mjs\");\n/* harmony import */ var _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jumpover.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/jumpover.mjs\");\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normal.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/normal.mjs\");\n/* harmony import */ var _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rounded.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/rounded.mjs\");\n/* harmony import */ var _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./smooth.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/smooth.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/curve.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDRjtBQUNDO0FBQ0Q7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2Nvbm5lY3RvcnMvaW5kZXgubWpzPzAwMzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9zdHJhaWdodC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9qdW1wb3Zlci5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ub3JtYWwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcm91bmRlZC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zbW9vdGgubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vY3VydmUubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/jumpover.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/jumpover.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jumpover: () => (/* binding */ jumpover)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = [\n    \"arc\",\n    \"gap\",\n    \"cubic\"\n];\n// default radius\nvar RADIUS = 0;\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = [\n    \"smooth\"\n];\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\nfunction sortPointsAscending(p1, p2) {\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n    if (x1 > x2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n    return [\n        new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1),\n        new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2)\n    ];\n}\nfunction overlapExists(line1, line2) {\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n    return xMatch && yMatch;\n}\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */ function createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on(\"batch:stop\", function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on(\"reset\", function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, \"change:connector remove\", function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */ function updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for(var i = 0; i < updateList.length; i++){\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */ function findLineIntersections(line, crossCheckLines) {\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */ function sortPoints(p1, p2) {\n    return _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */ function createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, -jumpSize);\n        var jumpEnd = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, +jumpSize);\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n        // finally create a jump line\n        var jumpLine = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n        resultLines.push(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(lastLine.start, jumpStart), jumpLine, _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpEnd, lastLine.end));\n        return resultLines;\n    }, []);\n}\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */ function buildPath(lines, jumpSize, jumpType, radius) {\n    var path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path();\n    var segment;\n    // first move to the start of a first line\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"M\", lines[0].start);\n    path.appendSegment(segment);\n    // make a paths from lines\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(lines).forEach(function(line, index) {\n        if (line.isJump) {\n            var angle, diff;\n            var control1, control2;\n            if (jumpType === \"arc\") {\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n                if (xAxisRotate) angle += 180;\n                var midpoint = line.midpoint();\n                var centerLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end).rotate(midpoint, angle);\n                var halfLine;\n                // first half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(line.start, midpoint);\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"C\", control1, control2, centerLine.end);\n                path.appendSegment(segment);\n                // second half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end);\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"C\", control1, control2, line.end);\n                path.appendSegment(segment);\n            } else if (jumpType === \"gap\") {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"M\", line.end);\n                path.appendSegment(segment);\n            } else if (jumpType === \"cubic\") {\n                angle = line.start.theta(line.end);\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n                if (xAxisRotate) yOffset *= -1;\n                control1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"C\", control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"L\", line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n    return path;\n}\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n    var control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n    var control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n    var segment;\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"L\", roundedStart);\n    path.appendSegment(segment);\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment(\"C\", control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */ const jumpover = function(sourcePoint, targetPoint, route, opt) {\n    setupUpdating(this);\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && (\"\" + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n    }\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n        var connector = link.get(\"connector\") || defaultConnector;\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== \"jumpover\";\n        }\n        return true;\n    });\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n    // create lines for this link\n    var thisLines = createLines(sourcePoint, targetPoint, route);\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n    }, this);\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line)=>overlapExists(thisLine, line));\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return raw ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9qdW1wb3Zlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEM7QUFDTjtBQUVwQyxtREFBbUQ7QUFDbkQsSUFBSUUsWUFBWTtBQUVoQix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLElBQUlDLGFBQWE7SUFBQztJQUFPO0lBQU87Q0FBUTtBQUV4QyxpQkFBaUI7QUFDakIsSUFBSUMsU0FBUztBQUViLDJFQUEyRTtBQUMzRSxJQUFJQywwQkFBMEI7QUFFOUIsNENBQTRDO0FBQzVDLElBQUlDLHFCQUFxQjtJQUFDO0NBQVM7QUFFbkMsdUNBQXVDO0FBQ3ZDLElBQUlDLE1BQU0sSUFBSTtBQUNkLElBQUlDLE1BQU0sSUFBSTtBQUVkLFNBQVNDLG9CQUFvQkMsRUFBRSxFQUFFQyxFQUFFO0lBRS9CLElBQUksRUFBRUMsR0FBR0MsRUFBRSxFQUFFQyxHQUFHQyxFQUFFLEVBQUUsR0FBR0w7SUFDdkIsSUFBSSxFQUFFRSxHQUFHSSxFQUFFLEVBQUVGLEdBQUdHLEVBQUUsRUFBRSxHQUFHTjtJQUV2QixJQUFJRSxLQUFLRyxJQUFJO1FBRVQsSUFBSUUsT0FBT0w7UUFDWEEsS0FBS0c7UUFDTEEsS0FBS0U7UUFFTEEsT0FBT0g7UUFDUEEsS0FBS0U7UUFDTEEsS0FBS0M7SUFDVDtJQUVBLElBQUlILEtBQUtFLElBQUk7UUFDVCxJQUFJQyxPQUFPTDtRQUNYQSxLQUFLRztRQUNMQSxLQUFLRTtRQUVMQSxPQUFPSDtRQUNQQSxLQUFLRTtRQUNMQSxLQUFLQztJQUNUO0lBRUEsT0FBTztRQUFDLElBQUlqQiwrQ0FBTyxDQUFDWSxJQUFJRTtRQUFLLElBQUlkLCtDQUFPLENBQUNlLElBQUlDO0tBQUk7QUFDckQ7QUFFQSxTQUFTRyxjQUFjQyxLQUFLLEVBQUVDLEtBQUs7SUFFL0IsTUFBTSxDQUFDLEVBQUVWLEdBQUdDLEVBQUUsRUFBRUMsR0FBR0MsRUFBRSxFQUFFLEVBQUUsRUFBRUgsR0FB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QUFhLENBQUNKLGVBQWUsQ0FBQ0UsYUFBYSxDQUFDeEksR0FBRyxHQUFHO29CQUNoRiw2REFBNkQ7b0JBQzdEc0ksZ0JBQWdCdEcsTUFBTSxDQUFDd0csZUFBZSxHQUFHO2dCQUM3QztnQkFDQSxNQUFNRyxvQkFBb0JqRyxzQkFBc0IyRixVQUFVQztnQkFDMUR6RixJQUFJZixJQUFJLENBQUM4RyxLQUFLLENBQUMvRixLQUFLOEY7WUFDeEI7WUFDQSxPQUFPOUY7UUFDWCxHQUFHLEVBQUUsRUFBRWdHLElBQUksQ0FBQyxTQUFTQyxDQUFDLEVBQUVDLENBQUM7WUFDckIsT0FBTy9GLFdBQVdxRixTQUFTdEksS0FBSyxFQUFFK0ksS0FBSzlGLFdBQVdxRixTQUFTdEksS0FBSyxFQUFFZ0o7UUFDdEU7UUFFQSxJQUFJNUYsY0FBY2pCLE1BQU0sR0FBRyxHQUFHO1lBQzFCLG9EQUFvRDtZQUNwRHBCLFlBQVlnQixJQUFJLENBQUM4RyxLQUFLLENBQUM5SCxhQUFhb0MsWUFBWW1GLFVBQVVsRixlQUFlQztRQUM3RSxPQUFPO1lBQ0gsdURBQXVEO1lBQ3ZEdEMsWUFBWWdCLElBQUksQ0FBQ3VHO1FBQ3JCO1FBQ0EsT0FBT3ZIO0lBQ1gsR0FBRyxFQUFFO0lBRUwsSUFBSXNELE9BQU9KLFVBQVVvRSxjQUFjaEYsVUFBVWMsVUFBVUM7SUFDdkQsT0FBTyxNQUFRQyxPQUFPQSxLQUFLNEUsU0FBUztBQUN4QyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9qdW1wb3Zlci5tanM/NWVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG4vLyBkZWZhdWx0IHNpemUgb2YganVtcCBpZiBub3Qgc3BlY2lmaWVkIGluIG9wdGlvbnNcbnZhciBKVU1QX1NJWkUgPSA1O1xuXG4vLyBhdmFpbGFibGUganVtcCB0eXBlc1xuLy8gZmlyc3Qgb25lIHRha2VuIGFzIGRlZmF1bHRcbnZhciBKVU1QX1RZUEVTID0gWydhcmMnLCAnZ2FwJywgJ2N1YmljJ107XG5cbi8vIGRlZmF1bHQgcmFkaXVzXG52YXIgUkFESVVTID0gMDtcblxuLy8gdGFrZXMgY2FyZSBvZiBtYXRoLiBlcnJvciBmb3IgY2FzZSB3aGVuIGp1bXAgaXMgdG9vIGNsb3NlIHRvIGVuZCBvZiBsaW5lXG52YXIgQ0xPU0VfUFJPWElNSVRZX1BBRERJTkcgPSAxO1xuXG4vLyBsaXN0IG9mIGNvbm5lY3RvciB0eXBlcyBub3QgdG8ganVtcCBvdmVyLlxudmFyIElHTk9SRURfQ09OTkVDVE9SUyA9IFsnc21vb3RoJ107XG5cbi8vIGludGVybmFsIGNvbnN0YW50cyBmb3Igcm91bmQgc2VnbWVudFxudmFyIF8xMyA9IDEgLyAzO1xudmFyIF8yMyA9IDIgLyAzO1xuXG5mdW5jdGlvbiBzb3J0UG9pbnRzQXNjZW5kaW5nKHAxLCBwMikge1xuXG4gICAgbGV0IHsgeDogeDEsIHk6IHkxIH0gPSBwMTtcbiAgICBsZXQgeyB4OiB4MiwgeTogeTIgfSA9IHAyO1xuXG4gICAgaWYgKHgxID4geDIpIHtcblxuICAgICAgICBsZXQgc3dhcCA9IHgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXA7XG5cbiAgICAgICAgc3dhcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgfVxuXG4gICAgaWYgKHkxID4geTIpIHtcbiAgICAgICAgbGV0IHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuXG4gICAgICAgIHN3YXAgPSB5MTtcbiAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgIH1cblxuICAgIHJldHVybiBbbmV3IGcuUG9pbnQoeDEsIHkxKSwgbmV3IGcuUG9pbnQoeDIsIHkyKV07XG59XG5cbmZ1bmN0aW9uIG92ZXJsYXBFeGlzdHMobGluZTEsIGxpbmUyKSB7XG5cbiAgICBjb25zdCBbeyB4OiB4MSwgeTogeTEgfSwgeyB4OiB4MiwgeTogeTIgfV0gPSBzb3J0UG9pbnRzQXNjZW5kaW5nKGxpbmUxLnN0YXJ0LCBsaW5lMS5lbmQpO1xuICAgIGNvbnN0IFt7IHg6IHgzLCB5OiB5MyB9LCB7IHg6IHg0LCB5OiB5NCB9XSA9IHNvcnRQb2ludHNBc2NlbmRpbmcobGluZTIuc3RhcnQsIGxpbmUyLmVuZCk7XG5cbiAgICBjb25zdCB4TWF0Y2ggPSB4MSA8PSB4NCAmJiB4MyA8PSB4MjtcbiAgICBjb25zdCB5TWF0Y2ggPSB5MSA8PSB5NCAmJiB5MyA8PSB5MjtcblxuICAgIHJldHVybiB4TWF0Y2ggJiYgeU1hdGNoO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBzdGFydC9lbmQgYW5kIHJvdXRlIGludG8gc2VyaWVzIG9mIGxpbmVzXG4gKiBAcGFyYW0ge2cucG9pbnR9IHNvdXJjZVBvaW50IHN0YXJ0IHBvaW50XG4gKiBAcGFyYW0ge2cucG9pbnR9IHRhcmdldFBvaW50IGVuZCBwb2ludFxuICogQHBhcmFtIHtnLnBvaW50W119IHJvdXRlIG9wdGlvbmFsIGxpc3Qgb2Ygcm91dGVcbiAqIEByZXR1cm4ge2cubGluZVtdfSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVzKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUpIHtcbiAgICAvLyBtYWtlIGEgZmxhdHRlbmVkIGFycmF5IG9mIGFsbCBwb2ludHNcbiAgICB2YXIgcG9pbnRzID0gW10uY29uY2F0KHNvdXJjZVBvaW50LCByb3V0ZSwgdGFyZ2V0UG9pbnQpO1xuICAgIHJldHVybiBwb2ludHMucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdExpbmVzLCBwb2ludCwgaWR4KSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbmV4dCBwb2ludCwgbWFrZSBhIGxpbmUgd2l0aCBpdFxuICAgICAgICB2YXIgbmV4dFBvaW50ID0gcG9pbnRzW2lkeCArIDFdO1xuICAgICAgICBpZiAobmV4dFBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdExpbmVzW2lkeF0gPSBnLmxpbmUocG9pbnQsIG5leHRQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gc2V0dXBVcGRhdGluZyhqdW1wT3ZlckxpbmtWaWV3KSB7XG4gICAgdmFyIHBhcGVyID0ganVtcE92ZXJMaW5rVmlldy5wYXBlcjtcbiAgICB2YXIgdXBkYXRlTGlzdCA9IHBhcGVyLl9qdW1wT3ZlclVwZGF0ZUxpc3Q7XG5cbiAgICAvLyBmaXJzdCB0aW1lIHNldHVwIGZvciB0aGlzIHBhcGVyXG4gICAgaWYgKHVwZGF0ZUxpc3QgPT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVMaXN0ID0gcGFwZXIuX2p1bXBPdmVyVXBkYXRlTGlzdCA9IFtdO1xuICAgICAgICB2YXIgZ3JhcGggPSBwYXBlci5tb2RlbDtcbiAgICAgICAgZ3JhcGgub24oJ2JhdGNoOnN0b3AnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0FjdGl2ZUJhdGNoKCkpIHJldHVybjtcbiAgICAgICAgICAgIHVwZGF0ZUp1bXBPdmVyKHBhcGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoLm9uKCdyZXNldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXBkYXRlTGlzdCA9IHBhcGVyLl9qdW1wT3ZlclVwZGF0ZUxpc3QgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoaXMgbGluayB0byBhIGxpc3Qgc28gaXQgY2FuIGJlIHVwZGF0ZWQgd2hlbiBzb21lIG90aGVyIGxpbmsgaXMgdXBkYXRlZFxuICAgIGlmICh1cGRhdGVMaXN0LmluZGV4T2YoanVtcE92ZXJMaW5rVmlldykgPCAwKSB7XG4gICAgICAgIHVwZGF0ZUxpc3QucHVzaChqdW1wT3ZlckxpbmtWaWV3KTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlIG9mIGNvbm5lY3RvciB0eXBlIG9yIHJlbW92YWwgb2YgbGluayBpdHNlbGZcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZSBsaW5rIGZyb20gYSBsaXN0IG9mIGp1bXAgb3ZlciBjb25uZWN0b3JzXG4gICAgICAgIGp1bXBPdmVyTGlua1ZpZXcubGlzdGVuVG9PbmNlKGp1bXBPdmVyTGlua1ZpZXcubW9kZWwsICdjaGFuZ2U6Y29ubmVjdG9yIHJlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXBkYXRlTGlzdC5zcGxpY2UodXBkYXRlTGlzdC5pbmRleE9mKGp1bXBPdmVyTGlua1ZpZXcpLCAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGEgYmF0Y2g6c3RvcCBldmVudCB0byBmb3JjZVxuICogdXBkYXRlIG9mIGFsbCByZWdpc3RlcmVkIGxpbmtzIHdpdGgganVtcCBvdmVyIGNvbm5lY3RvclxuICogQHBhcmFtIHtvYmplY3R9IGJhdGNoRXZlbnQgb3B0aW9uYWwgb2JqZWN0IHdpdGggaW5mbyBhYm91dCBiYXRjaFxuICovXG5mdW5jdGlvbiB1cGRhdGVKdW1wT3ZlcihwYXBlcikge1xuICAgIHZhciB1cGRhdGVMaXN0ID0gcGFwZXIuX2p1bXBPdmVyVXBkYXRlTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGlua1ZpZXcgPSB1cGRhdGVMaXN0W2ldO1xuICAgICAgICBjb25zdCB1cGRhdGVGbGFnID0gbGlua1ZpZXcuZ2V0RmxhZyhsaW5rVmlldy5jb25zdHJ1Y3Rvci5GbGFncy5DT05ORUNUT1IpO1xuICAgICAgICBsaW5rVmlldy5yZXF1ZXN0VXBkYXRlKHVwZGF0ZUZsYWcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbGxlY3QgYWxsIGludGVyc2VjdGlvbiBwb2ludHMgb2YgYSBzaW5nbGVcbiAqIGxpbmUgYWdhaW5zdCBncm91cCBvZiBvdGhlciBsaW5lcy5cbiAqIEBwYXJhbSB7Zy5saW5lfSBsaW5lIHdoZXJlIHRvIGZpbmQgcG9pbnRzXG4gKiBAcGFyYW0ge2cubGluZVtdfSBjcm9zc0NoZWNrTGluZXMgbGluZXMgdG8gY3Jvc3NcbiAqIEByZXR1cm4ge2cucG9pbnRbXX0gbGlzdCBvZiBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGZpbmRMaW5lSW50ZXJzZWN0aW9ucyhsaW5lLCBjcm9zc0NoZWNrTGluZXMpIHtcbiAgICByZXR1cm4gdXRpbC50b0FycmF5KGNyb3NzQ2hlY2tMaW5lcykucmVkdWNlKGZ1bmN0aW9uKHJlcywgY3Jvc3NDaGVja0xpbmUpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGxpbmUuaW50ZXJzZWN0aW9uKGNyb3NzQ2hlY2tMaW5lKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgcmVzLnB1c2goaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBTb3J0aW5nIGZ1bmN0aW9uIGZvciBsaXN0IG9mIHBvaW50cyBieSB0aGVpciBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7Zy5wb2ludH0gcDEgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB7Zy5wb2ludH0gcDIgc2Vjb25kIHBvaW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHNcbiAqL1xuZnVuY3Rpb24gc29ydFBvaW50cyhwMSwgcDIpIHtcbiAgICByZXR1cm4gZy5saW5lKHAxLCBwMikuc3F1YXJlZExlbmd0aCgpO1xufVxuXG4vKipcbiAqIFNwbGl0IGlucHV0IGxpbmUgaW50byBtdWx0aXBsZSBiYXNlZCBvbiBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICogQHBhcmFtIHtnLmxpbmV9IGxpbmUgaW5wdXQgbGluZSB0byBzcGxpdFxuICogQHBhcmFtIHtnLnBvaW50W119IGludGVyc2VjdGlvbnMgcG9pbnRzIHdoZXJlIHRvIHNwbGl0IHRoZSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0ganVtcFNpemUgdGhlIHNpemUgb2YganVtcCBhcmMgKGxlbmd0aCBlbXB0eSBzcG90IG9uIGEgbGluZSlcbiAqIEByZXR1cm4ge2cubGluZVtdfSBsaXN0IG9mIGxpbmVzIGJlaW5nIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUp1bXBzKGxpbmUsIGludGVyc2VjdGlvbnMsIGp1bXBTaXplKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnMucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdExpbmVzLCBwb2ludCwgaWR4KSB7XG4gICAgICAgIC8vIHNraXBwaW5nIHBvaW50cyB0aGF0IHdlcmUgbWVyZ2VkIHdpdGggdGhlIHByZXZpb3VzIGxpbmVcbiAgICAgICAgLy8gdG8gbWFrZSBiaWdnZXIgYXJjIG92ZXIgbXVsdGlwbGUgbGluZXMgdGhhdCBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlclxuICAgICAgICBpZiAocG9pbnQuc2tpcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWx3YXlzIGdyYWIgdGhlIGxhc3QgbGluZSBmcm9tIGJ1ZmZlciBhbmQgbW9kaWZ5IGl0XG4gICAgICAgIHZhciBsYXN0TGluZSA9IHJlc3VsdExpbmVzLnBvcCgpIHx8IGxpbmU7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHN0YXJ0IGFuZCBlbmQgb2YganVtcCBieSBtb3ZpbmcgYnkgYSBnaXZlbiBzaXplIG9mIGp1bXBcbiAgICAgICAgdmFyIGp1bXBTdGFydCA9IGcucG9pbnQocG9pbnQpLm1vdmUobGFzdExpbmUuc3RhcnQsIC0oanVtcFNpemUpKTtcbiAgICAgICAgdmFyIGp1bXBFbmQgPSBnLnBvaW50KHBvaW50KS5tb3ZlKGxhc3RMaW5lLnN0YXJ0LCArKGp1bXBTaXplKSk7XG5cbiAgICAgICAgLy8gbm93IHRyeSB0byBsb29rIGF0IHRoZSBuZXh0IGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICB2YXIgbmV4dFBvaW50ID0gaW50ZXJzZWN0aW9uc1tpZHggKyAxXTtcbiAgICAgICAgaWYgKG5leHRQb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBqdW1wRW5kLmRpc3RhbmNlKG5leHRQb2ludCk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0ganVtcFNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IHBvaW50IGlzIGNsb3NlIGVub3VnaCwgbW92ZSB0aGUganVtcCBlbmQgYnkgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgYW5kIG1hcmsgdGhlIG5leHQgcG9pbnQgdG8gYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgIGp1bXBFbmQgPSBuZXh0UG9pbnQubW92ZShsYXN0TGluZS5zdGFydCwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIG5leHRQb2ludC5za2lwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2sgaXMgaW5zaWRlIG9mIGBlbHNlYCBhcyBhbiBvcHRpbWl6YXRpb24gc28gdGhlIGRpc3RhbmNlIGlzXG4gICAgICAgICAgICAvLyBub3QgY2FsY3VsYXRlZCB3aGVuIHdlIGtub3cgdGhlcmUgYXJlIG5vIG90aGVyIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHZhciBlbmREaXN0YW5jZSA9IGp1bXBTdGFydC5kaXN0YW5jZShsYXN0TGluZS5lbmQpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGVuZCBpcyB0b28gY2xvc2UgdG8gcG9zc2libGUganVtcCwgZHJhdyByZW1haW5pbmcgbGluZSBpbnN0ZWFkIG9mIGEganVtcFxuICAgICAgICAgICAgaWYgKGVuZERpc3RhbmNlIDwganVtcFNpemUgKiAyICsgQ0xPU0VfUFJPWElNSVRZX1BBRERJTkcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKGxhc3RMaW5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnREaXN0YW5jZSA9IGp1bXBFbmQuZGlzdGFuY2UobGFzdExpbmUuc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnREaXN0YW5jZSA8IGp1bXBTaXplICogMiArIENMT1NFX1BST1hJTUlUWV9QQURESU5HKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RhcnQgb2YgbGluZSBpcyB0b28gY2xvc2UgdG8ganVtcCwgZHJhdyB0aGF0IGxpbmUgaW5zdGVhZCBvZiBhIGp1bXBcbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSBjcmVhdGUgYSBqdW1wIGxpbmVcbiAgICAgICAgdmFyIGp1bXBMaW5lID0gZy5saW5lKGp1bXBTdGFydCwganVtcEVuZCk7XG4gICAgICAgIC8vIGl0J3MganVzdCBzaW1wbGUgbGluZSBidXQgd2l0aCBhIGBpc0p1bXBgIHByb3BlcnR5XG4gICAgICAgIGp1bXBMaW5lLmlzSnVtcCA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0TGluZXMucHVzaChcbiAgICAgICAgICAgIGcubGluZShsYXN0TGluZS5zdGFydCwganVtcFN0YXJ0KSxcbiAgICAgICAgICAgIGp1bXBMaW5lLFxuICAgICAgICAgICAgZy5saW5lKGp1bXBFbmQsIGxhc3RMaW5lLmVuZClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBBc3NlbWJsZSBgRGAgYXR0cmlidXRlIG9mIGEgU1ZHIHBhdGggYnkgaXRlcmF0aW5nIGdpdmVuIGxpbmVzLlxuICogQHBhcmFtIHtnLmxpbmVbXX0gbGluZXMgc291cmNlIGxpbmVzIHRvIHVzZVxuICogQHBhcmFtIHtudW1iZXJ9IGp1bXBTaXplIHRoZSBzaXplIG9mIGp1bXAgYXJjIChsZW5ndGggZW1wdHkgc3BvdCBvbiBhIGxpbmUpXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHRoZSByYWRpdXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVpbGRQYXRoKGxpbmVzLCBqdW1wU2l6ZSwganVtcFR5cGUsIHJhZGl1cykge1xuXG4gICAgdmFyIHBhdGggPSBuZXcgZy5QYXRoKCk7XG4gICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAvLyBmaXJzdCBtb3ZlIHRvIHRoZSBzdGFydCBvZiBhIGZpcnN0IGxpbmVcbiAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBsaW5lc1swXS5zdGFydCk7XG4gICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgLy8gbWFrZSBhIHBhdGhzIGZyb20gbGluZXNcbiAgICB1dGlsLnRvQXJyYXkobGluZXMpLmZvckVhY2goZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcblxuICAgICAgICBpZiAobGluZS5pc0p1bXApIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSwgZGlmZjtcblxuICAgICAgICAgICAgdmFyIGNvbnRyb2wxLCBjb250cm9sMjtcblxuICAgICAgICAgICAgaWYgKGp1bXBUeXBlID09PSAnYXJjJykgeyAvLyBhcHByb3hpbWF0ZXMgc2VtaWNpcmNsZSB3aXRoIDIgY3VydmVzXG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtOTA7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHJvdGF0aW9uIG9mIGFyYyBiYXNlZCBvbiBkaWZmZXJlbmNlIGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICAgICAgZGlmZiA9IGxpbmUuc3RhcnQuZGlmZmVyZW5jZShsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBhcmMgYWx3YXlzIHBvaW50cyB1cCAob3IgcmlnaHQpXG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRlID0gTnVtYmVyKChkaWZmLnggPCAwKSB8fCAoZGlmZi54ID09PSAwICYmIGRpZmYueSA8IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNSb3RhdGUpIGFuZ2xlICs9IDE4MDtcblxuICAgICAgICAgICAgICAgIHZhciBtaWRwb2ludCA9IGxpbmUubWlkcG9pbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyTGluZSA9IG5ldyBnLkxpbmUobWlkcG9pbnQsIGxpbmUuZW5kKS5yb3RhdGUobWlkcG9pbnQsIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHZhciBoYWxmTGluZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGhhbGZcbiAgICAgICAgICAgICAgICBoYWxmTGluZSA9IG5ldyBnLkxpbmUobGluZS5zdGFydCwgbWlkcG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgY29udHJvbDEgPSBoYWxmTGluZS5wb2ludEF0KDIgLyAzKS5yb3RhdGUobGluZS5zdGFydCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wyID0gY2VudGVyTGluZS5wb2ludEF0KDEgLyAzKS5yb3RhdGUoY2VudGVyTGluZS5lbmQsIC1hbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sMSwgY29udHJvbDIsIGNlbnRlckxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWNvbmQgaGFsZlxuICAgICAgICAgICAgICAgIGhhbGZMaW5lID0gbmV3IGcuTGluZShtaWRwb2ludCwgbGluZS5lbmQpO1xuXG4gICAgICAgICAgICAgICAgY29udHJvbDEgPSBjZW50ZXJMaW5lLnBvaW50QXQoMSAvIDMpLnJvdGF0ZShjZW50ZXJMaW5lLmVuZCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wyID0gaGFsZkxpbmUucG9pbnRBdCgxIC8gMykucm90YXRlKGxpbmUuZW5kLCAtYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgY29udHJvbDEsIGNvbnRyb2wyLCBsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGp1bXBUeXBlID09PSAnZ2FwJykge1xuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnTScsIGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoanVtcFR5cGUgPT09ICdjdWJpYycpIHsgLy8gYXBwcm94aW1hdGVzIHNlbWljaXJjbGUgd2l0aCAxIGN1cnZlXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBsaW5lLnN0YXJ0LnRoZXRhKGxpbmUuZW5kKTtcblxuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0ganVtcFNpemUgKiAwLjY7XG4gICAgICAgICAgICAgICAgdmFyIHlPZmZzZXQgPSBqdW1wU2l6ZSAqIDEuMzU7XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgcm90YXRpb24gb2YgYXJjIGJhc2VkIG9uIGRpZmZlcmVuY2UgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgICAgICBkaWZmID0gbGluZS5zdGFydC5kaWZmZXJlbmNlKGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGFyYyBhbHdheXMgcG9pbnRzIHVwIChvciByaWdodClcbiAgICAgICAgICAgICAgICB4QXhpc1JvdGF0ZSA9IE51bWJlcigoZGlmZi54IDwgMCkgfHwgKGRpZmYueCA9PT0gMCAmJiBkaWZmLnkgPCAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzUm90YXRlKSB5T2Zmc2V0ICo9IC0xO1xuXG4gICAgICAgICAgICAgICAgY29udHJvbDEgPSBnLlBvaW50KGxpbmUuc3RhcnQueCArIHhPZmZzZXQsIGxpbmUuc3RhcnQueSArIHlPZmZzZXQpLnJvdGF0ZShsaW5lLnN0YXJ0LCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgY29udHJvbDIgPSBnLlBvaW50KGxpbmUuZW5kLnggLSB4T2Zmc2V0LCBsaW5lLmVuZC55ICsgeU9mZnNldCkucm90YXRlKGxpbmUuZW5kLCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sMSwgY29udHJvbDIsIGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IGxpbmVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAocmFkaXVzID09IDAgfHwgIW5leHRMaW5lIHx8IG5leHRMaW5lLmlzSnVtcCkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnTCcsIGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkUm91bmRlZFNlZ21lbnQocmFkaXVzLCBwYXRoLCBsaW5lLmVuZCwgbGluZS5zdGFydCwgbmV4dExpbmUuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUm91bmRlZFNlZ21lbnQob2Zmc2V0LCBwYXRoLCBjdXJyLCBwcmV2LCBuZXh0KSB7XG4gICAgdmFyIHByZXZEaXN0YW5jZSA9IGN1cnIuZGlzdGFuY2UocHJldikgLyAyO1xuICAgIHZhciBuZXh0RGlzdGFuY2UgPSBjdXJyLmRpc3RhbmNlKG5leHQpIC8gMjtcblxuICAgIHZhciBzdGFydE1vdmUgPSAtTWF0aC5taW4ob2Zmc2V0LCBwcmV2RGlzdGFuY2UpO1xuICAgIHZhciBlbmRNb3ZlID0gLU1hdGgubWluKG9mZnNldCwgbmV4dERpc3RhbmNlKTtcblxuICAgIHZhciByb3VuZGVkU3RhcnQgPSBjdXJyLmNsb25lKCkubW92ZShwcmV2LCBzdGFydE1vdmUpLnJvdW5kKCk7XG4gICAgdmFyIHJvdW5kZWRFbmQgPSBjdXJyLmNsb25lKCkubW92ZShuZXh0LCBlbmRNb3ZlKS5yb3VuZCgpO1xuXG4gICAgdmFyIGNvbnRyb2wxID0gbmV3IGcuUG9pbnQoKF8xMyAqIHJvdW5kZWRTdGFydC54KSArIChfMjMgKiBjdXJyLngpLCAoXzIzICogY3Vyci55KSArIChfMTMgKiByb3VuZGVkU3RhcnQueSkpO1xuICAgIHZhciBjb250cm9sMiA9IG5ldyBnLlBvaW50KChfMTMgKiByb3VuZGVkRW5kLngpICsgKF8yMyAqIGN1cnIueCksIChfMjMgKiBjdXJyLnkpICsgKF8xMyAqIHJvdW5kZWRFbmQueSkpO1xuXG4gICAgdmFyIHNlZ21lbnQ7XG4gICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdMJywgcm91bmRlZFN0YXJ0KTtcbiAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sMSwgY29udHJvbDIsIHJvdW5kZWRFbmQpO1xuICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbn1cblxuLyoqXG4gKiBBY3R1YWwgY29ubmVjdG9yIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gb24gZXZlcnkgdXBkYXRlLlxuICogQHBhcmFtIHtnLnBvaW50fSBzb3VyY2VQb2ludCBzdGFydCBwb2ludCBvZiB0aGlzIGxpbmtcbiAqIEBwYXJhbSB7Zy5wb2ludH0gdGFyZ2V0UG9pbnQgZW5kIHBvaW50IG9mIHRoaXMgbGlua1xuICogQHBhcmFtIHtnLnBvaW50W119IHJvdXRlIG9mIHRoaXMgbGlua1xuICogQHBhcmFtIHtvYmplY3R9IG9wdCBvcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBvcHRpb25hbCBzaXplIG9mIGEganVtcCBhcmNcbiAqIEByZXR1cm4ge3N0cmluZ30gY3JlYXRlZCBgRGAgYXR0cmlidXRlIG9mIFNWRyBwYXRoXG4gKi9cbmV4cG9ydCBjb25zdCBqdW1wb3ZlciA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIG9wdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1wYXJhbXNcblxuICAgIHNldHVwVXBkYXRpbmcodGhpcyk7XG5cbiAgICB2YXIgcmF3ID0gb3B0LnJhdztcbiAgICB2YXIganVtcFNpemUgPSBvcHQuc2l6ZSB8fCBKVU1QX1NJWkU7XG4gICAgdmFyIGp1bXBUeXBlID0gb3B0Lmp1bXAgJiYgKCcnICsgb3B0Lmp1bXApLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHJhZGl1cyA9IG9wdC5yYWRpdXMgfHwgUkFESVVTO1xuICAgIHZhciBpZ25vcmVDb25uZWN0b3JzID0gb3B0Lmlnbm9yZUNvbm5lY3RvcnMgfHwgSUdOT1JFRF9DT05ORUNUT1JTO1xuXG4gICAgLy8gZ3JhYiB0aGUgZmlyc3QganVtcCB0eXBlIGFzIGEgZGVmYXVsdCBpZiBzcGVjaWZpZWQgb25lIGlzIGludmFsaWRcbiAgICBpZiAoSlVNUF9UWVBFUy5pbmRleE9mKGp1bXBUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAganVtcFR5cGUgPSBKVU1QX1RZUEVTWzBdO1xuICAgIH1cblxuICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgdmFyIGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgdmFyIGFsbExpbmtzID0gZ3JhcGguZ2V0TGlua3MoKTtcblxuICAgIC8vIHRoZXJlIGlzIGp1c3Qgb25lIGxpbmssIGRyYXcgaXQgZGlyZWN0bHlcbiAgICBpZiAoYWxsTGlua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWlsZFBhdGgoXG4gICAgICAgICAgICBjcmVhdGVMaW5lcyhzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlKSxcbiAgICAgICAgICAgIGp1bXBTaXplLCBqdW1wVHlwZSwgcmFkaXVzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgdmFyIHRoaXNJbmRleCA9IGFsbExpbmtzLmluZGV4T2YodGhpc01vZGVsKTtcbiAgICB2YXIgZGVmYXVsdENvbm5lY3RvciA9IHBhcGVyLm9wdGlvbnMuZGVmYXVsdENvbm5lY3RvciB8fCB7fTtcblxuICAgIC8vIG5vdCBhbGwgbGlua3MgYXJlIG1lYW50IHRvIGJlIGp1bXBlZCBvdmVyLlxuICAgIHZhciBsaW5rcyA9IGFsbExpbmtzLmZpbHRlcihmdW5jdGlvbihsaW5rLCBpZHgpIHtcblxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbGluay5nZXQoJ2Nvbm5lY3RvcicpIHx8IGRlZmF1bHRDb25uZWN0b3I7XG5cbiAgICAgICAgLy8gYXZvaWQganVtcGluZyBvdmVyIGxpbmtzIHdpdGggY29ubmVjdG9yIHR5cGUgbGlzdGVkIGluIGBpZ25vcmVkIGNvbm5lY3RvcnNgLlxuICAgICAgICBpZiAodXRpbC50b0FycmF5KGlnbm9yZUNvbm5lY3RvcnMpLmluY2x1ZGVzKGNvbm5lY3Rvci5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgbGlua3MgdGhhdCBhcmUgYWJvdmUgdGhpcyBvbmUgYW5kICBoYXZlIHRoZSBzYW1lIGNvbm5lY3RvciB0eXBlXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGVyZSB3b3VsZCBkb3VibGUgaG9vcHMgZm9yIGVhY2ggaW50ZXJzZWN0aW9uXG4gICAgICAgIGlmIChpZHggPiB0aGlzSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3IubmFtZSAhPT0gJ2p1bXBvdmVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGZpbmQgdmlld3MgZm9yIGFsbCBsaW5rc1xuICAgIHZhciBsaW5rVmlld3MgPSBsaW5rcy5tYXAoZnVuY3Rpb24obGluaykge1xuICAgICAgICByZXR1cm4gcGFwZXIuZmluZFZpZXdCeU1vZGVsKGxpbmspO1xuICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlIGxpbmVzIGZvciB0aGlzIGxpbmtcbiAgICB2YXIgdGhpc0xpbmVzID0gY3JlYXRlTGluZXMoXG4gICAgICAgIHNvdXJjZVBvaW50LFxuICAgICAgICB0YXJnZXRQb2ludCxcbiAgICAgICAgcm91dGVcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGxpbmVzIGZvciBhbGwgb3RoZXIgbGlua3NcbiAgICB2YXIgbGlua0xpbmVzID0gbGlua1ZpZXdzLm1hcChmdW5jdGlvbihsaW5rVmlldykge1xuICAgICAgICBpZiAobGlua1ZpZXcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5rVmlldyA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNMaW5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTGluZXMoXG4gICAgICAgICAgICBsaW5rVmlldy5zb3VyY2VQb2ludCxcbiAgICAgICAgICAgIGxpbmtWaWV3LnRhcmdldFBvaW50LFxuICAgICAgICAgICAgbGlua1ZpZXcucm91dGVcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHRyYW5zZm9ybSBsaW5lcyBmb3IgdGhpcyBsaW5rIGJ5IHNwbGl0dGluZyB3aXRoIGp1bXAgbGluZXMgYXRcbiAgICAvLyBwb2ludHMgb2YgaW50ZXJzZWN0aW9uIHdpdGggb3RoZXIgbGlua3NcbiAgICB2YXIganVtcGluZ0xpbmVzID0gdGhpc0xpbmVzLnJlZHVjZShmdW5jdGlvbihyZXN1bHRMaW5lcywgdGhpc0xpbmUpIHtcbiAgICAgICAgLy8gaXRlcmF0ZSBhbGwgbGlua3MgYW5kIGdyYWIgdGhlIGludGVyc2VjdGlvbnMgd2l0aCB0aGlzIGxpbmVcbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZW4gc29ydGVkIGJ5IGRpc3RhbmNlIHNvIHRoZSBsaW5lIGNhbiBiZSBzcGxpdCBtb3JlIGVhc2lseVxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IGxpbmtzLnJlZHVjZShmdW5jdGlvbihyZXMsIGxpbmssIGkpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGludGVyc2VjdGlvbiB3aXRoIGl0c2VsZlxuICAgICAgICAgICAgaWYgKGxpbmsgIT09IHRoaXNNb2RlbCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbGlua0xpbmVzVG9UZXN0ID0gbGlua0xpbmVzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcEluZGV4ID0gbGlua0xpbmVzVG9UZXN0LmZpbmRJbmRleCgobGluZSkgPT4gb3ZlcmxhcEV4aXN0cyh0aGlzTGluZSwgbGluZSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3ZlcmxhcCBvY2N1cnMgYW5kIHRoZSBlbmQgcG9pbnQgb2Ygb25lIHNlZ21lbnQgbGllcyBvbiB0aGlzTGluZVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwSW5kZXggPiAtMSAmJiB0aGlzTGluZS5jb250YWluc1BvaW50KGxpbmtMaW5lc1RvVGVzdFtvdmVybGFwSW5kZXhdLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBuZXh0IHNlZ21lbnQgYmVjYXVzZSB0aGVyZSB3aWxsIG5ldmVyIGJlIGEganVtcFxuICAgICAgICAgICAgICAgICAgICBsaW5rTGluZXNUb1Rlc3Quc3BsaWNlKG92ZXJsYXBJbmRleCArIDEsIDEpO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUludGVyc2VjdGlvbnMgPSBmaW5kTGluZUludGVyc2VjdGlvbnModGhpc0xpbmUsIGxpbmtMaW5lc1RvVGVzdCk7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBsaW5lSW50ZXJzZWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydFBvaW50cyh0aGlzTGluZS5zdGFydCwgYSkgLSBzb3J0UG9pbnRzKHRoaXNMaW5lLnN0YXJ0LCBiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgdGhlIGxpbmUgYmFzZWQgb24gZm91bmQgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaC5hcHBseShyZXN1bHRMaW5lcywgY3JlYXRlSnVtcHModGhpc0xpbmUsIGludGVyc2VjdGlvbnMsIGp1bXBTaXplKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aXRob3V0IGFueSBpbnRlcnNlY3Rpb24gdGhlIGxpbmUgZ29lcyB1bmludGVycnVwdGVkXG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXNMaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgfSwgW10pO1xuXG4gICAgdmFyIHBhdGggPSBidWlsZFBhdGgoanVtcGluZ0xpbmVzLCBqdW1wU2l6ZSwganVtcFR5cGUsIHJhZGl1cyk7XG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJnIiwiSlVNUF9TSVpFIiwiSlVNUF9UWVBFUyIsIlJBRElVUyIsIkNMT1NFX1BST1hJTUlUWV9QQURESU5HIiwiSUdOT1JFRF9DT05ORUNUT1JTIiwiXzEzIiwiXzIzIiwic29ydFBvaW50c0FzY2VuZGluZyIsInAxIiwicDIiLCJ4IiwieDEiLCJ5IiwieTEiLCJ4MiIsInkyIiwic3dhcCIsIlBvaW50Iiwib3ZlcmxhcEV4aXN0cyIsImxpbmUxIiwibGluZTIiLCJzdGFydCIsImVuZCIsIngzIiwieTMiLCJ4NCIsInk0IiwieE1hdGNoIiwieU1hdGNoIiwiY3JlYXRlTGluZXMiLCJzb3VyY2VQb2ludCIsInRhcmdldFBvaW50Iiwicm91dGUiLCJwb2ludHMiLCJjb25jYXQiLCJyZWR1Y2UiLCJyZXN1bHRMaW5lcyIsInBvaW50IiwiaWR4IiwibmV4dFBvaW50IiwibGluZSIsInNldHVwVXBkYXRpbmciLCJqdW1wT3ZlckxpbmtWaWV3IiwicGFwZXIiLCJ1cGRhdGVMaXN0IiwiX2p1bXBPdmVyVXBkYXRlTGlzdCIsImdyYXBoIiwibW9kZWwiLCJvbiIsImhhc0FjdGl2ZUJhdGNoIiwidXBkYXRlSnVtcE92ZXIiLCJpbmRleE9mIiwicHVzaCIsImxpc3RlblRvT25jZSIsInNwbGljZSIsImkiLCJsZW5ndGgiLCJsaW5rVmlldyIsInVwZGF0ZUZsYWciLCJnZXRGbGFnIiwiY29uc3RydWN0b3IiLCJGbGFncyIsIkNPTk5FQ1RPUiIsInJlcXVlc3RVcGRhdGUiLCJmaW5kTGluZUludGVyc2VjdGlvbnMiLCJjcm9zc0NoZWNrTGluZXMiLCJ0b0FycmF5IiwicmVzIiwiY3Jvc3NDaGVja0xpbmUiLCJpbnRlcnNlY3Rpb24iLCJzb3J0UG9pbnRzIiwic3F1YXJlZExlbmd0aCIsImNyZWF0ZUp1bXBzIiwiaW50ZXJzZWN0aW9ucyIsImp1bXBTaXplIiwic2tpcCIsImxhc3RMaW5lIiwicG9wIiwianVtcFN0YXJ0IiwibW92ZSIsImp1bXBFbmQiLCJkaXN0YW5jZSIsImVuZERpc3RhbmNlIiwic3RhcnREaXN0YW5jZSIsImp1bXBMaW5lIiwiaXNKdW1wIiwiYnVpbGRQYXRoIiwibGluZXMiLCJqdW1wVHlwZSIsInJhZGl1cyIsInBhdGgiLCJQYXRoIiwic2VnbWVudCIsImNyZWF0ZVNlZ21lbnQiLCJhcHBlbmRTZWdtZW50IiwiZm9yRWFjaCIsImluZGV4IiwiYW5nbGUiLCJkaWZmIiwiY29udHJvbDEiLCJjb250cm9sMiIsImRpZmZlcmVuY2UiLCJ4QXhpc1JvdGF0ZSIsIk51bWJlciIsIm1pZHBvaW50IiwiY2VudGVyTGluZSIsIkxpbmUiLCJyb3RhdGUiLCJoYWxmTGluZSIsInBvaW50QXQiLCJ0aGV0YSIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwibmV4dExpbmUiLCJidWlsZFJvdW5kZWRTZWdtZW50Iiwib2Zmc2V0IiwiY3VyciIsInByZXYiLCJuZXh0IiwicHJldkRpc3RhbmNlIiwibmV4dERpc3RhbmNlIiwic3RhcnRNb3ZlIiwiTWF0aCIsIm1pbiIsImVuZE1vdmUiLCJyb3VuZGVkU3RhcnQiLCJjbG9uZSIsInJvdW5kIiwicm91bmRlZEVuZCIsImp1bXBvdmVyIiwib3B0IiwicmF3Iiwic2l6ZSIsImp1bXAiLCJ0b0xvd2VyQ2FzZSIsImlnbm9yZUNvbm5lY3RvcnMiLCJhbGxMaW5rcyIsImdldExpbmtzIiwidGhpc01vZGVsIiwidGhpc0luZGV4IiwiZGVmYXVsdENvbm5lY3RvciIsIm9wdGlvbnMiLCJsaW5rcyIsImZpbHRlciIsImxpbmsiLCJjb25uZWN0b3IiLCJnZXQiLCJpbmNsdWRlcyIsIm5hbWUiLCJsaW5rVmlld3MiLCJtYXAiLCJmaW5kVmlld0J5TW9kZWwiLCJ0aGlzTGluZXMiLCJsaW5rTGluZXMiLCJqdW1waW5nTGluZXMiLCJ0aGlzTGluZSIsImxpbmtMaW5lc1RvVGVzdCIsInNsaWNlIiwib3ZlcmxhcEluZGV4IiwiZmluZEluZGV4IiwiY29udGFpbnNQb2ludCIsImxpbmVJbnRlcnNlY3Rpb25zIiwiYXBwbHkiLCJzb3J0IiwiYSIsImIiLCJzZXJpYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/jumpover.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/normal.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/normal.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: () => (/* binding */ normal)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/straight.mjs\");\n\nconst normal = function(sourcePoint, targetPoint, route = [], opt = {}) {\n    const { raw } = opt;\n    const localOpt = {\n        cornerType: \"point\",\n        raw\n    };\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9ub3JtYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBRW5DLE1BQU1DLFNBQVMsU0FBU0MsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBRSxFQUFFQyxNQUFNLENBQUMsQ0FBQztJQUV6RSxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHRDtJQUNoQixNQUFNRSxXQUFXO1FBQ2JDLFlBQVk7UUFDWkY7SUFDSjtJQUVBLE9BQU9OLHVEQUFRQSxDQUFDRSxhQUFhQyxhQUFhQyxPQUFPRztBQUNyRCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9ub3JtYWwubWpzP2U5MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyYWlnaHQgfSBmcm9tICcuL3N0cmFpZ2h0Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBub3JtYWwgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlID0gW10sIG9wdCA9IHt9KSB7XG5cbiAgICBjb25zdCB7IHJhdyB9ID0gb3B0O1xuICAgIGNvbnN0IGxvY2FsT3B0ID0ge1xuICAgICAgICBjb3JuZXJUeXBlOiAncG9pbnQnLFxuICAgICAgICByYXdcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmFpZ2h0KHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIGxvY2FsT3B0KTtcbn07XG4iXSwibmFtZXMiOlsic3RyYWlnaHQiLCJub3JtYWwiLCJzb3VyY2VQb2ludCIsInRhcmdldFBvaW50Iiwicm91dGUiLCJvcHQiLCJyYXciLCJsb2NhbE9wdCIsImNvcm5lclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/normal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/rounded.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/rounded.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rounded: () => (/* binding */ rounded)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/straight.mjs\");\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 0;\nconst rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {\n    const { radius = CORNER_RADIUS, raw } = opt;\n    const localOpt = {\n        cornerType: \"cubic\",\n        cornerRadius: radius,\n        precision: PRECISION,\n        raw\n    };\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9yb3VuZGVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUUxQyxNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsWUFBWTtBQUVYLE1BQU1DLFVBQVUsU0FBU0MsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBRSxFQUFFQyxNQUFNLENBQUMsQ0FBQztJQUUxRSxNQUFNLEVBQUVDLFNBQVNQLGFBQWEsRUFBRVEsR0FBRyxFQUFFLEdBQUdGO0lBQ3hDLE1BQU1HLFdBQVc7UUFDYkMsWUFBWTtRQUNaQyxjQUFjSjtRQUNkSyxXQUFXWDtRQUNYTztJQUNKO0lBRUEsT0FBT1QsdURBQVFBLENBQUNJLGFBQWFDLGFBQWFDLE9BQU9JO0FBQ3JELEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9jb25uZWN0b3JzL3JvdW5kZWQubWpzPzY2ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyYWlnaHQgfSBmcm9tICcuL3N0cmFpZ2h0Lm1qcyc7XG5cbmNvbnN0IENPUk5FUl9SQURJVVMgPSAxMDtcbmNvbnN0IFBSRUNJU0lPTiA9IDA7XG5cbmV4cG9ydCBjb25zdCByb3VuZGVkID0gZnVuY3Rpb24oc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSA9IFtdLCBvcHQgPSB7fSkge1xuXG4gICAgY29uc3QgeyByYWRpdXMgPSBDT1JORVJfUkFESVVTLCByYXcgfSA9IG9wdDtcbiAgICBjb25zdCBsb2NhbE9wdCA9IHtcbiAgICAgICAgY29ybmVyVHlwZTogJ2N1YmljJyxcbiAgICAgICAgY29ybmVyUmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHByZWNpc2lvbjogUFJFQ0lTSU9OLFxuICAgICAgICByYXdcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmFpZ2h0KHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIGxvY2FsT3B0KTtcbn07XG4iXSwibmFtZXMiOlsic3RyYWlnaHQiLCJDT1JORVJfUkFESVVTIiwiUFJFQ0lTSU9OIiwicm91bmRlZCIsInNvdXJjZVBvaW50IiwidGFyZ2V0UG9pbnQiLCJyb3V0ZSIsIm9wdCIsInJhZGl1cyIsInJhdyIsImxvY2FsT3B0IiwiY29ybmVyVHlwZSIsImNvcm5lclJhZGl1cyIsInByZWNpc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/rounded.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/smooth.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/smooth.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   smooth: () => (/* binding */ smooth)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/curve.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n\nconst smooth = function(sourcePoint, targetPoint, route, opt) {\n    var raw = opt && opt.raw;\n    var path;\n    if (route && route.length !== 0) {\n        var points = [\n            sourcePoint\n        ].concat(route).concat([\n            targetPoint\n        ]);\n        var curves = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Curve.throughPoints(points);\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(curves);\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n        var segment;\n        segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"M\", sourcePoint);\n        path.appendSegment(segment);\n        if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"C\", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"C\", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n        }\n    }\n    return raw ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9zbW9vdGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUU3QixNQUFNQyxTQUFTLFNBQVNDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLEdBQUc7SUFFL0QsSUFBSUMsTUFBTUQsT0FBT0EsSUFBSUMsR0FBRztJQUN4QixJQUFJQztJQUVKLElBQUlILFNBQVNBLE1BQU1JLE1BQU0sS0FBSyxHQUFHO1FBRTdCLElBQUlDLFNBQVM7WUFBQ1A7U0FBWSxDQUFDUSxNQUFNLENBQUNOLE9BQU9NLE1BQU0sQ0FBQztZQUFDUDtTQUFZO1FBQzdELElBQUlRLFNBQVNYLCtDQUFPLENBQUNhLGFBQWEsQ0FBQ0o7UUFFbkNGLE9BQU8sSUFBSVAsOENBQU0sQ0FBQ1c7SUFFdEIsT0FBTztRQUNILHdEQUF3RDtRQUN4RCwyQ0FBMkM7UUFDM0MsK0RBQStEO1FBQy9ELGdDQUFnQztRQUVoQ0osT0FBTyxJQUFJUCw4Q0FBTTtRQUVqQixJQUFJZTtRQUVKQSxVQUFVZiw4Q0FBTSxDQUFDZ0IsYUFBYSxDQUFDLEtBQUtkO1FBQ3BDSyxLQUFLVSxhQUFhLENBQUNGO1FBRW5CLElBQUksS0FBTUksR0FBRyxDQUFDakIsWUFBWWtCLENBQUMsR0FBR2pCLFlBQVlpQixDQUFDLEtBQU9GLEtBQUtDLEdBQUcsQ0FBQ2pCLFlBQVltQixDQUFDLEdBQUdsQixZQUFZa0IsQ0FBQyxHQUFJO1lBQ3hGLElBQUlDLGdCQUFnQixDQUFDcEIsWUFBWWtCLENBQUMsR0FBR2pCLFlBQVlpQixDQUFDLElBQUk7WUFFdERMLFVBQVVmLDhDQUFNLENBQUNnQixhQUFhLENBQUMsS0FBS00sZUFBZXBCLFlBQVltQixDQUFDLEVBQUVDLGVBQWVuQixZQUFZa0IsQ0FBQyxFQUFFbEIsWUFBWWlCLENBQUMsRUFBRWpCLFlBQVlrQixDQUFDO1lBQzVIZCxLQUFLVSxhQUFhLENBQUNGO1FBRXZCLE9BQU87WUFDSCxJQUFJUSxnQkFBZ0IsQ0FBQ3JCLFlBQVltQixDQUFDLEdBQUdsQixZQUFZa0IsQ0FBQyxJQUFJO1lBRXRETixVQUFVZiw4Q0FBTSxDQUFDZ0IsYUFBYSxDQUFDLEtBQUtkLFlBQVlrQixDQUFDLEVBQUVHLGVBQWVwQixZQUFZaUIsQ0FBQyxFQUFFRyxlQUFlcEIsWUFBWWlCLENBQUMsRUFBRWpCLFlBQVlrQixDQUFDO1lBQzVIZCxLQUFLVSxhQUFhLENBQUNGO1FBRXZCO0lBQ0o7SUFFQSxPQUFPLE1BQVFSLE9BQU9BLEtBQUtpQixTQUFTO0FBQ3hDLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9jb25uZWN0b3JzL3Ntb290aC5tanM/MmFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IHNtb290aCA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIG9wdCkge1xuXG4gICAgdmFyIHJhdyA9IG9wdCAmJiBvcHQucmF3O1xuICAgIHZhciBwYXRoO1xuXG4gICAgaWYgKHJvdXRlICYmIHJvdXRlLmxlbmd0aCAhPT0gMCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbc291cmNlUG9pbnRdLmNvbmNhdChyb3V0ZSkuY29uY2F0KFt0YXJnZXRQb2ludF0pO1xuICAgICAgICB2YXIgY3VydmVzID0gZy5DdXJ2ZS50aHJvdWdoUG9pbnRzKHBvaW50cyk7XG5cbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgoY3VydmVzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gcm91dGUsIHVzZSBhIGRlZmF1bHQgY3ViaWMgYmV6aWVyIGN1cnZlXG4gICAgICAgIC8vIGN1YmljIGJlemllciByZXF1aXJlcyB0d28gY29udHJvbCBwb2ludHNcbiAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnRzIGhhdmUgYHhgIG1pZHdheSBiZXR3ZWVuIHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgICAgIC8vIHRoaXMgcHJvZHVjZXMgYW4gUy1saWtlIGN1cnZlXG5cbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgoKTtcblxuICAgICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBzb3VyY2VQb2ludCk7XG4gICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICBpZiAoKE1hdGguYWJzKHNvdXJjZVBvaW50LnggLSB0YXJnZXRQb2ludC54KSkgPj0gKE1hdGguYWJzKHNvdXJjZVBvaW50LnkgLSB0YXJnZXRQb2ludC55KSkpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRYID0gKHNvdXJjZVBvaW50LnggKyB0YXJnZXRQb2ludC54KSAvIDI7XG5cbiAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2xQb2ludFgsIHNvdXJjZVBvaW50LnksIGNvbnRyb2xQb2ludFgsIHRhcmdldFBvaW50LnksIHRhcmdldFBvaW50LngsIHRhcmdldFBvaW50LnkpO1xuICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFBvaW50WSA9IChzb3VyY2VQb2ludC55ICsgdGFyZ2V0UG9pbnQueSkgLyAyO1xuXG4gICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBzb3VyY2VQb2ludC54LCBjb250cm9sUG9pbnRZLCB0YXJnZXRQb2ludC54LCBjb250cm9sUG9pbnRZLCB0YXJnZXRQb2ludC54LCB0YXJnZXRQb2ludC55KTtcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuIl0sIm5hbWVzIjpbImciLCJzbW9vdGgiLCJzb3VyY2VQb2ludCIsInRhcmdldFBvaW50Iiwicm91dGUiLCJvcHQiLCJyYXciLCJwYXRoIiwibGVuZ3RoIiwicG9pbnRzIiwiY29uY2F0IiwiY3VydmVzIiwiQ3VydmUiLCJ0aHJvdWdoUG9pbnRzIiwiUGF0aCIsInNlZ21lbnQiLCJjcmVhdGVTZWdtZW50IiwiYXBwZW5kU2VnbWVudCIsIk1hdGgiLCJhYnMiLCJ4IiwieSIsImNvbnRyb2xQb2ludFgiLCJjb250cm9sUG9pbnRZIiwic2VyaWFsaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/smooth.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/connectors/straight.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/jointjs/src/connectors/straight.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   straight: () => (/* binding */ straight)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n\nconst CornerTypes = {\n    POINT: \"point\",\n    CUBIC: \"cubic\",\n    LINE: \"line\",\n    GAP: \"gap\"\n};\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\nconst straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n    const { cornerType = CornerTypes.POINT, cornerRadius = CORNER_RADIUS, cornerPreserveAspectRatio = false, precision = PRECISION, raw = false } = opt;\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error(\"Invalid `cornerType` provided to `straight` connector.\");\n    }\n    let path;\n    if (cornerType === CornerTypes.POINT || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [\n            sourcePoint\n        ].concat(routePoints).concat([\n            targetPoint\n        ]);\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(polyline);\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n        // add initial gap segment = to source point\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"M\", sourcePoint));\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for(let i = 0; i < routePointsLength; i++){\n            const curr = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(routePoints[i]);\n            const prev = routePoints[i - 1] || sourcePoint;\n            const next = routePoints[i + 1] || targetPoint;\n            const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`\n            nextDistance = curr.distance(next) / 2;\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"L\", cornerStart));\n            // add corner segment = from corner start point to corner end point\n            switch(cornerType){\n                case CornerTypes.CUBIC:\n                    {\n                        // corner is rounded\n                        const _13 = 1 / 3;\n                        const _23 = 2 / 3;\n                        const control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);\n                        const control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);\n                        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"C\", control1, control2, cornerEnd));\n                        break;\n                    }\n                case CornerTypes.LINE:\n                    {\n                        // corner has bevel\n                        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"L\", cornerEnd));\n                        break;\n                    }\n                case CornerTypes.GAP:\n                    {\n                        // corner has empty space\n                        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"M\", cornerEnd));\n                        break;\n                    }\n            }\n        }\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment(\"L\", targetPoint));\n    }\n    return raw ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvY29ubmVjdG9ycy9zdHJhaWdodC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvQztBQUVwQyxNQUFNQyxjQUFjO0lBQ2hCQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxLQUFLO0FBQ1Q7QUFFQSxNQUFNQyx1QkFBdUJDLE9BQU9DLE1BQU0sQ0FBQ1A7QUFFM0MsTUFBTVEsZ0JBQWdCO0FBQ3RCLE1BQU1DLFlBQVk7QUFFWCxNQUFNQyxXQUFXLFNBQVNDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxjQUFjLEVBQUUsRUFBRUMsTUFBTSxDQUFDLENBQUM7SUFFakYsTUFBTSxFQUNGQyxhQUFhZixZQUFZQyxLQUFLLEVBQzlCZSxlQUFlUixhQUFhLEVBQzVCUyw0QkFBNEIsS0FBSyxFQUNqQ0MsWUFBWVQsU0FBUyxFQUNyQlUsTUFBTSxLQUFLLEVBQ2QsR0FBR0w7SUFFSixJQUFJVCxxQkFBcUJlLE9BQU8sQ0FBQ0wsZ0JBQWdCLENBQUMsR0FBRztRQUNqRCx5Q0FBeUM7UUFDekMsTUFBTSxJQUFJTSxNQUFNO0lBQ3BCO0lBRUEsSUFBSUM7SUFFSixJQUFJLGVBQWdCdEIsWUFBWUMsS0FBSyxJQUFLLENBQUNlLGNBQWM7UUFDckQscUNBQXFDO1FBQ3JDLGdEQUFnRDtRQUNoRCxNQUFNTyxTQUFTO1lBQUNaO1NBQVksQ0FBQ2EsTUFBTSxDQUFDWCxhQUFhVyxNQUFNLENBQUM7WUFBQ1o7U0FBWTtRQUNyRSxNQUFNYSxXQUFXLElBQUkxQixrREFBVSxDQUFDd0I7UUFDaENELE9BQU8sSUFBSXZCLDhDQUFNLENBQUMwQjtJQUV0QixPQUFPO1FBQ0gsNEZBQTRGO1FBQzVGSCxPQUFPLElBQUl2Qiw4Q0FBTTtRQUVqQiw0Q0FBNEM7UUFDNUN1QixLQUFLTSxhQUFhLENBQUM3Qiw4Q0FBTSxDQUFDOEIsYUFBYSxDQUFDLEtBQUtsQjtRQUU3QyxJQUFJbUI7UUFDSixNQUFNQyxvQkFBb0JsQixZQUFZbUIsTUFBTTtRQUM1QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsbUJBQW1CRSxJQUFLO1lBRXhDLE1BQU1DLE9BQU8sSUFBSW5DLCtDQUFPLENBQUNjLFdBQVcsQ0FBQ29CLEVBQUU7WUFDdkMsTUFBTUcsT0FBUXZCLFdBQVcsQ0FBQ29CLElBQUksRUFBRSxJQUFJdEI7WUFDcEMsTUFBTTBCLE9BQVF4QixXQUFXLENBQUNvQixJQUFJLEVBQUUsSUFBSXJCO1lBQ3BDLE1BQU0wQixlQUFnQlIsZ0JBQWlCSSxLQUFLSyxRQUFRLENBQUNILFFBQVEsR0FBSyxtREFBbUQ7WUFDckhOLGVBQWdCSSxLQUFLSyxRQUFRLENBQUNGLFFBQVE7WUFFdEMsSUFBSUcsV0FBV0M7WUFDZixJQUFJLENBQUN4QiwyQkFBMkI7Z0JBQzVCLDZDQUE2QztnQkFDN0Msb0ZBQW9GO2dCQUNwRnVCLFlBQVksQ0FBQ0UsS0FBS0MsR0FBRyxDQUFDM0IsY0FBY3NCO2dCQUNwQ0csVUFBVSxDQUFDQyxLQUFLQyxHQUFHLENBQUMzQixjQUFjYztZQUN0QyxPQUFPO2dCQUNILGlEQUFpRDtnQkFDakRVLFlBQVlDLFVBQVUsQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDM0IsY0FBY3NCLGNBQWNSO1lBQ2hFO1lBRUEsbUdBQW1HO1lBQ25HLG1FQUFtRTtZQUNuRSxvRUFBb0U7WUFDcEUsd0RBQXdEO1lBQ3hELE1BQU1jLGNBQWNWLEtBQUtXLEtBQUssR0FBR0MsSUFBSSxDQUFDVixNQUFNSSxXQUFXTyxLQUFLLENBQUM3QjtZQUM3RCxNQUFNOEIsWUFBWWQsS0FBS1csS0FBSyxHQUFHQyxJQUFJLENBQUNULE1BQU1JLFNBQVNNLEtBQUssQ0FBQzdCO1lBRXpELG9GQUFvRjtZQUNwRix5QkFBeUI7WUFDekJJLEtBQUtNLGFBQWEsQ0FBQzdCLDhDQUFNLENBQUM4QixhQUFhLENBQUMsS0FBS2U7WUFFN0MsbUVBQW1FO1lBQ25FLE9BQVE3QjtnQkFDSixLQUFLZixZQUFZRSxLQUFLO29CQUFFO3dCQUNwQixvQkFBb0I7d0JBQ3BCLE1BQU0rQyxNQUFPLElBQUk7d0JBQ2pCLE1BQU1DLE1BQU8sSUFBSTt3QkFDakIsTUFBTUMsV0FBVyxJQUFJcEQsK0NBQU8sQ0FBQyxNQUFPNkMsWUFBWVEsQ0FBQyxHQUFLRixNQUFNaEIsS0FBS2tCLENBQUMsRUFBRyxNQUFPbEIsS0FBS21CLENBQUMsR0FBS0osTUFBTUwsWUFBWVMsQ0FBQzt3QkFDMUcsTUFBTUMsV0FBVyxJQUFJdkQsK0NBQU8sQ0FBQyxNQUFPaUQsVUFBVUksQ0FBQyxHQUFLRixNQUFNaEIsS0FBS2tCLENBQUMsRUFBRyxNQUFPbEIsS0FBS21CLENBQUMsR0FBS0osTUFBTUQsVUFBVUssQ0FBQzt3QkFDdEcvQixLQUFLTSxhQUFhLENBQUM3Qiw4Q0FBTSxDQUFDOEIsYUFBYSxDQUFDLEtBQUtzQixVQUFVRyxVQUFVTjt3QkFDakU7b0JBQ0o7Z0JBQ0EsS0FBS2hELFlBQVlHLElBQUk7b0JBQUU7d0JBQ25CLG1CQUFtQjt3QkFDbkJtQixLQUFLTSxhQUFhLENBQUM3Qiw4Q0FBTSxDQUFDOEIsYUFBYSxDQUFDLEtBQUttQjt3QkFDN0M7b0JBQ0o7Z0JBQ0EsS0FBS2hELFlBQVlJLEdBQUc7b0JBQUU7d0JBQ2xCLHlCQUF5Qjt3QkFDekJrQixLQUFLTSxhQUFhLENBQUM3Qiw4Q0FBTSxDQUFDOEIsYUFBYSxDQUFDLEtBQUttQjt3QkFDN0M7b0JBQ0o7WUFFSjtRQUNKO1FBRUEsMEVBQTBFO1FBQzFFLHFFQUFxRTtRQUNyRSx5QkFBeUI7UUFDekIxQixLQUFLTSxhQUFhLENBQUM3Qiw4Q0FBTSxDQUFDOEIsYUFBYSxDQUFDLEtBQUtqQjtJQUNqRDtJQUVBLE9BQVEsTUFBUVUsT0FBT0EsS0FBS2lDLFNBQVM7QUFDekMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2Nvbm5lY3RvcnMvc3RyYWlnaHQubWpzP2UzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmNvbnN0IENvcm5lclR5cGVzID0ge1xuICAgIFBPSU5UOiAncG9pbnQnLFxuICAgIENVQklDOiAnY3ViaWMnLFxuICAgIExJTkU6ICdsaW5lJyxcbiAgICBHQVA6ICdnYXAnXG59O1xuXG5jb25zdCBERUZJTkVEX0NPUk5FUl9UWVBFUyA9IE9iamVjdC52YWx1ZXMoQ29ybmVyVHlwZXMpO1xuXG5jb25zdCBDT1JORVJfUkFESVVTID0gMTA7XG5jb25zdCBQUkVDSVNJT04gPSAxO1xuXG5leHBvcnQgY29uc3Qgc3RyYWlnaHQgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlUG9pbnRzID0gW10sIG9wdCA9IHt9KSB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNvcm5lclR5cGUgPSBDb3JuZXJUeXBlcy5QT0lOVCxcbiAgICAgICAgY29ybmVyUmFkaXVzID0gQ09STkVSX1JBRElVUyxcbiAgICAgICAgY29ybmVyUHJlc2VydmVBc3BlY3RSYXRpbyA9IGZhbHNlLFxuICAgICAgICBwcmVjaXNpb24gPSBQUkVDSVNJT04sXG4gICAgICAgIHJhdyA9IGZhbHNlXG4gICAgfSA9IG9wdDtcblxuICAgIGlmIChERUZJTkVEX0NPUk5FUl9UWVBFUy5pbmRleE9mKGNvcm5lclR5cGUpID09PSAtMSkge1xuICAgICAgICAvLyB1bmtub3duIGBjb3JuZXJUeXBlYCBwcm92aWRlZCA9PiBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYGNvcm5lclR5cGVgIHByb3ZpZGVkIHRvIGBzdHJhaWdodGAgY29ubmVjdG9yLicpO1xuICAgIH1cblxuICAgIGxldCBwYXRoO1xuXG4gICAgaWYgKChjb3JuZXJUeXBlID09PSBDb3JuZXJUeXBlcy5QT0lOVCkgfHwgIWNvcm5lclJhZGl1cykge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbiA9PiBub3JtYWwgY29ubmVjdG9yXG4gICAgICAgIC8vIHNpbXBseSBjb25uZWN0IGFsbCBwb2ludHMgd2l0aCBzdHJhaWdodCBsaW5lc1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbc291cmNlUG9pbnRdLmNvbmNhdChyb3V0ZVBvaW50cykuY29uY2F0KFt0YXJnZXRQb2ludF0pO1xuICAgICAgICBjb25zdCBwb2x5bGluZSA9IG5ldyBnLlBvbHlsaW5lKHBvaW50cyk7XG4gICAgICAgIHBhdGggPSBuZXcgZy5QYXRoKHBvbHlsaW5lKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGBjb3JuZXJUeXBlYCBpcyBub3QgdW5rbm93biBhbmQgbm90ICdwb2ludCcgKGRlZmF1bHQpID0+IG11c3QgYmUgb25lIG9mIG90aGVyIHZhbGlkIHR5cGVzXG4gICAgICAgIHBhdGggPSBuZXcgZy5QYXRoKCk7XG5cbiAgICAgICAgLy8gYWRkIGluaXRpYWwgZ2FwIHNlZ21lbnQgPSB0byBzb3VyY2UgcG9pbnRcbiAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgc291cmNlUG9pbnQpKTtcblxuICAgICAgICBsZXQgbmV4dERpc3RhbmNlO1xuICAgICAgICBjb25zdCByb3V0ZVBvaW50c0xlbmd0aCA9IHJvdXRlUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZVBvaW50c0xlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBuZXcgZy5Qb2ludChyb3V0ZVBvaW50c1tpXSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gKHJvdXRlUG9pbnRzW2kgLSAxXSB8fCBzb3VyY2VQb2ludCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKHJvdXRlUG9pbnRzW2kgKyAxXSB8fCB0YXJnZXRQb2ludCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2RGlzdGFuY2UgPSAobmV4dERpc3RhbmNlIHx8IChjdXJyLmRpc3RhbmNlKHByZXYpIC8gMikpOyAvLyB0cnkgdG8gcmUtdXNlIHByZXZpb3VzbHktY29tcHV0ZWQgYG5leHREaXN0YW5jZWBcbiAgICAgICAgICAgIG5leHREaXN0YW5jZSA9IChjdXJyLmRpc3RhbmNlKG5leHQpIC8gMik7XG5cbiAgICAgICAgICAgIGxldCBzdGFydE1vdmUsIGVuZE1vdmU7XG4gICAgICAgICAgICBpZiAoIWNvcm5lclByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICAvLyBgc3RhcnRNb3ZlYCBhbmQgYGVuZE1vdmVgIG1heSBiZSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAvLyAodGhpcyBoYXBwZW5zIHdoZW4gbmV4dCBvciBwcmV2aW91cyBwYXRoIHBvaW50IGlzIGNsb3NlciB0aGFuIGAyICogY29ybmVyUmFkaXVzYClcbiAgICAgICAgICAgICAgICBzdGFydE1vdmUgPSAtTWF0aC5taW4oY29ybmVyUmFkaXVzLCBwcmV2RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGVuZE1vdmUgPSAtTWF0aC5taW4oY29ybmVyUmFkaXVzLCBuZXh0RGlzdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBgc3RhcnRNb3ZlYCBhbmQgYGVuZE1vdmVgIHRvIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgc3RhcnRNb3ZlID0gZW5kTW92ZSA9IC1NYXRoLm1pbihjb3JuZXJSYWRpdXMsIHByZXZEaXN0YW5jZSwgbmV4dERpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdG8gZmluZCBgY29ybmVyU3RhcnRgIGFuZCBgY29ybmVyRW5kYCwgdGhlIGxvZ2ljIGlzIGFzIGZvbGxvd3MgKHVzaW5nIGBjb3JuZXJTdGFydGAgYXMgZXhhbXBsZSk6XG4gICAgICAgICAgICAvLyAtIGZpbmQgYSBwb2ludCBseWluZyBvbiB0aGUgbGluZSBgcHJldiAtIHN0YXJ0TW92ZWAgc3VjaCB0aGF0Li4uXG4gICAgICAgICAgICAvLyAtIC4uLnRoZSBwb2ludCBsaWVzIGBhYnMoc3RhcnRNb3ZlKWAgZGlzdGFuY2UgYXdheSBmcm9tIGBjdXJyYC4uLlxuICAgICAgICAgICAgLy8gLSAuLi5hbmQgaXRzIGNvb3JkaW5hdGVzIGFyZSByb3VuZGVkIHRvIHdob2xlIG51bWJlcnNcbiAgICAgICAgICAgIGNvbnN0IGNvcm5lclN0YXJ0ID0gY3Vyci5jbG9uZSgpLm1vdmUocHJldiwgc3RhcnRNb3ZlKS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICAgICAgY29uc3QgY29ybmVyRW5kID0gY3Vyci5jbG9uZSgpLm1vdmUobmV4dCwgZW5kTW92ZSkucm91bmQocHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgLy8gYWRkIGluLWJldHdlZW4gc3RyYWlnaHQgc2VnbWVudCA9IGZyb20gcHJldmlvdXMgcm91dGUgcG9pbnQgdG8gY29ybmVyIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAvLyAobWF5IGhhdmUgemVybyBsZW5ndGgpXG4gICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBjb3JuZXJTdGFydCkpO1xuXG4gICAgICAgICAgICAvLyBhZGQgY29ybmVyIHNlZ21lbnQgPSBmcm9tIGNvcm5lciBzdGFydCBwb2ludCB0byBjb3JuZXIgZW5kIHBvaW50XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvcm5lclR5cGVzLkNVQklDOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcm5lciBpcyByb3VuZGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF8xMyA9ICgxIC8gMyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF8yMyA9ICgyIC8gMyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wxID0gbmV3IGcuUG9pbnQoKF8xMyAqIGNvcm5lclN0YXJ0LngpICsgKF8yMyAqIGN1cnIueCksIChfMjMgKiBjdXJyLnkpICsgKF8xMyAqIGNvcm5lclN0YXJ0LnkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJvbDIgPSBuZXcgZy5Qb2ludCgoXzEzICogY29ybmVyRW5kLngpICsgKF8yMyAqIGN1cnIueCksIChfMjMgKiBjdXJyLnkpICsgKF8xMyAqIGNvcm5lckVuZC55KSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2wxLCBjb250cm9sMiwgY29ybmVyRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvcm5lclR5cGVzLkxJTkU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ybmVyIGhhcyBiZXZlbFxuICAgICAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBjb3JuZXJFbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQ29ybmVyVHlwZXMuR0FQOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcm5lciBoYXMgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgY29ybmVyRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBubyBzZWdtZW50IGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBmaW5hbCBzdHJhaWdodCBzZWdtZW50ID0gZnJvbSBsYXN0IGNvcm5lciBlbmQgcG9pbnQgdG8gdGFyZ2V0IHBvaW50XG4gICAgICAgIC8vICg9IG9yIGZyb20gc3RhcnQgcG9pbnQgdG8gZW5kIHBvaW50LCBpZiB0aGVyZSBhcmUgbm8gcm91dGUgcG9pbnRzKVxuICAgICAgICAvLyAobWF5IGhhdmUgemVybyBsZW5ndGgpXG4gICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnTCcsIHRhcmdldFBvaW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgocmF3KSA/IHBhdGggOiBwYXRoLnNlcmlhbGl6ZSgpKTtcbn07XG4iXSwibmFtZXMiOlsiZyIsIkNvcm5lclR5cGVzIiwiUE9JTlQiLCJDVUJJQyIsIkxJTkUiLCJHQVAiLCJERUZJTkVEX0NPUk5FUl9UWVBFUyIsIk9iamVjdCIsInZhbHVlcyIsIkNPUk5FUl9SQURJVVMiLCJQUkVDSVNJT04iLCJzdHJhaWdodCIsInNvdXJjZVBvaW50IiwidGFyZ2V0UG9pbnQiLCJyb3V0ZVBvaW50cyIsIm9wdCIsImNvcm5lclR5cGUiLCJjb3JuZXJSYWRpdXMiLCJjb3JuZXJQcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJlY2lzaW9uIiwicmF3IiwiaW5kZXhPZiIsIkVycm9yIiwicGF0aCIsInBvaW50cyIsImNvbmNhdCIsInBvbHlsaW5lIiwiUG9seWxpbmUiLCJQYXRoIiwiYXBwZW5kU2VnbWVudCIsImNyZWF0ZVNlZ21lbnQiLCJuZXh0RGlzdGFuY2UiLCJyb3V0ZVBvaW50c0xlbmd0aCIsImxlbmd0aCIsImkiLCJjdXJyIiwiUG9pbnQiLCJwcmV2IiwibmV4dCIsInByZXZEaXN0YW5jZSIsImRpc3RhbmNlIiwic3RhcnRNb3ZlIiwiZW5kTW92ZSIsIk1hdGgiLCJtaW4iLCJjb3JuZXJTdGFydCIsImNsb25lIiwibW92ZSIsInJvdW5kIiwiY29ybmVyRW5kIiwiXzEzIiwiXzIzIiwiY29udHJvbDEiLCJ4IiwieSIsImNvbnRyb2wyIiwic2VyaWFsaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/connectors/straight.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/Cell.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/dia/Cell.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ Cell)\n/* harmony export */ });\n/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ \"(ssr)/./node_modules/backbone/backbone.js\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/cloneCells.mjs */ \"(ssr)/./node_modules/jointjs/src/util/cloneCells.mjs\");\n/* harmony import */ var _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes/index.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/attributes/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n\n\n\n\n\n// Cell base model.\n// --------------------------\nconst Cell = backbone__WEBPACK_IMPORTED_MODULE_0__.Model.extend({\n    // This is the same as Backbone.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === \"function\") {\n            // Check to support an older version of Backbone (prior v1.4)\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniqueId)(\"c\");\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if (defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, \"defaults\")) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, defaults, attrs);\n        //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n    translate: function(dx, dy, opt) {\n        throw new Error(\"Must define a translate() method.\");\n    },\n    toJSON: function() {\n        const defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this.constructor.prototype, \"defaults\");\n        const defaultAttrs = defaults.attrs || {};\n        const attrs = this.attributes.attrs;\n        const finalAttrs = {};\n        // Loop through all the attributes and\n        // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn)(attrs, function(attr, selector) {\n            const defaultAttr = defaultAttrs[selector];\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn)(attr, function(value, name) {\n                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n                // Check if the `value` is object and if yes, go one level deep.\n                if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && !Array.isArray(value)) {\n                    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn)(value, function(value2, name2) {\n                        if (!defaultAttr || !defaultAttr[name] || !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(defaultAttr[name][name2], value2)) {\n                            finalAttrs[selector] = finalAttrs[selector] || {};\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n                        }\n                    });\n                } else if (!defaultAttr || !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(defaultAttr[name], value)) {\n                    // `value` is not an object, default attribute for such a selector does not exist\n                    // or it is different than the attribute value set on the model.\n                    finalAttrs[selector] = finalAttrs[selector] || {};\n                    finalAttrs[selector][name] = value;\n                }\n            });\n        });\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.omit)(this.attributes, \"attrs\"));\n        attributes.attrs = finalAttrs;\n        return attributes;\n    },\n    initialize: function(options) {\n        const idAttribute = this.getIdAttribute();\n        if (!options || options[idAttribute] === undefined) {\n            this.set(idAttribute, this.generateId(), {\n                silent: true\n            });\n        }\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on(\"change:attrs\", this.processPorts, this);\n    },\n    getIdAttribute: function() {\n        return this.idAttribute || \"id\";\n    },\n    generateId: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.uuid)();\n    },\n    /**\n     * @deprecated\n     */ processPorts: function() {\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n        var previousPorts = this.ports;\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn)(this.get(\"attrs\"), function(attrs, selector) {\n            if (attrs && attrs.port) {\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = {\n                        id: attrs.port\n                    };\n                }\n            }\n        });\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn)(previousPorts, function(port, id) {\n            if (!ports[id]) removedPorts[id] = true;\n        });\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(removedPorts)) {\n            var inboundLinks = this.graph.getConnectedLinks(this, {\n                inbound: true\n            });\n            inboundLinks.forEach(function(link) {\n                if (removedPorts[link.get(\"target\").port]) link.remove();\n            });\n            var outboundLinks = this.graph.getConnectedLinks(this, {\n                outbound: true\n            });\n            outboundLinks.forEach(function(link) {\n                if (removedPorts[link.get(\"source\").port]) link.remove();\n            });\n        }\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n    remove: function(opt = {}) {\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common Backbone collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n        graph.startBatch(\"remove\");\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for(let i = 0, n = embeddedCells.length; i < n; i++){\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n        this.trigger(\"remove\", this, graph.attributes.cells, opt);\n        graph.stopBatch(\"remove\");\n        return this;\n    },\n    toFront: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults)(opt || {}, {\n                foregroundEmbeds: true\n            });\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({\n                    deep: true,\n                    breadthFirst: opt.breadthFirst !== false,\n                    sortSiblings: opt.foregroundEmbeds\n                });\n                cells.unshift(this);\n            } else {\n                cells = [\n                    this\n                ];\n            }\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortBy)(cells, (cell)=>cell.z());\n            const maxZ = graph.maxZIndex();\n            let z = maxZ - cells.length + 1;\n            const collection = graph.get(\"cells\");\n            let shouldUpdate = collection.indexOf(sortedCells[0]) !== collection.length - cells.length;\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n            if (shouldUpdate) {\n                this.startBatch(\"to-front\");\n                z = z + cells.length;\n                sortedCells.forEach(function(cell, index) {\n                    cell.set(\"z\", z + index, opt);\n                });\n                this.stopBatch(\"to-front\");\n            }\n        }\n        return this;\n    },\n    toBack: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults)(opt || {}, {\n                foregroundEmbeds: true\n            });\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({\n                    deep: true,\n                    breadthFirst: opt.breadthFirst !== false,\n                    sortSiblings: opt.foregroundEmbeds\n                });\n                cells.unshift(this);\n            } else {\n                cells = [\n                    this\n                ];\n            }\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortBy)(cells, (cell)=>cell.z());\n            let z = graph.minZIndex();\n            var collection = graph.get(\"cells\");\n            let shouldUpdate = collection.indexOf(sortedCells[0]) !== 0;\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n            if (shouldUpdate) {\n                this.startBatch(\"to-back\");\n                z -= cells.length;\n                sortedCells.forEach(function(cell, index) {\n                    cell.set(\"z\", z + index, opt);\n                });\n                this.stopBatch(\"to-back\");\n            }\n        }\n        return this;\n    },\n    parent: function(parent, opt) {\n        // getter\n        if (parent === undefined) return this.get(\"parent\");\n        // setter\n        return this.set(\"parent\", parent, opt);\n    },\n    embed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [\n            cell\n        ];\n        if (!this.canEmbed(cells)) {\n            throw new Error(\"Recursive embedding not allowed.\");\n        }\n        if (cells.some((c)=>c.isEmbedded() && this.id !== c.parent())) {\n            throw new Error(\"Embedding of already embedded cells is not allowed.\");\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [\n            cell\n        ];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [\n            cell\n        ];\n        return cells.every((c)=>this !== c && !this.isEmbeddedIn(c));\n    },\n    _embedCells: function(cells, opt) {\n        const batchName = \"embed\";\n        this.startBatch(batchName);\n        const embeds = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)([], this.get(\"embeds\"));\n        cells.forEach((cell)=>{\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? \"unshift\" : \"push\"](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set(\"embeds\", (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq)(embeds), opt);\n        this.stopBatch(batchName);\n    },\n    _unembedCells: function(cells, opt) {\n        const batchName = \"unembed\";\n        this.startBatch(batchName);\n        cells.forEach((cell)=>cell.unset(\"parent\", opt));\n        this.set(\"embeds\", (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.without)(this.get(\"embeds\"), ...cells.map((cell)=>cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n    getParentCell: function() {\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n        return parentId && graph && graph.getCell(parentId) || null;\n    },\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n        var ancestors = [];\n        if (!this.graph) {\n            return ancestors;\n        }\n        var parentCell = this.getParentCell();\n        while(parentCell){\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n        return ancestors;\n    },\n    getEmbeddedCells: function(opt) {\n        opt = opt || {};\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (!this.graph) {\n            return [];\n        }\n        if (opt.deep) {\n            if (opt.breadthFirst) {\n                return this._getEmbeddedCellsBfs(opt.sortSiblings);\n            } else {\n                return this._getEmbeddedCellsDfs(opt.sortSiblings);\n            }\n        }\n        const embeddedIds = this.get(\"embeds\");\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(embeddedIds)) {\n            return [];\n        }\n        let cells = embeddedIds.map(this.graph.getCell, this.graph);\n        if (opt.sortSiblings) {\n            cells = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortBy)(cells, (cell)=>cell.z());\n        }\n        return cells;\n    },\n    _getEmbeddedCellsBfs: function(sortSiblings) {\n        const cells = [];\n        const queue = [];\n        queue.push(this);\n        while(queue.length > 0){\n            const current = queue.shift();\n            cells.push(current);\n            const embeddedCells = current.getEmbeddedCells({\n                sortSiblings: sortSiblings\n            });\n            queue.push(...embeddedCells);\n        }\n        cells.shift();\n        return cells;\n    },\n    _getEmbeddedCellsDfs: function(sortSiblings) {\n        const cells = [];\n        const stack = [];\n        stack.push(this);\n        while(stack.length > 0){\n            const current = stack.pop();\n            cells.push(current);\n            const embeddedCells = current.getEmbeddedCells({\n                sortSiblings: sortSiblings\n            });\n            // When using the stack, cells that are embedded last are processed first.\n            // To maintain the original order, we need to push the cells in reverse order\n            for(let i = embeddedCells.length - 1; i >= 0; --i){\n                stack.push(embeddedCells[i]);\n            }\n        }\n        cells.shift();\n        return cells;\n    },\n    isEmbeddedIn: function(cell, opt) {\n        var cellId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(cell) ? cell : cell.id;\n        var parentId = this.parent();\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({\n            deep: true\n        }, opt);\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n            while(parentId){\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n            return false;\n        } else {\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n        return !!this.parent();\n    },\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n        opt = opt || {};\n        if (!opt.deep) {\n            // Shallow cloning.\n            var clone = backbone__WEBPACK_IMPORTED_MODULE_0__.Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset(\"embeds\");\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset(\"parent\");\n            return clone;\n        } else {\n            // Deep cloning.\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray)((0,_util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneCells)([\n                this\n            ].concat(this.getEmbeddedCells({\n                deep: true\n            }))));\n        }\n    },\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n        var delim = \"/\";\n        var _isString = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(props);\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            if (arguments.length > 1) {\n                var path;\n                var pathArray;\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split(\"/\");\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n                const options = opt || {};\n                options.propertyPath = path;\n                options.propertyValue = value;\n                options.propertyPathArray = pathArray;\n                if (!(\"rewrite\" in options)) {\n                    options.rewrite = false;\n                }\n                var update = {};\n                // Initialize the nested object. Sub-objects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n                for(var i = 1; i < pathArrayLength; i++){\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n                // Fill update with the `value` on `path`.\n                update = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(update, pathArray, value, \"/\");\n                var baseAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                options.rewrite && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(baseAttributes, path, \"/\");\n                // Merge update with the model attributes.\n                var attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], options);\n            } else {\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, props, delim);\n            }\n        }\n        const options = value || {};\n        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n        options.propertyPath = null;\n        options.propertyValue = props;\n        options.propertyPathArray = [];\n        if (!(\"rewrite\" in options)) {\n            options.rewrite = false;\n        }\n        // Create a new object containing only the changed attributes.\n        const changedAttributes = {};\n        for(const key in props){\n            // Merging the values of changed attributes with the current ones.\n            const { changedValue } = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, {\n                changedValue: this.attributes[key]\n            }, {\n                changedValue: props[key]\n            });\n            changedAttributes[key] = changedValue;\n        }\n        return this.set(changedAttributes, options);\n    },\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n        opt = opt || {};\n        var pathArray = Array.isArray(path) ? path : path.split(\"/\");\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === \"attrs\") opt.dirty = true;\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = this.get(property);\n        if (propertyValue === undefined || propertyValue === null) return this;\n        propertyValue = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(propertyValue);\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(propertyValue, nestedPath, \"/\");\n        return this.set(property, propertyValue, opt);\n    },\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get(\"attrs\");\n        }\n        if (Array.isArray(attrs)) {\n            args[0] = [\n                \"attrs\"\n            ].concat(attrs);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = \"attrs/\" + attrs;\n        } else {\n            args[0] = {\n                \"attrs\": attrs\n            };\n        }\n        return this.prop.apply(this, args);\n    },\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n        if (Array.isArray(path)) {\n            return this.removeProp([\n                \"attrs\"\n            ].concat(path));\n        }\n        return this.removeProp(\"attrs/\" + path, opt);\n    },\n    transition: function(path, value, opt, delim) {\n        delim = delim || \"/\";\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.timing.linear,\n            valueFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.interpolate.number\n        };\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(defaults, opt);\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n        var setter = (function(runtime) {\n            var id, progress, propertyValue;\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n            if (progress < 1) {\n                this._transitionIds[path] = id = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n            opt.transitionId = id;\n            this.prop(path, propertyValue, opt);\n            if (!id) this.trigger(\"transition:end\", this, path);\n        }).bind(this);\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n        var initiator = (callback)=>{\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.without)(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n            this.stopPendingTransitions(path, delim);\n            interpolatingFunction = opt.valueFunction((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, path, delim), value);\n            this._transitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(callback);\n            this.trigger(\"transition:start\", this, path);\n        };\n        initialId = setTimeout(initiator, opt.delay, setter);\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n        return initialId;\n    },\n    getTransitions: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.union)(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n    },\n    stopScheduledTransitions: function(path, delim = \"/\") {\n        const { _scheduledTransitionIds = {} } = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key)=>{\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key)=>{\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach((transitionId)=>clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n        // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n    stopPendingTransitions (path, delim = \"/\") {\n        const { _transitionIds = {} } = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key)=>{\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key)=>{\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.cancelFrame)(transitionId);\n            delete _transitionIds[key];\n            this.trigger(\"transition:end\", this, key);\n        });\n    },\n    stopTransitions: function(path, delim = \"/\") {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n    addTo: function(graph, opt) {\n        graph.addCell(this, opt);\n        return this;\n    },\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n        return paper.findViewByModel(this);\n    },\n    isElement: function() {\n        return false;\n    },\n    isLink: function() {\n        return false;\n    },\n    startBatch: function(name, opt) {\n        if (this.graph) {\n            this.graph.startBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt, {\n                cell: this\n            }));\n        }\n        return this;\n    },\n    stopBatch: function(name, opt) {\n        if (this.graph) {\n            this.graph.stopBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt, {\n                cell: this\n            }));\n        }\n        return this;\n    },\n    getChangeFlag: function(attributes) {\n        var flag = 0;\n        if (!attributes) return flag;\n        for(var key in attributes){\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n    angle: function() {\n        // To be overridden.\n        return 0;\n    },\n    position: function() {\n        // To be overridden.\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);\n    },\n    z: function() {\n        return this.get(\"z\") || 0;\n    },\n    getPointFromConnectedLink: function() {\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point();\n    },\n    getBBox: function() {\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(0, 0, 0, 0);\n    },\n    getPointRotatedAroundCenter (angle, x, y) {\n        const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n    getAbsolutePointFromRelative (x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(-this.angle(), // Transform the relative position to absolute\n        this.position().offset(x, y));\n    },\n    getRelativePointFromAbsolute (x, y) {\n        return this// Rotate the coordinates to mitigate the element's rotation.\n        .getPointRotatedAroundCenter(this.angle(), x, y)// Transform the absolute position into relative\n        .difference(this.position());\n    }\n}, {\n    getAttributeDefinition: function(attrName) {\n        var defNS = this.attributes;\n        var globalDefNS = _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__.attributes;\n        return defNS && defNS[attrName] || globalDefNS[attrName];\n    },\n    define: function(type, defaults, protoProps, staticProps) {\n        protoProps = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({\n            defaults: (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultsDeep)({\n                type: type\n            }, defaults, this.prototype.defaults)\n        }, protoProps);\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */ if (typeof joint !== \"undefined\" && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.has)(joint, \"shapes\")) {\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(joint.shapes, type, Cell, \".\");\n        }\n        /* eslint-enable no-undef */ return Cell;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0NlbGwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBNkJOO0FBQzBCO0FBQ0E7QUFDaEI7QUFHcEMsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUV0QixNQUFNK0IsT0FBTy9CLDJDQUFjLENBQUNpQyxNQUFNLENBQUM7SUFFdEMsc0ZBQXNGO0lBQ3RGLGlHQUFpRztJQUNqR0MsYUFBYSxTQUFTTCxVQUFVLEVBQUVNLE9BQU87UUFFckMsSUFBSVI7UUFDSixJQUFJUyxRQUFRUCxjQUFjLENBQUM7UUFDM0IsSUFBSSxPQUFPLElBQUksQ0FBQ1EsYUFBYSxLQUFLLFlBQVk7WUFDMUMsNkRBQTZEO1lBQzdELElBQUksQ0FBQ0EsYUFBYSxDQUFDQyxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUNuQztRQUNBLElBQUksQ0FBQ0MsR0FBRyxHQUFHdkMsd0RBQVFBLENBQUM7UUFDcEIsSUFBSSxDQUFDNEIsVUFBVSxHQUFHLENBQUM7UUFDbkIsSUFBSU0sV0FBV0EsUUFBUU0sVUFBVSxFQUFFLElBQUksQ0FBQ0EsVUFBVSxHQUFHTixRQUFRTSxVQUFVO1FBQ3ZFLElBQUlOLFdBQVdBLFFBQVFPLEtBQUssRUFBRU4sUUFBUSxJQUFJLENBQUNNLEtBQUssQ0FBQ04sT0FBT0QsWUFBWSxDQUFDO1FBQ3JFLElBQUtSLFdBQVd4QixzREFBTUEsQ0FBQyxJQUFJLEVBQUUsYUFBYztZQUN2QyxlQUFlO1lBQ2YsbURBQW1EO1lBQ25EaUMsUUFBUWhDLHFEQUFLQSxDQUFDLENBQUMsR0FBR3VCLFVBQVVTO1FBQzVCLGdCQUFnQjtRQUNwQjtRQUNBLElBQUksQ0FBQ08sR0FBRyxDQUFDUCxPQUFPRDtRQUNoQixJQUFJLENBQUNTLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsVUFBVSxDQUFDUCxLQUFLLENBQUMsSUFBSSxFQUFFQztJQUNoQztJQUVBTyxXQUFXLFNBQVNDLEVBQUUsRUFBRUMsRUFB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LENBQUMsSUFBSSxDQUFDTixLQUFLLElBQ1gsOENBQThDO1FBQzlDLElBQUksQ0FBQ0MsUUFBUSxHQUFHWSxNQUFNLENBQUNOLEdBQUdDO0lBRWxDO0lBRUFNLDhCQUE2QlAsQ0FBQyxFQUFFQyxDQUFDO1FBQzdCLE9BQU8sSUFBSSw2REFDc0Q7U0FDNURGLDJCQUEyQixDQUFDLElBQUksQ0FBQ04sS0FBSyxJQUFJTyxHQUFHQyxFQUM5QyxnREFBZ0Q7U0FDL0NPLFVBQVUsQ0FBQyxJQUFJLENBQUNkLFFBQVE7SUFDakM7QUFFSixHQUFHO0lBRUNlLHdCQUF3QixTQUFTQyxRQUFRO1FBRXJDLElBQUlDLFFBQVEsSUFBSSxDQUFDOU0sVUFBVTtRQUMzQixJQUFJK00sY0FBYy9NLDZEQUFVQTtRQUM1QixPQUFPLFNBQVU4TSxLQUFLLENBQUNELFNBQVMsSUFBS0UsV0FBVyxDQUFDRixTQUFTO0lBQzlEO0lBRUFHLFFBQVEsU0FBU0MsSUFBSSxFQUFFbk4sUUFBUSxFQUFFb04sVUFBVSxFQUFFQyxXQUFXO1FBRXBERCxhQUFhbE8sc0RBQU1BLENBQUM7WUFDaEJjLFVBQVVILDREQUFZQSxDQUFDO2dCQUFFc04sTUFBTUE7WUFBSyxHQUFHbk4sVUFBVSxJQUFJLENBQUN5QixTQUFTLENBQUN6QixRQUFRO1FBQzVFLEdBQUdvTjtRQUVILElBQUloTixPQUFPLElBQUksQ0FBQ0UsTUFBTSxDQUFDOE0sWUFBWUM7UUFDbkMsNkJBQTZCO1FBQzdCLDJCQUEyQixHQUMzQixJQUFJLE9BQU9DLFVBQVUsZUFBZXhOLG1EQUFHQSxDQUFDd04sT0FBTyxXQUFXO1lBQ3REak8seURBQVNBLENBQUNpTyxNQUFNQyxNQUFNLEVBQUVKLE1BQU0vTSxNQUFNO1FBQ3hDO1FBQ0EsMEJBQTBCLEdBQzFCLE9BQU9BO0lBQ1g7QUFDSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0NlbGwubWpzPzNmZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhY2tib25lIGZyb20gJ2JhY2tib25lJztcbmltcG9ydCB7XG4gICAgdW5pcXVlSWQsXG4gICAgdW5pb24sXG4gICAgcmVzdWx0LFxuICAgIG1lcmdlLFxuICAgIGZvckluLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzRXF1YWwsXG4gICAgaXNTdHJpbmcsXG4gICAgY2xvbmVEZWVwLFxuICAgIG9taXQsXG4gICAgdXVpZCxcbiAgICBpc0VtcHR5LFxuICAgIGFzc2lnbixcbiAgICB1bmlxLFxuICAgIHRvQXJyYXksXG4gICAgc2V0QnlQYXRoLFxuICAgIHVuc2V0QnlQYXRoLFxuICAgIGdldEJ5UGF0aCxcbiAgICB0aW1pbmcsXG4gICAgaW50ZXJwb2xhdGUsXG4gICAgbmV4dEZyYW1lLFxuICAgIHdpdGhvdXQsXG4gICAgY2FuY2VsRnJhbWUsXG4gICAgZGVmYXVsdHNEZWVwLFxuICAgIGhhcyxcbiAgICBzb3J0QnksXG4gICAgZGVmYXVsdHNcbn0gZnJvbSAnLi4vdXRpbC91dGlsLm1qcyc7XG5pbXBvcnQgeyBjbG9uZUNlbGxzIH0gZnJvbSAnLi4vdXRpbC9jbG9uZUNlbGxzLm1qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGVzIH0gZnJvbSAnLi9hdHRyaWJ1dGVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuXG4vLyBDZWxsIGJhc2UgbW9kZWwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgQ2VsbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIEJhY2tib25lLk1vZGVsIHdpdGggdGhlIG9ubHkgZGlmZmVyZW5jZSB0aGF0IGlzIHVzZXMgdXRpbC5tZXJnZVxuICAgIC8vIGluc3RlYWQgb2YganVzdCBfLmV4dGVuZC4gVGhlIHJlYXNvbiBpcyB0aGF0IHdlIHdhbnQgdG8gbWl4aW4gYXR0cmlidXRlcyBzZXQgaW4gdXBwZXIgY2xhc3Nlcy5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciBkZWZhdWx0cztcbiAgICAgICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZWluaXRpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHN1cHBvcnQgYW4gb2xkZXIgdmVyc2lvbiBvZiBCYWNrYm9uZSAocHJpb3IgdjEuNClcbiAgICAgICAgICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2lkID0gdW5pcXVlSWQoJ2MnKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29sbGVjdGlvbikgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhcnNlKSBhdHRycyA9IHRoaXMucGFyc2UoYXR0cnMsIG9wdGlvbnMpIHx8IHt9O1xuICAgICAgICBpZiAoKGRlZmF1bHRzID0gcmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKSkge1xuICAgICAgICAgICAgLy88Y3VzdG9tIGNvZGU+XG4gICAgICAgICAgICAvLyBSZXBsYWNlZCB0aGUgY2FsbCB0byBfLmRlZmF1bHRzIHdpdGggdXRpbC5tZXJnZS5cbiAgICAgICAgICAgIGF0dHJzID0gbWVyZ2Uoe30sIGRlZmF1bHRzLCBhdHRycyk7XG4gICAgICAgICAgICAvLzwvY3VzdG9tIGNvZGU+XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oZHgsIGR5LCBvcHQpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgZGVmaW5lIGEgdHJhbnNsYXRlKCkgbWV0aG9kLicpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gcmVzdWx0KHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLCAnZGVmYXVsdHMnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0gZGVmYXVsdHMuYXR0cnMgfHwge307XG4gICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzLmF0dHJzO1xuICAgICAgICBjb25zdCBmaW5hbEF0dHJzID0ge307XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgYXR0cmlidXRlcyBhbmRcbiAgICAgICAgLy8gb21pdCB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGFzIHRoZXkgYXJlIGltcGxpY2l0bHkgcmVjb25zdHJ1Y3RpYmxlIGJ5IHRoZSBjZWxsICd0eXBlJy5cbiAgICAgICAgZm9ySW4oYXR0cnMsIGZ1bmN0aW9uKGF0dHIsIHNlbGVjdG9yKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdHRyID0gZGVmYXVsdEF0dHJzW3NlbGVjdG9yXTtcblxuICAgICAgICAgICAgZm9ySW4oYXR0ciwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIC8vIGF0dHIgaXMgbWFpbmx5IGZsYXQgdGhvdWdoIGl0IG1pZ2h0IGhhdmUgb25lIG1vcmUgbGV2ZWwgKGNvbnNpZGVyIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZSkuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgb2JqZWN0IGFuZCBpZiB5ZXMsIGdvIG9uZSBsZXZlbCBkZWVwLlxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlMiwgbmFtZTIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0QXR0ciB8fCAhZGVmYXVsdEF0dHJbbmFtZV0gfHwgIWlzRXF1YWwoZGVmYXVsdEF0dHJbbmFtZV1bbmFtZTJdLCB2YWx1ZTIpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEF0dHJzW3NlbGVjdG9yXSA9IGZpbmFsQXR0cnNbc2VsZWN0b3JdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaW5hbEF0dHJzW3NlbGVjdG9yXVtuYW1lXSB8fCAoZmluYWxBdHRyc1tzZWxlY3Rvcl1bbmFtZV0gPSB7fSkpW25hbWUyXSA9IHZhbHVlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWZhdWx0QXR0ciB8fCAhaXNFcXVhbChkZWZhdWx0QXR0cltuYW1lXSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgZGVmYXVsdCBhdHRyaWJ1dGUgZm9yIHN1Y2ggYSBzZWxlY3RvciBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgYXR0cmlidXRlIHZhbHVlIHNldCBvbiB0aGUgbW9kZWwuXG5cbiAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tzZWxlY3Rvcl0gPSBmaW5hbEF0dHJzW3NlbGVjdG9yXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxBdHRyc1tzZWxlY3Rvcl1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNsb25lRGVlcChvbWl0KHRoaXMuYXR0cmlidXRlcywgJ2F0dHJzJykpO1xuICAgICAgICBhdHRyaWJ1dGVzLmF0dHJzID0gZmluYWxBdHRycztcblxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGlkQXR0cmlidXRlID0gdGhpcy5nZXRJZEF0dHJpYnV0ZSgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9uc1tpZEF0dHJpYnV0ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoaWRBdHRyaWJ1dGUsIHRoaXMuZ2VuZXJhdGVJZCgpLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25JZHMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkVHJhbnNpdGlvbklkcyA9IHt9O1xuXG4gICAgICAgIC8vIENvbGxlY3QgcG9ydHMgZGVmaW5lZCBpbiBgYXR0cnNgIGFuZCBrZWVwIGNvbGxlY3Rpbmcgd2hlbmV2ZXIgYGF0dHJzYCBvYmplY3QgY2hhbmdlcy5cbiAgICAgICAgdGhpcy5wcm9jZXNzUG9ydHMoKTtcbiAgICAgICAgdGhpcy5vbignY2hhbmdlOmF0dHJzJywgdGhpcy5wcm9jZXNzUG9ydHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRJZEF0dHJpYnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkQXR0cmlidXRlIHx8ICdpZCc7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlSWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXVpZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHByb2Nlc3NQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gV2hlbmV2ZXIgYGF0dHJzYCBjaGFuZ2VzLCB3ZSBleHRyYWN0IHBvcnRzIGZyb20gdGhlIGBhdHRyc2Agb2JqZWN0IGFuZCBzdG9yZSBpdFxuICAgICAgICAvLyBpbiBhIG1vcmUgYWNjZXNzaWJsZSB3YXkuIEFsc28sIGlmIGFueSBwb3J0IGdvdCByZW1vdmVkIGFuZCB0aGVyZSB3ZXJlIGxpbmtzIHRoYXQgaGFkIGB0YXJnZXRgL2Bzb3VyY2VgXG4gICAgICAgIC8vIHNldCB0byB0aGF0IHBvcnQsIHdlIHJlbW92ZSB0aG9zZSBsaW5rcyBhcyB3ZWxsICh0byBmb2xsb3cgdGhlIHNhbWUgYmVoYXZpb3VyIGFzXG4gICAgICAgIC8vIHdpdGggYSByZW1vdmVkIGVsZW1lbnQpLlxuXG4gICAgICAgIHZhciBwcmV2aW91c1BvcnRzID0gdGhpcy5wb3J0cztcblxuICAgICAgICAvLyBDb2xsZWN0IHBvcnRzIGZyb20gdGhlIGBhdHRyc2Agb2JqZWN0LlxuICAgICAgICB2YXIgcG9ydHMgPSB7fTtcbiAgICAgICAgZm9ySW4odGhpcy5nZXQoJ2F0dHJzJyksIGZ1bmN0aW9uKGF0dHJzLCBzZWxlY3Rvcikge1xuXG4gICAgICAgICAgICBpZiAoYXR0cnMgJiYgYXR0cnMucG9ydCkge1xuXG4gICAgICAgICAgICAgICAgLy8gYHBvcnRgIGNhbiBlaXRoZXIgYmUgZGlyZWN0bHkgYW4gYGlkYCBvciBhbiBvYmplY3QgY29udGFpbmluZyBhbiBgaWRgIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgZGF0YSkuXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvcnQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwb3J0c1thdHRycy5wb3J0LmlkXSA9IGF0dHJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydHNbYXR0cnMucG9ydF0gPSB7IGlkOiBhdHRycy5wb3J0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb2xsZWN0IHBvcnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgKGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBwb3J0cykgLSBpZiBhbnkuXG4gICAgICAgIC8vIFVzZSBoYXNoIHRhYmxlIGZvciBxdWljayBsb29rdXAuXG4gICAgICAgIHZhciByZW1vdmVkUG9ydHMgPSB7fTtcbiAgICAgICAgZm9ySW4ocHJldmlvdXNQb3J0cywgZnVuY3Rpb24ocG9ydCwgaWQpIHtcblxuICAgICAgICAgICAgaWYgKCFwb3J0c1tpZF0pIHJlbW92ZWRQb3J0c1tpZF0gPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgYWxsIHRoZSBpbmNvbWluZy9vdXRnb2luZyBsaW5rcyB0aGF0IGhhdmUgc291cmNlL3RhcmdldCBwb3J0IHNldCB0byBhbnkgb2YgdGhlIHJlbW92ZWQgcG9ydHMuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoICYmICFpc0VtcHR5KHJlbW92ZWRQb3J0cykpIHtcblxuICAgICAgICAgICAgdmFyIGluYm91bmRMaW5rcyA9IHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBpbmJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgaW5ib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRQb3J0c1tsaW5rLmdldCgndGFyZ2V0JykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG91dGJvdW5kTGlua3MgPSB0aGlzLmdyYXBoLmdldENvbm5lY3RlZExpbmtzKHRoaXMsIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICBvdXRib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRQb3J0c1tsaW5rLmdldCgnc291cmNlJykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYHBvcnRzYCBvYmplY3QuXG4gICAgICAgIHRoaXMucG9ydHMgPSBwb3J0cztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBncmFwaCBpbiBhIHZhcmlhYmxlIGJlY2F1c2UgYHRoaXMuZ3JhcGhgIHdvbid0IGJlIGFjY2Vzc2libGVcbiAgICAgICAgLy8gYWZ0ZXIgYHRoaXMudHJpZ2dlcigncmVtb3ZlJywgLi4uKWAgZG93biBiZWxvdy5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgY29sbGVjdGlvbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaCkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbGxlY3Rpb24gaXMgYSBjb21tb24gQmFja2JvbmUgY29sbGVjdGlvbiAobm90IHRoZSBncmFwaCBjb2xsZWN0aW9uKS5cbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uKSBjb2xsZWN0aW9uLnJlbW92ZSh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaC5zdGFydEJhdGNoKCdyZW1vdmUnKTtcblxuICAgICAgICAvLyBGaXJzdCwgdW5lbWJlZCB0aGlzIGNlbGwgZnJvbSBpdHMgcGFyZW50IGNlbGwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICBjb25zdCBwYXJlbnRDZWxsID0gdGhpcy5nZXRQYXJlbnRDZWxsKCk7XG4gICAgICAgIGlmIChwYXJlbnRDZWxsKSB7XG4gICAgICAgICAgICBwYXJlbnRDZWxsLnVuZW1iZWQodGhpcywgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbHNvIGFsbCB0aGUgY2VsbHMsIHdoaWNoIHdlcmUgZW1iZWRkZWQgaW50byB0aGlzIGNlbGxcbiAgICAgICAgY29uc3QgZW1iZWRkZWRDZWxscyA9IHRoaXMuZ2V0RW1iZWRkZWRDZWxscygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGVtYmVkZGVkQ2VsbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZCA9IGVtYmVkZGVkQ2VsbHNbaV07XG4gICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICBlbWJlZC5yZW1vdmUob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlJywgdGhpcywgZ3JhcGguYXR0cmlidXRlcy5jZWxscywgb3B0KTtcblxuICAgICAgICBncmFwaC5zdG9wQmF0Y2goJ3JlbW92ZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0Zyb250OiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICBvcHQgPSBkZWZhdWx0cyhvcHQgfHwge30sIHsgZm9yZWdyb3VuZEVtYmVkczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgbGV0IGNlbGxzO1xuICAgICAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMgPSB0aGlzLmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlLCBicmVhZHRoRmlyc3Q6IG9wdC5icmVhZHRoRmlyc3QgIT09IGZhbHNlLCBzb3J0U2libGluZ3M6IG9wdC5mb3JlZ3JvdW5kRW1iZWRzIH0pO1xuICAgICAgICAgICAgICAgIGNlbGxzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzID0gW3RoaXNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRDZWxscyA9IG9wdC5mb3JlZ3JvdW5kRW1iZWRzID8gY2VsbHMgOiBzb3J0QnkoY2VsbHMsIGNlbGwgPT4gY2VsbC56KCkpO1xuXG4gICAgICAgICAgICBjb25zdCBtYXhaID0gZ3JhcGgubWF4WkluZGV4KCk7XG4gICAgICAgICAgICBsZXQgeiA9IG1heFogLSBjZWxscy5sZW5ndGggKyAxO1xuXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gZ3JhcGguZ2V0KCdjZWxscycpO1xuXG4gICAgICAgICAgICBsZXQgc2hvdWxkVXBkYXRlID0gKGNvbGxlY3Rpb24uaW5kZXhPZihzb3J0ZWRDZWxsc1swXSkgIT09IChjb2xsZWN0aW9uLmxlbmd0aCAtIGNlbGxzLmxlbmd0aCkpO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGUgPSBzb3J0ZWRDZWxscy5zb21lKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLnooKSAhPT0geiArIGluZGV4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgICAgICAgICAgeiA9IHogKyBjZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzb3J0ZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgeiArIGluZGV4LCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3RvLWZyb250Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CYWNrOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICBvcHQgPSBkZWZhdWx0cyhvcHQgfHwge30sIHsgZm9yZWdyb3VuZEVtYmVkczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgbGV0IGNlbGxzO1xuICAgICAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMgPSB0aGlzLmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlLCBicmVhZHRoRmlyc3Q6IG9wdC5icmVhZHRoRmlyc3QgIT09IGZhbHNlLCBzb3J0U2libGluZ3M6IG9wdC5mb3JlZ3JvdW5kRW1iZWRzIH0pO1xuICAgICAgICAgICAgICAgIGNlbGxzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzID0gW3RoaXNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRDZWxscyA9IG9wdC5mb3JlZ3JvdW5kRW1iZWRzID8gY2VsbHMgOiBzb3J0QnkoY2VsbHMsIGNlbGwgPT4gY2VsbC56KCkpO1xuXG4gICAgICAgICAgICBsZXQgeiA9IGdyYXBoLm1pblpJbmRleCgpO1xuXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGdyYXBoLmdldCgnY2VsbHMnKTtcblxuICAgICAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IChjb2xsZWN0aW9uLmluZGV4T2Yoc29ydGVkQ2VsbHNbMF0pICE9PSAwKTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gc29ydGVkQ2VsbHMuc29tZShmdW5jdGlvbihjZWxsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC56KCkgIT09IHogKyBpbmRleDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgndG8tYmFjaycpO1xuXG4gICAgICAgICAgICAgICAgeiAtPSBjZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzb3J0ZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgeiArIGluZGV4LCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3RvLWJhY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCwgb3B0KSB7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgncGFyZW50JywgcGFyZW50LCBvcHQpO1xuICAgIH0sXG5cbiAgICBlbWJlZDogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuaXNBcnJheShjZWxsKSA/IGNlbGwgOiBbY2VsbF07XG4gICAgICAgIGlmICghdGhpcy5jYW5FbWJlZChjZWxscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaXZlIGVtYmVkZGluZyBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbHMuc29tZShjID0+IGMuaXNFbWJlZGRlZCgpICYmIHRoaXMuaWQgIT09IGMucGFyZW50KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYmVkZGluZyBvZiBhbHJlYWR5IGVtYmVkZGVkIGNlbGxzIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtYmVkQ2VsbHMoY2VsbHMsIG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1bmVtYmVkOiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBBcnJheS5pc0FycmF5KGNlbGwpID8gY2VsbCA6IFtjZWxsXTtcbiAgICAgICAgdGhpcy5fdW5lbWJlZENlbGxzKGNlbGxzLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2FuRW1iZWQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBBcnJheS5pc0FycmF5KGNlbGwpID8gY2VsbCA6IFtjZWxsXTtcbiAgICAgICAgcmV0dXJuIGNlbGxzLmV2ZXJ5KGMgPT4gdGhpcyAhPT0gYyAmJiAhdGhpcy5pc0VtYmVkZGVkSW4oYykpO1xuICAgIH0sXG5cbiAgICBfZW1iZWRDZWxsczogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuICAgICAgICBjb25zdCBiYXRjaE5hbWUgPSAnZW1iZWQnO1xuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goYmF0Y2hOYW1lKTtcbiAgICAgICAgY29uc3QgZW1iZWRzID0gYXNzaWduKFtdLCB0aGlzLmdldCgnZW1iZWRzJykpO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgICAgLy8gV2Uga2VlcCBhbGwgZWxlbWVudCBpZHMgYWZ0ZXIgbGluayBpZHMuXG4gICAgICAgICAgICBlbWJlZHNbY2VsbC5pc0xpbmsoKSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oY2VsbC5pZCk7XG4gICAgICAgICAgICBjZWxsLnBhcmVudCh0aGlzLmlkLCBvcHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXQoJ2VtYmVkcycsIHVuaXEoZW1iZWRzKSwgb3B0KTtcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goYmF0Y2hOYW1lKTtcbiAgICB9LFxuXG4gICAgX3VuZW1iZWRDZWxsczogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuICAgICAgICBjb25zdCBiYXRjaE5hbWUgPSAndW5lbWJlZCc7XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaChiYXRjaE5hbWUpO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC51bnNldCgncGFyZW50Jywgb3B0KSk7XG4gICAgICAgIHRoaXMuc2V0KCdlbWJlZHMnLCB3aXRob3V0KHRoaXMuZ2V0KCdlbWJlZHMnKSwgLi4uY2VsbHMubWFwKGNlbGwgPT4gY2VsbC5pZCkpLCBvcHQpO1xuICAgICAgICB0aGlzLnN0b3BCYXRjaChiYXRjaE5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRQYXJlbnRDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyB1bmxpa2UgbGluay5zb3VyY2UvdGFyZ2V0LCBjZWxsLnBhcmVudCBzdG9yZXMgaWQgZGlyZWN0bHkgYXMgYSBzdHJpbmdcbiAgICAgICAgdmFyIHBhcmVudElkID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcblxuICAgICAgICByZXR1cm4gKHBhcmVudElkICYmIGdyYXBoICYmIGdyYXBoLmdldENlbGwocGFyZW50SWQpKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgYW5jZXN0b3IgY2VsbHMuXG4gICAgLy8gVGhlIGFycmF5IGlzIG9yZGVyZWQgZnJvbSB0aGUgcGFyZW50IG9mIHRoZSBjZWxsXG4gICAgLy8gdG8gdGhlIG1vc3QgZGlzdGFudCBhbmNlc3Rvci5cbiAgICBnZXRBbmNlc3RvcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50Q2VsbCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICB3aGlsZSAocGFyZW50Q2VsbCkge1xuICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50Q2VsbCk7XG4gICAgICAgICAgICBwYXJlbnRDZWxsID0gcGFyZW50Q2VsbC5nZXRQYXJlbnRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH0sXG5cbiAgICBnZXRFbWJlZGRlZENlbGxzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgLy8gQ2VsbCBtb2RlbHMgY2FuIG9ubHkgYmUgcmV0cmlldmVkIHdoZW4gdGhpcyBlbGVtZW50IGlzIHBhcnQgb2YgYSBjb2xsZWN0aW9uLlxuICAgICAgICAvLyBUaGVyZSBpcyBubyB3YXkgdGhpcyBlbGVtZW50IGtub3dzIGFib3V0IG90aGVyIGNlbGxzIG90aGVyd2lzZS5cbiAgICAgICAgLy8gVGhpcyBhbHNvIG1lYW5zIHRoYXQgY2FsbGluZyBlLmcuIGB0cmFuc2xhdGUoKWAgb24gYW4gZWxlbWVudCB3aXRoIGVtYmVkcyBiZWZvcmVcbiAgICAgICAgLy8gYWRkaW5nIGl0IHRvIGEgZ3JhcGggZG9lcyBub3QgdHJhbnNsYXRlIGl0cyBlbWJlZHMuXG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICBpZiAob3B0LmJyZWFkdGhGaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFbWJlZGRlZENlbGxzQmZzKG9wdC5zb3J0U2libGluZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RW1iZWRkZWRDZWxsc0RmcyhvcHQuc29ydFNpYmxpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVtYmVkZGVkSWRzID0gdGhpcy5nZXQoJ2VtYmVkcycpO1xuICAgICAgICBpZiAoaXNFbXB0eShlbWJlZGRlZElkcykpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjZWxscyA9IGVtYmVkZGVkSWRzLm1hcCh0aGlzLmdyYXBoLmdldENlbGwsIHRoaXMuZ3JhcGgpO1xuICAgICAgICBpZiAob3B0LnNvcnRTaWJsaW5ncykge1xuICAgICAgICAgICAgY2VsbHMgPSBzb3J0QnkoY2VsbHMsIGNlbGwgPT4gY2VsbC56KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sXG5cbiAgICBfZ2V0RW1iZWRkZWRDZWxsc0JmczogZnVuY3Rpb24oc29ydFNpYmxpbmdzKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG5cbiAgICAgICAgY29uc3QgcXVldWUgPSBbXTtcbiAgICAgICAgcXVldWUucHVzaCh0aGlzKTtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZENlbGxzID0gY3VycmVudC5nZXRFbWJlZGRlZENlbGxzKHsgc29ydFNpYmxpbmdzOiBzb3J0U2libGluZ3MgfSk7XG5cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goLi4uZW1iZWRkZWRDZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbHMuc2hpZnQoKTtcblxuICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSxcblxuICAgIF9nZXRFbWJlZGRlZENlbGxzRGZzOiBmdW5jdGlvbihzb3J0U2libGluZ3MpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBbXTtcblxuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZENlbGxzID0gY3VycmVudC5nZXRFbWJlZGRlZENlbGxzKHsgc29ydFNpYmxpbmdzOiBzb3J0U2libGluZ3MgfSk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgdGhlIHN0YWNrLCBjZWxscyB0aGF0IGFyZSBlbWJlZGRlZCBsYXN0IGFyZSBwcm9jZXNzZWQgZmlyc3QuXG4gICAgICAgICAgICAvLyBUbyBtYWludGFpbiB0aGUgb3JpZ2luYWwgb3JkZXIsIHdlIG5lZWQgdG8gcHVzaCB0aGUgY2VsbHMgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVtYmVkZGVkQ2VsbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVtYmVkZGVkQ2VsbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNlbGxzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sXG5cbiAgICBpc0VtYmVkZGVkSW46IGZ1bmN0aW9uKGNlbGwsIG9wdCkge1xuXG4gICAgICAgIHZhciBjZWxsSWQgPSBpc1N0cmluZyhjZWxsKSA/IGNlbGwgOiBjZWxsLmlkO1xuICAgICAgICB2YXIgcGFyZW50SWQgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgICAgIG9wdCA9IGFzc2lnbih7IGRlZXA6IHRydWUgfSwgb3B0KTtcblxuICAgICAgICAvLyBTZWUgZ2V0RW1iZWRkZWRDZWxscygpLlxuICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiBvcHQuZGVlcCkge1xuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IGNlbGxJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSB0aGlzLmdyYXBoLmdldENlbGwocGFyZW50SWQpLnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gV2hlbiB0aGlzIGNlbGwgaXMgbm90IHBhcnQgb2YgYSBjb2xsZWN0aW9uIGNoZWNrXG4gICAgICAgICAgICAvLyBhdCBsZWFzdCB3aGV0aGVyIGl0J3MgYSBkaXJlY3QgY2hpbGQgb2YgZ2l2ZW4gY2VsbC5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRJZCA9PT0gY2VsbElkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBjZWxsIGlzIGVtYmVkZGVkIGluIGFueSBvdGhlciBjZWxsLlxuICAgIGlzRW1iZWRkZWQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMucGFyZW50KCk7XG4gICAgfSxcblxuICAgIC8vIElzb2xhdGVkIGNsb25pbmcuIElzb2xhdGVkIGNsb25pbmcgaGFzIHR3byB2ZXJzaW9uczogc2hhbGxvdyBhbmQgZGVlcCAocGFzcyBgeyBkZWVwOiB0cnVlIH1gIGluIGBvcHRgKS5cbiAgICAvLyBTaGFsbG93IGNsb25pbmcgc2ltcGx5IGNsb25lcyB0aGUgY2VsbCBhbmQgcmV0dXJucyBhIG5ldyBjZWxsIHdpdGggZGlmZmVyZW50IElELlxuICAgIC8vIERlZXAgY2xvbmluZyBjbG9uZXMgdGhlIGNlbGwgYW5kIGFsbCBpdHMgZW1iZWRkZWQgY2VsbHMgcmVjdXJzaXZlbHkuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICBpZiAoIW9wdC5kZWVwKSB7XG4gICAgICAgICAgICAvLyBTaGFsbG93IGNsb25pbmcuXG5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5jbG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgY2xvbmUgdG8gaGF2ZSB0aGUgc2FtZSBJRCBhcyB0aGUgb3JpZ2luYWwuXG4gICAgICAgICAgICBjbG9uZS5zZXQodGhpcy5nZXRJZEF0dHJpYnV0ZSgpLCB0aGlzLmdlbmVyYXRlSWQoKSk7XG4gICAgICAgICAgICAvLyBBIHNoYWxsb3cgY2xvbmVkIGVsZW1lbnQgZG9lcyBub3QgY2Fycnkgb3ZlciB0aGUgb3JpZ2luYWwgZW1iZWRzLlxuICAgICAgICAgICAgY2xvbmUudW5zZXQoJ2VtYmVkcycpO1xuICAgICAgICAgICAgLy8gQW5kIGNhbiBub3QgYmUgZW1iZWRkZWQgaW4gYW55IGNlbGxcbiAgICAgICAgICAgIC8vIGFzIHRoZSBjbG9uZSBpcyBub3QgcGFydCBvZiB0aGUgZ3JhcGguXG4gICAgICAgICAgICBjbG9uZS51bnNldCgncGFyZW50Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVlcCBjbG9uaW5nLlxuXG4gICAgICAgICAgICAvLyBGb3IgYSBkZWVwIGNsb25lLCBzaW1wbHkgY2FsbCBgZ3JhcGguY2xvbmVDZWxscygpYCB3aXRoIHRoZSBjZWxsIGFuZCBhbGwgaXRzIGVtYmVkZGVkIGNlbGxzLlxuICAgICAgICAgICAgcmV0dXJuIHRvQXJyYXkoY2xvbmVDZWxscyhbdGhpc10uY29uY2F0KHRoaXMuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUgfSkpKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQSBjb252ZW5pZW50IHdheSB0byBzZXQgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAgLy8gVGhpcyBtZXRob2QgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIHlvdSdkIGxpa2UgdG8gc2V0IHdpdGggdGhlIG9uZXNcbiAgICAvLyBzdG9yZWQgaW4gdGhlIGNlbGwgYW5kIG1ha2VzIHN1cmUgY2hhbmdlIGV2ZW50cyBhcmUgcHJvcGVybHkgdHJpZ2dlcmVkLlxuICAgIC8vIFlvdSBjYW4gZWl0aGVyIHNldCBhIG5lc3RlZCBwcm9wZXJ0eSB3aXRoIG9uZSBvYmplY3RcbiAgICAvLyBvciB1c2UgYSBwcm9wZXJ0eSBwYXRoLlxuICAgIC8vIFRoZSBtb3N0IHNpbXBsZSB1c2UgY2FzZSBpczpcbiAgICAvLyBgY2VsbC5wcm9wKCduYW1lL2ZpcnN0JywgJ0pvaG4nKWAgb3JcbiAgICAvLyBgY2VsbC5wcm9wKHsgbmFtZTogeyBmaXJzdDogJ0pvaG4nIH0gfSlgLlxuICAgIC8vIE5lc3RlZCBhcnJheXMgYXJlIHN1cHBvcnRlZCB0b286XG4gICAgLy8gYGNlbGwucHJvcCgnc2VyaWVzLzAvZGF0YS8wL2RlZ3JlZScsIDUwKWAgb3JcbiAgICAvLyBgY2VsbC5wcm9wKHsgc2VyaWVzOiBbIHsgZGF0YTogWyB7IGRlZ3JlZTogNTAgfSBdIH0gXSB9KWAuXG4gICAgcHJvcDogZnVuY3Rpb24ocHJvcHMsIHZhbHVlLCBvcHQpIHtcblxuICAgICAgICB2YXIgZGVsaW0gPSAnLyc7XG4gICAgICAgIHZhciBfaXNTdHJpbmcgPSBpc1N0cmluZyhwcm9wcyk7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyB8fCBBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgICAgICAgLy8gR2V0L3NldCBhbiBhdHRyaWJ1dGUgYnkgYSBzcGVjaWFsIHBhdGggc3ludGF4IHRoYXQgZGVsaW1pdHNcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzIGJ5IHRoZSBjb2xvbiBjaGFyYWN0ZXIuXG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhBcnJheTtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHByb3BzLmpvaW4oZGVsaW0pO1xuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkgPSBwcm9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHBhdGhBcnJheVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEFycmF5TGVuZ3RoID0gcGF0aEFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvcHQgfHwge307XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHlWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHlQYXRoQXJyYXkgPSBwYXRoQXJyYXk7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ3Jld3JpdGUnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmV3cml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBuZXN0ZWQgb2JqZWN0LiBTdWItb2JqZWN0cyBhcmUgZWl0aGVyIGFycmF5cyBvciBvYmplY3RzLlxuICAgICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGFycmF5IGlzIGNyZWF0ZWQgaWYgdGhlIHN1Yi1rZXkgaXMgYW4gaW50ZWdlci4gT3RoZXJ3aXNlLCBhbiBlbXB0eSBvYmplY3QgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBvc2VzIGEgbGltaXRhdGlvbiBvbiBvYmplY3Qga2V5cyBvbmUgY2FuIHVzZSB3aXRoIEluc3BlY3Rvci5cbiAgICAgICAgICAgICAgICAvLyBQdXJlIGludGVnZXIga2V5cyB3aWxsIGNhdXNlIGlzc3VlcyBhbmQgYXJlIHRoZXJlZm9yZSBub3QgYWxsb3dlZC5cbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoQXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aEl0ZW0gPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0FycmF5SW5kZXggPSBOdW1iZXIuaXNGaW5pdGUoX2lzU3RyaW5nID8gTnVtYmVyKHBhdGhJdGVtKSA6IHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcltwcmV2UHJvcGVydHldID0gaXNBcnJheUluZGV4ID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BlcnR5ID0gcGF0aEl0ZW07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmlsbCB1cGRhdGUgd2l0aCB0aGUgYHZhbHVlYCBvbiBgcGF0aGAuXG4gICAgICAgICAgICAgICAgdXBkYXRlID0gc2V0QnlQYXRoKHVwZGF0ZSwgcGF0aEFycmF5LCB2YWx1ZSwgJy8nKTtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlQXR0cmlidXRlcyA9IG1lcmdlKHt9LCB0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHJld3JpdGUgbW9kZSBlbmFibGVkLCB3ZSByZXBsYWNlIHZhbHVlIHJlZmVyZW5jZWQgYnkgcGF0aCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ldyBvbmUgKHdlIGRvbid0IG1lcmdlKS5cbiAgICAgICAgICAgICAgICBvcHRpb25zLnJld3JpdGUgJiYgdW5zZXRCeVBhdGgoYmFzZUF0dHJpYnV0ZXMsIHBhdGgsICcvJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBNZXJnZSB1cGRhdGUgd2l0aCB0aGUgbW9kZWwgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlKGJhc2VBdHRyaWJ1dGVzLCB1cGRhdGUpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHNldCB0aGUgcHJvcGVydHkgdG8gdGhlIHVwZGF0ZWQgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQocHJvcGVydHksIGF0dHJpYnV0ZXNbcHJvcGVydHldLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeVBhdGgodGhpcy5hdHRyaWJ1dGVzLCBwcm9wcywgZGVsaW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlIHx8IHt9O1xuICAgICAgICAvLyBOb3RlOiAnJyBpcyBub3QgdGhlIHBhdGggdG8gdGhlIHJvb3QuIEl0J3MgYSBwYXRoIHdpdGggYW4gZW1wdHkgc3RyaW5nIGkuZS4geyAnJzoge319LlxuICAgICAgICBvcHRpb25zLnByb3BlcnR5UGF0aCA9IG51bGw7XG4gICAgICAgIG9wdGlvbnMucHJvcGVydHlWYWx1ZSA9IHByb3BzO1xuICAgICAgICBvcHRpb25zLnByb3BlcnR5UGF0aEFycmF5ID0gW107XG4gICAgICAgIGlmICghKCdyZXdyaXRlJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgLy8gTWVyZ2luZyB0aGUgdmFsdWVzIG9mIGNoYW5nZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBjdXJyZW50IG9uZXMuXG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZWRWYWx1ZSB9ID0gbWVyZ2Uoe30sIHsgY2hhbmdlZFZhbHVlOiB0aGlzLmF0dHJpYnV0ZXNba2V5XSB9LCB7IGNoYW5nZWRWYWx1ZTogcHJvcHNba2V5XSB9KTtcbiAgICAgICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2tleV0gPSBjaGFuZ2VkVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoY2hhbmdlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBBIGNvbnZlbmllbnQgd2F5IHRvIHVuc2V0IG5lc3RlZCBwcm9wZXJ0aWVzXG4gICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24ocGF0aCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy8nKTtcblxuICAgICAgICAvLyBPbmNlIGEgcHJvcGVydHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBgYXR0cnNgIGF0dHJpYnV0ZVxuICAgICAgICAvLyB0aGUgY2VsbFZpZXcgd2lsbCByZWNvZ25pemUgYSBgZGlydHlgIGZsYWcgYW5kIHJlLXJlbmRlciBpdHNlbGZcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZnJvbSBTVkcgZWxlbWVudC5cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcGF0aEFycmF5WzBdO1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdhdHRycycpIG9wdC5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEEgdG9wIGxldmVsIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNldChwYXRoLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQSBuZXN0ZWQgcHJvcGVydHlcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoQXJyYXkuc2xpY2UoMSk7XG4gICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdGhpcy5nZXQocHJvcGVydHkpO1xuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnR5VmFsdWUgPT09IG51bGwpIHJldHVybiB0aGlzO1xuICAgICAgICBwcm9wZXJ0eVZhbHVlID0gY2xvbmVEZWVwKHByb3BlcnR5VmFsdWUpO1xuXG4gICAgICAgIHVuc2V0QnlQYXRoKHByb3BlcnR5VmFsdWUsIG5lc3RlZFBhdGgsICcvJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHByb3BlcnR5LCBwcm9wZXJ0eVZhbHVlLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBBIGNvbnZlbmllbnQgd2F5IHRvIHNldCBuZXN0ZWQgYXR0cmlidXRlcy5cbiAgICBhdHRyOiBmdW5jdGlvbihhdHRycywgdmFsdWUsIG9wdCkge1xuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICAgICAgYXJnc1swXSA9IFsnYXR0cnMnXS5jb25jYXQoYXR0cnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGF0dHJzKSkge1xuICAgICAgICAgICAgLy8gR2V0L3NldCBhbiBhdHRyaWJ1dGUgYnkgYSBzcGVjaWFsIHBhdGggc3ludGF4IHRoYXQgZGVsaW1pdHNcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzIGJ5IHRoZSBjb2xvbiBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBhcmdzWzBdID0gJ2F0dHJzLycgKyBhdHRycztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBhcmdzWzBdID0geyAnYXR0cnMnIDogYXR0cnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb3AuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIEEgY29udmVuaWVudCB3YXkgdG8gdW5zZXQgbmVzdGVkIGF0dHJpYnV0ZXNcbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihwYXRoLCBvcHQpIHtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVQcm9wKFsnYXR0cnMnXS5jb25jYXQocGF0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlUHJvcCgnYXR0cnMvJyArIHBhdGgsIG9wdCk7XG4gICAgfSxcblxuICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBvcHQsIGRlbGltKSB7XG5cbiAgICAgICAgZGVsaW0gPSBkZWxpbSB8fCAnLyc7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgIHRpbWluZ0Z1bmN0aW9uOiB0aW1pbmcubGluZWFyLFxuICAgICAgICAgICAgdmFsdWVGdW5jdGlvbjogaW50ZXJwb2xhdGUubnVtYmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0ID0gYXNzaWduKGRlZmF1bHRzLCBvcHQpO1xuXG4gICAgICAgIHZhciBmaXJzdEZyYW1lVGltZSA9IDA7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW5nRnVuY3Rpb247XG5cbiAgICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHJ1bnRpbWUpIHtcblxuICAgICAgICAgICAgdmFyIGlkLCBwcm9ncmVzcywgcHJvcGVydHlWYWx1ZTtcblxuICAgICAgICAgICAgZmlyc3RGcmFtZVRpbWUgPSBmaXJzdEZyYW1lVGltZSB8fCBydW50aW1lO1xuICAgICAgICAgICAgcnVudGltZSAtPSBmaXJzdEZyYW1lVGltZTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gcnVudGltZSAvIG9wdC5kdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25JZHNbcGF0aF0gPSBpZCA9IG5leHRGcmFtZShzZXR0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IDE7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RyYW5zaXRpb25JZHNbcGF0aF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSBpbnRlcnBvbGF0aW5nRnVuY3Rpb24ob3B0LnRpbWluZ0Z1bmN0aW9uKHByb2dyZXNzKSk7XG5cbiAgICAgICAgICAgIG9wdC50cmFuc2l0aW9uSWQgPSBpZDtcblxuICAgICAgICAgICAgdGhpcy5wcm9wKHBhdGgsIHByb3BlcnR5VmFsdWUsIG9wdCk7XG5cbiAgICAgICAgICAgIGlmICghaWQpIHRoaXMudHJpZ2dlcigndHJhbnNpdGlvbjplbmQnLCB0aGlzLCBwYXRoKTtcblxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgY29uc3QgeyBfc2NoZWR1bGVkVHJhbnNpdGlvbklkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGluaXRpYWxJZDtcblxuICAgICAgICB2YXIgaW5pdGlhdG9yID0gKGNhbGxiYWNrKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXSkge1xuICAgICAgICAgICAgICAgIF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdID0gd2l0aG91dChfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXSwgaW5pdGlhbElkKTtcbiAgICAgICAgICAgICAgICBpZiAoX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcFBlbmRpbmdUcmFuc2l0aW9ucyhwYXRoLCBkZWxpbSk7XG5cbiAgICAgICAgICAgIGludGVycG9sYXRpbmdGdW5jdGlvbiA9IG9wdC52YWx1ZUZ1bmN0aW9uKGdldEJ5UGF0aCh0aGlzLmF0dHJpYnV0ZXMsIHBhdGgsIGRlbGltKSwgdmFsdWUpO1xuXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uSWRzW3BhdGhdID0gbmV4dEZyYW1lKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0cmFuc2l0aW9uOnN0YXJ0JywgdGhpcywgcGF0aCk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBpbml0aWFsSWQgPSBzZXRUaW1lb3V0KGluaXRpYXRvciwgb3B0LmRlbGF5LCBzZXR0ZXIpO1xuXG4gICAgICAgIF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdIHx8IChfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXSA9IFtdKTtcbiAgICAgICAgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0ucHVzaChpbml0aWFsSWQpO1xuXG4gICAgICAgIHJldHVybiBpbml0aWFsSWQ7XG4gICAgfSxcblxuICAgIGdldFRyYW5zaXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVuaW9uKFxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fdHJhbnNpdGlvbklkcyksXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBzdG9wU2NoZWR1bGVkVHJhbnNpdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIGRlbGltID0gJy8nKSB7XG4gICAgICAgIGNvbnN0IHsgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHMgPSB7fX0gPSB0aGlzO1xuICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyhfc2NoZWR1bGVkVHJhbnNpdGlvbklkcyk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KGRlbGltKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbChwYXRoQXJyYXksIGtleS5zcGxpdChkZWxpbSkuc2xpY2UoMCwgcGF0aEFycmF5Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbnMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uSWRzID0gX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNba2V5XTtcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGluaXRpYXRvclxuICAgICAgICAgICAgdHJhbnNpdGlvbklkcy5mb3JFYWNoKHRyYW5zaXRpb25JZCA9PiBjbGVhclRpbWVvdXQodHJhbnNpdGlvbklkKSk7XG4gICAgICAgICAgICBkZWxldGUgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNba2V5XTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdlIGNvdWxkIHRyaWdnZXIgdHJhbnNpdGlvbjpjYW5jZWxgIGV2ZW50IGhlcmVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdG9wUGVuZGluZ1RyYW5zaXRpb25zKHBhdGgsIGRlbGltID0gJy8nKSB7XG4gICAgICAgIGNvbnN0IHsgX3RyYW5zaXRpb25JZHMgPSB7fX0gPSB0aGlzO1xuICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyhfdHJhbnNpdGlvbklkcyk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KGRlbGltKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbChwYXRoQXJyYXksIGtleS5zcGxpdChkZWxpbSkuc2xpY2UoMCwgcGF0aEFycmF5Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbnMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uSWQgPSBfdHJhbnNpdGlvbklkc1trZXldO1xuICAgICAgICAgICAgLy8gc3RvcCB0aGUgc2V0dGVyXG4gICAgICAgICAgICBjYW5jZWxGcmFtZSh0cmFuc2l0aW9uSWQpO1xuICAgICAgICAgICAgZGVsZXRlIF90cmFuc2l0aW9uSWRzW2tleV07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RyYW5zaXRpb246ZW5kJywgdGhpcywga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHN0b3BUcmFuc2l0aW9uczogZnVuY3Rpb24ocGF0aCwgZGVsaW0gPSAnLycpIHtcbiAgICAgICAgdGhpcy5zdG9wU2NoZWR1bGVkVHJhbnNpdGlvbnMocGF0aCwgZGVsaW0pO1xuICAgICAgICB0aGlzLnN0b3BQZW5kaW5nVHJhbnNpdGlvbnMocGF0aCwgZGVsaW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQSBzaG9yY3V0IG1ha2luZyBpdCBlYXN5IHRvIGNyZWF0ZSBjb25zdHJ1Y3RzIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgICAvLyBgdmFyIGVsID0gKG5ldyBqb2ludC5zaGFwZXMuYmFzaWMuUmVjdCkuYWRkVG8oZ3JhcGgpYC5cbiAgICBhZGRUbzogZnVuY3Rpb24oZ3JhcGgsIG9wdCkge1xuXG4gICAgICAgIGdyYXBoLmFkZENlbGwodGhpcywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgc2hvcnRjdXQgZm9yIGFuIGVxdWl2YWxlbnQgY2FsbDogYHBhcGVyLmZpbmRWaWV3QnlNb2RlbChjZWxsKWBcbiAgICAvLyBtYWtpbmcgaXQgZWFzeSB0byBjcmVhdGUgY29uc3RydWN0cyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gYGNlbGwuZmluZFZpZXcocGFwZXIpLmhpZ2hsaWdodCgpYFxuICAgIGZpbmRWaWV3OiBmdW5jdGlvbihwYXBlcikge1xuXG4gICAgICAgIHJldHVybiBwYXBlci5maW5kVmlld0J5TW9kZWwodGhpcyk7XG4gICAgfSxcblxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBpc0xpbms6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24obmFtZSwgb3B0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHsgdGhpcy5ncmFwaC5zdGFydEJhdGNoKG5hbWUsIGFzc2lnbih7fSwgb3B0LCB7IGNlbGw6IHRoaXMgfSkpOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdG9wQmF0Y2g6IGZ1bmN0aW9uKG5hbWUsIG9wdCkge1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7IHRoaXMuZ3JhcGguc3RvcEJhdGNoKG5hbWUsIGFzc2lnbih7fSwgb3B0LCB7IGNlbGw6IHRoaXMgfSkpOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDaGFuZ2VGbGFnOiBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgdmFyIGZsYWcgPSAwO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHJldHVybiBmbGFnO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkgfHwgIXRoaXMuaGFzQ2hhbmdlZChrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZsYWcgfD0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gVG8gYmUgb3ZlcnJpZGRlbi5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuLlxuICAgICAgICByZXR1cm4gbmV3IGcuUG9pbnQoMCwgMCk7XG4gICAgfSxcblxuICAgIHo6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ3onKSB8fCAwO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2ludCgpO1xuICAgIH0sXG5cbiAgICBnZXRCQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiBuZXcgZy5SZWN0KDAsIDAsIDAsIDApO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludFJvdGF0ZWRBcm91bmRDZW50ZXIoYW5nbGUsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgZy5Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGFuZ2xlKSBwb2ludC5yb3RhdGUodGhpcy5nZXRCQm94KCkuY2VudGVyKCksIGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG5cbiAgICBnZXRBYnNvbHV0ZVBvaW50RnJvbVJlbGF0aXZlKHgsIHkpIHtcbiAgICAgICAgLy8gUm90YXRlIHRoZSBwb3NpdGlvbiB0byB0YWtlIHRoZSBtb2RlbCBhbmdsZSBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSb3RhdGVkQXJvdW5kQ2VudGVyKFxuICAgICAgICAgICAgLXRoaXMuYW5nbGUoKSxcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gYWJzb2x1dGVcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKS5vZmZzZXQoeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVsYXRpdmVQb2ludEZyb21BYnNvbHV0ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNvb3JkaW5hdGVzIHRvIG1pdGlnYXRlIHRoZSBlbGVtZW50J3Mgcm90YXRpb24uXG4gICAgICAgICAgICAuZ2V0UG9pbnRSb3RhdGVkQXJvdW5kQ2VudGVyKHRoaXMuYW5nbGUoKSwgeCwgeSlcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaW50byByZWxhdGl2ZVxuICAgICAgICAgICAgLmRpZmZlcmVuY2UodGhpcy5wb3NpdGlvbigpKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIGdldEF0dHJpYnV0ZURlZmluaXRpb246IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG5cbiAgICAgICAgdmFyIGRlZk5TID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgZ2xvYmFsRGVmTlMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gKGRlZk5TICYmIGRlZk5TW2F0dHJOYW1lXSkgfHwgZ2xvYmFsRGVmTlNbYXR0ck5hbWVdO1xuICAgIH0sXG5cbiAgICBkZWZpbmU6IGZ1bmN0aW9uKHR5cGUsIGRlZmF1bHRzLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXG4gICAgICAgIHByb3RvUHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzRGVlcCh7IHR5cGU6IHR5cGUgfSwgZGVmYXVsdHMsIHRoaXMucHJvdG90eXBlLmRlZmF1bHRzKVxuICAgICAgICB9LCBwcm90b1Byb3BzKTtcblxuICAgICAgICB2YXIgQ2VsbCA9IHRoaXMuZXh0ZW5kKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgLy8gZXM1IGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKGpvaW50LCAnc2hhcGVzJykpIHtcbiAgICAgICAgICAgIHNldEJ5UGF0aChqb2ludC5zaGFwZXMsIHR5cGUsIENlbGwsICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICByZXR1cm4gQ2VsbDtcbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbIkJhY2tib25lIiwidW5pcXVlSWQiLCJ1bmlvbiIsInJlc3VsdCIsIm1lcmdlIiwiZm9ySW4iLCJpc09iamVjdCIsImlzRXF1YWwiLCJpc1N0cmluZyIsImNsb25lRGVlcCIsIm9taXQiLCJ1dWlkIiwiaXNFbXB0eSIsImFzc2lnbiIsInVuaXEiLCJ0b0FycmF5Iiwic2V0QnlQYXRoIiwidW5zZXRCeVBhdGgiLCJnZXRCeVBhdGgiLCJ0aW1pbmciLCJpbnRlcnBvbGF0ZSIsIm5leHRGcmFtZSIsIndpdGhvdXQiLCJjYW5jZWxGcmFtZSIsImRlZmF1bHRzRGVlcCIsImhhcyIsInNvcnRCeSIsImRlZmF1bHRzIiwiY2xvbmVDZWxscyIsImF0dHJpYnV0ZXMiLCJnIiwiQ2VsbCIsIk1vZGVsIiwiZXh0ZW5kIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYXR0cnMiLCJwcmVpbml0aWFsaXplIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjaWQiLCJjb2xsZWN0aW9uIiwicGFyc2UiLCJzZXQiLCJjaGFuZ2VkIiwiaW5pdGlhbGl6ZSIsInRyYW5zbGF0ZSIsImR4IiwiZHkiLCJvcHQiLCJFcnJvciIsInRvSlNPTiIsInByb3RvdHlwZSIsImRlZmF1bHRBdHRycyIsImZpbmFsQXR0cnMiLCJhdHRyIiwic2VsZWN0b3IiLCJkZWZhdWx0QXR0ciIsInZhbHVlIiwibmFtZSIsIkFycmF5IiwiaXNBcnJheSIsInZhbHVlMiIsIm5hbWUyIiwiaWRBdHRyaWJ1dGUiLCJnZXRJZEF0dHJpYnV0ZSIsInVuZGVmaW5lZCIsImdlbmVyYXRlSWQiLCJzaWxlbnQiLCJfdHJhbnNpdGlvbklkcyIsIl9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzIiwicHJvY2Vzc1BvcnRzIiwib24iLCJwcmV2aW91c1BvcnRzIiwicG9ydHMiLCJnZXQiLCJwb3J0IiwiaWQiLCJyZW1vdmVkUG9ydHMiLCJncmFwaCIsImluYm91bmRMaW5rcyIsImdldENvbm5lY3RlZExpbmtzIiwiaW5ib3VuZCIsImZvckVhY2giLCJsaW5rIiwicmVtb3ZlIiwib3V0Ym91bmRMaW5rcyIsIm91dGJvdW5kIiwic3RhcnRCYXRjaCIsInBhcmVudENlbGwiLCJnZXRQYXJlbnRDZWxsIiwidW5lbWJlZCIsImVtYmVkZGVkQ2VsbHMiLCJnZXRFbWJlZGRlZENlbGxzIiwiaSIsIm4iLCJsZW5ndGgiLCJlbWJlZCIsInRyaWdnZXIiLCJjZWxscyIsInN0b3BCYXRjaCIsInRvRnJvbnQiLCJmb3JlZ3JvdW5kRW1iZWRzIiwiZGVlcCIsImJyZWFkdGhGaXJzdCIsInNvcnRTaWJsaW5ncyIsInVuc2hpZnQiLCJzb3J0ZWRDZWxscyIsImNlbGwiLCJ6IiwibWF4WiIsIm1heFpJbmRleCIsInNob3VsZFVwZGF0ZSIsImluZGV4T2YiLCJzb21lIiwiaW5kZXgiLCJ0b0JhY2siLCJtaW5aSW5kZXgiLCJwYXJlbnQiLCJjYW5FbWJlZCIsImMiLCJpc0VtYmVkZGVkIiwiX2VtYmVkQ2VsbHMiLCJfdW5lbWJlZENlbGxzIiwiZXZlcnkiLCJpc0VtYmVkZGVkSW4iLCJiYXRjaE5hbWUiLCJlbWJlZHMiLCJpc0xpbmsiLCJ1bnNldCIsIm1hcCIsInBhcmVudElkIiwiZ2V0Q2VsbCIsImdldEFuY2VzdG9ycyIsImFuY2VzdG9ycyIsInB1c2giLCJfZ2V0RW1iZWRkZWRDZWxsc0JmcyIsIl9nZXRFbWJlZGRlZENlbGxzRGZzIiwiZW1iZWRkZWRJZHMiLCJxdWV1ZSIsImN1cnJlbnQiLCJzaGlmdCIsInN0YWNrIiwicG9wIiwiY2VsbElkIiwiY2xvbmUiLCJjb25jYXQiLCJwcm9wIiwicHJvcHMiLCJkZWxpbSIsIl9pc1N0cmluZyIsInBhdGgiLCJwYXRoQXJyYXkiLCJzcGxpdCIsImpvaW4iLCJzbGljZSIsInByb3BlcnR5IiwicGF0aEFycmF5TGVuZ3RoIiwicHJvcGVydHlQYXRoIiwicHJvcGVydHlWYWx1ZSIsInByb3BlcnR5UGF0aEFycmF5IiwicmV3cml0ZSIsInVwZGF0ZSIsImluaXRpYWxpemVyIiwicHJldlByb3BlcnR5IiwicGF0aEl0ZW0iLCJpc0FycmF5SW5kZXgiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImJhc2VBdHRyaWJ1dGVzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJrZXkiLCJjaGFuZ2VkVmFsdWUiLCJyZW1vdmVQcm9wIiwiZGlydHkiLCJuZXN0ZWRQYXRoIiwiYXJncyIsImZyb20iLCJyZW1vdmVBdHRyIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiZGVsYXkiLCJ0aW1pbmdGdW5jdGlvbiIsImxpbmVhciIsInZhbHVlRnVuY3Rpb24iLCJudW1iZXIiLCJmaXJzdEZyYW1lVGltZSIsImludGVycG9sYXRpbmdGdW5jdGlvbiIsInNldHRlciIsInJ1bnRpbWUiLCJwcm9ncmVzcyIsInRyYW5zaXRpb25JZCIsImJpbmQiLCJpbml0aWFsSWQiLCJpbml0aWF0b3IiLCJjYWxsYmFjayIsInN0b3BQZW5kaW5nVHJhbnNpdGlvbnMiLCJzZXRUaW1lb3V0IiwiZ2V0VHJhbnNpdGlvbnMiLCJPYmplY3QiLCJrZXlzIiwic3RvcFNjaGVkdWxlZFRyYW5zaXRpb25zIiwidHJhbnNpdGlvbnMiLCJmaWx0ZXIiLCJ0cmFuc2l0aW9uSWRzIiwiY2xlYXJUaW1lb3V0Iiwic3RvcFRyYW5zaXRpb25zIiwiYWRkVG8iLCJhZGRDZWxsIiwiZmluZFZpZXciLCJwYXBlciIsImZpbmRWaWV3QnlNb2RlbCIsImlzRWxlbWVudCIsImdldENoYW5nZUZsYWciLCJmbGFnIiwiaGFzT3duUHJvcGVydHkiLCJoYXNDaGFuZ2VkIiwiYW5nbGUiLCJwb3NpdGlvbiIsIlBvaW50IiwiZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayIsImdldEJCb3giLCJSZWN0IiwiZ2V0UG9pbnRSb3RhdGVkQXJvdW5kQ2VudGVyIiwieCIsInkiLCJwb2ludCIsInJvdGF0ZSIsImNlbnRlciIsImdldEFic29sdXRlUG9pbnRGcm9tUmVsYXRpdmUiLCJvZmZzZXQiLCJnZXRSZWxhdGl2ZVBvaW50RnJvbUFic29sdXRlIiwiZGlmZmVyZW5jZSIsImdldEF0dHJpYnV0ZURlZmluaXRpb24iLCJhdHRyTmFtZSIsImRlZk5TIiwiZ2xvYmFsRGVmTlMiLCJkZWZpbmUiLCJ0eXBlIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiam9pbnQiLCJzaGFwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/CellView.mjs":
/*!***************************************************!*\
  !*** ./node_modules/jointjs/src/dia/CellView.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellView: () => (/* binding */ CellView)\n/* harmony export */ });\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/jointjs/src/config/index.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/jointjs/src/mvc/View.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n\n\n\n\n\n\n\nconst HighlightingTypes = {\n    DEFAULT: \"default\",\n    EMBEDDING: \"embedding\",\n    CONNECTING: \"connecting\",\n    MAGNET_AVAILABILITY: \"magnetAvailability\",\n    ELEMENT_AVAILABILITY: \"elementAvailability\"\n};\nconst Flags = {\n    TOOLS: \"TOOLS\"\n};\n// CellView base view and controller.\n// --------------------------------------------\n// This is the base view and controller for `ElementView` and `LinkView`.\nconst CellView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_1__.View.extend({\n    tagName: \"g\",\n    svgElement: true,\n    selector: \"root\",\n    metrics: null,\n    className: function() {\n        var classNames = [\n            \"cell\"\n        ];\n        var type = this.model.get(\"type\");\n        if (type) {\n            type.toLowerCase().split(\".\").forEach(function(value, index, list) {\n                classNames.push(\"type-\" + list.slice(0, index + 1).join(\"-\"));\n            });\n        }\n        return classNames.join(\" \");\n    },\n    _presentationAttributes: null,\n    _flags: null,\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.result)(this, \"presentationAttributes\");\n        for(var attribute in presentationAttributes){\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [\n                labels\n            ];\n            for(i = 0, n = labels.length; i < n; i++){\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1 << shift++;\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.result)(this, \"initFlag\");\n        if (!Array.isArray(initFlag)) initFlag = [\n            initFlag\n        ];\n        for(i = 0, n = initFlag.length; i < n; i++){\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1 << shift++;\n        }\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error(\"dia.CellView: Maximum number of flags exceeded.\");\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n    removeFlag: function(flag, label) {\n        return flag ^ flag & this.getFlag(label);\n    },\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for(var i = 0, n = label.length; i < n; i++)flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n    attributes: function() {\n        var cell = this.model;\n        return {\n            \"model-id\": cell.id,\n            \"data-type\": cell.attributes.type\n        };\n    },\n    constructor: function(options) {\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.guid)(this);\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_1__.View.call(this, options);\n    },\n    initialize: function() {\n        this.setFlags();\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_1__.View.prototype.initialize.apply(this, arguments);\n        this.cleanNodesCache();\n        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n        this.$el.data(\"view\", this);\n        this.startListening();\n    },\n    startListening: function() {\n        this.listenTo(this.model, \"change\", this.onAttributesChange);\n    },\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, \"UPDATE\")) flag |= this.getFlag(\"RENDER\");\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n    parseDOMJSON: function(markup, root) {\n        var doc = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.parseDOMJSON)(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for(var group in groups){\n            if (selectors[group]) throw new Error(\"dia.CellView: ambiguous group selector\");\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error(\"dia.CellView: ambiguous root selector.\");\n            selectors[rootSelector] = root;\n        }\n        return {\n            fragment: doc.fragment,\n            selectors: selectors\n        };\n    },\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('vertexMove')`, `can('labelMove')`.\n    can: function(feature) {\n        var interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isFunction)(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(interactive) && interactive[feature] !== false || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(interactive) && interactive !== false;\n    },\n    findBySelector: function(selector, root, selectors) {\n        root || (root = this.el);\n        selectors || (selectors = this.selectors);\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === \".\") return [\n            root\n        ];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [\n                    nodes\n                ];\n            }\n        }\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (_config_index_mjs__WEBPACK_IMPORTED_MODULE_4__.config.useCSSSelectors) return jquery__WEBPACK_IMPORTED_MODULE_0__(root).find(selector).toArray();\n        return [];\n    },\n    notify: function(eventName) {\n        if (this.paper) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [\n                eventName\n            ].concat(args));\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [\n                eventName,\n                this\n            ].concat(args));\n        }\n    },\n    getBBox: function(opt) {\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n        return this.paper.localToPaperRect(bbox);\n    },\n    getNodeBBox: function(magnet) {\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n    getNodeRotateMatrix (node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix();\n    },\n    getNodeUnrotatedBBox: function(magnet) {\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n    getRootTranslateMatrix: function() {\n        var model = this.model;\n        var position = model.position();\n        var mt = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n    getRootRotateMatrix: function() {\n        var mr = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === \"string\") {\n            [node = rootNode] = this.findBySelector(el);\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = node !== rootNode;\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch(true){\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n    highlight: function(el, opt) {\n        return this._notifyHighlight(\"cell:highlight\", el, opt);\n    },\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight(\"cell:unhighlight\", el, opt);\n    },\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n        do {\n            const magnetAttribute = magnet.getAttribute(\"magnet\");\n            const isMagnetRoot = magnet === root;\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== \"false\") {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        }while (magnet);\n        return undefined;\n    },\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const [proxyNode] = this.findBySelector(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n        var selector;\n        if (el === this.el) {\n            if (typeof prevSelector === \"string\") selector = \"> \" + prevSelector;\n            return selector;\n        }\n        if (el) {\n            var nthChild = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(el).index() + 1;\n            selector = el.tagName + \":nth-child(\" + nthChild + \")\";\n            if (prevSelector) {\n                selector += \" > \" + prevSelector;\n            }\n            selector = this.getSelector(el.parentNode, selector);\n        }\n        return selector;\n    },\n    addLinkFromMagnet: function(magnet, x, y) {\n        var paper = this.paper;\n        var graph = paper.model;\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, \"source\"),\n            target: {\n                x: x,\n                y: y\n            }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n        return link.findView(paper);\n    },\n    getLinkEnd: function(magnet, ...args) {\n        var model = this.model;\n        var id = model.id;\n        var port = this.findAttribute(\"port\", magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        var selector = magnet.getAttribute(\"joint-selector\");\n        var end = {\n            id: id\n        };\n        if (selector != null) end.magnet = selector;\n        if (port != null) {\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === \"function\") {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n    getMagnetFromLinkEnd: function(end) {\n        var root = this.el;\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || root;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findBySelector(selector, root, this.selectors)[0];\n        }\n        return this.findProxyNode(magnet, \"magnet\");\n    },\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch(\"add-link\");\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove(\"target\", {\n            whenNotAllowed: \"remove\"\n        }));\n        this.eventData(evt, {\n            linkView\n        });\n    },\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === \"onleave\") {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch(\"add-link\");\n    },\n    getAttributeDefinition: function(attrName) {\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n    setNodeAttributes: function(node, attrs) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(attrs)) {\n            if (node instanceof SVGElement) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(node).attr(attrs);\n            } else {\n                jquery__WEBPACK_IMPORTED_MODULE_0__(node).attr(attrs);\n            }\n        }\n    },\n    processNodeAttributes: function(node, attrs) {\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        // divide the attributes between normal and special\n        for(attrName in attrs){\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            attrVal = attrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def && (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isFunction)(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {\n                if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isString)(def.set)) {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[def.set] = attrVal;\n                }\n                if (attrVal !== null) {\n                    relatives.push(attrName, def);\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toKebabCase)(attrName)] = attrVal;\n            }\n        }\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for(i = 0, n = relatives.length; i < n; i += 2){\n            attrName = relatives[i];\n            def = relatives[i + 1];\n            attrVal = attrs[attrName];\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isFunction)(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isFunction)(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isFunction)(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n        return {\n            raw: attrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n        opt || (opt = {});\n        var attrName, attrVal, def;\n        var rawAttrs = attrs.raw || {};\n        var nodeAttrs = attrs.normal || {};\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n        for(attrName in setAttrs){\n            attrVal = setAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(setResult)) {\n                (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].transformStringToMatrix(nodeTransform);\n        var nodePosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Point)(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.omit)(nodeAttrs, \"transform\");\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n        var positioned = false;\n        for(attrName in positionAttrs){\n            attrVal = positionAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n            if (translation) {\n                nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Point)(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for(attrName in offsetAttrs){\n                    attrVal = offsetAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);\n                    if (translation) {\n                        nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Point)(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute(\"transform\", _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].matrixToTransformString(nodeMatrix));\n        // TODO: store nodeMatrix metrics?\n        }\n    },\n    getNodeScale: function(node, scalableNode) {\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n        return {\n            sx: sx,\n            sy: sy\n        };\n    },\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n    nodeCache: function(magnet) {\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n    getNodeData: function(magnet) {\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n    getNodeBoundingRect: function(magnet) {\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(magnet).getBBox();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect(metrics.boundingRect);\n    },\n    getNodeMatrix: function(magnet) {\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(magnet).getTransformToElement(target);\n        }\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix(metrics.magnetMatrix);\n    },\n    getNodeShape: function(magnet) {\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for(var selector in attrs){\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for(i = 0, n = selected.length; i < n; i++){\n                var node = selected[i];\n                nodeId = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = selectors && selectors[selector] === node;\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [\n                            prevNodeAttrs.attributes\n                        ];\n                        prevNodeAttrs.selectedLength = [\n                            prevNodeAttrs.selectedLength\n                        ];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.sortedIndex)(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n        for(i = 0, n = mergeIds.length; i < n; i++){\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.merge)({}, ...nodeAttrs.attributes.reverse());\n        }\n        return nodesAttrs;\n    },\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (// Explicitly defined `fromPoint` option\n        opt.fromPoint || // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n        // It holds the element when a touchstart triggered.\n        type === \"touchmove\" || type === \"touchend\" || // Pointermove/Pointerup event with the pointer captured\n        \"pointerId\" in evt && target.hasPointerCapture(evt.pointerId)) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n        return target;\n    },\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect)());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n        for(var nodeId in nodesAttrs){\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, processedAttrs.normal);\n            } else {\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n        relativeItems.push(...relativeRefItems);\n        for(let i = 0, n = relativeItems.length; i < n; i++){\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ensureId(refNode) : \"\";\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = refNode ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(refNode).getBBox({\n                    target: getCommonAncestorNode(node, refNode)\n                }) : opt.rootBBox;\n            }\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)(processedAttrs.set, roProcessedAttrs.set);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)(processedAttrs.position, roProcessedAttrs.position);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)(processedAttrs.offset, roProcessedAttrs.offset);\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n    // Lifecycle methods\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount (isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.mount(this);\n    },\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach () {\n        this.unmountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.unmount(this);\n    },\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n    _toolsView: null,\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return toolsView.getName() === name;\n    },\n    addTools: function(toolsView) {\n        this.removeTools();\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({\n                relatedView: this\n            });\n            toolsView.listenTo(this.paper, \"tools:event\", this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n    unmountTools () {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n    mountTools () {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n    updateTools: function(opt) {\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n    removeTools: function() {\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n    hideTools: function() {\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n    showTools: function() {\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n    onToolEvent: function(event) {\n        switch(event){\n            case \"remove\":\n                this.removeTools();\n                break;\n            case \"hide\":\n                this.hideTools();\n                break;\n            case \"show\":\n                this.showTools();\n                break;\n        }\n    },\n    removeHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.remove(this);\n    },\n    updateHighlighters: function(dirty = false) {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.update(this, null, dirty);\n    },\n    transformHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.transform(this);\n    },\n    // Interaction. The controller part.\n    // ---------------------------------\n    preventDefaultInteraction (evt) {\n        this.eventData(evt, {\n            defaultInteractionPrevented: true\n        });\n    },\n    isDefaultInteractionPrevented (evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n    pointerdblclick: function(evt, x, y) {\n        this.notify(\"cell:pointerdblclick\", evt, x, y);\n    },\n    pointerclick: function(evt, x, y) {\n        this.notify(\"cell:pointerclick\", evt, x, y);\n    },\n    contextmenu: function(evt, x, y) {\n        this.notify(\"cell:contextmenu\", evt, x, y);\n    },\n    pointerdown: function(evt, x, y) {\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch(\"pointer\");\n            this.eventData(evt, {\n                graph\n            });\n        }\n        this.notify(\"cell:pointerdown\", evt, x, y);\n    },\n    pointermove: function(evt, x, y) {\n        this.notify(\"cell:pointermove\", evt, x, y);\n    },\n    pointerup: function(evt, x, y) {\n        const { graph } = this.eventData(evt);\n        this.notify(\"cell:pointerup\", evt, x, y);\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch(\"pointer\", {\n                cell: this.model\n            });\n        }\n    },\n    mouseover: function(evt) {\n        this.notify(\"cell:mouseover\", evt);\n    },\n    mouseout: function(evt) {\n        this.notify(\"cell:mouseout\", evt);\n    },\n    mouseenter: function(evt) {\n        this.notify(\"cell:mouseenter\", evt);\n    },\n    mouseleave: function(evt) {\n        this.notify(\"cell:mouseleave\", evt);\n    },\n    mousewheel: function(evt, x, y, delta) {\n        this.notify(\"cell:mousewheel\", evt, x, y, delta);\n    },\n    onevent: function(evt, eventName, x, y) {\n        this.notify(eventName, evt, x, y);\n    },\n    onmagnet: function() {\n    // noop\n    },\n    magnetpointerdblclick: function() {\n    // noop\n    },\n    magnetcontextmenu: function() {\n    // noop\n    },\n    checkMouseleave (evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, {\n            fromPoint: true\n        });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n    setInteractivity: function(value) {\n        this.options.interactive = value;\n    }\n}, {\n    Flags,\n    Highlighting: HighlightingTypes,\n    addPresentationAttributes: function(presentationAttributes) {\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.merge)({}, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.result)(this.prototype, \"presentationAttributes\"), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === \"string\") a = [\n                a\n            ];\n            if (typeof b === \"string\") b = [\n                b\n            ];\n            if (Array.isArray(a) && Array.isArray(b)) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.uniq)(a.concat(b));\n        });\n    }\n});\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    }while (parent);\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0NlbGxWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0w7QUFpQmI7QUFDa0I7QUFDZDtBQUNSO0FBQ2lDO0FBRXhELE1BQU1zQixvQkFBb0I7SUFDdEJDLFNBQVM7SUFDVEMsV0FBVztJQUNYQyxZQUFZO0lBQ1pDLHFCQUFxQjtJQUNyQkMsc0JBQXNCO0FBQzFCO0FBRUEsTUFBTUMsUUFBUTtJQUNWQyxPQUFPO0FBQ1g7QUFFQSxxQ0FBcUM7QUFDckMsK0NBQStDO0FBRS9DLHlFQUF5RTtBQUNsRSxNQUFNQyxXQUFXN0IsZ0RBQUlBLENBQUM4QixNQUFNLENBQUM7SUFFaENDLFNBQVM7SUFFVEMsWUFBWTtJQUVaQyxVQUFVO0lBRVZDLFNBQVM7SUFFVEMsV0FBVztRQUVQLElBQUlDLGFBQWE7WUFBQztTQUFPO1FBQ3pCLElBQUlDLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNDLEdBQUcsQ0FBQztRQUUxQixJQUFJRixNQUFNO1lBRU5BLEtBQUtHLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxTQUFTQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtnQkFDN0RULFdBQVdVLElBQUksQ0FBQyxVQUFVRCxLQUFLRSxLQUFLLENBQUMsR0FBR0gsUUFBUSxHQUFHSSxJQUFJLENBQUM7WUFDNUQ7UUFDSjtRQUVBLE9BQU9aLFdBQVdZLElBQUksQ0FBQztJQUMzQjtJQUVBQyx5QkFBeUI7SUFDekJDLFFBQVE7SUFFUkMsVUFBVTtRQUNOLElBQUlDLFFBQVEsQ0FBQztRQUNiLElBQUlDLGFBQWEsQ0FBQztRQUNsQixJQUFJQyxRQUFRO1FBQ1osSUFBSUMsR0FBR0MsR0FBR0M7UUFDVixJQUFJQyx5QkFBeUI5Qyx1REFBTUEsQ0FBQyxJQUFJLEVBQUU7UUFDMUMsSUFBSyxJQUFJK0MsYUFBYUQsdUJBQXdCO1lBQzFDLElBQUksQ0FBQ0EsdUJBQXVCRSxjQUFjLENBQUNELFlBQVk7WUFDdkQsSUFBSUUsU0FBU0gsc0JBQXNCLENBQUNDLFVBQVU7WUFDOUMsSUFBSSxDQUFDRyxNQUFNQyxPQUFPLENBQUNGLFNBQVNBLFNBQVM7Z0JBQUNBO2FBQU87WUFDN0MsSUFBS04sSUFBSSxHQUFHQyxJQUFJSyxPQUFPRyxNQUFNLEVBQUVULElBQUlDLEdBQUdELElBQUs7Z0JBQ3ZDRSxRQUFRSSxNQUFNLENBQUNOLEVBQUU7Z0JBQ2pCLElBQUlVLE9BQU9iLEtBQUssQ0FBQ0ssTUFBTTtnQkFDdkIsSUFBSSxDQUFDUSxNQUFNO29CQUNQQSxPQUFPYixLQUFLLENBQUNLLE1BQU0sR0FBRyxLQUFJSDtnQkFDOUI7Z0JBQ0FELFVBQVUsQ0FBQ00sVUFBVSxJQUFJTTtZQUM3QjtRQUNKO1FBQ0EsSUFBSUMsV0FBV3RELHVEQUFNQSxDQUFDLElBQUksRUFBRTtRQUM1QixJQUFJLENBQUNrRCxNQUFNQyxPQUFPLENBQUNHLFdBQVdBLFdBQVc7WUFBQ0E7U0FBUztRQUNuRCxJQUFLWCxJQUFJLEdBQUdDLElBQUlVLFNBQVNGLE1BQU0sRUFBRVQsSUFBSUMsR0FBR0QsSUFBSztZQUN6Q0UsUUFBUVMsUUFBUSxDQUFDWCxFQUFFO1lBQ25CLElBQUksQ0FBQ0gsS0FBSyxDQUFDSyxNQUFNLEVBQUVMLEtBQUssQ0FBQ0ssTUFBTSxHQUFHLEtBQUlIO1FBQzFDO1FBRUEsdUNBQXVDO1FBQ3ZDLCtCQUErQjtRQUMvQixJQUFJQSxRQUFRLElBQUksTUFBTSxJQUFJYSxNQUFNO1FBRWhDLElBQUksQ0FBQ2pCLE1BQU0sR0FBR0U7UUFDZCxJQUFJLENBQUNILHVCQUF1QixHQUFHSTtJQUNuQztJQUVBZSxTQUFTLFNBQVNILElBQUksRUFBRVIsS0FBSztRQUN6QixPQUFPUSxPQUFPLElBQUksQ0FBQ0ksT0FBTyxDQUFDWjtJQUMvQjtJQUVBYSxZQUFZLFNBQVNMLElBQUksRUFBRVIsS0FBSztRQUM1QixPQUFPUSxPQUFRQSxPQUFPLElBQUksQ0FBQ0ksT0FBTyxDQUFDWjtJQUN2QztJQUVBWSxTQUFTLFNBQVNaLEtBQUs7UUFDbkIsSUFBSUwsUUFBUSxJQUFJLENBQUNGLE1BQU07UUFDdkIsSUFBSSxDQUFDRSxPQUFPLE9BQU87UUFDbkIsSUFBSWEsT0FBTztRQUNYLElBQUlILE1BQU1DLE9BQU8sQ0FBQ04sUUFBUTtZQUN0QixJQUFLLElBQUlGLElBQUksR0FBR0MsSUFBSUMsTUFBTU8sTUFBTSxFQUFFVCxJQUFJQyxHQUFHRCxJQUFLVSxRQUFRYixLQUFLLENBQUNLLEtBQUssQ0FBQ0YsRUFBRSxDQUFDO1FBQ3pFLE9BQU87WUFDSFUsUUFBUWIsS0FBSyxDQUFDSyxNQUFNO1FBQ3hCO1FBQ0EsT0FBT1E7SUFDWDtJQUVBWixZQUFZO1FBQ1IsSUFBSWtCLE9BQU8sSUFBSSxDQUFDakMsS0FBSztRQUNyQixPQUFPO1lBQ0gsWUFBWWlDLEtBQUtDLEVBQUU7WUFDbkIsYUFBYUQsS0FBS2xCLFVBQVUsQ0FBQ2hCLElBQUk7UUFDckM7SUFDSjtJQUVBb0MsYUFBYSxTQUFTQyxPQUFPO1FBRXpCLHNHQUFzRztRQUN0RyxvR0FBb0c7UUFDcEcsa0dBQWtHO1FBQ2xHLDJCQUEyQjtRQUMzQkEsUUFBUUYsRUFBRSxHQUFHRSxRQUFRRixFQUFFLElBQUl0RSxxREFBSUEsQ0FBQyxJQUFJO1FBRXBDRixnREFBSUEsQ0FBQzJFLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBQ3BCO0lBRUFFLFlBQVk7UUFFUixJQUFJLENBQUN6QixRQUFRO1FBRWJuRCxnREFBSUEsQ0FBQzZFLFNBQVMsQ0FBQ0QsVUFBVSxDQUFDRSxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUV0QyxJQUFJLENBQUNDLGVBQWU7UUFFcEIsc0dBQXNHO1FBQ3RHLElBQUksQ0FBQ0MsR0FBRyxDQUFDQyxJQUFJLENBQUMsUUFBUSxJQUFJO1FBRTFCLElBQUksQ0FBQ0MsY0FBYztJQUN2QjtJQUVBQSxnQkFBZ0I7UUFDWixJQUFJLENBQUNDLFFBQVEsQ0FBQyxJQUFJLENBQUM5QyxLQUFLLEVBQUUsVUFBVSxJQUFJLENBQUMrQyxrQkFBa0I7SUFDL0Q7SUFFQUEsb0JBQW9CLFNBQVMvQyxLQUFLLEVBQUVnRCxHQUFHO1FBQ25DLElBQUlyQixPQUFPM0IsTUFBTWlELGFBQWEsQ0FBQyxJQUFJLENBQUN0Qyx1QkFBdUI7UUFDM0QsSUFBSXFDLElBQUlFLGFBQWEsSUFBSSxDQUFDdkIsTUFBTTtRQUNoQyxJQUFJcUIsSUFBSUcsS0FBSyxJQUFJLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ0gsTUFBTSxXQUFXQSxRQUFRLElBQUksQ0FBQ0ksT0FBTyxDQUFDO1FBQ3BFLDhDQUE4QztRQUM5QyxxQkFBcUI7UUFDckIsSUFBSWlCLElBQUlJLElBQUksRUFBRUosSUFBSUssS0FBSyxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsYUFBYSxDQUFDM0IsTUFBTXFCO0lBQzdCO0lBRUFNLGVBQWUsU0FBU3hDLEtBQUssRUFBRWtDLEdBQUc7UUFDOUIsTUFBTSxFQUFFTyxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3RCLElBQUlBLFNBQVN6QyxRQUFRLEdBQUc7WUFDcEJ5QyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUxQyxPQUFPLElBQUksQ0FBQzJDLGVBQWUsRUFBRVQ7UUFDL0Q7SUFDSjtJQUVBbEYsY0FBYyxTQUFTNEYsTUFBTSxFQUFFQyxJQUFJO1FBRS9CLElBQUlDLE1BQU05Riw2REFBWUEsQ0FBQzRGO1FBQ3ZCLElBQUlHLFlBQVlELElBQUlDLFNBQVM7UUFDN0IsSUFBSUMsU0FBU0YsSUFBSUcsY0FBYztRQUMvQixJQUFLLElBQUlDLFNBQVNGLE9BQVE7WUFDdEIsSUFBSUQsU0FBUyxDQUFDRyxNQUFNLEVBQUUsTUFBTSxJQUFJbkMsTUFBTTtZQUN0Q2dDLFNBQVMsQ0FBQ0csTUFBTSxHQUFHRixNQUFNLENBQUNFLE1BQU07UUFDcEM7UUFDQSxJQUFJTCxNQUFNO1lBQ04sSUFBSU0sZUFBZSxJQUFJLENBQUN0RSxRQUFRO1lBQ2hDLElBQUlrRSxTQUFTLENBQUNJLGFBQWEsRUFBRSxNQUFNLElBQUlwQyxNQUFNO1lBQzdDZ0MsU0FBUyxDQUFDSSxhQUFhLEdBQUdOO1FBQzlCO1FBQ0EsT0FBTztZQUFFTyxVQUFVTixJQUFJTSxRQUFRO1lBQUVMLFdBQVdBO1FBQVU7SUFDMUQ7SUFFQSwyRUFBMkU7SUFDM0Usb0RBQW9EO0lBQ3BETSxLQUFLLFNBQVNDLE9BQU87UUFFakIsSUFBSUMsY0FBY3RHLDJEQUFVQSxDQUFDLElBQUksQ0FBQ3FFLE9BQU8sQ0FBQ2lDLFdBQVcsSUFDL0MsSUFBSSxDQUFDakMsT0FBTyxDQUFDaUMsV0FBVyxDQUFDLElBQUksSUFDN0IsSUFBSSxDQUFDakMsT0FBTyxDQUFDaUMsV0FBVztRQUU5QixPQUFPLDBEQUFVQSxnQkFBZ0JBLFdBQVcsQ0FBQ0QsUUFBUSxLQUFLLFNBQ3JEbEcsMERBQVNBLENBQUNtRyxnQkFBZ0JBLGdCQUFnQjtJQUNuRDtJQUVBQyxnQkFBZ0IsU0FBUzNFLFFBQVEsRUFBRWdFLElBQUksRUFBRUUsU0FBUztRQUU5Q0YsUUFBU0EsQ0FBQUEsT0FBTyxJQUFJLENBQUNZLEVBQUU7UUFDdkJWLGFBQWNBLENBQUFBLFlBQVksSUFBSSxDQUFDQSxTQUFTO1FBRXhDLG1FQUFtRTtRQUNuRSx1RUFBdUU7UUFDdkUsSUFBSSxDQUFDbEUsWUFBWUEsYUFBYSxLQUFLLE9BQU87WUFBQ2dFO1NBQUs7UUFDaEQsSUFBSUUsV0FBVztZQUNYLElBQUlXLFFBQVFYLFNBQVMsQ0FBQ2xFLFNBQVM7WUFDL0IsSUFBSTZFLE9BQU87Z0JBQ1AsSUFBSWhELE1BQU1DLE9BQU8sQ0FBQytDLFFBQVEsT0FBT0E7Z0JBQ2pDLE9BQU87b0JBQUNBO2lCQUFNO1lBQ2xCO1FBQ0o7UUFFQSxzQ0FBc0M7UUFDdEMsMkRBQTJEO1FBQzNELElBQUkvRyxxREFBTUEsQ0FBQ2dILGVBQWUsRUFBRSxPQUFPNUYsbUNBQUNBLENBQUM4RSxNQUFNZSxJQUFJLENBQUMvRSxVQUFVZ0YsT0FBTztRQUVqRSxPQUFPLEVBQUU7SUFDYjtJQUVBQyxRQUFRLFNBQVNDLFNBQVM7UUFFdEIsSUFBSSxJQUFJLENBQUN0QixLQUFLLEVBQUU7WUFFWixJQUFJdUIsT0FBT3RELE1BQU1lLFNBQVMsQ0FBQzlCLEtBQUssQ0FBQzRCLElBQUksQ0FBQ0ksV0FBVztZQUVqRCxzRUFBc0U7WUFDdEUsSUFBSSxDQUFDc0MsT0FBTyxDQUFDdkMsS0FBSyxDQUFDLElBQUksRUFBRTtnQkFBQ3FDO2FBQVUsQ0FBQ0csTUFBTSxDQUFDRjtZQUU1QyxzRUFBc0U7WUFDdEUsSUFBSSxDQUFDdkIsS0FBSyxDQUFDd0IsT0FBTyxDQUFDdkMsS0FBSyxDQUFDLElBQUksQ0FBQ2UsS0FBSyxFQUFFO2dCQUFDc0I7Z0JBQVcsSUFBSTthQUFDLENBQUNHLE1BQU0sQ0FBQ0Y7UUFDbEU7SUFDSjtJQUVBRyxTQUFTLFNBQVNqQyxHQUFHO1FBRWpCLElBQUlrQztRQUNKLElBQUlsQyxPQUFPQSxJQUFJbUMsZ0JBQWdCLEVBQUU7WUFDN0IsSUFBSW5GLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1lBQ3RCa0YsT0FBT2xGLE1BQU1pRixPQUFPLEdBQUdDLElBQUksQ0FBQ2xGLE1BQU1vRixLQUFLO1FBQzNDLE9BQU87WUFDSEYsT0FBTyxJQUFJLENBQUNHLFdBQVcsQ0FBQyxJQUFJLENBQUNkLEVBQUU7UUFDbkM7UUFFQSxPQUFPLElBQUksQ0FBQ2hCLEtBQUssQ0FBQytCLGdCQUFnQixDQUFDSjtJQUN2QztJQUVBRyxhQUFhLFNBQVNFLE1BQU07UUFFeEIsTUFBTUMsT0FBTyxJQUFJLENBQUNDLG1CQUFtQixDQUFDRjtRQUN0QyxNQUFNRyxrQkFBa0IsSUFBSSxDQUFDQyxzQkFBc0IsR0FBR0MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNOO1FBQ3hGLE1BQU1PLGVBQWUsSUFBSSxDQUFDQyxhQUFhLENBQUNSO1FBQ3hDLE9BQU8zRyxvREFBQ0EsQ0FBQ29ILGFBQWEsQ0FBQ1IsTUFBTUUsZ0JBQWdCRSxRQUFRLENBQUNFO0lBQzFEO0lBRUFELHFCQUFvQkksSUFBSTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLElBQUksSUFBSSxDQUFDQSxhQUFhLENBQUNDLFFBQVEsQ0FBQ0YsT0FBTztZQUMxRCx1RUFBdUU7WUFDdkUseURBQXlEO1lBQ3pELE9BQU8sSUFBSSxDQUFDRyxtQkFBbUI7UUFDbkM7UUFDQSxvQ0FBb0M7UUFDcEMsT0FBT3hILG9EQUFDQSxDQUFDeUgsZUFBZTtJQUM1QjtJQUVBQyxzQkFBc0IsU0FBU2YsTUFBTTtRQUVqQyxJQUFJQyxPQUFPLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNGO1FBQ3BDLElBQUlPLGVBQWUsSUFBSSxDQUFDQyxhQUFhLENBQUNSO1FBQ3RDLElBQUlnQixrQkFBa0IsSUFBSSxDQUFDWixzQkFBc0I7UUFDakQsT0FBTy9HLG9EQUFDQSxDQUFDb0gsYUFBYSxDQUFDUixNQUFNZSxnQkFBZ0JYLFFBQVEsQ0FBQ0U7SUFDMUQ7SUFFQUgsd0JBQXdCO1FBRXBCLElBQUkzRixRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJd0csV0FBV3hHLE1BQU13RyxRQUFRO1FBQzdCLElBQUlDLEtBQUs3SCxvREFBQ0EsQ0FBQ3lILGVBQWUsR0FBR0ssU0FBUyxDQUFDRixTQUFTRyxDQUFDLEVBQUVILFNBQVNJLENBQUM7UUFDN0QsT0FBT0g7SUFDWDtJQUVBTCxxQkFBcUI7UUFFakIsSUFBSVMsS0FBS2pJLG9EQUFDQSxDQUFDeUgsZUFBZTtRQUMxQixJQUFJckcsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSW9GLFFBQVFwRixNQUFNb0YsS0FBSztRQUN2QixJQUFJQSxPQUFPO1lBQ1AsSUFBSUYsT0FBT2xGLE1BQU1pRixPQUFPO1lBQ3hCLElBQUk2QixLQUFLNUIsS0FBSzZCLEtBQUssR0FBRztZQUN0QixJQUFJQyxLQUFLOUIsS0FBSytCLE1BQU0sR0FBRztZQUN2QkosS0FBS0EsR0FBR0gsU0FBUyxDQUFDSSxJQUFJRSxJQUFJRSxNQUFNLENBQUM5QixPQUFPc0IsU0FBUyxDQUFDLENBQUNJLElBQUksQ0FBQ0U7UUFDNUQ7UUFDQSxPQUFPSDtJQUNYO0lBRUFNLGtCQUFrQixTQUFTdEMsU0FBUyxFQUFFTixFQUFFLEVBQUV2QixNQUFNLENBQUMsQ0FBQztRQUM5QyxNQUFNLEVBQUV1QixJQUFJNkMsUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUM3QixJQUFJbkI7UUFDSixJQUFJLE9BQU8xQixPQUFPLFVBQVU7WUFDeEIsQ0FBQzBCLE9BQU9tQixRQUFRLENBQUMsR0FBRyxJQUFJLENBQUM5QyxjQUFjLENBQUNDO1FBQzVDLE9BQU87WUFDSCxDQUFDMEIsT0FBT21CLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQ3ZJLENBQUMsQ0FBQzBGO1FBQy9CO1FBQ0Esc0VBQXNFO1FBQ3RFdkIsSUFBSXFFLE9BQU8sR0FBSXBCLFNBQVNtQjtRQUN4Qix5Q0FBeUM7UUFDekMsSUFBSXBFLElBQUlqRCxJQUFJLEtBQUt1SCxXQUFXO1lBQ3hCLElBQUl2SDtZQUNKLE9BQVE7Z0JBQ0osS0FBS2lELElBQUl1RSxTQUFTO29CQUNkeEgsT0FBT2hCLGtCQUFrQkUsU0FBUztvQkFDbEM7Z0JBQ0osS0FBSytELElBQUl3RSxVQUFVO29CQUNmekgsT0FBT2hCLGtCQUFrQkcsVUFBVTtvQkFDbkM7Z0JBQ0osS0FBSzhELElBQUl5RSxrQkFBa0I7b0JBQ3ZCMUgsT0FBT2hCLGtCQUFrQkksbUJBQW1CO29CQUM1QztnQkFDSixLQUFLNkQsSUFBSTBFLG1CQUFtQjtvQkFDeEIzSCxPQUFPaEIsa0JBQWtCSyxvQkFBb0I7b0JBQzdDO2dCQUNKO29CQUNJVyxPQUFPaEIsa0JBQWtCQyxPQUFPO29CQUNoQztZQUNSO1lBQ0FnRSxJQUFJakQsSUFBSSxHQUFHQTtRQUNmO1FBQ0EsSUFBSSxDQUFDNkUsTUFBTSxDQUFDQyxXQUFXb0IsTUFBTWpEO1FBQzdCLE9BQU8sSUFBSTtJQUNmO0lBRUEyRSxXQUFXLFNBQVNwRCxFQUFFLEVBQUV2QixHQUFHO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDbUUsZ0JBQWdCLENBQUMsa0JBQWtCNUMsSUFBSXZCO0lBQ3ZEO0lBRUE0RSxhQUFhLFNBQVNyRCxFQUFFLEVBQUV2QixNQUFNLENBQUMsQ0FBQztRQUM5QixPQUFPLElBQUksQ0FBQ21FLGdCQUFnQixDQUFDLG9CQUFvQjVDLElBQUl2QjtJQUN6RDtJQUVBLGdHQUFnRztJQUNoRyw4REFBOEQ7SUFDOUQ2RSxZQUFZLFNBQVN0RCxFQUFFO1FBRW5CLE1BQU1aLE9BQU8sSUFBSSxDQUFDWSxFQUFFO1FBQ3BCLElBQUlnQixTQUFTLElBQUksQ0FBQzFHLENBQUMsQ0FBQzBGLEdBQUcsQ0FBQyxFQUFFO1FBQzFCLElBQUksQ0FBQ2dCLFFBQVE7WUFDVEEsU0FBUzVCO1FBQ2I7UUFFQSxHQUFHO1lBQ0MsTUFBTW1FLGtCQUFrQnZDLE9BQU93QyxZQUFZLENBQUM7WUFDNUMsTUFBTUMsZUFBZ0J6QyxXQUFXNUI7WUFDakMsSUFBSSxDQUFDbUUsbUJBQW1CRSxZQUFXLEtBQU1GLG9CQUFvQixTQUFTO2dCQUNsRSxPQUFPdkM7WUFDWDtZQUNBLElBQUl5QyxjQUFjO2dCQUNkLDZFQUE2RTtnQkFDN0UsbURBQW1EO2dCQUNuRCw2RUFBNkU7Z0JBQzdFLDRGQUE0RjtnQkFDNUYsT0FBT1Y7WUFDWDtZQUNBL0IsU0FBU0EsT0FBTzBDLFVBQVU7UUFDOUIsUUFBUzFDLFFBQVE7UUFFakIsT0FBTytCO0lBQ1g7SUFFQVksZUFBZSxTQUFTM0QsRUFBRSxFQUFFeEUsSUFBSTtRQUM1QndFLE1BQU9BLENBQUFBLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ25CLE1BQU00RCxlQUFlNUQsR0FBR3dELFlBQVksQ0FBQyxDQUFDLEVBQUVoSSxLQUFLLFNBQVMsQ0FBQztRQUN2RCxJQUFJb0ksY0FBYztZQUNkLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHLElBQUksQ0FBQzlELGNBQWMsQ0FBQzZEO1lBQ3hDLElBQUlDLFdBQVcsT0FBT0E7UUFDMUI7UUFDQSxPQUFPN0Q7SUFDWDtJQUVBLHFFQUFxRTtJQUNyRSxnRUFBZ0U7SUFDaEUsa0VBQWtFO0lBQ2xFOEQsYUFBYSxTQUFTOUQsRUFBRSxFQUFFK0QsWUFBWTtRQUVsQyxJQUFJM0k7UUFFSixJQUFJNEUsT0FBTyxJQUFJLENBQUNBLEVBQUUsRUFBRTtZQUNoQixJQUFJLE9BQU8rRCxpQkFBaUIsVUFBVTNJLFdBQVcsT0FBTzJJO1lBQ3hELE9BQU8zSTtRQUNYO1FBRUEsSUFBSTRFLElBQUk7WUFFSixJQUFJZ0UsV0FBVzNKLHdEQUFDQSxDQUFDMkYsSUFBSWpFLEtBQUssS0FBSztZQUMvQlgsV0FBVzRFLEdBQUc5RSxPQUFPLEdBQUcsZ0JBQWdCOEksV0FBVztZQUVuRCxJQUFJRCxjQUFjO2dCQUNkM0ksWUFBWSxRQUFRMkk7WUFDeEI7WUFFQTNJLFdBQVcsSUFBSSxDQUFDMEksV0FBVyxDQUFDOUQsR0FBRzBELFVBQVUsRUFBRXRJO1FBQy9DO1FBRUEsT0FBT0E7SUFDWDtJQUVBNkksbUJBQW1CLFNBQVNqRCxNQUFNLEVBQUVvQixDQUFDLEVBQUVDLENBQUM7UUFFcEMsSUFBSXJELFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlrRixRQUFRbEYsTUFBTXZELEtBQUs7UUFFdkIsSUFBSTBJLE9BQU9uRixNQUFNb0YsY0FBYyxDQUFDLElBQUksRUFBRXBEO1FBQ3RDbUQsS0FBS0UsR0FBRyxDQUFDO1lBQ0xDLFFBQVEsSUFBSSxDQUFDQyxVQUFVLENBQUN2RCxRQUFRb0IsR0FBR0MsR0FBRzhCLE1BQU07WUFDNUNLLFFBQVE7Z0JBQUVwQyxHQUFHQTtnQkFBR0MsR0FBR0E7WUFBRTtRQUN6QixHQUFHb0MsS0FBSyxDQUFDUCxPQUFPO1lBQ1pwRixPQUFPO1lBQ1A0RixJQUFJO1FBQ1I7UUFFQSxPQUFPUCxLQUFLUSxRQUFRLENBQUMzRjtJQUN6QjtJQUVBdUYsWUFBWSxTQUFTdkQsTUFBTSxFQUFFLEdBQUdULElBQUk7UUFFaEMsSUFBSTlFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlrQyxLQUFLbEMsTUFBTWtDLEVBQUU7UUFDakIsSUFBSWlILE9BQU8sSUFBSSxDQUFDQyxhQUFhLENBQUMsUUFBUTdEO1FBQ3RDLDBFQUEwRTtRQUMxRSxJQUFJNUYsV0FBVzRGLE9BQU93QyxZQUFZLENBQUM7UUFFbkMsSUFBSXNCLE1BQU07WUFBRW5ILElBQUlBO1FBQUc7UUFDbkIsSUFBSXZDLFlBQVksTUFBTTBKLElBQUk5RCxNQUFNLEdBQUc1RjtRQUNuQyxJQUFJd0osUUFBUSxNQUFNO1lBQ2RFLElBQUlGLElBQUksR0FBR0E7WUFDWCxJQUFJLENBQUNuSixNQUFNc0osT0FBTyxDQUFDSCxTQUFTLENBQUN4SixVQUFVO2dCQUNuQyxrREFBa0Q7Z0JBQ2xEMEosSUFBSTFKLFFBQVEsR0FBRyxJQUFJLENBQUMwSSxXQUFXLENBQUM5QztZQUNwQztRQUNKLE9BQU8sSUFBSTVGLFlBQVksUUFBUSxJQUFJLENBQUM0RSxFQUFFLEtBQUtnQixRQUFRO1lBQy9DOEQsSUFBSTFKLFFBQVEsR0FBRyxJQUFJLENBQUMwSSxXQUFXLENBQUM5QztRQUNwQztRQUVBLE9BQU8sSUFBSSxDQUFDZ0UsZ0JBQWdCLENBQUNGLEtBQUs5RCxXQUFXVDtJQUNqRDtJQUVBeUUsa0JBQWtCLFNBQVNGLEdBQUcsRUFBRTlELE1BQU0sRUFBRW9CLENBQUMsRUFBRUMsQ0FBQyxFQUFFOEIsSUFBSSxFQUFFYyxPQUFPO1FBQ3ZELE1BQU0sRUFBRWpHLEtBQUssRUFBRSxHQUFHLElBQUk7UUFDdEIsTUFBTSxFQUFFa0csa0JBQWtCLEVBQUUsR0FBR2xHLE1BQU1uQixPQUFPO1FBQzVDLElBQUksT0FBT3FILHVCQUF1QixZQUFZO1lBQzFDLElBQUlDLFdBQVdELG1CQUFtQnBILElBQUksQ0FBQ2tCLE9BQU84RixLQUFLLElBQUksRUFBRTlELFFBQVEsSUFBSTdHLCtDQUFLQSxDQUFDaUksR0FBR0MsSUFBSThCLE1BQU1jLFNBQVNqRztZQUNqRyxJQUFJbUcsVUFBVSxPQUFPQTtRQUN6QjtRQUNBLE9BQU9MO0lBQ1g7SUFFQU0sc0JBQXNCLFNBQVNOLEdBQUc7UUFFOUIsSUFBSTFGLE9BQU8sSUFBSSxDQUFDWSxFQUFFO1FBQ2xCLElBQUk0RSxPQUFPRSxJQUFJRixJQUFJO1FBQ25CLElBQUl4SixXQUFXMEosSUFBSTlELE1BQU07UUFDekIsSUFBSXZGLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUl1RjtRQUNKLElBQUk0RCxRQUFRLFFBQVFuSixNQUFNNEosU0FBUyxNQUFNNUosTUFBTXNKLE9BQU8sQ0FBQ0gsT0FBTztZQUMxRDVELFNBQVMsSUFBSSxDQUFDc0UsWUFBWSxDQUFDVixNQUFNeEosYUFBYWdFO1FBQ2xELE9BQU87WUFDSCxJQUFJLENBQUNoRSxVQUFVQSxXQUFXMEosSUFBSTFKLFFBQVE7WUFDdEMsSUFBSSxDQUFDQSxZQUFZd0osUUFBUSxNQUFNO2dCQUMzQix5REFBeUQ7Z0JBQ3pELHFEQUFxRDtnQkFDckR4SixXQUFXLFlBQVl3SixPQUFPO1lBQ2xDO1lBQ0E1RCxTQUFTLElBQUksQ0FBQ2pCLGNBQWMsQ0FBQzNFLFVBQVVnRSxNQUFNLElBQUksQ0FBQ0UsU0FBUyxDQUFDLENBQUMsRUFBRTtRQUNuRTtRQUVBLE9BQU8sSUFBSSxDQUFDcUUsYUFBYSxDQUFDM0MsUUFBUTtJQUN0QztJQUVBdUUsZUFBZSxTQUFTQyxHQUFHLEVBQUV4RSxNQUFNLEVBQUVvQixDQUFDLEVBQUVDLENBQUM7UUFDckMsSUFBSSxDQUFDNUcsS0FBSyxDQUFDZ0ssVUFBVSxDQUFDO1FBQ3RCLE1BQU1DLFdBQVcsSUFBSSxDQUFDekIsaUJBQWlCLENBQUNqRCxRQUFRb0IsR0FBR0M7UUFDbkQsaUNBQWlDO1FBQ2pDcUQsU0FBU0MsaUJBQWlCLENBQUNILEtBQUtwRCxHQUFHQztRQUNuQ3FELFNBQVNFLFNBQVMsQ0FBQ0osS0FBS0UsU0FBU0csa0JBQWtCLENBQUMsVUFBVTtZQUFFQyxnQkFBZ0I7UUFBUztRQUN6RixJQUFJLENBQUNGLFNBQVMsQ0FBQ0osS0FBSztZQUFFRTtRQUFTO0lBQ25DO0lBRUFLLFVBQVUsU0FBU1AsR0FBRyxFQUFFcEQsQ0FBQyxFQUFFQyxDQUFDO1FBQ3hCLElBQUloRSxPQUFPLElBQUksQ0FBQ3VILFNBQVMsQ0FBQ0o7UUFDMUIsSUFBSUUsV0FBV3JILEtBQUtxSCxRQUFRO1FBQzVCLElBQUlBLFVBQVU7WUFDVkEsU0FBU00sV0FBVyxDQUFDUixLQUFLcEQsR0FBR0M7UUFDakMsT0FBTztZQUNILElBQUlyRCxRQUFRLElBQUksQ0FBQ0EsS0FBSztZQUN0QixJQUFJaUgsa0JBQWtCakgsTUFBTW5CLE9BQU8sQ0FBQ29JLGVBQWU7WUFDbkQsSUFBSUMsZ0JBQWdCLElBQUksQ0FBQ0MsY0FBYyxDQUFDWDtZQUN4QyxJQUFJWSxlQUFlL0gsS0FBSytILFlBQVk7WUFDcEMsSUFBSUgsb0JBQW9CLFdBQVc7Z0JBQy9CLHFEQUFxRDtnQkFDckQsSUFBSUcsaUJBQWlCRixpQkFBaUI3TCx3REFBQ0EsQ0FBQytMLGNBQWN4RSxRQUFRLENBQUNzRSxnQkFBZ0I7WUFDbkYsT0FBTztnQkFDSCxtREFBbUQ7Z0JBQ25ELElBQUlsSCxNQUFNNEcsU0FBUyxDQUFDSixLQUFLYSxVQUFVLElBQUlKLGlCQUFpQjtZQUM1RDtZQUNBLElBQUksQ0FBQ1YsYUFBYSxDQUFDQyxLQUFLWSxjQUFjaEUsR0FBR0M7UUFDN0M7SUFDSjtJQUVBaUUsYUFBYSxTQUFTZCxHQUFHLEVBQUVwRCxDQUFDLEVBQUVDLENBQUM7UUFDM0IsSUFBSWhFLE9BQU8sSUFBSSxDQUFDdUgsU0FBUyxDQUFDSjtRQUMxQixJQUFJRSxXQUFXckgsS0FBS3FILFFBQVE7UUFDNUIsSUFBSSxDQUFDQSxVQUFVO1FBQ2ZBLFNBQVNhLFNBQVMsQ0FBQ2YsS0FBS3BELEdBQUdDO1FBQzNCLElBQUksQ0FBQzVHLEtBQUssQ0FBQytLLFNBQVMsQ0FBQztJQUN6QjtJQUVBQyx3QkFBd0IsU0FBU0MsUUFBUTtRQUVyQyxPQUFPLElBQUksQ0FBQ2pMLEtBQUssQ0FBQ21DLFdBQVcsQ0FBQzZJLHNCQUFzQixDQUFDQztJQUN6RDtJQUVBQyxtQkFBbUIsU0FBU2pGLElBQUksRUFBRWtGLEtBQUs7UUFFbkMsSUFBSSxDQUFDaE4sd0RBQU9BLENBQUNnTixRQUFRO1lBQ2pCLElBQUlsRixnQkFBZ0JtRixZQUFZO2dCQUM1QnhNLHdEQUFDQSxDQUFDcUgsTUFBTW9GLElBQUksQ0FBQ0Y7WUFDakIsT0FBTztnQkFDSHRNLG1DQUFDQSxDQUFDb0gsTUFBTW9GLElBQUksQ0FBQ0Y7WUFDakI7UUFDSjtJQUNKO0lBRUFHLHVCQUF1QixTQUFTckYsSUFBSSxFQUFFa0YsS0FBSztRQUV2QyxJQUFJRixVQUFVTSxTQUFTQyxLQUFLdkssR0FBR0M7UUFDL0IsSUFBSXVLLGFBQWFDLFVBQVVDLGVBQWVDO1FBQzFDLElBQUlDLFlBQVksRUFBRTtRQUNsQixtREFBbUQ7UUFDbkQsSUFBS1osWUFBWUUsTUFBTztZQUNwQixJQUFJLENBQUNBLE1BQU03SixjQUFjLENBQUMySixXQUFXO1lBQ3JDTSxVQUFVSixLQUFLLENBQUNGLFNBQVM7WUFDekJPLE1BQU0sSUFBSSxDQUFDUixzQkFBc0IsQ0FBQ0M7WUFDbEMsSUFBSU8sT0FBUSxFQUFDek4sMkRBQVVBLENBQUN5TixJQUFJTSxPQUFPLEtBQUtOLElBQUlNLE9BQU8sQ0FBQ3pKLElBQUksQ0FBQyxJQUFJLEVBQUVrSixTQUFTdEYsTUFBTWtGLE9BQU8sSUFBSSxJQUFJO2dCQUN6RixJQUFJL00seURBQVFBLENBQUNvTixJQUFJNUMsR0FBRyxHQUFHO29CQUNuQjZDLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7b0JBQy9CQSxXQUFXLENBQUNELElBQUk1QyxHQUFHLENBQUMsR0FBRzJDO2dCQUMzQjtnQkFDQSxJQUFJQSxZQUFZLE1BQU07b0JBQ2xCTSxVQUFVckwsSUFBSSxDQUFDeUssVUFBVU87Z0JBQzdCO1lBQ0osT0FBTztnQkFDSEMsZUFBZ0JBLENBQUFBLGNBQWMsQ0FBQztnQkFDL0JBLFdBQVcsQ0FBQ3BOLDREQUFXQSxDQUFDNE0sVUFBVSxHQUFHTTtZQUN6QztRQUNKO1FBRUEsbURBQW1EO1FBQ25ELHlDQUF5QztRQUN6QyxJQUFLdEssSUFBSSxHQUFHQyxJQUFJMkssVUFBVW5LLE1BQU0sRUFBRVQsSUFBSUMsR0FBR0QsS0FBRyxFQUFHO1lBQzNDZ0ssV0FBV1ksU0FBUyxDQUFDNUssRUFBRTtZQUN2QnVLLE1BQU1LLFNBQVMsQ0FBQzVLLElBQUUsRUFBRTtZQUNwQnNLLFVBQVVKLEtBQUssQ0FBQ0YsU0FBUztZQUN6QixJQUFJbE4sMkRBQVVBLENBQUN5TixJQUFJNUMsR0FBRyxHQUFHO2dCQUNyQjhDLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztnQkFDekJBLFFBQVEsQ0FBQ1QsU0FBUyxHQUFHTTtZQUN6QjtZQUNBLElBQUl4TiwyREFBVUEsQ0FBQ3lOLElBQUloRixRQUFRLEdBQUc7Z0JBQzFCbUYsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztnQkFDbkNBLGFBQWEsQ0FBQ1YsU0FBUyxHQUFHTTtZQUM5QjtZQUNBLElBQUl4TiwyREFBVUEsQ0FBQ3lOLElBQUlPLE1BQU0sR0FBRztnQkFDeEJILGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7Z0JBQy9CQSxXQUFXLENBQUNYLFNBQVMsR0FBR007WUFDNUI7UUFDSjtRQUVBLE9BQU87WUFDSFMsS0FBS2I7WUFDTGMsUUFBUVI7WUFDUjdDLEtBQUs4QztZQUNMbEYsVUFBVW1GO1lBQ1ZJLFFBQVFIO1FBQ1o7SUFDSjtJQUVBTSwwQkFBMEIsU0FBU2pHLElBQUksRUFBRWtGLEtBQUssRUFBRWdCLE9BQU8sRUFBRW5KLEdBQUc7UUFFeERBLE9BQVFBLENBQUFBLE1BQU0sQ0FBQztRQUVmLElBQUlpSSxVQUFVTSxTQUFTQztRQUN2QixJQUFJWSxXQUFXakIsTUFBTWEsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSUssWUFBWWxCLE1BQU1jLE1BQU0sSUFBSSxDQUFDO1FBQ2pDLElBQUlQLFdBQVdQLE1BQU12QyxHQUFHO1FBQ3hCLElBQUkrQyxnQkFBZ0JSLE1BQU0zRSxRQUFRO1FBQ2xDLElBQUlvRixjQUFjVCxNQUFNWSxNQUFNO1FBRTlCLElBQUtkLFlBQVlTLFNBQVU7WUFDdkJILFVBQVVHLFFBQVEsQ0FBQ1QsU0FBUztZQUM1Qk8sTUFBTSxJQUFJLENBQUNSLHNCQUFzQixDQUFDQztZQUNsQyxxRUFBcUU7WUFDckUsd0VBQXdFO1lBQ3hFLHdEQUF3RDtZQUN4RCxJQUFJcUIsWUFBWWQsSUFBSTVDLEdBQUcsQ0FBQ3ZHLElBQUksQ0FBQyxJQUFJLEVBQUVrSixTQUFTWSxRQUFRSSxLQUFLLElBQUl0RyxNQUFNbUcsVUFBVSxJQUFJO1lBQ2pGLElBQUlwTyx5REFBUUEsQ0FBQ3NPLFlBQVk7Z0JBQ3JCM08sdURBQU1BLENBQUMwTyxXQUFXQztZQUN0QixPQUFPLElBQUlBLGNBQWNoRixXQUFXO2dCQUNoQytFLFNBQVMsQ0FBQ3BCLFNBQVMsR0FBR3FCO1lBQzFCO1FBQ0o7UUFFQSxJQUFJckcsZ0JBQWdCdUcsYUFBYTtZQUM3QiwwREFBMEQ7WUFDMUQsOERBQThEO1lBQzlELDRDQUE0QztZQUM1QyxJQUFJLENBQUN0QixpQkFBaUIsQ0FBQ2pGLE1BQU1vRztZQUM3QjtRQUNKO1FBRUEsMkNBQTJDO1FBQzNDLElBQUlJLGdCQUFnQkosVUFBVUssU0FBUztRQUN2QyxJQUFJQyxhQUFhL04sb0RBQUNBLENBQUNnTyx1QkFBdUIsQ0FBQ0g7UUFDM0MsSUFBSUksZUFBZW5PLG1EQUFLQSxDQUFDaU8sV0FBV0csQ0FBQyxFQUFFSCxXQUFXSSxDQUFDO1FBQ25ELElBQUlOLGVBQWU7WUFDZkosWUFBWXhPLHFEQUFJQSxDQUFDd08sV0FBVztZQUM1Qk0sV0FBV0csQ0FBQyxHQUFHSCxXQUFXSSxDQUFDLEdBQUc7UUFDbEM7UUFFQSx3REFBd0Q7UUFDeEQsd0JBQXdCO1FBQ3hCLElBQUlDLElBQUlDLElBQUlDO1FBQ1osSUFBSXZCLGlCQUFpQkMsYUFBYTtZQUM5QixJQUFJdUIsWUFBWSxJQUFJLENBQUNDLFlBQVksQ0FBQ25ILE1BQU1qRCxJQUFJcUssWUFBWTtZQUN4REwsS0FBS0csVUFBVUgsRUFBRTtZQUNqQkMsS0FBS0UsVUFBVUYsRUFBRTtRQUNyQjtRQUVBLElBQUlLLGFBQWE7UUFDakIsSUFBS3JDLFlBQVlVLGNBQWU7WUFDNUJKLFVBQVVJLGFBQWEsQ0FBQ1YsU0FBUztZQUNqQ08sTUFBTSxJQUFJLENBQUNSLHNCQUFzQixDQUFDQztZQUNsQyw4REFBOEQ7WUFDOUQsMEVBQTBFO1lBQzFFLGlFQUFpRTtZQUNqRSwrQkFBK0I7WUFDL0JpQyxjQUFjMUIsSUFBSWhGLFFBQVEsQ0FBQ25FLElBQUksQ0FBQyxJQUFJLEVBQUVrSixTQUFTWSxRQUFRSSxLQUFLLElBQUl0RyxNQUFNbUcsVUFBVSxJQUFJO1lBQ3BGLElBQUljLGFBQWE7Z0JBQ2JMLGFBQWFkLE1BQU0sQ0FBQ3JOLG1EQUFLQSxDQUFDd08sYUFBYUssS0FBSyxDQUFDUCxJQUFJQztnQkFDakRLLGNBQWVBLENBQUFBLGFBQWEsSUFBRztZQUNuQztRQUNKO1FBRUEsK0VBQStFO1FBQy9FLG9FQUFvRTtRQUNwRSxJQUFJLENBQUNwQyxpQkFBaUIsQ0FBQ2pGLE1BQU1vRztRQUU3QixJQUFJbUIsV0FBVztRQUNmLElBQUk1QixhQUFhO1lBQ2IsK0JBQStCO1lBQy9CLElBQUk2QixtQkFBbUIsSUFBSSxDQUFDaEksbUJBQW1CLENBQUNRO1lBQ2hELElBQUl3SCxpQkFBaUIxRyxLQUFLLEdBQUcsS0FBSzBHLGlCQUFpQnhHLE1BQU0sR0FBRyxHQUFHO2dCQUMzRCxJQUFJeUcsV0FBVzlPLG9EQUFDQSxDQUFDb0gsYUFBYSxDQUFDeUgsa0JBQWtCZCxZQUFZWSxLQUFLLENBQUMsSUFBSVAsSUFBSSxJQUFJQztnQkFDL0UsSUFBS2hDLFlBQVlXLFlBQWE7b0JBQzFCTCxVQUFVSyxXQUFXLENBQUNYLFNBQVM7b0JBQy9CTyxNQUFNLElBQUksQ0FBQ1Isc0JBQXNCLENBQUNDO29CQUNsQyxrRUFBa0U7b0JBQ2xFLGtGQUFrRjtvQkFDbEYsa0VBQWtFO29CQUNsRWlDLGNBQWMxQixJQUFJTyxNQUFNLENBQUMxSixJQUFJLENBQUMsSUFBSSxFQUFFa0osU0FBU21DLFVBQVV6SCxNQUFNbUcsVUFBVSxJQUFJO29CQUMzRSxJQUFJYyxhQUFhO3dCQUNiTCxhQUFhZCxNQUFNLENBQUNyTixtREFBS0EsQ0FBQ3dPLGFBQWFLLEtBQUssQ0FBQ1AsSUFBSUM7d0JBQ2pETyxZQUFhQSxDQUFBQSxXQUFXLElBQUc7b0JBQy9CO2dCQUNKO1lBQ0o7UUFDSjtRQUVBLGlGQUFpRjtRQUNqRixJQUFJZixrQkFBa0JuRixhQUFhZ0csY0FBY0UsVUFBVTtZQUN2RCw0Q0FBNEM7WUFDNUNYLGFBQWFjLEtBQUssQ0FBQztZQUNuQmhCLFdBQVdHLENBQUMsR0FBR0QsYUFBYWxHLENBQUM7WUFDN0JnRyxXQUFXSSxDQUFDLEdBQUdGLGFBQWFqRyxDQUFDO1lBQzdCWCxLQUFLMkgsWUFBWSxDQUFDLGFBQWFoUCxvREFBQ0EsQ0FBQ2lQLHVCQUF1QixDQUFDbEI7UUFDekQsa0NBQWtDO1FBQ3RDO0lBQ0o7SUFFQVMsY0FBYyxTQUFTbkgsSUFBSSxFQUFFb0gsWUFBWTtRQUVyQywyREFBMkQ7UUFDM0QsSUFBSUwsSUFBSUM7UUFDUixJQUFJSSxnQkFBZ0JBLGFBQWFsSCxRQUFRLENBQUNGLE9BQU87WUFDN0MsSUFBSXNILFFBQVFGLGFBQWFFLEtBQUs7WUFDOUJQLEtBQUssSUFBSU8sTUFBTVAsRUFBRTtZQUNqQkMsS0FBSyxJQUFJTSxNQUFNTixFQUFFO1FBQ3JCLE9BQU87WUFDSEQsS0FBSztZQUNMQyxLQUFLO1FBQ1Q7UUFFQSxPQUFPO1lBQUVELElBQUlBO1lBQUlDLElBQUlBO1FBQUc7SUFDNUI7SUFFQXZLLGlCQUFpQjtRQUNiLElBQUksQ0FBQzlDLE9BQU8sR0FBRyxDQUFDO0lBQ3BCO0lBRUFrTyxXQUFXLFNBQVN2SSxNQUFNO1FBRXRCLElBQUkzRixVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUMxQix3RUFBd0U7UUFDeEUsSUFBSSxDQUFDQSxTQUFTLE9BQU8sQ0FBQztRQUN0QixJQUFJc0MsS0FBS3RELG9EQUFDQSxDQUFDbVAsUUFBUSxDQUFDeEk7UUFDcEIsSUFBSWxGLFFBQVFULE9BQU8sQ0FBQ3NDLEdBQUc7UUFDdkIsSUFBSSxDQUFDN0IsT0FBT0EsUUFBUVQsT0FBTyxDQUFDc0MsR0FBRyxHQUFHLENBQUM7UUFDbkMsT0FBTzdCO0lBQ1g7SUFFQTJOLGFBQWEsU0FBU3pJLE1BQU07UUFFeEIsSUFBSTNGLFVBQVUsSUFBSSxDQUFDa08sU0FBUyxDQUFDdkk7UUFDN0IsSUFBSSxDQUFDM0YsUUFBUWdELElBQUksRUFBRWhELFFBQVFnRCxJQUFJLEdBQUcsQ0FBQztRQUNuQyxPQUFPaEQsUUFBUWdELElBQUk7SUFDdkI7SUFFQTZDLHFCQUFxQixTQUFTRixNQUFNO1FBRWhDLElBQUkzRixVQUFVLElBQUksQ0FBQ2tPLFNBQVMsQ0FBQ3ZJO1FBQzdCLElBQUkzRixRQUFRcU8sWUFBWSxLQUFLM0csV0FBVzFILFFBQVFxTyxZQUFZLEdBQUdyUCx3REFBQ0EsQ0FBQzJHLFFBQVFOLE9BQU87UUFDaEYsT0FBTyxJQUFJdEcsOENBQUlBLENBQUNpQixRQUFRcU8sWUFBWTtJQUN4QztJQUVBbEksZUFBZSxTQUFTUixNQUFNO1FBRTFCLE1BQU0zRixVQUFVLElBQUksQ0FBQ2tPLFNBQVMsQ0FBQ3ZJO1FBQy9CLElBQUkzRixRQUFRa0csWUFBWSxLQUFLd0IsV0FBVztZQUNwQyxNQUFNLEVBQUVwQixhQUFhLEVBQUUzQixFQUFFLEVBQUUsR0FBRyxJQUFJO1lBQ2xDLElBQUl3RTtZQUNKLElBQUk3QyxpQkFBaUJBLGNBQWNDLFFBQVEsQ0FBQ1osU0FBUztnQkFDakR3RCxTQUFTN0M7WUFDYixPQUFPO2dCQUNINkMsU0FBU3hFO1lBQ2I7WUFDQTNFLFFBQVFrRyxZQUFZLEdBQUdsSCx3REFBQ0EsQ0FBQzJHLFFBQVEySSxxQkFBcUIsQ0FBQ25GO1FBQzNEO1FBQ0EsT0FBT25LLG9EQUFDQSxDQUFDeUgsZUFBZSxDQUFDekcsUUFBUWtHLFlBQVk7SUFDakQ7SUFFQXFJLGNBQWMsU0FBUzVJLE1BQU07UUFFekIsSUFBSTNGLFVBQVUsSUFBSSxDQUFDa08sU0FBUyxDQUFDdkk7UUFDN0IsSUFBSTNGLFFBQVF3TyxhQUFhLEtBQUs5RyxXQUFXMUgsUUFBUXdPLGFBQWEsR0FBR3hQLHdEQUFDQSxDQUFDMkcsUUFBUThJLGVBQWU7UUFDMUYsT0FBT3pPLFFBQVF3TyxhQUFhLENBQUM3QixLQUFLO0lBQ3RDO0lBRUErQixrQkFBa0IsU0FBU3JJLElBQUk7UUFDM0IsT0FBTyxJQUFJLENBQUNqRyxLQUFLLENBQUN1TyxNQUFNLE1BQU8sRUFBQ3RJLFFBQVFBLFNBQVMsSUFBSSxDQUFDMUIsRUFBRTtJQUM1RDtJQUVBaUsscUJBQXFCLFNBQVNyRCxLQUFLLEVBQUV4SCxJQUFJLEVBQUU4SyxhQUFhLEVBQUU1SyxTQUFTO1FBRS9ELElBQUk1QyxHQUFHQyxHQUFHbUwsV0FBV3FDO1FBQ3JCLElBQUlDLGFBQWEsQ0FBQztRQUNsQixJQUFJQyxXQUFXLEVBQUU7UUFDakIsSUFBSyxJQUFJalAsWUFBWXdMLE1BQU87WUFDeEIsSUFBSSxDQUFDQSxNQUFNN0osY0FBYyxDQUFDM0IsV0FBVztZQUNyQzBNLFlBQVlsQixLQUFLLENBQUN4TCxTQUFTO1lBQzNCLElBQUksQ0FBQzFCLDhEQUFhQSxDQUFDb08sWUFBWSxVQUFVLHVDQUF1QztZQUNoRixJQUFJd0MsV0FBV0osYUFBYSxDQUFDOU8sU0FBUyxHQUFHLElBQUksQ0FBQzJFLGNBQWMsQ0FBQzNFLFVBQVVnRSxNQUFNRTtZQUM3RSxJQUFLNUMsSUFBSSxHQUFHQyxJQUFJMk4sU0FBU25OLE1BQU0sRUFBRVQsSUFBSUMsR0FBR0QsSUFBSztnQkFDekMsSUFBSWdGLE9BQU80SSxRQUFRLENBQUM1TixFQUFFO2dCQUN0QnlOLFNBQVM5UCxvREFBQ0EsQ0FBQ21QLFFBQVEsQ0FBQzlIO2dCQUNwQiwwRkFBMEY7Z0JBQzFGLDBEQUEwRDtnQkFDMUQsSUFBSTZJLFNBQVVqTCxhQUFhQSxTQUFTLENBQUNsRSxTQUFTLEtBQUtzRztnQkFDbkQsSUFBSThJLGdCQUFnQkosVUFBVSxDQUFDRCxPQUFPO2dCQUN0QyxJQUFJSyxlQUFlO29CQUNmLHdGQUF3RjtvQkFDeEYsNEVBQTRFO29CQUM1RSxJQUFJLENBQUNBLGNBQWNDLEtBQUssRUFBRTt3QkFDdEJKLFNBQVNwTyxJQUFJLENBQUNrTzt3QkFDZEssY0FBY0MsS0FBSyxHQUFHO3dCQUN0QkQsY0FBY2hPLFVBQVUsR0FBRzs0QkFBQ2dPLGNBQWNoTyxVQUFVO3lCQUFDO3dCQUNyRGdPLGNBQWNFLGNBQWMsR0FBRzs0QkFBQ0YsY0FBY0UsY0FBYzt5QkFBQztvQkFDakU7b0JBQ0EsSUFBSWxPLGFBQWFnTyxjQUFjaE8sVUFBVTtvQkFDekMsSUFBSWtPLGlCQUFpQkYsY0FBY0UsY0FBYztvQkFDakQsSUFBSUgsUUFBUTt3QkFDUixnQ0FBZ0M7d0JBQ2hDL04sV0FBV21PLE9BQU8sQ0FBQzdDO3dCQUNuQjRDLGVBQWVDLE9BQU8sQ0FBQyxDQUFDO29CQUM1QixPQUFPO3dCQUNILHFDQUFxQzt3QkFDckMsSUFBSUMsWUFBWTVRLDREQUFXQSxDQUFDMFEsZ0JBQWdCL047d0JBQzVDSCxXQUFXcU8sTUFBTSxDQUFDRCxXQUFXLEdBQUc5Qzt3QkFDaEM0QyxlQUFlRyxNQUFNLENBQUNELFdBQVcsR0FBR2pPO29CQUN4QztnQkFDSixPQUFPO29CQUNIeU4sVUFBVSxDQUFDRCxPQUFPLEdBQUc7d0JBQ2pCM04sWUFBWXNMO3dCQUNaNEMsZ0JBQWdCSCxTQUFTLENBQUMsSUFBSTVOO3dCQUM5QitFLE1BQU1BO3dCQUNOK0ksT0FBTztvQkFDWDtnQkFDSjtZQUNKO1FBQ0o7UUFFQSxJQUFLL04sSUFBSSxHQUFHQyxJQUFJME4sU0FBU2xOLE1BQU0sRUFBRVQsSUFBSUMsR0FBR0QsSUFBSztZQUN6Q3lOLFNBQVNFLFFBQVEsQ0FBQzNOLEVBQUU7WUFDcEJvTCxZQUFZc0MsVUFBVSxDQUFDRCxPQUFPO1lBQzlCckMsVUFBVXRMLFVBQVUsR0FBR3ZDLHNEQUFLQSxDQUFDLENBQUMsTUFBTTZOLFVBQVV0TCxVQUFVLENBQUNzTyxPQUFPO1FBQ3BFO1FBRUEsT0FBT1Y7SUFDWDtJQUVBakUsZ0JBQWdCLFNBQVNYLEdBQUcsRUFBRS9HLE1BQU0sQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sRUFBRStGLE1BQU0sRUFBRWhKLElBQUksRUFBRXVQLFVBQVUsQ0FBQyxFQUFFQyxVQUFVLENBQUMsRUFBRSxHQUFHeEY7UUFDbkQsSUFDSSx3Q0FBd0M7UUFDeEMvRyxJQUFJd00sU0FBUyxJQUNiLDJHQUEyRztRQUMzRyxvREFBb0Q7UUFDcER6UCxTQUFTLGVBQWVBLFNBQVMsY0FDakMsd0RBQXdEO1FBQ3ZELGVBQWVnSyxPQUFPaEIsT0FBTzBHLGlCQUFpQixDQUFDMUYsSUFBSTJGLFNBQVMsR0FDL0Q7WUFDRSxPQUFPQyxTQUFTQyxnQkFBZ0IsQ0FBQ04sU0FBU0M7UUFDOUM7UUFFQSxPQUFPeEc7SUFDWDtJQUVBLHNIQUFzSDtJQUN0SCx1Q0FBdUM7SUFDdkM4Ryw0QkFBNEIsU0FBU3pJLFFBQVEsRUFBRStELEtBQUssRUFBRW5JLEdBQUc7UUFFckRBLE9BQVFBLENBQUFBLE1BQU0sQ0FBQztRQUNmQSxJQUFJOE0sUUFBUSxJQUFLOU0sQ0FBQUEsSUFBSThNLFFBQVEsR0FBR25SLGtEQUFJQSxFQUFDO1FBQ3JDcUUsSUFBSWEsU0FBUyxJQUFLYixDQUFBQSxJQUFJYSxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTLEdBQUcsNkJBQTZCO1FBRWhGLDhEQUE4RDtRQUM5RCw0REFBNEQ7UUFDNUQsNERBQTREO1FBQzVELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsSUFBSTRLLGdCQUFnQixDQUFDO1FBQ3JCLElBQUlzQixZQUFZLENBQUM7UUFDakIsSUFBSUMsZ0JBQWdCLEVBQUU7UUFDdEIsSUFBSUMsbUJBQW1CLEVBQUU7UUFDekIsSUFBSUMsTUFBTWpLLE1BQU1vRyxXQUFXOEQsVUFBVUM7UUFFckMsSUFBSUMsVUFBVXJOLElBQUlzTixZQUFZO1FBQzlCLElBQUkzQixhQUFhLElBQUksQ0FBQ0gsbUJBQW1CLENBQUM2QixXQUFXbEYsT0FBTy9ELFVBQVVxSCxlQUFlekwsSUFBSWEsU0FBUztRQUNsRyx1REFBdUQ7UUFDdkQsa0RBQWtEO1FBQ2xELElBQUkwTSxnQkFBZ0IsVUFDZCxJQUFJLENBQUMvQixtQkFBbUIsQ0FBQ3JELE9BQU8vRCxVQUFVcUgsZUFBZXpMLElBQUlhLFNBQVMsSUFDdEU4SztRQUVOLElBQUssSUFBSUQsVUFBVUMsV0FBWTtZQUMzQndCLFdBQVd4QixVQUFVLENBQUNELE9BQU87WUFDN0JyQyxZQUFZOEQsU0FBU3BQLFVBQVU7WUFDL0JrRixPQUFPa0ssU0FBU2xLLElBQUk7WUFDcEJtSyxpQkFBaUIsSUFBSSxDQUFDOUUscUJBQXFCLENBQUNyRixNQUFNb0c7WUFFbEQsSUFBSSxDQUFDK0QsZUFBZXhILEdBQUcsSUFBSSxDQUFDd0gsZUFBZTVKLFFBQVEsSUFBSSxDQUFDNEosZUFBZXJFLE1BQU0sRUFBRTtnQkFDM0UsK0RBQStEO2dCQUMvRCxJQUFJLENBQUNiLGlCQUFpQixDQUFDakYsTUFBTW1LLGVBQWVuRSxNQUFNO1lBRXRELE9BQU87Z0JBRUgsSUFBSXVFLGVBQWVELGFBQWEsQ0FBQzdCLE9BQU8sSUFBSTZCLGFBQWEsQ0FBQzdCLE9BQU8sQ0FBQzNOLFVBQVU7Z0JBQzVFLElBQUkwUCxjQUFjLGdCQUFrQnBFLFVBQVVxRSxHQUFHLEtBQUtwSixZQUNoRGtKLGFBQWFFLEdBQUcsR0FDaEJyRSxVQUFVcUUsR0FBRztnQkFFbkIsSUFBSUM7Z0JBQ0osSUFBSUYsYUFBYTtvQkFDYkUsVUFBVSxDQUFDbEMsYUFBYSxDQUFDZ0MsWUFBWSxJQUFJLElBQUksQ0FBQ25NLGNBQWMsQ0FBQ21NLGFBQWFySixVQUFVcEUsSUFBSWEsU0FBUyxFQUFFLENBQUMsRUFBRTtvQkFDdEcsSUFBSSxDQUFDOE0sU0FBUzt3QkFDVixNQUFNLElBQUk5TyxNQUFNLG9CQUFvQjRPLGNBQWM7b0JBQ3REO2dCQUNKLE9BQU87b0JBQ0hFLFVBQVU7Z0JBQ2Q7Z0JBRUFULE9BQU87b0JBQ0hqSyxNQUFNQTtvQkFDTjBLLFNBQVNBO29CQUNUQyxxQkFBcUJSO29CQUNyQlMsZUFBZUw7Z0JBQ25CO2dCQUVBLElBQUlHLFNBQVM7b0JBQ1QscUVBQXFFO29CQUNyRSxvREFBb0Q7b0JBQ3BELElBQUlHLFlBQVliLGlCQUFpQmMsU0FBUyxDQUFDLFNBQVNiLElBQUk7d0JBQ3BELE9BQU9BLEtBQUtTLE9BQU8sS0FBSzFLO29CQUM1QjtvQkFFQSxJQUFJNkssWUFBWSxDQUFDLEdBQUc7d0JBQ2hCYixpQkFBaUJiLE1BQU0sQ0FBQzBCLFdBQVcsR0FBR1o7b0JBQzFDLE9BQU87d0JBQ0hELGlCQUFpQnpQLElBQUksQ0FBQzBQO29CQUMxQjtnQkFDSixPQUFPO29CQUNILHdGQUF3RjtvQkFDeEYsd0RBQXdEO29CQUN4REYsY0FBY3hQLElBQUksQ0FBQzBQO2dCQUN2QjtZQUNKO1FBQ0o7UUFFQUYsY0FBY3hQLElBQUksSUFBSXlQO1FBRXRCLElBQUssSUFBSWhQLElBQUksR0FBR0MsSUFBSThPLGNBQWN0TyxNQUFNLEVBQUVULElBQUlDLEdBQUdELElBQUs7WUFDbERpUCxPQUFPRixhQUFhLENBQUMvTyxFQUFFO1lBQ3ZCZ0YsT0FBT2lLLEtBQUtqSyxJQUFJO1lBQ2hCMEssVUFBVVQsS0FBS1MsT0FBTztZQUV0Qiw0RUFBNEU7WUFDNUUsaUNBQWlDO1lBQ2pDLE1BQU1LLFlBQVlMLFVBQVUvUixvREFBQ0EsQ0FBQ21QLFFBQVEsQ0FBQzRDLFdBQVc7WUFDbEQsSUFBSXhFLFVBQVU0RCxTQUFTLENBQUNpQixVQUFVO1lBQ2xDLElBQUksQ0FBQzdFLFNBQVM7Z0JBQ1YsNkVBQTZFO2dCQUM3RSx3QkFBd0I7Z0JBQ3hCLEVBQUU7Z0JBQ0YsYUFBYTtnQkFDYixvQ0FBb0M7Z0JBQ3BDLDZEQUE2RDtnQkFDN0QsNEJBQTRCO2dCQUM1QixPQUFPO2dCQUNQLEVBQUU7Z0JBQ0YsK0RBQStEO2dCQUMvRCxxREFBcUQ7Z0JBQ3JELHNFQUFzRTtnQkFDdEUsaUNBQWlDO2dCQUNqQyxFQUFFO2dCQUNGLGFBQWE7Z0JBQ2Isb0NBQW9DO2dCQUNwQyw2REFBNkQ7Z0JBQzdELE9BQU87Z0JBQ1Asd0JBQXdCO2dCQUN4QixFQUFFO2dCQUNGLHNFQUFzRTtnQkFDdEUsc0VBQXNFO2dCQUN0RSxrRUFBa0U7Z0JBQ2xFLHlCQUF5QjtnQkFDekJBLFVBQVU0RCxTQUFTLENBQUNpQixVQUFVLEdBQUcsVUFDM0JwUyx3REFBQ0EsQ0FBQytSLFNBQVMxTCxPQUFPLENBQUM7b0JBQUU4RCxRQUFRa0ksc0JBQXNCaEwsTUFBTTBLO2dCQUFTLEtBQ2xFM04sSUFBSThNLFFBQVE7WUFDdEI7WUFFQSxJQUFJTyxTQUFTO2dCQUNULHVGQUF1RjtnQkFDdkYsc0ZBQXNGO2dCQUN0Riw4REFBOEQ7Z0JBQzlERCxpQkFBaUIsSUFBSSxDQUFDOUUscUJBQXFCLENBQUNyRixNQUFNaUssS0FBS1csYUFBYTtnQkFDcEUsSUFBSSxDQUFDSyx3QkFBd0IsQ0FBQ2QsZ0JBQWdCRixLQUFLVSxtQkFBbUI7WUFFMUUsT0FBTztnQkFDSFIsaUJBQWlCRixLQUFLVSxtQkFBbUI7WUFDN0M7WUFFQSxJQUFJLENBQUMxRSx3QkFBd0IsQ0FBQ2pHLE1BQU1tSyxnQkFBZ0JqRSxTQUFTbko7UUFDakU7SUFDSjtJQUVBa08sMEJBQTBCLFNBQVNkLGNBQWMsRUFBRWUsZ0JBQWdCO1FBRS9EZixlQUFleEgsR0FBRyxJQUFLd0gsQ0FBQUEsZUFBZXhILEdBQUcsR0FBRyxDQUFDO1FBQzdDd0gsZUFBZTVKLFFBQVEsSUFBSzRKLENBQUFBLGVBQWU1SixRQUFRLEdBQUcsQ0FBQztRQUN2RDRKLGVBQWVyRSxNQUFNLElBQUtxRSxDQUFBQSxlQUFlckUsTUFBTSxHQUFHLENBQUM7UUFFbkRwTyx1REFBTUEsQ0FBQ3lTLGVBQWV4SCxHQUFHLEVBQUV1SSxpQkFBaUJ2SSxHQUFHO1FBQy9DakwsdURBQU1BLENBQUN5UyxlQUFlNUosUUFBUSxFQUFFMkssaUJBQWlCM0ssUUFBUTtRQUN6RDdJLHVEQUFNQSxDQUFDeVMsZUFBZXJFLE1BQU0sRUFBRW9GLGlCQUFpQnBGLE1BQU07UUFFckQsOENBQThDO1FBQzlDLElBQUlXLFlBQVkwRCxlQUFlbkUsTUFBTSxJQUFJbUUsZUFBZW5FLE1BQU0sQ0FBQ1MsU0FBUztRQUN4RSxJQUFJQSxjQUFjcEYsYUFBYTZKLGlCQUFpQmxGLE1BQU0sRUFBRTtZQUNwRGtGLGlCQUFpQmxGLE1BQU0sQ0FBQ1MsU0FBUyxHQUFHQTtRQUN4QztRQUNBMEQsZUFBZW5FLE1BQU0sR0FBR2tGLGlCQUFpQmxGLE1BQU07SUFDbkQ7SUFFQSxvQkFBb0I7SUFFcEIsK0NBQStDO0lBQy9DLDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0VtRixTQUFRQyxjQUFjO1FBQ2xCLElBQUlBLGdCQUFnQjtRQUNwQixJQUFJLENBQUNDLFVBQVU7UUFDZnhTLGlFQUFlQSxDQUFDeVMsS0FBSyxDQUFDLElBQUk7SUFDOUI7SUFFQSxpREFBaUQ7SUFDakQsMkRBQTJEO0lBQzNEQztRQUNJLElBQUksQ0FBQ0MsWUFBWTtRQUNqQjNTLGlFQUFlQSxDQUFDNFMsT0FBTyxDQUFDLElBQUk7SUFDaEM7SUFFQSwrQ0FBK0M7SUFDL0MsZ0NBQWdDO0lBQ2hDQyxVQUFVO1FBQ04sSUFBSSxDQUFDQyxXQUFXO1FBQ2hCLElBQUksQ0FBQ0Msa0JBQWtCO0lBQzNCO0lBRUFDLFlBQVk7SUFFWkMsVUFBVSxTQUFTQyxJQUFJO1FBQ25CLElBQUlDLFlBQVksSUFBSSxDQUFDSCxVQUFVO1FBQy9CLElBQUksQ0FBQ0csV0FBVyxPQUFPO1FBQ3ZCLElBQUksQ0FBQ0QsTUFBTSxPQUFPO1FBQ2xCLE9BQVFDLFVBQVVDLE9BQU8sT0FBT0Y7SUFDcEM7SUFFQUcsVUFBVSxTQUFTRixTQUFTO1FBRXhCLElBQUksQ0FBQ0wsV0FBVztRQUVoQixJQUFJSyxXQUFXO1lBQ1gsSUFBSSxDQUFDSCxVQUFVLEdBQUdHO1lBQ2xCQSxVQUFVRyxTQUFTLENBQUM7Z0JBQUVDLGFBQWEsSUFBSTtZQUFDO1lBQ3hDSixVQUFVblAsUUFBUSxDQUFDLElBQUksQ0FBQ1MsS0FBSyxFQUFFLGVBQWUsSUFBSSxDQUFDK08sV0FBVyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUM1RTtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBRUFkO1FBQ0ksTUFBTVEsWUFBWSxJQUFJLENBQUNILFVBQVU7UUFDakMsSUFBSUcsV0FBV0EsVUFBVVAsT0FBTztRQUNoQyxPQUFPLElBQUk7SUFDZjtJQUVBSjtRQUNJLE1BQU1XLFlBQVksSUFBSSxDQUFDSCxVQUFVO1FBQ2pDLGlEQUFpRDtRQUNqRCxJQUFJRyxhQUFhLENBQUNBLFVBQVVPLFNBQVMsSUFBSVAsVUFBVVYsS0FBSztRQUN4RCxPQUFPLElBQUk7SUFDZjtJQUVBa0IsYUFBYSxTQUFTelAsR0FBRztRQUVyQixJQUFJaVAsWUFBWSxJQUFJLENBQUNILFVBQVU7UUFDL0IsSUFBSUcsV0FBV0EsVUFBVVMsTUFBTSxDQUFDMVA7UUFDaEMsT0FBTyxJQUFJO0lBQ2Y7SUFFQTRPLGFBQWE7UUFFVCxJQUFJSyxZQUFZLElBQUksQ0FBQ0gsVUFBVTtRQUMvQixJQUFJRyxXQUFXO1lBQ1hBLFVBQVVVLE1BQU07WUFDaEIsSUFBSSxDQUFDYixVQUFVLEdBQUc7UUFDdEI7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUVBYyxXQUFXO1FBRVAsSUFBSVgsWUFBWSxJQUFJLENBQUNILFVBQVU7UUFDL0IsSUFBSUcsV0FBV0EsVUFBVVksSUFBSTtRQUM3QixPQUFPLElBQUk7SUFDZjtJQUVBQyxXQUFXO1FBRVAsSUFBSWIsWUFBWSxJQUFJLENBQUNILFVBQVU7UUFDL0IsSUFBSUcsV0FBV0EsVUFBVWMsSUFBSTtRQUM3QixPQUFPLElBQUk7SUFDZjtJQUVBVCxhQUFhLFNBQVNVLEtBQUs7UUFDdkIsT0FBUUE7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ3BCLFdBQVc7Z0JBQ2hCO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNnQixTQUFTO2dCQUNkO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNFLFNBQVM7Z0JBQ2Q7UUFDUjtJQUNKO0lBRUFqQixvQkFBb0I7UUFDaEIvUyxpRUFBZUEsQ0FBQzZULE1BQU0sQ0FBQyxJQUFJO0lBQy9CO0lBRUFNLG9CQUFvQixTQUFTOVAsUUFBUSxLQUFLO1FBQ3RDckUsaUVBQWVBLENBQUM0VCxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU12UDtJQUN2QztJQUVBK1AsdUJBQXVCO1FBQ25CcFUsaUVBQWVBLENBQUM0TixTQUFTLENBQUMsSUFBSTtJQUNsQztJQUVBLG9DQUFvQztJQUNwQyxvQ0FBb0M7SUFFcEN5RywyQkFBMEJwSixHQUFHO1FBQ3pCLElBQUksQ0FBQ0ksU0FBUyxDQUFDSixLQUFLO1lBQUVxSiw2QkFBNkI7UUFBTTtJQUM3RDtJQUVBQywrQkFBOEJ0SixHQUFHO1FBQzdCLE1BQU0sRUFBRXFKLDhCQUE4QixLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUNqSixTQUFTLENBQUNKO1FBQy9ELE9BQU9xSjtJQUNYO0lBRUEsNkVBQTZFO0lBQzdFLDhHQUE4RztJQUM5Ryw4RUFBOEU7SUFFOUUsaUdBQWlHO0lBQ2pHLGlEQUFpRDtJQUVqREUsaUJBQWlCLFNBQVN2SixHQUFHLEVBQUVwRCxDQUFDLEVBQUVDLENBQUM7UUFFL0IsSUFBSSxDQUFDaEMsTUFBTSxDQUFDLHdCQUF3Qm1GLEtBQUtwRCxHQUFHQztJQUNoRDtJQUVBMk0sY0FBYyxTQUFTeEosR0FBRyxFQUFFcEQsQ0FBQyxFQUFFQyxDQUFDO1FBRTVCLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQyxxQkFBcUJtRixLQUFLcEQsR0FBR0M7SUFDN0M7SUFFQTRNLGFBQWEsU0FBU3pKLEdBQUcsRUFBRXBELENBQUMsRUFBRUMsQ0FBQztRQUUzQixJQUFJLENBQUNoQyxNQUFNLENBQUMsb0JBQW9CbUYsS0FBS3BELEdBQUdDO0lBQzVDO0lBRUE2TSxhQUFhLFNBQVMxSixHQUFHLEVBQUVwRCxDQUFDLEVBQUVDLENBQUM7UUFFM0IsTUFBTSxFQUFFNUcsS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUN0QixNQUFNLEVBQUV5SSxLQUFLLEVBQUUsR0FBR3pJO1FBQ2xCLElBQUl5SSxPQUFPO1lBQ1B6SSxNQUFNZ0ssVUFBVSxDQUFDO1lBQ2pCLElBQUksQ0FBQ0csU0FBUyxDQUFDSixLQUFLO2dCQUFFdEI7WUFBTTtRQUNoQztRQUVBLElBQUksQ0FBQzdELE1BQU0sQ0FBQyxvQkFBb0JtRixLQUFLcEQsR0FBR0M7SUFDNUM7SUFFQTJELGFBQWEsU0FBU1IsR0FBRyxFQUFFcEQsQ0FBQyxFQUFFQyxDQUFDO1FBRTNCLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQyxvQkFBb0JtRixLQUFLcEQsR0FBR0M7SUFDNUM7SUFFQWtFLFdBQVcsU0FBU2YsR0FBRyxFQUFFcEQsQ0FBQyxFQUFFQyxDQUFDO1FBRXpCLE1BQU0sRUFBRTZCLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQzBCLFNBQVMsQ0FBQ0o7UUFFakMsSUFBSSxDQUFDbkYsTUFBTSxDQUFDLGtCQUFrQm1GLEtBQUtwRCxHQUFHQztRQUV0QyxJQUFJNkIsT0FBTztZQUNQLDJEQUEyRDtZQUMzRCxtREFBbUQ7WUFDbkRBLE1BQU1zQyxTQUFTLENBQUMsV0FBVztnQkFBRTlJLE1BQU0sSUFBSSxDQUFDakMsS0FBSztZQUFDO1FBQ2xEO0lBQ0o7SUFFQTBULFdBQVcsU0FBUzNKLEdBQUc7UUFFbkIsSUFBSSxDQUFDbkYsTUFBTSxDQUFDLGtCQUFrQm1GO0lBQ2xDO0lBRUE0SixVQUFVLFNBQVM1SixHQUFHO1FBRWxCLElBQUksQ0FBQ25GLE1BQU0sQ0FBQyxpQkFBaUJtRjtJQUNqQztJQUVBNkosWUFBWSxTQUFTN0osR0FBRztRQUVwQixJQUFJLENBQUNuRixNQUFNLENBQUMsbUJBQW1CbUY7SUFDbkM7SUFFQThKLFlBQVksU0FBUzlKLEdBQUc7UUFFcEIsSUFBSSxDQUFDbkYsTUFBTSxDQUFDLG1CQUFtQm1GO0lBQ25DO0lBRUErSixZQUFZLFNBQVMvSixHQUFHLEVBQUVwRCxDQUFDLEVBQUVDLENBQUMsRUFBRW1OLEtBQUs7UUFFakMsSUFBSSxDQUFDblAsTUFBTSxDQUFDLG1CQUFtQm1GLEtBQUtwRCxHQUFHQyxHQUFHbU47SUFDOUM7SUFFQUMsU0FBUyxTQUFTakssR0FBRyxFQUFFbEYsU0FBUyxFQUFFOEIsQ0FBQyxFQUFFQyxDQUFDO1FBRWxDLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ0MsV0FBV2tGLEtBQUtwRCxHQUFHQztJQUNuQztJQUVBcU4sVUFBVTtJQUVOLE9BQU87SUFDWDtJQUVBQyx1QkFBdUI7SUFFbkIsT0FBTztJQUNYO0lBRUFDLG1CQUFtQjtJQUVmLE9BQU87SUFDWDtJQUVBQyxpQkFBZ0JySyxHQUFHO1FBQ2YsTUFBTSxFQUFFeEcsS0FBSyxFQUFFdkQsS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUM3QixJQUFJdUQsTUFBTThRLE9BQU8sSUFBSTtZQUNqQixrRUFBa0U7WUFDbEUsaUZBQWlGO1lBQ2pGLHFFQUFxRTtZQUNyRSxvRUFBb0U7WUFDcEUscUNBQXFDO1lBQ3JDLElBQUlyVSxNQUFNdU8sTUFBTSxJQUFJO2dCQUNoQix3RUFBd0U7Z0JBQ3hFLHlDQUF5QztnQkFDekMsTUFBTStGLGdCQUFnQnRVLE1BQU11VSxnQkFBZ0I7Z0JBQzVDLElBQUlELGVBQWU7b0JBQ2YsTUFBTUUsYUFBYWpSLE1BQU1rUixlQUFlLENBQUNIO29CQUN6QyxJQUFJRSxZQUFZO3dCQUNaalIsTUFBTW1SLFFBQVEsQ0FBQ0Y7d0JBQ2ZqUixNQUFNb1IsbUJBQW1CLENBQUNIO29CQUM5QjtnQkFDSjtnQkFDQSxNQUFNSSxnQkFBZ0I1VSxNQUFNNlUsZ0JBQWdCO2dCQUM1QyxJQUFJRCxlQUFlO29CQUNmLE1BQU1FLGFBQWF2UixNQUFNa1IsZUFBZSxDQUFDRztvQkFDekMsSUFBSUUsWUFBWTt3QkFDWnZSLE1BQU1tUixRQUFRLENBQUNJO3dCQUNmdlIsTUFBTW9SLG1CQUFtQixDQUFDRztvQkFDOUI7Z0JBQ0o7WUFDSjtZQUNBLHVEQUF1RDtZQUN2RHZSLE1BQU1tUixRQUFRLENBQUMsSUFBSTtZQUNuQm5SLE1BQU1vUixtQkFBbUIsQ0FBQyxJQUFJO1FBQ2xDO1FBQ0EsTUFBTTVMLFNBQVMsSUFBSSxDQUFDMkIsY0FBYyxDQUFDWCxLQUFLO1lBQUV5RixXQUFXO1FBQUs7UUFDMUQsTUFBTXVGLE9BQU94UixNQUFNMkYsUUFBUSxDQUFDSDtRQUM1QixJQUFJZ00sU0FBUyxJQUFJLEVBQUU7UUFDbkIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQzlKO1FBQ2hCLElBQUksQ0FBQ2dMLE1BQU07UUFDWCx3QkFBd0I7UUFDeEJBLEtBQUtuQixVQUFVLENBQUM3SjtJQUNwQjtJQUVBaUwsa0JBQWtCLFNBQVMzVSxLQUFLO1FBRTVCLElBQUksQ0FBQytCLE9BQU8sQ0FBQ2lDLFdBQVcsR0FBR2hFO0lBQy9CO0FBQ0osR0FBRztJQUVDaEI7SUFFQTRWLGNBQWNsVztJQUVkbVcsMkJBQTJCLFNBQVM5VCxzQkFBc0I7UUFDdEQsT0FBTzVDLHNEQUFLQSxDQUFDLENBQUMsR0FBR0YsdURBQU1BLENBQUMsSUFBSSxDQUFDaUUsU0FBUyxFQUFFLDJCQUEyQm5CLHdCQUF3QixTQUFTK1QsQ0FBQyxFQUFFQyxDQUFDO1lBQ3BHLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxHQUFHO1lBQ2QsSUFBSSxPQUFPRCxNQUFNLFVBQVVBLElBQUk7Z0JBQUNBO2FBQUU7WUFDbEMsSUFBSSxPQUFPQyxNQUFNLFVBQVVBLElBQUk7Z0JBQUNBO2FBQUU7WUFDbEMsSUFBSTVULE1BQU1DLE9BQU8sQ0FBQzBULE1BQU0zVCxNQUFNQyxPQUFPLENBQUMyVCxJQUFJLE9BQU8zVyxxREFBSUEsQ0FBQzBXLEVBQUVuUSxNQUFNLENBQUNvUTtRQUNuRTtJQUNKO0FBQ0osR0FBRztBQUVILG9DQUFvQztBQUNwQyxTQUFTbkUsc0JBQXNCb0UsS0FBSyxFQUFFQyxLQUFLO0lBQ3ZDLElBQUlDLFNBQVNGO0lBQ2IsR0FBRztRQUNDLElBQUlFLE9BQU9wUCxRQUFRLENBQUNtUCxRQUFRLE9BQU9DO1FBQ25DQSxTQUFTQSxPQUFPdE4sVUFBVTtJQUM5QixRQUFTc04sUUFBUTtJQUNqQixPQUFPO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvQ2VsbFZpZXcubWpzPzIxM2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBWaWV3IH0gZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQge1xuICAgIGFzc2lnbixcbiAgICBndWlkLFxuICAgIG9taXQsXG4gICAgcGFyc2VET01KU09OLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNPYmplY3QsXG4gICAgaXNQbGFpbk9iamVjdCxcbiAgICBpc0Jvb2xlYW4sXG4gICAgaXNFbXB0eSxcbiAgICBpc1N0cmluZyxcbiAgICB0b0tlYmFiQ2FzZSxcbiAgICByZXN1bHQsXG4gICAgc29ydGVkSW5kZXgsXG4gICAgbWVyZ2UsXG4gICAgdW5pcVxufSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCwgUmVjdCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuL0hpZ2hsaWdodGVyVmlldy5tanMnO1xuXG5jb25zdCBIaWdobGlnaHRpbmdUeXBlcyA9IHtcbiAgICBERUZBVUxUOiAnZGVmYXVsdCcsXG4gICAgRU1CRURESU5HOiAnZW1iZWRkaW5nJyxcbiAgICBDT05ORUNUSU5HOiAnY29ubmVjdGluZycsXG4gICAgTUFHTkVUX0FWQUlMQUJJTElUWTogJ21hZ25ldEF2YWlsYWJpbGl0eScsXG4gICAgRUxFTUVOVF9BVkFJTEFCSUxJVFk6ICdlbGVtZW50QXZhaWxhYmlsaXR5J1xufTtcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6ICdUT09MUycsXG59O1xuXG4vLyBDZWxsVmlldyBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBUaGlzIGlzIHRoZSBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIgZm9yIGBFbGVtZW50Vmlld2AgYW5kIGBMaW5rVmlld2AuXG5leHBvcnQgY29uc3QgQ2VsbFZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAnZycsXG5cbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuXG4gICAgc2VsZWN0b3I6ICdyb290JyxcblxuICAgIG1ldHJpY3M6IG51bGwsXG5cbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gWydjZWxsJ107XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5tb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgICAgICBpZiAodHlwZSkge1xuXG4gICAgICAgICAgICB0eXBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndHlwZS0nICsgbGlzdC5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgX3ByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IG51bGwsXG4gICAgX2ZsYWdzOiBudWxsLFxuXG4gICAgc2V0RmxhZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgICAgdmFyIGksIG4sIGxhYmVsO1xuICAgICAgICB2YXIgcHJlc2VudGF0aW9uQXR0cmlidXRlcyA9IHJlc3VsdCh0aGlzLCAncHJlc2VudGF0aW9uQXR0cmlidXRlcycpO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gcHJlc2VudGF0aW9uQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50YXRpb25BdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGxhYmVscyA9IHByZXNlbnRhdGlvbkF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSBsYWJlbHMgPSBbbGFiZWxzXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGZsYWcgPSBmbGFnc1tsYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tsYWJlbF0gPSAxPDwoc2hpZnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXSB8PSBmbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbml0RmxhZyA9IHJlc3VsdCh0aGlzLCAnaW5pdEZsYWcnKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluaXRGbGFnKSkgaW5pdEZsYWcgPSBbaW5pdEZsYWddO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gaW5pdEZsYWcubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGluaXRGbGFnW2ldO1xuICAgICAgICAgICAgaWYgKCFmbGFnc1tsYWJlbF0pIGZsYWdzW2xhYmVsXSA9IDE8PChzaGlmdCsrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDI2IC0gMzAgYXJlIHJlc2VydmVkIGZvciBwYXBlciBmbGFnc1xuICAgICAgICAvLyAzMSsgb3ZlcmZsb3dzIG1heGltYWwgbnVtYmVyXG4gICAgICAgIGlmIChzaGlmdCA+IDI1KSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogTWF4aW11bSBudW1iZXIgb2YgZmxhZ3MgZXhjZWVkZWQuJyk7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5fcHJlc2VudGF0aW9uQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIGhhc0ZsYWc6IGZ1bmN0aW9uKGZsYWcsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFnICYgdGhpcy5nZXRGbGFnKGxhYmVsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRmxhZzogZnVuY3Rpb24oZmxhZywgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcgXiAoZmxhZyAmIHRoaXMuZ2V0RmxhZyhsYWJlbCkpO1xuICAgIH0sXG5cbiAgICBnZXRGbGFnOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgICAgICAgaWYgKCFmbGFncykgcmV0dXJuIDA7XG4gICAgICAgIHZhciBmbGFnID0gMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxhYmVsLmxlbmd0aDsgaSA8IG47IGkrKykgZmxhZyB8PSBmbGFnc1tsYWJlbFtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGFnIHw9IGZsYWdzW2xhYmVsXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuXG4gICAgYXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtb2RlbC1pZCc6IGNlbGwuaWQsXG4gICAgICAgICAgICAnZGF0YS10eXBlJzogY2VsbC5hdHRyaWJ1dGVzLnR5cGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYSBnbG9iYWwgdW5pcXVlIGlkIGlzIGFzc2lnbmVkIHRvIHRoaXMgdmlldy4gU3RvcmUgdGhpcyBpZCBhbHNvIHRvIHRoZSBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgICAgLy8gVGhlIGdsb2JhbCB1bmlxdWUgaWQgbWFrZXMgc3VyZSB0aGF0IHRoZSBzYW1lIHZpZXcgY2FuIGJlIHJlbmRlcmVkIG9uIGUuZy4gZGlmZmVyZW50IG1hY2hpbmVzIGFuZFxuICAgICAgICAvLyBzdGlsbCBiZSBhc3NvY2lhdGVkIHRvIHRoZSBzYW1lIG9iamVjdCBhbW9uZyBhbGwgdGhvc2UgY2xpZW50cy4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHJlYWwtdGltZVxuICAgICAgICAvLyBjb2xsYWJvcmF0aW9uIG1lY2hhbmlzbS5cbiAgICAgICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuaWQgfHwgZ3VpZCh0aGlzKTtcblxuICAgICAgICBWaWV3LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc2V0RmxhZ3MoKTtcblxuICAgICAgICBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5jbGVhbk5vZGVzQ2FjaGUoKTtcblxuICAgICAgICAvLyBTdG9yZSByZWZlcmVuY2UgdG8gdGhpcyB0byB0aGUgPGc+IERPTSBlbGVtZW50IHNvIHRoYXQgdGhlIHZpZXcgaXMgYWNjZXNzaWJsZSB0aHJvdWdoIHRoZSBET00gdHJlZS5cbiAgICAgICAgdGhpcy4kZWwuZGF0YSgndmlldycsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICB9LFxuXG4gICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLm9uQXR0cmlidXRlc0NoYW5nZSk7XG4gICAgfSxcblxuICAgIG9uQXR0cmlidXRlc0NoYW5nZTogZnVuY3Rpb24obW9kZWwsIG9wdCkge1xuICAgICAgICB2YXIgZmxhZyA9IG1vZGVsLmdldENoYW5nZUZsYWcodGhpcy5fcHJlc2VudGF0aW9uQXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChvcHQudXBkYXRlSGFuZGxlZCB8fCAhZmxhZykgcmV0dXJuO1xuICAgICAgICBpZiAob3B0LmRpcnR5ICYmIHRoaXMuaGFzRmxhZyhmbGFnLCAnVVBEQVRFJykpIGZsYWcgfD0gdGhpcy5nZXRGbGFnKCdSRU5ERVInKTtcbiAgICAgICAgLy8gVE9ETzogdG9vbCBjaGFuZ2VzIGRvZXMgbm90IG5lZWQgdG8gYmUgc3luY1xuICAgICAgICAvLyBGaXggU2VnbWVudHMgdG9vbHNcbiAgICAgICAgaWYgKG9wdC50b29sKSBvcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKGZsYWcsIG9wdCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RVcGRhdGU6IGZ1bmN0aW9uKGZsYWdzLCBvcHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBhcGVyICYmIGZsYWdzID4gMCkge1xuICAgICAgICAgICAgcGFwZXIucmVxdWVzdFZpZXdVcGRhdGUodGhpcywgZmxhZ3MsIHRoaXMuVVBEQVRFX1BSSU9SSVRZLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlRE9NSlNPTjogZnVuY3Rpb24obWFya3VwLCByb290KSB7XG5cbiAgICAgICAgdmFyIGRvYyA9IHBhcnNlRE9NSlNPTihtYXJrdXApO1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgdmFyIGdyb3VwcyA9IGRvYy5ncm91cFNlbGVjdG9ycztcbiAgICAgICAgZm9yICh2YXIgZ3JvdXAgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzW2dyb3VwXSkgdGhyb3cgbmV3IEVycm9yKCdkaWEuQ2VsbFZpZXc6IGFtYmlndW91cyBncm91cCBzZWxlY3RvcicpO1xuICAgICAgICAgICAgc2VsZWN0b3JzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciByb290U2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tyb290U2VsZWN0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogYW1iaWd1b3VzIHJvb3Qgc2VsZWN0b3IuJyk7XG4gICAgICAgICAgICBzZWxlY3RvcnNbcm9vdFNlbGVjdG9yXSA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJhZ21lbnQ6IGRvYy5mcmFnbWVudCwgc2VsZWN0b3JzOiBzZWxlY3RvcnMgfTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpZiBjZWxsIGxpbmsgaXMgYWxsb3dlZCB0byBwZXJmb3JtIGEgY2VydGFpbiBVSSBgZmVhdHVyZWAuXG4gICAgLy8gRXhhbXBsZTogYGNhbigndmVydGV4TW92ZScpYCwgYGNhbignbGFiZWxNb3ZlJylgLlxuICAgIGNhbjogZnVuY3Rpb24oZmVhdHVyZSkge1xuXG4gICAgICAgIHZhciBpbnRlcmFjdGl2ZSA9IGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmludGVyYWN0aXZlKVxuICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUodGhpcylcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmludGVyYWN0aXZlO1xuXG4gICAgICAgIHJldHVybiAoaXNPYmplY3QoaW50ZXJhY3RpdmUpICYmIGludGVyYWN0aXZlW2ZlYXR1cmVdICE9PSBmYWxzZSkgfHxcbiAgICAgICAgICAgIChpc0Jvb2xlYW4oaW50ZXJhY3RpdmUpICYmIGludGVyYWN0aXZlICE9PSBmYWxzZSk7XG4gICAgfSxcblxuICAgIGZpbmRCeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCwgc2VsZWN0b3JzKSB7XG5cbiAgICAgICAgcm9vdCB8fCAocm9vdCA9IHRoaXMuZWwpO1xuICAgICAgICBzZWxlY3RvcnMgfHwgKHNlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzKTtcblxuICAgICAgICAvLyBUaGVzZSBhcmUgZWl0aGVyIGRlc2NlbmRhbnRzIG9mIGB0aGlzLiRlbGAgb2YgYHRoaXMuJGVsYCBpdHNlbGYuXG4gICAgICAgIC8vIGAuYCBpcyBhIHNwZWNpYWwgc2VsZWN0b3IgdXNlZCB0byBzZWxlY3QgdGhlIHdyYXBwaW5nIGA8Zz5gIGVsZW1lbnQuXG4gICAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcuJykgcmV0dXJuIFtyb290XTtcbiAgICAgICAgaWYgKHNlbGVjdG9ycykge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gc2VsZWN0b3JzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbm9kZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFpbnRhaW5pbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gZS5nLiBgY2lyY2xlOmZpcnN0YCB3b3VsZCBmYWlsIHdpdGggcXVlcnlTZWxlY3RvcigpIGNhbGxcbiAgICAgICAgaWYgKGNvbmZpZy51c2VDU1NTZWxlY3RvcnMpIHJldHVybiAkKHJvb3QpLmZpbmQoc2VsZWN0b3IpLnRvQXJyYXkoKTtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIG5vdGlmeTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIpIHtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBldmVudCBvbiBib3RoIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgYWxzbyBvbiB0aGUgcGFwZXIuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgW2V2ZW50TmFtZV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgICAgICAgLy8gUGFwZXIgZXZlbnQgaGFuZGxlcnMgcmVjZWl2ZSB0aGUgdmlldyBvYmplY3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICAgICAgdGhpcy5wYXBlci50cmlnZ2VyLmFwcGx5KHRoaXMucGFwZXIsIFtldmVudE5hbWUsIHRoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QkJveDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIGJib3g7XG4gICAgICAgIGlmIChvcHQgJiYgb3B0LnVzZU1vZGVsR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICBiYm94ID0gbW9kZWwuZ2V0QkJveCgpLmJib3gobW9kZWwuYW5nbGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYm94ID0gdGhpcy5nZXROb2RlQkJveCh0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcGVyLmxvY2FsVG9QYXBlclJlY3QoYmJveCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVCQm94OiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5nZXROb2RlQm91bmRpbmdSZWN0KG1hZ25ldCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRoaXMuZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCgpLm11bHRpcGx5KHRoaXMuZ2V0Tm9kZVJvdGF0ZU1hdHJpeChtYWduZXQpKTtcbiAgICAgICAgY29uc3QgbWFnbmV0TWF0cml4ID0gdGhpcy5nZXROb2RlTWF0cml4KG1hZ25ldCk7XG4gICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3QocmVjdCwgdHJhbnNmb3JtTWF0cml4Lm11bHRpcGx5KG1hZ25ldE1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlUm90YXRlTWF0cml4KG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdGF0YWJsZU5vZGUgfHwgdGhpcy5yb3RhdGFibGVOb2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBSb3RhdGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCB0byBhbGwgbm9kZXMgd2hlbiBubyByb3RhdGFibGVHcm91cFxuICAgICAgICAgICAgLy8gaXMgcHJlc2VudCBvciB0byBub2RlcyBpbnNpZGUgdGhlIHJvdGF0YWJsZUdyb3VwIG9ubHkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZXMgb3V0c2lkZSB0aGUgcm90YXRhYmxlIGdyb3VwXG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlVW5yb3RhdGVkQkJveDogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldE5vZGVCb3VuZGluZ1JlY3QobWFnbmV0KTtcbiAgICAgICAgdmFyIG1hZ25ldE1hdHJpeCA9IHRoaXMuZ2V0Tm9kZU1hdHJpeChtYWduZXQpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5nZXRSb290VHJhbnNsYXRlTWF0cml4KCk7XG4gICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3QocmVjdCwgdHJhbnNsYXRlTWF0cml4Lm11bHRpcGx5KG1hZ25ldE1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICBnZXRSb290VHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgbXQgPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgcmV0dXJuIG10O1xuICAgIH0sXG5cbiAgICBnZXRSb290Um90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbXIgPSBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgYW5nbGUgPSBtb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gbW9kZWwuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdmFyIGN4ID0gYmJveC53aWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgY3kgPSBiYm94LmhlaWdodCAvIDI7XG4gICAgICAgICAgICBtciA9IG1yLnRyYW5zbGF0ZShjeCwgY3kpLnJvdGF0ZShhbmdsZSkudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXI7XG4gICAgfSxcblxuICAgIF9ub3RpZnlIaWdobGlnaHQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZWwsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZWw6IHJvb3ROb2RlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFtub2RlID0gcm9vdE5vZGVdID0gdGhpcy5maW5kQnlTZWxlY3RvcihlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBbbm9kZSA9IHJvb3ROb2RlXSA9IHRoaXMuJChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHBhcnRpYWwgZmxhZyBpZiB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudCBpcyBub3QgdGhlIGVudGlyZSB2aWV3LlxuICAgICAgICBvcHQucGFydGlhbCA9IChub2RlICE9PSByb290Tm9kZSk7XG4gICAgICAgIC8vIHRyYW5zbGF0ZSB0eXBlIGZsYWcgaW50byBhIHR5cGUgc3RyaW5nXG4gICAgICAgIGlmIChvcHQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0LmVtYmVkZGluZzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkVNQkVERElORztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvcHQuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0Lm1hZ25ldEF2YWlsYWJpbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLk1BR05FVF9BVkFJTEFCSUxJVFk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0LmVsZW1lbnRBdmFpbGFiaWxpdHk6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBIaWdobGlnaHRpbmdUeXBlcy5FTEVNRU5UX0FWQUlMQUJJTElUWTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0LnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5KGV2ZW50TmFtZSwgbm9kZSwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZWwsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm90aWZ5SGlnaGxpZ2h0KCdjZWxsOmhpZ2hsaWdodCcsIGVsLCBvcHQpO1xuICAgIH0sXG5cbiAgICB1bmhpZ2hsaWdodDogZnVuY3Rpb24oZWwsIG9wdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RpZnlIaWdobGlnaHQoJ2NlbGw6dW5oaWdobGlnaHQnLCBlbCwgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBlbGVtZW50IHRoYXQgaGFzIHRoZSBgbWFnbmV0YCBhdHRyaWJ1dGUgc2V0IHRvIGB0cnVlYC4gSWYgdGhlcmUgd2FzIG5vdCBzdWNoXG4gICAgLy8gYW4gZWxlbWVudCBmb3VuZCwgcmV0dXJuIHRoZSByb290IGVsZW1lbnQgb2YgdGhlIGNlbGwgdmlldy5cbiAgICBmaW5kTWFnbmV0OiBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmVsO1xuICAgICAgICBsZXQgbWFnbmV0ID0gdGhpcy4kKGVsKVswXTtcbiAgICAgICAgaWYgKCFtYWduZXQpIHtcbiAgICAgICAgICAgIG1hZ25ldCA9IHJvb3Q7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBtYWduZXRBdHRyaWJ1dGUgPSBtYWduZXQuZ2V0QXR0cmlidXRlKCdtYWduZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzTWFnbmV0Um9vdCA9IChtYWduZXQgPT09IHJvb3QpO1xuICAgICAgICAgICAgaWYgKChtYWduZXRBdHRyaWJ1dGUgfHwgaXNNYWduZXRSb290KSAmJiBtYWduZXRBdHRyaWJ1dGUgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFnbmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTWFnbmV0Um9vdCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvdmVyYWxsIGNlbGwgaGFzIHNldCBgbWFnbmV0ID09PSBmYWxzZWAsIHRoZW4gcmV0dXJuIGB1bmRlZmluZWRgIHRvXG4gICAgICAgICAgICAgICAgLy8gYW5ub3VuY2UgdGhlcmUgaXMgbm8gbWFnbmV0IGZvdW5kIGZvciB0aGlzIGNlbGwuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB0byBzZXQgb24gY2VsbHMgdGhhdCBoYXZlICdwb3J0cycuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBwb3J0cyBoYXZlIHNldCBgbWFnbmV0ID09PSB0cnVlYCBhbmQgdGhlIG92ZXJhbGwgZWxlbWVudCBoYXMgYG1hZ25ldCA9PT0gZmFsc2VgLlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWduZXQgPSBtYWduZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfSB3aGlsZSAobWFnbmV0KTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmaW5kUHJveHlOb2RlOiBmdW5jdGlvbihlbCwgdHlwZSkge1xuICAgICAgICBlbCB8fCAoZWwgPSB0aGlzLmVsKTtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdG9yID0gZWwuZ2V0QXR0cmlidXRlKGAke3R5cGV9LXNlbGVjdG9yYCk7XG4gICAgICAgIGlmIChub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwcm94eU5vZGVdID0gdGhpcy5maW5kQnlTZWxlY3Rvcihub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKHByb3h5Tm9kZSkgcmV0dXJuIHByb3h5Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8vIENvbnN0cnVjdCBhIHVuaXF1ZSBzZWxlY3RvciBmb3IgdGhlIGBlbGAgZWxlbWVudCB3aXRoaW4gdGhpcyB2aWV3LlxuICAgIC8vIGBwcmV2U2VsZWN0b3JgIGlzIGJlaW5nIGNvbGxlY3RlZCB0aHJvdWdoIHRoZSByZWN1cnNpdmUgY2FsbC5cbiAgICAvLyBObyB2YWx1ZSBmb3IgYHByZXZTZWxlY3RvcmAgaXMgZXhwZWN0ZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICBnZXRTZWxlY3RvcjogZnVuY3Rpb24oZWwsIHByZXZTZWxlY3Rvcikge1xuXG4gICAgICAgIHZhciBzZWxlY3RvcjtcblxuICAgICAgICBpZiAoZWwgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldlNlbGVjdG9yID09PSAnc3RyaW5nJykgc2VsZWN0b3IgPSAnPiAnICsgcHJldlNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsKSB7XG5cbiAgICAgICAgICAgIHZhciBudGhDaGlsZCA9IFYoZWwpLmluZGV4KCkgKyAxO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBlbC50YWdOYW1lICsgJzpudGgtY2hpbGQoJyArIG50aENoaWxkICsgJyknO1xuXG4gICAgICAgICAgICBpZiAocHJldlNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gJyA+ICcgKyBwcmV2U2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvcihlbC5wYXJlbnROb2RlLCBzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfSxcblxuICAgIGFkZExpbmtGcm9tTWFnbmV0OiBmdW5jdGlvbihtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICB2YXIgZ3JhcGggPSBwYXBlci5tb2RlbDtcblxuICAgICAgICB2YXIgbGluayA9IHBhcGVyLmdldERlZmF1bHRMaW5rKHRoaXMsIG1hZ25ldCk7XG4gICAgICAgIGxpbmsuc2V0KHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXRMaW5rRW5kKG1hZ25ldCwgeCwgeSwgbGluaywgJ3NvdXJjZScpLFxuICAgICAgICAgICAgdGFyZ2V0OiB7IHg6IHgsIHk6IHkgfVxuICAgICAgICB9KS5hZGRUbyhncmFwaCwge1xuICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgdWk6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbmsuZmluZFZpZXcocGFwZXIpO1xuICAgIH0sXG5cbiAgICBnZXRMaW5rRW5kOiBmdW5jdGlvbihtYWduZXQsIC4uLmFyZ3MpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgaWQgPSBtb2RlbC5pZDtcbiAgICAgICAgdmFyIHBvcnQgPSB0aGlzLmZpbmRBdHRyaWJ1dGUoJ3BvcnQnLCBtYWduZXQpO1xuICAgICAgICAvLyBGaW5kIGEgdW5pcXVlIGBzZWxlY3RvcmAgb2YgdGhlIGVsZW1lbnQgdW5kZXIgcG9pbnRlciB0aGF0IGlzIGEgbWFnbmV0LlxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBtYWduZXQuZ2V0QXR0cmlidXRlKCdqb2ludC1zZWxlY3RvcicpO1xuXG4gICAgICAgIHZhciBlbmQgPSB7IGlkOiBpZCB9O1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkgZW5kLm1hZ25ldCA9IHNlbGVjdG9yO1xuICAgICAgICBpZiAocG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQucG9ydCA9IHBvcnQ7XG4gICAgICAgICAgICBpZiAoIW1vZGVsLmhhc1BvcnQocG9ydCkgJiYgIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9ydCBjcmVhdGVkIHZpYSB0aGUgYHBvcnRgIGF0dHJpYnV0ZSAobm90IEFQSSlcbiAgICAgICAgICAgICAgICBlbmQuc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yKG1hZ25ldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT0gbnVsbCAmJiB0aGlzLmVsICE9PSBtYWduZXQpIHtcbiAgICAgICAgICAgIGVuZC5zZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3IobWFnbmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbWl6ZUxpbmtFbmQoZW5kLCBtYWduZXQsIC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBjdXN0b21pemVMaW5rRW5kOiBmdW5jdGlvbihlbmQsIG1hZ25ldCwgeCwgeSwgbGluaywgZW5kVHlwZSkge1xuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25TdHJhdGVneSB9ID0gcGFwZXIub3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uU3RyYXRlZ3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBzdHJhdGVneSA9IGNvbm5lY3Rpb25TdHJhdGVneS5jYWxsKHBhcGVyLCBlbmQsIHRoaXMsIG1hZ25ldCwgbmV3IFBvaW50KHgsIHkpLCBsaW5rLCBlbmRUeXBlLCBwYXBlcik7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kpIHJldHVybiBzdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH0sXG5cbiAgICBnZXRNYWduZXRGcm9tTGlua0VuZDogZnVuY3Rpb24oZW5kKSB7XG5cbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcG9ydCA9IGVuZC5wb3J0O1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbmQubWFnbmV0O1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbWFnbmV0O1xuICAgICAgICBpZiAocG9ydCAhPSBudWxsICYmIG1vZGVsLmlzRWxlbWVudCgpICYmIG1vZGVsLmhhc1BvcnQocG9ydCkpIHtcbiAgICAgICAgICAgIG1hZ25ldCA9IHRoaXMuZmluZFBvcnROb2RlKHBvcnQsIHNlbGVjdG9yKSB8fCByb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikgc2VsZWN0b3IgPSBlbmQuc2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yICYmIHBvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxpbmsgZW5kIGhhcyBvbmx5IGBpZGAgYW5kIGBwb3J0YCBwcm9wZXJ0eSByZWZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIC8vIGEgcG9ydCBjcmVhdGVkIHZpYSB0aGUgYHBvcnRgIGF0dHJpYnV0ZSAobm90IEFQSSkuXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnW3BvcnQ9XCInICsgcG9ydCArICdcIl0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFnbmV0ID0gdGhpcy5maW5kQnlTZWxlY3RvcihzZWxlY3Rvciwgcm9vdCwgdGhpcy5zZWxlY3RvcnMpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFByb3h5Tm9kZShtYWduZXQsICdtYWduZXQnKTtcbiAgICB9LFxuXG4gICAgZHJhZ0xpbmtTdGFydDogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdGFydEJhdGNoKCdhZGQtbGluaycpO1xuICAgICAgICBjb25zdCBsaW5rVmlldyA9IHRoaXMuYWRkTGlua0Zyb21NYWduZXQobWFnbmV0LCB4LCB5KTtcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZXZlbnRzXG4gICAgICAgIGxpbmtWaWV3Lm5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG4gICAgICAgIGxpbmtWaWV3LmV2ZW50RGF0YShldnQsIGxpbmtWaWV3LnN0YXJ0QXJyb3doZWFkTW92ZSgndGFyZ2V0JywgeyB3aGVuTm90QWxsb3dlZDogJ3JlbW92ZScgfSkpO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgbGlua1ZpZXcgfSk7XG4gICAgfSxcblxuICAgIGRyYWdMaW5rOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSBkYXRhLmxpbmtWaWV3O1xuICAgICAgICBpZiAobGlua1ZpZXcpIHtcbiAgICAgICAgICAgIGxpbmtWaWV3LnBvaW50ZXJtb3ZlKGV2dCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICAgICAgdmFyIG1hZ25ldFRocmVzaG9sZCA9IHBhcGVyLm9wdGlvbnMubWFnbmV0VGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSB0aGlzLmdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWFnbmV0ID0gZGF0YS50YXJnZXRNYWduZXQ7XG4gICAgICAgICAgICBpZiAobWFnbmV0VGhyZXNob2xkID09PSAnb25sZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWduZXRUaHJlc2hvbGQgd2hlbiB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIG1hZ25ldFxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRNYWduZXQgPT09IGN1cnJlbnRUYXJnZXQgfHwgVih0YXJnZXRNYWduZXQpLmNvbnRhaW5zKGN1cnJlbnRUYXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1hZ25ldFRocmVzaG9sZCBkZWZpbmVkIGFzIGEgbnVtYmVyIG9mIG1vdmVtZW50c1xuICAgICAgICAgICAgICAgIGlmIChwYXBlci5ldmVudERhdGEoZXZ0KS5tb3VzZW1vdmVkIDw9IG1hZ25ldFRocmVzaG9sZCkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnTGlua1N0YXJ0KGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkcmFnTGlua0VuZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gZGF0YS5saW5rVmlldztcbiAgICAgICAgaWYgKCFsaW5rVmlldykgcmV0dXJuO1xuICAgICAgICBsaW5rVmlldy5wb2ludGVydXAoZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdG9wQmF0Y2goJ2FkZC1saW5rJyk7XG4gICAgfSxcblxuICAgIGdldEF0dHJpYnV0ZURlZmluaXRpb246IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29uc3RydWN0b3IuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgfSxcblxuICAgIHNldE5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlLCBhdHRycykge1xuXG4gICAgICAgIGlmICghaXNFbXB0eShhdHRycykpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIFYobm9kZSkuYXR0cihhdHRycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobm9kZSkuYXR0cihhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvY2Vzc05vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlLCBhdHRycykge1xuXG4gICAgICAgIHZhciBhdHRyTmFtZSwgYXR0clZhbCwgZGVmLCBpLCBuO1xuICAgICAgICB2YXIgbm9ybWFsQXR0cnMsIHNldEF0dHJzLCBwb3NpdGlvbkF0dHJzLCBvZmZzZXRBdHRycztcbiAgICAgICAgdmFyIHJlbGF0aXZlcyA9IFtdO1xuICAgICAgICAvLyBkaXZpZGUgdGhlIGF0dHJpYnV0ZXMgYmV0d2VlbiBub3JtYWwgYW5kIHNwZWNpYWxcbiAgICAgICAgZm9yIChhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYXR0clZhbCA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVmICYmICghaXNGdW5jdGlvbihkZWYucXVhbGlmeSkgfHwgZGVmLnF1YWxpZnkuY2FsbCh0aGlzLCBhdHRyVmFsLCBub2RlLCBhdHRycywgdGhpcykpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlZi5zZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsQXR0cnNbZGVmLnNldF0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0clZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZXMucHVzaChhdHRyTmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1t0b0tlYmFiQ2FzZShhdHRyTmFtZSldID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgcmVzdCBvZiBhdHRyaWJ1dGVzIHZpYSByZWxhdGVkIG1ldGhvZFxuICAgICAgICAvLyBmcm9tIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgbmFtZXNwYWNlLlxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gcmVsYXRpdmVzLmxlbmd0aDsgaSA8IG47IGkrPTIpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gcmVsYXRpdmVzW2ldO1xuICAgICAgICAgICAgZGVmID0gcmVsYXRpdmVzW2krMV07XG4gICAgICAgICAgICBhdHRyVmFsID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmLnNldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRycyB8fCAoc2V0QXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZi5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkF0dHJzIHx8IChwb3NpdGlvbkF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZi5vZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QXR0cnMgfHwgKG9mZnNldEF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIG9mZnNldEF0dHJzW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiBhdHRycyxcbiAgICAgICAgICAgIG5vcm1hbDogbm9ybWFsQXR0cnMsXG4gICAgICAgICAgICBzZXQ6IHNldEF0dHJzLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uQXR0cnMsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldEF0dHJzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlbGF0aXZlQXR0cmlidXRlczogZnVuY3Rpb24obm9kZSwgYXR0cnMsIHJlZkJCb3gsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIHZhciBhdHRyTmFtZSwgYXR0clZhbCwgZGVmO1xuICAgICAgICB2YXIgcmF3QXR0cnMgPSBhdHRycy5yYXcgfHwge307XG4gICAgICAgIHZhciBub2RlQXR0cnMgPSBhdHRycy5ub3JtYWwgfHwge307XG4gICAgICAgIHZhciBzZXRBdHRycyA9IGF0dHJzLnNldDtcbiAgICAgICAgdmFyIHBvc2l0aW9uQXR0cnMgPSBhdHRycy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIG9mZnNldEF0dHJzID0gYXR0cnMub2Zmc2V0O1xuXG4gICAgICAgIGZvciAoYXR0ck5hbWUgaW4gc2V0QXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBzZXRBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICBkZWYgPSB0aGlzLmdldEF0dHJpYnV0ZURlZmluaXRpb24oYXR0ck5hbWUpO1xuICAgICAgICAgICAgLy8gU0VUIC0gc2V0IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIG5vZGUsXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIGFmZmVjdCB0aGUgbm9kZSBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSByZWZlcmVuY2UgYm91bmRpbmdcbiAgICAgICAgICAgIC8vIGJveC4gZS5nLiBgd2lkdGhgLCBgaGVpZ2h0YCwgYGRgLCBgcnhgLCBgcnlgLCBgcG9pbnRzXG4gICAgICAgICAgICB2YXIgc2V0UmVzdWx0ID0gZGVmLnNldC5jYWxsKHRoaXMsIGF0dHJWYWwsIHJlZkJCb3guY2xvbmUoKSwgbm9kZSwgcmF3QXR0cnMsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNldFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ24obm9kZUF0dHJzLCBzZXRSZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVBdHRyc1thdHRyTmFtZV0gPSBzZXRSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzZXR0aW5nIHRoZSBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUgb24gSFRNTEVsZW1lbnRzXG4gICAgICAgICAgICAvLyB2aWEgYG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ21hdHJpeCguLi4pJztgIHdvdWxkIGludHJvZHVjZVxuICAgICAgICAgICAgLy8gYSBicmVha2luZyBjaGFuZ2UgKGUuZy4gYmFzaWMuVGV4dEJsb2NrKS5cbiAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZXMobm9kZSwgbm9kZUF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmaW5hbCB0cmFuc2xhdGlvbiBvZiB0aGUgc3ViZWxlbWVudC5cbiAgICAgICAgdmFyIG5vZGVUcmFuc2Zvcm0gPSBub2RlQXR0cnMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbm9kZU1hdHJpeCA9IFYudHJhbnNmb3JtU3RyaW5nVG9NYXRyaXgobm9kZVRyYW5zZm9ybSk7XG4gICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBQb2ludChub2RlTWF0cml4LmUsIG5vZGVNYXRyaXguZik7XG4gICAgICAgIGlmIChub2RlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBvbWl0KG5vZGVBdHRycywgJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgbm9kZU1hdHJpeC5lID0gbm9kZU1hdHJpeC5mID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBub2RlIHNjYWxlIGRldGVybWluZWQgYnkgdGhlIHNjYWxhYmxlIGdyb3VwXG4gICAgICAgIC8vIG9ubHkgaWYgbGF0ZXIgbmVlZGVkLlxuICAgICAgICB2YXIgc3gsIHN5LCB0cmFuc2xhdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uQXR0cnMgfHwgb2Zmc2V0QXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBub2RlU2NhbGUgPSB0aGlzLmdldE5vZGVTY2FsZShub2RlLCBvcHQuc2NhbGFibGVOb2RlKTtcbiAgICAgICAgICAgIHN4ID0gbm9kZVNjYWxlLnN4O1xuICAgICAgICAgICAgc3kgPSBub2RlU2NhbGUuc3k7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGF0dHJOYW1lIGluIHBvc2l0aW9uQXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBwb3NpdGlvbkF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICAvLyBQT1NJVElPTiAtIHBvc2l0aW9uIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwb2ludCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGJvdW5kaW5nIGJveC4gVGhlIGRlZmF1bHQgcG9zaXRpb24gb2YgdGhlIG5vZGUgaXMgeDowLCB5OjAgb2ZcbiAgICAgICAgICAgIC8vIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IG9yIGNvdWxkIGJlIGZ1cnRoZXIgc3BlY2lmeSBieSBzb21lXG4gICAgICAgICAgICAvLyBTVkcgYXR0cmlidXRlcyBlLmcuIGB4YCwgYHlgXG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IGRlZi5wb3NpdGlvbi5jYWxsKHRoaXMsIGF0dHJWYWwsIHJlZkJCb3guY2xvbmUoKSwgbm9kZSwgcmF3QXR0cnMsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbm9kZVBvc2l0aW9uLm9mZnNldChQb2ludCh0cmFuc2xhdGlvbikuc2NhbGUoc3gsIHN5KSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25lZCB8fCAocG9zaXRpb25lZCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG5vZGUgYm91bmRpbmcgYm94IGNvdWxkIGRlcGVuZCBvbiB0aGUgYHNpemVgIHNldCBmcm9tIHRoZSBwcmV2aW91cyBsb29wLlxuICAgICAgICAvLyBIZXJlIHdlIGtub3csIHRoYXQgYWxsIHRoZSBzaXplIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGFscmVhZHkgc2V0LlxuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGVzKG5vZGUsIG5vZGVBdHRycyk7XG5cbiAgICAgICAgdmFyIG9mZnNldGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvZmZzZXRBdHRycykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgaXMgdmlzaWJsZVxuICAgICAgICAgICAgdmFyIG5vZGVCb3VuZGluZ1JlY3QgPSB0aGlzLmdldE5vZGVCb3VuZGluZ1JlY3Qobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZUJvdW5kaW5nUmVjdC53aWR0aCA+IDAgJiYgbm9kZUJvdW5kaW5nUmVjdC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVCQm94ID0gVi50cmFuc2Zvcm1SZWN0KG5vZGVCb3VuZGluZ1JlY3QsIG5vZGVNYXRyaXgpLnNjYWxlKDEgLyBzeCwgMSAvIHN5KTtcbiAgICAgICAgICAgICAgICBmb3IgKGF0dHJOYW1lIGluIG9mZnNldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWwgPSBvZmZzZXRBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9GRlNFVCAtIG9mZnNldCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcG9pbnQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBib3VuZGluZyBib3guIFRoZSBkZWZhdWx0IG9mZnNldCBwb2ludCBpcyB4OjAsIHk6MCAob3JpZ2luKSBvciBjb3VsZCBiZSBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZnkgd2l0aCBzb21lIFNWRyBhdHRyaWJ1dGVzIGUuZy4gYHRleHQtYW5jaG9yYCwgYGN4YCwgYGN5YFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IGRlZi5vZmZzZXQuY2FsbCh0aGlzLCBhdHRyVmFsLCBub2RlQkJveCwgbm9kZSwgcmF3QXR0cnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQb3NpdGlvbi5vZmZzZXQoUG9pbnQodHJhbnNsYXRpb24pLnNjYWxlKHN4LCBzeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ZWQgfHwgKG9mZnNldGVkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3QgdG91Y2ggbm9kZSdzIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaWYgdGhlcmUgaXMgbm8gdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAgICAgICAgaWYgKG5vZGVUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbmVkIHx8IG9mZnNldGVkKSB7XG4gICAgICAgICAgICAvLyBSb3VuZCB0aGUgY29vcmRpbmF0ZXMgdG8gMSBkZWNpbWFsIHBvaW50LlxuICAgICAgICAgICAgbm9kZVBvc2l0aW9uLnJvdW5kKDEpO1xuICAgICAgICAgICAgbm9kZU1hdHJpeC5lID0gbm9kZVBvc2l0aW9uLng7XG4gICAgICAgICAgICBub2RlTWF0cml4LmYgPSBub2RlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKG5vZGVNYXRyaXgpKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHN0b3JlIG5vZGVNYXRyaXggbWV0cmljcz9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXROb2RlU2NhbGU6IGZ1bmN0aW9uKG5vZGUsIHNjYWxhYmxlTm9kZSkge1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgc2NhbGFibGUgZ3JvdXAuXG4gICAgICAgIHZhciBzeCwgc3k7XG4gICAgICAgIGlmIChzY2FsYWJsZU5vZGUgJiYgc2NhbGFibGVOb2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsYWJsZU5vZGUuc2NhbGUoKTtcbiAgICAgICAgICAgIHN4ID0gMSAvIHNjYWxlLnN4O1xuICAgICAgICAgICAgc3kgPSAxIC8gc2NhbGUuc3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeCA9IDE7XG4gICAgICAgICAgICBzeSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzeDogc3gsIHN5OiBzeSB9O1xuICAgIH0sXG5cbiAgICBjbGVhbk5vZGVzQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1ldHJpY3MgPSB7fTtcbiAgICB9LFxuXG4gICAgbm9kZUNhY2hlOiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgLy8gRG9uJ3QgdXNlIGNhY2hlPyBJdCBtb3N0IGxpa2VseSBhIGN1c3RvbSB2aWV3IHdpdGggb3ZlcnJpZGRlbiB1cGRhdGUuXG4gICAgICAgIGlmICghbWV0cmljcykgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgaWQgPSBWLmVuc3VyZUlkKG1hZ25ldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1ldHJpY3NbaWRdO1xuICAgICAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IG1ldHJpY3NbaWRdID0ge307XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZURhdGE6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5ub2RlQ2FjaGUobWFnbmV0KTtcbiAgICAgICAgaWYgKCFtZXRyaWNzLmRhdGEpIG1ldHJpY3MuZGF0YSA9IHt9O1xuICAgICAgICByZXR1cm4gbWV0cmljcy5kYXRhO1xuICAgIH0sXG5cbiAgICBnZXROb2RlQm91bmRpbmdSZWN0OiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubm9kZUNhY2hlKG1hZ25ldCk7XG4gICAgICAgIGlmIChtZXRyaWNzLmJvdW5kaW5nUmVjdCA9PT0gdW5kZWZpbmVkKSBtZXRyaWNzLmJvdW5kaW5nUmVjdCA9IFYobWFnbmV0KS5nZXRCQm94KCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdChtZXRyaWNzLmJvdW5kaW5nUmVjdCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVNYXRyaXg6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLm5vZGVDYWNoZShtYWduZXQpO1xuICAgICAgICBpZiAobWV0cmljcy5tYWduZXRNYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3RhdGFibGVOb2RlLCBlbCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAocm90YXRhYmxlTm9kZSAmJiByb3RhdGFibGVOb2RlLmNvbnRhaW5zKG1hZ25ldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSByb3RhdGFibGVOb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldHJpY3MubWFnbmV0TWF0cml4ID0gVihtYWduZXQpLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeChtZXRyaWNzLm1hZ25ldE1hdHJpeCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVTaGFwZTogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm5vZGVDYWNoZShtYWduZXQpO1xuICAgICAgICBpZiAobWV0cmljcy5nZW9tZXRyeVNoYXBlID09PSB1bmRlZmluZWQpIG1ldHJpY3MuZ2VvbWV0cnlTaGFwZSA9IFYobWFnbmV0KS50b0dlb21ldHJ5U2hhcGUoKTtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3MuZ2VvbWV0cnlTaGFwZS5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBpc05vZGVDb25uZWN0aW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmlzTGluaygpICYmICghbm9kZSB8fCBub2RlID09PSB0aGlzLmVsKTtcbiAgICB9LFxuXG4gICAgZmluZE5vZGVzQXR0cmlidXRlczogZnVuY3Rpb24oYXR0cnMsIHJvb3QsIHNlbGVjdG9yQ2FjaGUsIHNlbGVjdG9ycykge1xuXG4gICAgICAgIHZhciBpLCBuLCBub2RlQXR0cnMsIG5vZGVJZDtcbiAgICAgICAgdmFyIG5vZGVzQXR0cnMgPSB7fTtcbiAgICAgICAgdmFyIG1lcmdlSWRzID0gW107XG4gICAgICAgIGZvciAodmFyIHNlbGVjdG9yIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KHNlbGVjdG9yKSkgY29udGludWU7XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBhdHRyc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3Qobm9kZUF0dHJzKSkgY29udGludWU7IC8vIE5vdCBhIHZhbGlkIHNlbGVjdG9yLWF0dHJpYnV0ZXMgcGFpclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCByb290LCBzZWxlY3RvcnMpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHNlbGVjdGVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0ZWRbaV07XG4gICAgICAgICAgICAgICAgbm9kZUlkID0gVi5lbnN1cmVJZChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBcInVuaXF1ZVwiIHNlbGVjdG9ycyBhcmUgc2VsZWN0b3JzIHRoYXQgcmVmZXJlbmNpbmcgYSBzaW5nbGUgbm9kZSAoZGVmaW5lZCBieSBgc2VsZWN0b3JgKVxuICAgICAgICAgICAgICAgIC8vIGdyb3VwU2VsZWN0b3IgcmVmZXJlbmNpbmcgYSBzaW5nbGUgbm9kZSBpcyBub3QgXCJ1bmlxdWVcIlxuICAgICAgICAgICAgICAgIHZhciB1bmlxdWUgPSAoc2VsZWN0b3JzICYmIHNlbGVjdG9yc1tzZWxlY3Rvcl0gPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Tm9kZUF0dHJzID0gbm9kZXNBdHRyc1tub2RlSWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Tm9kZUF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUsIHRoYXQgbm9kZXMgcmVmZXJlbmNlZCBieSBkZXByZWNhdGVkIGBDU1Mgc2VsZWN0b3JzYCBhcmUgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBjc3M6YC5jaXJjbGVgIGFuZCBzZWxlY3RvcjpgY2lyY2xlYCBjYW4gYmUgYXBwbGllZCBpbiBhIHJhbmRvbSBvcmRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZOb2RlQXR0cnMuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZOb2RlQXR0cnMuYXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGVBdHRycy5hdHRyaWJ1dGVzID0gW3ByZXZOb2RlQXR0cnMuYXR0cmlidXRlc107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZUF0dHJzLnNlbGVjdGVkTGVuZ3RoID0gW3ByZXZOb2RlQXR0cnMuc2VsZWN0ZWRMZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJldk5vZGVBdHRycy5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBwcmV2Tm9kZUF0dHJzLnNlbGVjdGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlIHJlZmVyZW5jZWQgYnkgYHNlbGVjdG9yYFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy51bnNoaWZ0KG5vZGVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZExlbmd0aC51bnNoaWZ0KC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgcmVmZXJlbmNlZCBieSBgZ3JvdXBTZWxlY3RvcmBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0SW5kZXggPSBzb3J0ZWRJbmRleChzZWxlY3RlZExlbmd0aCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnNwbGljZShzb3J0SW5kZXgsIDAsIG5vZGVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZExlbmd0aC5zcGxpY2Uoc29ydEluZGV4LCAwLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzQXR0cnNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG5vZGVBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTGVuZ3RoOiB1bmlxdWUgPyAtMSA6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IG1lcmdlSWRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbm9kZUlkID0gbWVyZ2VJZHNbaV07XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBub2Rlc0F0dHJzW25vZGVJZF07XG4gICAgICAgICAgICBub2RlQXR0cnMuYXR0cmlidXRlcyA9IG1lcmdlKHt9LCAuLi5ub2RlQXR0cnMuYXR0cmlidXRlcy5yZXZlcnNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGVzQXR0cnM7XG4gICAgfSxcblxuICAgIGdldEV2ZW50VGFyZ2V0OiBmdW5jdGlvbihldnQsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCB0eXBlLCBjbGllbnRYID0gMCwgY2xpZW50WSA9IDAgfSA9IGV2dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSBkZWZpbmVkIGBmcm9tUG9pbnRgIG9wdGlvblxuICAgICAgICAgICAgb3B0LmZyb21Qb2ludCB8fFxuICAgICAgICAgICAgLy8gVG91Y2htb3ZlL1RvdWNoZW5kIGV2ZW50J3MgdGFyZ2V0IGlzIG5vdCByZWZsZWN0aW5nIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBjb29yZGluYXRlcyBhcyBtb3VzZW1vdmUgZG9lcy5cbiAgICAgICAgICAgIC8vIEl0IGhvbGRzIHRoZSBlbGVtZW50IHdoZW4gYSB0b3VjaHN0YXJ0IHRyaWdnZXJlZC5cbiAgICAgICAgICAgIHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd0b3VjaGVuZCcgfHxcbiAgICAgICAgICAgIC8vIFBvaW50ZXJtb3ZlL1BvaW50ZXJ1cCBldmVudCB3aXRoIHRoZSBwb2ludGVyIGNhcHR1cmVkXG4gICAgICAgICAgICAoJ3BvaW50ZXJJZCcgaW4gZXZ0ICYmIHRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShldnQucG9pbnRlcklkKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgaXMgdG8gcHJvY2VzcyB0aGUgYG1vZGVsLmF0dHJpYnV0ZXMuYXR0cnNgIG9iamVjdCBhbmQgc2V0IGF0dHJpYnV0ZXMgb24gc3ViZWxlbWVudHMgYmFzZWQgb24gdGhlIHNlbGVjdG9ycyxcbiAgICAvLyB1bmxlc3MgYGF0dHJzYCBwYXJhbWV0ZXIgd2FzIHBhc3NlZC5cbiAgICB1cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlczogZnVuY3Rpb24ocm9vdE5vZGUsIGF0dHJzLCBvcHQpIHtcblxuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgb3B0LnJvb3RCQm94IHx8IChvcHQucm9vdEJCb3ggPSBSZWN0KCkpO1xuICAgICAgICBvcHQuc2VsZWN0b3JzIHx8IChvcHQuc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMpOyAvLyBzZWxlY3RvciBjb2xsZWN0aW9uIHRvIHVzZVxuXG4gICAgICAgIC8vIENhY2hlIHRhYmxlIGZvciBxdWVyeSByZXN1bHRzIGFuZCBib3VuZGluZyBib3ggY2FsY3VsYXRpb24uXG4gICAgICAgIC8vIE5vdGUgdGhhdCBgc2VsZWN0b3JDYWNoZWAgbmVlZHMgdG8gYmUgaW52YWxpZGF0ZWQgZm9yIGFsbFxuICAgICAgICAvLyBgdXBkYXRlQXR0cmlidXRlc2AgY2FsbHMsIGFzIHRoZSBzZWxlY3RvcnMgbWlnaHQgcG9pbnRpbmdcbiAgICAgICAgLy8gdG8gbm9kZXMgZGVzaWduYXRlZCBieSBhbiBhdHRyaWJ1dGUgb3IgZWxlbWVudHMgZHluYW1pY2FsbHlcbiAgICAgICAgLy8gY3JlYXRlZC5cbiAgICAgICAgdmFyIHNlbGVjdG9yQ2FjaGUgPSB7fTtcbiAgICAgICAgdmFyIGJib3hDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgcmVsYXRpdmVJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgcmVsYXRpdmVSZWZJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbSwgbm9kZSwgbm9kZUF0dHJzLCBub2RlRGF0YSwgcHJvY2Vzc2VkQXR0cnM7XG5cbiAgICAgICAgdmFyIHJvQXR0cnMgPSBvcHQucm9BdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgbm9kZXNBdHRycyA9IHRoaXMuZmluZE5vZGVzQXR0cmlidXRlcyhyb0F0dHJzIHx8IGF0dHJzLCByb290Tm9kZSwgc2VsZWN0b3JDYWNoZSwgb3B0LnNlbGVjdG9ycyk7XG4gICAgICAgIC8vIGBub2Rlc0F0dHJzYCBhcmUgZGlmZmVyZW50IGZyb20gYWxsIGF0dHJpYnV0ZXMsIHdoZW5cbiAgICAgICAgLy8gcmVuZGVyaW5nIG9ubHkgIGF0dHJpYnV0ZXMgc2VudCB0byB0aGlzIG1ldGhvZC5cbiAgICAgICAgdmFyIG5vZGVzQWxsQXR0cnMgPSAocm9BdHRycylcbiAgICAgICAgICAgID8gdGhpcy5maW5kTm9kZXNBdHRyaWJ1dGVzKGF0dHJzLCByb290Tm9kZSwgc2VsZWN0b3JDYWNoZSwgb3B0LnNlbGVjdG9ycylcbiAgICAgICAgICAgIDogbm9kZXNBdHRycztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXNBdHRycykge1xuICAgICAgICAgICAgbm9kZURhdGEgPSBub2Rlc0F0dHJzW25vZGVJZF07XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBub2RlRGF0YS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVEYXRhLm5vZGU7XG4gICAgICAgICAgICBwcm9jZXNzZWRBdHRycyA9IHRoaXMucHJvY2Vzc05vZGVBdHRyaWJ1dGVzKG5vZGUsIG5vZGVBdHRycyk7XG5cbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkQXR0cnMuc2V0ICYmICFwcm9jZXNzZWRBdHRycy5wb3NpdGlvbiAmJiAhcHJvY2Vzc2VkQXR0cnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGFsbCB0aGUgbm9ybWFsIGF0dHJpYnV0ZXMgcmlnaHQgb24gdGhlIFNWRy9IVE1MIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlcyhub2RlLCBwcm9jZXNzZWRBdHRycy5ub3JtYWwpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVBbGxBdHRycyA9IG5vZGVzQWxsQXR0cnNbbm9kZUlkXSAmJiBub2Rlc0FsbEF0dHJzW25vZGVJZF0uYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmU2VsZWN0b3IgPSAobm9kZUFsbEF0dHJzICYmIChub2RlQXR0cnMucmVmID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgICAgICAgICA/IG5vZGVBbGxBdHRycy5yZWZcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlQXR0cnMucmVmO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSAoc2VsZWN0b3JDYWNoZVtyZWZTZWxlY3Rvcl0gfHwgdGhpcy5maW5kQnlTZWxlY3RvcihyZWZTZWxlY3Rvciwgcm9vdE5vZGUsIG9wdC5zZWxlY3RvcnMpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogXCInICsgcmVmU2VsZWN0b3IgKyAnXCIgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmTm9kZTogcmVmTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXR0cmlidXRlczogcHJvY2Vzc2VkQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbEF0dHJpYnV0ZXM6IG5vZGVBbGxBdHRyc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IGluIHRoZSBsaXN0IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhpcyBvbmUsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBpbnNlcnQgdGhpcyBvbmUgYmVmb3JlIGl0IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUluZGV4ID0gcmVsYXRpdmVSZWZJdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucmVmTm9kZSA9PT0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVJlZkl0ZW1zLnNwbGljZShpdGVtSW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVSZWZJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBub2RlIHdpdGggbm8gcmVmIGF0dHJpYnV0ZS4gVG8gYmUgdXBkYXRlZCBiZWZvcmUgdGhlIG5vZGVzIHJlZmVyZW5jaW5nIG90aGVyIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2Ygbm8tcmVmLWl0ZW1zIGlzIG5vdCBzcGVjaWZpZWQvaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVsYXRpdmVJdGVtcy5wdXNoKC4uLnJlbGF0aXZlUmVmSXRlbXMpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVsYXRpdmVJdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWxhdGl2ZUl0ZW1zW2ldO1xuICAgICAgICAgICAgbm9kZSA9IGl0ZW0ubm9kZTtcbiAgICAgICAgICAgIHJlZk5vZGUgPSBpdGVtLnJlZk5vZGU7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGJvdW5kaW5nIGJveC4gSWYgbm8gcmVmZXJlbmNlIHdhcyBwcm92aWRlZCwgd2VcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgb3B0aW9uYWwgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgY29uc3QgcmVmTm9kZUlkID0gcmVmTm9kZSA/IFYuZW5zdXJlSWQocmVmTm9kZSkgOiAnJztcbiAgICAgICAgICAgIGxldCByZWZCQm94ID0gYmJveENhY2hlW3JlZk5vZGVJZF07XG4gICAgICAgICAgICBpZiAoIXJlZkJCb3gpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNpbmcgdG8gdGhlIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIHNwYWNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQGV4YW1wbGUgMVxuICAgICAgICAgICAgICAgIC8vIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMSwgMTMpXCI+XG4gICAgICAgICAgICAgICAgLy8gICAgIDxyZWN0IEBzZWxlY3Rvcj1cImJcIiB4PVwiMVwiIHk9XCIyXCIgd2lkdGg9XCIzXCIgaGVpZ2h0PVwiNFwiLz5cbiAgICAgICAgICAgICAgICAvLyAgICAgPHJlY3QgQHNlbGVjdG9yPVwiYVwiLz5cbiAgICAgICAgICAgICAgICAvLyA8L2c+XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IGNhbiBub3QgYmUgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgYHRyYW5zZm9ybWAgYXR0cmlidXRlIG9mIHRoZSBgPGc+YCBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGV4YWN0IHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYGFgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhcyB3ZWxsIGFzIHRvIHRoZSBgYmAgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEBleGFtcGxlIDJcbiAgICAgICAgICAgICAgICAvLyA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTEsIDEzKVwiPlxuICAgICAgICAgICAgICAgIC8vICAgICA8cmVjdCBAc2VsZWN0b3I9XCJiXCIgeD1cIjFcIiB5PVwiMlwiIHdpZHRoPVwiM1wiIGhlaWdodD1cIjRcIi8+XG4gICAgICAgICAgICAgICAgLy8gPC9nPlxuICAgICAgICAgICAgICAgIC8vIDxyZWN0IEBzZWxlY3Rvcj1cImFcIi8+XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IGhhdmUgdG8gYmUgYWZmZWN0ZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gYHRyYW5zZm9ybWAgYXR0cmlidXRlIG9mIHRoZSBgPGc+YCBlbGVtZW50LCBiZWNhdXNlIHRoZSBgYWAgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBkZXNjZW5kYW50IG9mIHRoZSBgPGc+YCBlbGVtZW50IGFuZCB3aWxsIG5vdCBiZSBhZmZlY3RlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICByZWZCQm94ID0gYmJveENhY2hlW3JlZk5vZGVJZF0gPSAocmVmTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgPyBWKHJlZk5vZGUpLmdldEJCb3goeyB0YXJnZXQ6IGdldENvbW1vbkFuY2VzdG9yTm9kZShub2RlLCByZWZOb2RlKSB9KVxuICAgICAgICAgICAgICAgICAgICA6IG9wdC5yb290QkJveDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBzcGVjaWFsIGF0dHJpYnV0ZSBhZmZlY3RpbmcgdGhlIHBvc2l0aW9uIGFtb25nc3QgcGFzc2VkLWluIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIG1lcmdlIGl0IHdpdGggdGhlIHJlc3Qgb2YgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzIGFzIHRoZXkgYXJlIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIC8vIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24gcmVsYXRpdmVseSAoaS5lIGByZWYteGAgJiYgJ3JlZi1keCcpXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXR0cnMgPSB0aGlzLnByb2Nlc3NOb2RlQXR0cmlidXRlcyhub2RlLCBpdGVtLmFsbEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VQcm9jZXNzZWRBdHRyaWJ1dGVzKHByb2Nlc3NlZEF0dHJzLCBpdGVtLnByb2Nlc3NlZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZEF0dHJzID0gaXRlbS5wcm9jZXNzZWRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbGF0aXZlQXR0cmlidXRlcyhub2RlLCBwcm9jZXNzZWRBdHRycywgcmVmQkJveCwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXJnZVByb2Nlc3NlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHByb2Nlc3NlZEF0dHJzLCByb1Byb2Nlc3NlZEF0dHJzKSB7XG5cbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMuc2V0IHx8IChwcm9jZXNzZWRBdHRycy5zZXQgPSB7fSk7XG4gICAgICAgIHByb2Nlc3NlZEF0dHJzLnBvc2l0aW9uIHx8IChwcm9jZXNzZWRBdHRycy5wb3NpdGlvbiA9IHt9KTtcbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMub2Zmc2V0IHx8IChwcm9jZXNzZWRBdHRycy5vZmZzZXQgPSB7fSk7XG5cbiAgICAgICAgYXNzaWduKHByb2Nlc3NlZEF0dHJzLnNldCwgcm9Qcm9jZXNzZWRBdHRycy5zZXQpO1xuICAgICAgICBhc3NpZ24ocHJvY2Vzc2VkQXR0cnMucG9zaXRpb24sIHJvUHJvY2Vzc2VkQXR0cnMucG9zaXRpb24pO1xuICAgICAgICBhc3NpZ24ocHJvY2Vzc2VkQXR0cnMub2Zmc2V0LCByb1Byb2Nlc3NlZEF0dHJzLm9mZnNldCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGFsc28gdGhlIHNwZWNpYWwgdHJhbnNmb3JtIHByb3BlcnR5LlxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gcHJvY2Vzc2VkQXR0cnMubm9ybWFsICYmIHByb2Nlc3NlZEF0dHJzLm5vcm1hbC50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCAmJiByb1Byb2Nlc3NlZEF0dHJzLm5vcm1hbCkge1xuICAgICAgICAgICAgcm9Qcm9jZXNzZWRBdHRycy5ub3JtYWwudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NlZEF0dHJzLm5vcm1hbCA9IHJvUHJvY2Vzc2VkQXR0cnMubm9ybWFsO1xuICAgIH0sXG5cbiAgICAvLyBMaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSxcbiAgICAvLyBhcyByZXN1bHQgb2YgYGNlbGwuYWRkVG8oZ3JhcGgpYCBiZWluZyBjYWxsZWQgKGlzSW5pdGlhbE1vdW50ID09PSB0cnVlKVxuICAgIC8vIG9yIGBwYXBlci5vcHRpb25zLnZpZXdwb3J0YCByZXR1cm5pbmcgYHRydWVgIChpc0luaXRpYWxNb3VudCA9PT0gZmFsc2UpLlxuICAgIG9uTW91bnQoaXNJbml0aWFsTW91bnQpIHtcbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50KSByZXR1cm47XG4gICAgICAgIHRoaXMubW91bnRUb29scygpO1xuICAgICAgICBIaWdobGlnaHRlclZpZXcubW91bnQodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIGRldGFjaGVkIGZyb20gdGhlIERPTSxcbiAgICAvLyBhcyByZXN1bHQgb2YgYHBhcGVyLm9wdGlvbnMudmlld3BvcnRgIHJldHVybmluZyBgZmFsc2VgLlxuICAgIG9uRGV0YWNoKCkge1xuICAgICAgICB0aGlzLnVubW91bnRUb29scygpO1xuICAgICAgICBIaWdobGlnaHRlclZpZXcudW5tb3VudCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAvLyBhcyByZXN1bHQgb2YgYGNlbGwucmVtb3ZlKClgLlxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUb29scygpO1xuICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodGVycygpO1xuICAgIH0sXG5cbiAgICBfdG9vbHNWaWV3OiBudWxsLFxuXG4gICAgaGFzVG9vbHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgaWYgKCF0b29sc1ZpZXcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0b29sc1ZpZXcuZ2V0TmFtZSgpID09PSBuYW1lKTtcbiAgICB9LFxuXG4gICAgYWRkVG9vbHM6IGZ1bmN0aW9uKHRvb2xzVmlldykge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHMoKTtcblxuICAgICAgICBpZiAodG9vbHNWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl90b29sc1ZpZXcgPSB0b29sc1ZpZXc7XG4gICAgICAgICAgICB0b29sc1ZpZXcuY29uZmlndXJlKHsgcmVsYXRlZFZpZXc6IHRoaXMgfSk7XG4gICAgICAgICAgICB0b29sc1ZpZXcubGlzdGVuVG8odGhpcy5wYXBlciwgJ3Rvb2xzOmV2ZW50JywgdGhpcy5vblRvb2xFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5tb3VudFRvb2xzKCkge1xuICAgICAgICBjb25zdCB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHRvb2xzVmlldy51bm1vdW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb3VudFRvb2xzKCkge1xuICAgICAgICBjb25zdCB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIC8vIFByZXZlbnQgdW5uZWNlc3NhcnkgcmUtYXBwZW5kaW5nIG9mIHRoZSB0b29scy5cbiAgICAgICAgaWYgKHRvb2xzVmlldyAmJiAhdG9vbHNWaWV3LmlzTW91bnRlZCgpKSB0b29sc1ZpZXcubW91bnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZVRvb2xzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcudXBkYXRlKG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVUb29sczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgaWYgKHRvb2xzVmlldykge1xuICAgICAgICAgICAgdG9vbHNWaWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHNWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZVRvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcuaGlkZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2hvd1Rvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcuc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25Ub29sRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUb29scygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlkZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlVG9vbHMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Nob3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlSGlnaGxpZ2h0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGlnaGxpZ2h0ZXJWaWV3LnJlbW92ZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlSGlnaGxpZ2h0ZXJzOiBmdW5jdGlvbihkaXJ0eSA9IGZhbHNlKSB7XG4gICAgICAgIEhpZ2hsaWdodGVyVmlldy51cGRhdGUodGhpcywgbnVsbCwgZGlydHkpO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1IaWdobGlnaHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIaWdobGlnaHRlclZpZXcudHJhbnNmb3JtKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbi4gVGhlIGNvbnRyb2xsZXIgcGFydC5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZXZlbnREZWZhdWx0SW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBkZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQ6IHRydWUgIH0pO1xuICAgIH0sXG5cbiAgICBpc0RlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZChldnQpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQgPSBmYWxzZSB9ID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24gaXMgaGFuZGxlZCBieSB0aGUgcGFwZXIgYW5kIGRlbGVnYXRlZCB0byB0aGUgdmlldyBpbiBpbnRlcmVzdC5cbiAgICAvLyBgeGAgJiBgeWAgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlc2UgZnVuY3Rpb25zIHJlcHJlc2VudCB0aGUgY29vcmRpbmF0ZXMgYWxyZWFkeSBzbmFwcGVkIHRvIHRoZSBwYXBlciBncmlkLlxuICAgIC8vIElmIG5lY2Vzc2FyeSwgcmVhbCBjb29yZGluYXRlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgYGV2dGAgZXZlbnQgb2JqZWN0LlxuXG4gICAgLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBzdXBwb3NlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHRoZSB2aWV3cyB0aGF0IGluaGVyaXQgZnJvbSBgam9pbnQuZGlhLkNlbGxgLFxuICAgIC8vIGkuZS4gYGpvaW50LmRpYS5FbGVtZW50YCBhbmQgYGpvaW50LmRpYS5MaW5rYC5cblxuICAgIHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVyY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6Y29udGV4dG1lbnUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBncmFwaCB9ID0gbW9kZWw7XG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgbW9kZWwuc3RhcnRCYXRjaCgncG9pbnRlcicpO1xuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IGdyYXBoIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcmRvd24nLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcm1vdmUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGggfSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcnVwJywgZXZ0LCB4LCB5KTtcblxuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudCBvbiBtb2RlbCBhcyBtb2RlbCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJlIG1lbWJlciBvZiBjb2xsZWN0aW9uIGFueW1vcmUgKHJlbW92ZSlcbiAgICAgICAgICAgIGdyYXBoLnN0b3BCYXRjaCgncG9pbnRlcicsIHsgY2VsbDogdGhpcy5tb2RlbCB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlb3ZlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDptb3VzZW91dCcsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlZW50ZXInLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDptb3VzZWxlYXZlJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0LCB4LCB5LCBkZWx0YSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNld2hlZWwnLCBldnQsIHgsIHksIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgb25ldmVudDogZnVuY3Rpb24oZXZ0LCBldmVudE5hbWUsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeShldmVudE5hbWUsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG9ubWFnbmV0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBtYWduZXRjb250ZXh0bWVudTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBjaGVja01vdXNlbGVhdmUoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBpZiAocGFwZXIuaXNBc3luYygpKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdXJjZS90YXJnZXQgdmlld3MgYXJlIHVwZGF0ZWQgYmVmb3JlIHRoaXMgdmlldy5cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IDEwMCUgYnVsbGV0cHJvb2YgKHNlZSBiZWxvdykgYnV0IGl0J3MgYSBnb29kIGVub3VnaCBzb2x1dGlvbiBmb3Igbm93LlxuICAgICAgICAgICAgLy8gVGhlIGNvbm5lY3RlZCBjZWxscyBjb3VsZCBiZSBsaW5rcyBhcyB3ZWxsLiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGdvIHRocm91Z2ggYWxsIHRoZSBjb25uZWN0ZWQgbGlua3MgYW5kIHVwZGF0ZVxuICAgICAgICAgICAgLy8gdGhlaXIgc291cmNlL3RhcmdldCB2aWV3cyBhcyB3ZWxsLlxuICAgICAgICAgICAgaWYgKG1vZGVsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB0aGlzLnNvdXJjZVZpZXdgIGFuZCBgdGhpcy50YXJnZXRWaWV3YCBtaWdodCBub3QgYmUgdXBkYXRlZCB5ZXQuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSB2aWV3IGJ5IHRoZSBtb2RlbC5cbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gbW9kZWwuZ2V0U291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXcgPSBwYXBlci5maW5kVmlld0J5TW9kZWwoc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlci5kdW1wVmlldyhzb3VyY2VWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcGVyLmNoZWNrVmlld1Zpc2liaWxpdHkoc291cmNlVmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IG1vZGVsLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3ID0gcGFwZXIuZmluZFZpZXdCeU1vZGVsKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Vmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFwZXIuZHVtcFZpZXcodGFyZ2V0Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlci5jaGVja1ZpZXdWaXNpYmlsaXR5KHRhcmdldFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gdGhlIHVwZGF0ZXMgb2YgdGhlIGN1cnJlbnQgdmlldyBzeW5jaHJvbm91c2x5IG5vd1xuICAgICAgICAgICAgcGFwZXIuZHVtcFZpZXcodGhpcyk7XG4gICAgICAgICAgICBwYXBlci5jaGVja1ZpZXdWaXNpYmlsaXR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0RXZlbnRUYXJnZXQoZXZ0LCB7IGZyb21Qb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgdmlldyA9IHBhcGVyLmZpbmRWaWV3KHRhcmdldCk7XG4gICAgICAgIGlmICh2aWV3ID09PSB0aGlzKSByZXR1cm47XG4gICAgICAgIC8vIExlYXZpbmcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICB0aGlzLm1vdXNlbGVhdmUoZXZ0KTtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm47XG4gICAgICAgIC8vIEVudGVyaW5nIGFub3RoZXIgdmlld1xuICAgICAgICB2aWV3Lm1vdXNlZW50ZXIoZXZ0KTtcbiAgICB9LFxuXG4gICAgc2V0SW50ZXJhY3Rpdml0eTogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgPSB2YWx1ZTtcbiAgICB9XG59LCB7XG5cbiAgICBGbGFncyxcblxuICAgIEhpZ2hsaWdodGluZzogSGlnaGxpZ2h0aW5nVHlwZXMsXG5cbiAgICBhZGRQcmVzZW50YXRpb25BdHRyaWJ1dGVzOiBmdW5jdGlvbihwcmVzZW50YXRpb25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBtZXJnZSh7fSwgcmVzdWx0KHRoaXMucHJvdG90eXBlLCAncHJlc2VudGF0aW9uQXR0cmlidXRlcycpLCBwcmVzZW50YXRpb25BdHRyaWJ1dGVzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoIWEgfHwgIWIpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIGEgPSBbYV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSBiID0gW2JdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkgcmV0dXJuIHVuaXEoYS5jb25jYXQoYikpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLy8gVE9ETzogTW92ZSB0byBWZWN0b3JpemVyIGxpYnJhcnkuXG5mdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvck5vZGUobm9kZTEsIG5vZGUyKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUxO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHBhcmVudC5jb250YWlucyhub2RlMikpIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKHBhcmVudCk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbiJdLCJuYW1lcyI6WyJjb25maWciLCJWaWV3IiwiYXNzaWduIiwiZ3VpZCIsIm9taXQiLCJwYXJzZURPTUpTT04iLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwiaXNCb29sZWFuIiwiaXNFbXB0eSIsImlzU3RyaW5nIiwidG9LZWJhYkNhc2UiLCJyZXN1bHQiLCJzb3J0ZWRJbmRleCIsIm1lcmdlIiwidW5pcSIsIlBvaW50IiwiUmVjdCIsIlYiLCIkIiwiSGlnaGxpZ2h0ZXJWaWV3IiwiSGlnaGxpZ2h0aW5nVHlwZXMiLCJERUZBVUxUIiwiRU1CRURESU5HIiwiQ09OTkVDVElORyIsIk1BR05FVF9BVkFJTEFCSUxJVFkiLCJFTEVNRU5UX0FWQUlMQUJJTElUWSIsIkZsYWdzIiwiVE9PTFMiLCJDZWxsVmlldyIsImV4dGVuZCIsInRhZ05hbWUiLCJzdmdFbGVtZW50Iiwic2VsZWN0b3IiLCJtZXRyaWNzIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lcyIsInR5cGUiLCJtb2RlbCIsImdldCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsImxpc3QiLCJwdXNoIiwic2xpY2UiLCJqb2luIiwiX3ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMiLCJfZmxhZ3MiLCJzZXRGbGFncyIsImZsYWdzIiwiYXR0cmlidXRlcyIsInNoaWZ0IiwiaSIsIm4iLCJsYWJlbCIsInByZXNlbnRhdGlvbkF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGUiLCJoYXNPd25Qcm9wZXJ0eSIsImxhYmVscyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImZsYWciLCJpbml0RmxhZyIsIkVycm9yIiwiaGFzRmxhZyIsImdldEZsYWciLCJyZW1vdmVGbGFnIiwiY2VsbCIsImlkIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY2FsbCIsImluaXRpYWxpemUiLCJwcm90b3R5cGUiLCJhcHBseSIsImFyZ3VtZW50cyIsImNsZWFuTm9kZXNDYWNoZSIsIiRlbCIsImRhdGEiLCJzdGFydExpc3RlbmluZyIsImxpc3RlblRvIiwib25BdHRyaWJ1dGVzQ2hhbmdlIiwib3B0IiwiZ2V0Q2hhbmdlRmxhZyIsInVwZGF0ZUhhbmRsZWQiLCJkaXJ0eSIsInRvb2wiLCJhc3luYyIsInJlcXVlc3RVcGRhdGUiLCJwYXBlciIsInJlcXVlc3RWaWV3VXBkYXRlIiwiVVBEQVRFX1BSSU9SSVRZIiwibWFya3VwIiwicm9vdCIsImRvYyIsInNlbGVjdG9ycyIsImdyb3VwcyIsImdyb3VwU2VsZWN0b3JzIiwiZ3JvdXAiLCJyb290U2VsZWN0b3IiLCJmcmFnbWVudCIsImNhbiIsImZlYXR1cmUiLCJpbnRlcmFjdGl2ZSIsImZpbmRCeVNlbGVjdG9yIiwiZWwiLCJub2RlcyIsInVzZUNTU1NlbGVjdG9ycyIsImZpbmQiLCJ0b0FycmF5Iiwibm90aWZ5IiwiZXZlbnROYW1lIiwiYXJncyIsInRyaWdnZXIiLCJjb25jYXQiLCJnZXRCQm94IiwiYmJveCIsInVzZU1vZGVsR2VvbWV0cnkiLCJhbmdsZSIsImdldE5vZGVCQm94IiwibG9jYWxUb1BhcGVyUmVjdCIsIm1hZ25ldCIsInJlY3QiLCJnZXROb2RlQm91bmRpbmdSZWN0IiwidHJhbnNmb3JtTWF0cml4IiwiZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCIsIm11bHRpcGx5IiwiZ2V0Tm9kZVJvdGF0ZU1hdHJpeCIsIm1hZ25ldE1hdHJpeCIsImdldE5vZGVNYXRyaXgiLCJ0cmFuc2Zvcm1SZWN0Iiwibm9kZSIsInJvdGF0YWJsZU5vZGUiLCJjb250YWlucyIsImdldFJvb3RSb3RhdGVNYXRyaXgiLCJjcmVhdGVTVkdNYXRyaXgiLCJnZXROb2RlVW5yb3RhdGVkQkJveCIsInRyYW5zbGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwibXQiLCJ0cmFuc2xhdGUiLCJ4IiwieSIsIm1yIiwiY3giLCJ3aWR0aCIsImN5IiwiaGVpZ2h0Iiwicm90YXRlIiwiX25vdGlmeUhpZ2hsaWdodCIsInJvb3ROb2RlIiwicGFydGlhbCIsInVuZGVmaW5lZCIsImVtYmVkZGluZyIsImNvbm5lY3RpbmciLCJtYWduZXRBdmFpbGFiaWxpdHkiLCJlbGVtZW50QXZhaWxhYmlsaXR5IiwiaGlnaGxpZ2h0IiwidW5oaWdobGlnaHQiLCJmaW5kTWFnbmV0IiwibWFnbmV0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiaXNNYWduZXRSb290IiwicGFyZW50Tm9kZSIsImZpbmRQcm94eU5vZGUiLCJub2RlU2VsZWN0b3IiLCJwcm94eU5vZGUiLCJnZXRTZWxlY3RvciIsInByZXZTZWxlY3RvciIsIm50aENoaWxkIiwiYWRkTGlua0Zyb21NYWduZXQiLCJncmFwaCIsImxpbmsiLCJnZXREZWZhdWx0TGluayIsInNldCIsInNvdXJjZSIsImdldExpbmtFbmQiLCJ0YXJnZXQiLCJhZGRUbyIsInVpIiwiZmluZFZpZXciLCJwb3J0IiwiZmluZEF0dHJpYnV0ZSIsImVuZCIsImhhc1BvcnQiLCJjdXN0b21pemVMaW5rRW5kIiwiZW5kVHlwZSIsImNvbm5lY3Rpb25TdHJhdGVneSIsInN0cmF0ZWd5IiwiZ2V0TWFnbmV0RnJvbUxpbmtFbmQiLCJpc0VsZW1lbnQiLCJmaW5kUG9ydE5vZGUiLCJkcmFnTGlua1N0YXJ0IiwiZXZ0Iiwic3RhcnRCYXRjaCIsImxpbmtWaWV3Iiwibm90aWZ5UG9pbnRlcmRvd24iLCJldmVudERhdGEiLCJzdGFydEFycm93aGVhZE1vdmUiLCJ3aGVuTm90QWxsb3dlZCIsImRyYWdMaW5rIiwicG9pbnRlcm1vdmUiLCJtYWduZXRUaHJlc2hvbGQiLCJjdXJyZW50VGFyZ2V0IiwiZ2V0RXZlbnRUYXJnZXQiLCJ0YXJnZXRNYWduZXQiLCJtb3VzZW1vdmVkIiwiZHJhZ0xpbmtFbmQiLCJwb2ludGVydXAiLCJzdG9wQmF0Y2giLCJnZXRBdHRyaWJ1dGVEZWZpbml0aW9uIiwiYXR0ck5hbWUiLCJzZXROb2RlQXR0cmlidXRlcyIsImF0dHJzIiwiU1ZHRWxlbWVudCIsImF0dHIiLCJwcm9jZXNzTm9kZUF0dHJpYnV0ZXMiLCJhdHRyVmFsIiwiZGVmIiwibm9ybWFsQXR0cnMiLCJzZXRBdHRycyIsInBvc2l0aW9uQXR0cnMiLCJvZmZzZXRBdHRycyIsInJlbGF0aXZlcyIsInF1YWxpZnkiLCJvZmZzZXQiLCJyYXciLCJub3JtYWwiLCJ1cGRhdGVSZWxhdGl2ZUF0dHJpYnV0ZXMiLCJyZWZCQm94IiwicmF3QXR0cnMiLCJub2RlQXR0cnMiLCJzZXRSZXN1bHQiLCJjbG9uZSIsIkhUTUxFbGVtZW50Iiwibm9kZVRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIm5vZGVNYXRyaXgiLCJ0cmFuc2Zvcm1TdHJpbmdUb01hdHJpeCIsIm5vZGVQb3NpdGlvbiIsImUiLCJmIiwic3giLCJzeSIsInRyYW5zbGF0aW9uIiwibm9kZVNjYWxlIiwiZ2V0Tm9kZVNjYWxlIiwic2NhbGFibGVOb2RlIiwicG9zaXRpb25lZCIsInNjYWxlIiwib2Zmc2V0ZWQiLCJub2RlQm91bmRpbmdSZWN0Iiwibm9kZUJCb3giLCJyb3VuZCIsInNldEF0dHJpYnV0ZSIsIm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nIiwibm9kZUNhY2hlIiwiZW5zdXJlSWQiLCJnZXROb2RlRGF0YSIsImJvdW5kaW5nUmVjdCIsImdldFRyYW5zZm9ybVRvRWxlbWVudCIsImdldE5vZGVTaGFwZSIsImdlb21ldHJ5U2hhcGUiLCJ0b0dlb21ldHJ5U2hhcGUiLCJpc05vZGVDb25uZWN0aW9uIiwiaXNMaW5rIiwiZmluZE5vZGVzQXR0cmlidXRlcyIsInNlbGVjdG9yQ2FjaGUiLCJub2RlSWQiLCJub2Rlc0F0dHJzIiwibWVyZ2VJZHMiLCJzZWxlY3RlZCIsInVuaXF1ZSIsInByZXZOb2RlQXR0cnMiLCJhcnJheSIsInNlbGVjdGVkTGVuZ3RoIiwidW5zaGlmdCIsInNvcnRJbmRleCIsInNwbGljZSIsInJldmVyc2UiLCJjbGllbnRYIiwiY2xpZW50WSIsImZyb21Qb2ludCIsImhhc1BvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwiZG9jdW1lbnQiLCJlbGVtZW50RnJvbVBvaW50IiwidXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXMiLCJyb290QkJveCIsImJib3hDYWNoZSIsInJlbGF0aXZlSXRlbXMiLCJyZWxhdGl2ZVJlZkl0ZW1zIiwiaXRlbSIsIm5vZGVEYXRhIiwicHJvY2Vzc2VkQXR0cnMiLCJyb0F0dHJzIiwicm9BdHRyaWJ1dGVzIiwibm9kZXNBbGxBdHRycyIsIm5vZGVBbGxBdHRycyIsInJlZlNlbGVjdG9yIiwicmVmIiwicmVmTm9kZSIsInByb2Nlc3NlZEF0dHJpYnV0ZXMiLCJhbGxBdHRyaWJ1dGVzIiwiaXRlbUluZGV4IiwiZmluZEluZGV4IiwicmVmTm9kZUlkIiwiZ2V0Q29tbW9uQW5jZXN0b3JOb2RlIiwibWVyZ2VQcm9jZXNzZWRBdHRyaWJ1dGVzIiwicm9Qcm9jZXNzZWRBdHRycyIsIm9uTW91bnQiLCJpc0luaXRpYWxNb3VudCIsIm1vdW50VG9vbHMiLCJtb3VudCIsIm9uRGV0YWNoIiwidW5tb3VudFRvb2xzIiwidW5tb3VudCIsIm9uUmVtb3ZlIiwicmVtb3ZlVG9vbHMiLCJyZW1vdmVIaWdobGlnaHRlcnMiLCJfdG9vbHNWaWV3IiwiaGFzVG9vbHMiLCJuYW1lIiwidG9vbHNWaWV3IiwiZ2V0TmFtZSIsImFkZFRvb2xzIiwiY29uZmlndXJlIiwicmVsYXRlZFZpZXciLCJvblRvb2xFdmVudCIsImJpbmQiLCJpc01vdW50ZWQiLCJ1cGRhdGVUb29scyIsInVwZGF0ZSIsInJlbW92ZSIsImhpZGVUb29scyIsImhpZGUiLCJzaG93VG9vbHMiLCJzaG93IiwiZXZlbnQiLCJ1cGRhdGVIaWdobGlnaHRlcnMiLCJ0cmFuc2Zvcm1IaWdobGlnaHRlcnMiLCJwcmV2ZW50RGVmYXVsdEludGVyYWN0aW9uIiwiZGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkIiwiaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQiLCJwb2ludGVyZGJsY2xpY2siLCJwb2ludGVyY2xpY2siLCJjb250ZXh0bWVudSIsInBvaW50ZXJkb3duIiwibW91c2VvdmVyIiwibW91c2VvdXQiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm1vdXNld2hlZWwiLCJkZWx0YSIsIm9uZXZlbnQiLCJvbm1hZ25ldCIsIm1hZ25ldHBvaW50ZXJkYmxjbGljayIsIm1hZ25ldGNvbnRleHRtZW51IiwiY2hlY2tNb3VzZWxlYXZlIiwiaXNBc3luYyIsInNvdXJjZUVsZW1lbnQiLCJnZXRTb3VyY2VFbGVtZW50Iiwic291cmNlVmlldyIsImZpbmRWaWV3QnlNb2RlbCIsImR1bXBWaWV3IiwiY2hlY2tWaWV3VmlzaWJpbGl0eSIsInRhcmdldEVsZW1lbnQiLCJnZXRUYXJnZXRFbGVtZW50IiwidGFyZ2V0VmlldyIsInZpZXciLCJzZXRJbnRlcmFjdGl2aXR5IiwiSGlnaGxpZ2h0aW5nIiwiYWRkUHJlc2VudGF0aW9uQXR0cmlidXRlcyIsImEiLCJiIiwibm9kZTEiLCJub2RlMiIsInBhcmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/CellView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/Element.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jointjs/src/dia/Element.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Element: () => (/* binding */ Element)\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ports.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/ports.mjs\");\n\n\n\n\n// Element base model.\n// -----------------------------\nconst Element = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n    defaults: {\n        position: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 1,\n            height: 1\n        },\n        angle: 0\n    },\n    initialize: function() {\n        this._initializePorts();\n        _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.prototype.initialize.apply(this, arguments);\n    },\n    /**\n     * @abstract\n     */ _initializePorts: function() {\n    // implemented in ports.js\n    },\n    _refreshPorts: function() {\n    // implemented in ports.js\n    },\n    isElement: function() {\n        return true;\n    },\n    position: function(x, y, opt) {\n        const isSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error(\"Element must be part of a graph.\");\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get(\"position\");\n            }\n        }\n        if (isSetter) {\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get(\"position\");\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set(\"position\", {\n                    x,\n                    y\n                }, opt);\n            }\n            return this;\n        } else {\n            const elementPosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(this.get(\"position\"));\n            return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n        }\n    },\n    translate: function(tx, ty, opt) {\n        tx = tx || 0;\n        ty = ty || 0;\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n        var position = this.get(\"position\") || {\n            x: 0,\n            y: 0\n        };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n            if (typeof ra === \"function\") {\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n            } else {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({\n                    deep: true\n                });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                   |\n                //         \n                //                 |\n                //   \n                //                  |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |    translated element\n                //   <- - bbox.width - ->        embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n        if (opt.transition) {\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt.transition)) opt.transition = {};\n            this.transition(\"position\", translatedPosition, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt.transition, {\n                valueFunction: _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.interpolate.object\n            }));\n            // Recursively call `translate()` on all the embeds cells.\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), \"translate\", tx, ty, opt);\n        } else {\n            this.startBatch(\"translate\", opt);\n            this.set(\"position\", translatedPosition, opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), \"translate\", tx, ty, opt);\n            this.stopBatch(\"translate\", opt);\n        }\n        return this;\n    },\n    size: function(width, height, opt) {\n        var currentSize = this.get(\"size\");\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(width)) {\n            opt = height;\n            height = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.height) ? width.height : currentSize.height;\n            width = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.width) ? width.width : currentSize.width;\n        }\n        return this.resize(width, height, opt);\n    },\n    resize: function(width, height, opt) {\n        opt = opt || {};\n        this.startBatch(\"resize\", opt);\n        if (opt.direction) {\n            var currentSize = this.get(\"size\");\n            switch(opt.direction){\n                case \"left\":\n                case \"right\":\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n                case \"top\":\n                case \"bottom\":\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get(\"angle\") || 0);\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n            var origin;\n            if (angle) {\n                var quadrant = {\n                    \"top-right\": 0,\n                    \"right\": 0,\n                    \"top-left\": 1,\n                    \"top\": 1,\n                    \"bottom-left\": 2,\n                    \"left\": 2,\n                    \"bottom-right\": 3,\n                    \"bottom\": 3\n                }[opt.direction];\n                if (opt.absolute) {\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[[\n                    \"bottomLeft\",\n                    \"corner\",\n                    \"topRight\",\n                    \"origin\"\n                ][quadrant]]();\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(fixedPoint).rotate(bbox.center(), -angle);\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt(width * width + height * height) / 2;\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toRad)(angle);\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point.fromPolar(radius, alpha, imageFixedPoint);\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(center).offset(width / -2, height / -2);\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n                switch(opt.direction){\n                    case \"top\":\n                    case \"top-right\":\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case \"left\":\n                    case \"bottom-left\":\n                        origin.offset(bbox.width - width, 0);\n                        break;\n                    case \"top-left\":\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n            // Resize the element (before re-positioning it).\n            this.set(\"size\", {\n                width: width,\n                height: height\n            }, opt);\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n        } else {\n            // Resize the element.\n            this.set(\"size\", {\n                width: width,\n                height: height\n            }, opt);\n        }\n        this.stopBatch(\"resize\", opt);\n        return this;\n    },\n    scale: function(sx, sy, origin, opt) {\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch(\"scale\", opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch(\"scale\");\n        return this;\n    },\n    fitEmbeds: function(opt) {\n        return this.fitToChildren(opt);\n    },\n    fitToChildren: function(opt = {}) {\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') holds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error(\"Element must be part of a graph.\");\n        const childElements = this.getEmbeddedCells().filter((cell)=>cell.isElement());\n        if (childElements.length === 0) return this;\n        this.startBatch(\"fit-embeds\", opt);\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(childElements, \"fitToChildren\", opt);\n        }\n        // Set new size and position of this element, based on:\n        // - union of bboxes of all children\n        // - inflated by given `opt.padding`\n        this._fitToElements(Object.assign({\n            elements: childElements\n        }, opt));\n        this.stopBatch(\"fit-embeds\");\n        return this;\n    },\n    fitParent: function(opt = {}) {\n        const { graph } = this;\n        if (!graph) throw new Error(\"Element must be part of a graph.\");\n        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n        if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;\n        const parentElement = this.getParentCell();\n        if (!parentElement || !parentElement.isElement()) return this;\n        // Get all children of parent element (i.e. this element + any sibling elements).\n        const siblingElements = parentElement.getEmbeddedCells().filter((cell)=>cell.isElement());\n        if (siblingElements.length === 0) return this;\n        this.startBatch(\"fit-parent\", opt);\n        // Set new size and position of parent element, based on:\n        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n        // - inflated by given `opt.padding`\n        parentElement._fitToElements(Object.assign({\n            elements: siblingElements\n        }, opt));\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n        }\n        this.stopBatch(\"fit-parent\");\n        return this;\n    },\n    // Assumption: This element is part of a graph.\n    _fitToElements: function(opt = {}) {\n        const elementsBBox = this.graph.getCellsBBox(opt.elements);\n        // If no `opt.elements` were provided, do nothing.\n        if (!elementsBBox) return;\n        const { expandOnly, shrinkOnly } = opt;\n        // This combination is meaningless, do nothing.\n        if (expandOnly && shrinkOnly) return;\n        // Calculate new size and position of this element based on:\n        // - union of bboxes of `opt.elements`\n        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n        let { x, y, width, height } = elementsBBox;\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeSides)(opt.padding);\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n        let resultBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n        if (expandOnly) {\n            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n        } else if (shrinkOnly) {\n            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n            const intersectionBBox = this.getBBox().intersect(resultBBox);\n            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n            if (!intersectionBBox) return;\n            resultBBox = intersectionBBox;\n        }\n        // Set the new size and position of this element.\n        this.set({\n            position: {\n                x: resultBBox.x,\n                y: resultBBox.y\n            },\n            size: {\n                width: resultBBox.width,\n                height: resultBBox.height\n            }\n        }, opt);\n    },\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n        if (origin) {\n            var center = this.getBBox().center();\n            var size = this.get(\"size\");\n            var position = this.get(\"position\");\n            center.rotate(origin, this.get(\"angle\") - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch(\"rotate\", {\n                angle: angle,\n                absolute: absolute,\n                origin: origin\n            });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch(\"rotate\");\n        } else {\n            this.set(\"angle\", absolute ? angle : (this.get(\"angle\") + angle) % 360, opt);\n        }\n        return this;\n    },\n    angle: function() {\n        return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get(\"angle\") || 0);\n    },\n    getBBox: function(opt = {}) {\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({\n                deep: true,\n                breadthFirst: true\n            });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n        const { angle = 0, position: { x, y }, size: { width, height } } = attributes;\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, [\n            \"group\"\n        ]);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(Element.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_6__.elementPortPrototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0VsZW1lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ2tDO0FBQ2dDO0FBQ2pEO0FBRW5ELHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFFekIsTUFBTVksVUFBVVosMkNBQUlBLENBQUNhLE1BQU0sQ0FBQztJQUUvQkMsVUFBVTtRQUNOQyxVQUFVO1lBQUVDLEdBQUc7WUFBR0MsR0FBRztRQUFFO1FBQ3ZCQyxNQUFNO1lBQUVDLE9BQU87WUFBR0MsUUFBUTtRQUFFO1FBQzVCQyxPQUFPO0lBQ1g7SUFFQUMsWUFBWTtRQUVSLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQ3JCdkIsMkNBQUlBLENBQUN3QixTQUFTLENBQUNGLFVBQVUsQ0FBQ0csS0FBSyxDQUFDLElBQUksRUFBRUM7SUFDMUM7SUFFQTs7S0FFQyxHQUNESCxrQkFBa0I7SUFDZCwwQkFBMEI7SUFDOUI7SUFFQUksZUFBZTtJQUNYLDBCQUEwQjtJQUM5QjtJQUVBQyxXQUFXO1FBRVAsT0FBTztJQUNYO0lBRUFiLFVBQVUsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVZLEdBQUc7UUFFeEIsTUFBTUMsV0FBV3pCLHlEQUFRQSxDQUFDWTtRQUMxQlksTUFBTSxDQUFDQyxXQUFXRCxNQUFNYixDQUFBQSxLQUFNLENBQUM7UUFDL0IsTUFBTSxFQUFFZSxjQUFjLEVBQUVDLElBQUksRUFBRUMsY0FBYyxFQUFFLEdBQUdKO1FBR2pELHFGQUFxRjtRQUNyRixJQUFJSztRQUNKLElBQUlILGdCQUFnQjtZQUVoQix5REFBeUQ7WUFDekQsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRSxNQUFNLElBQUlDLE1BQU07WUFFakMsTUFBTUMsU0FBUyxJQUFJLENBQUNDLGFBQWE7WUFDakMsSUFBSUQsVUFBVSxDQUFDQSxPQUFPRSxNQUFNLElBQUk7Z0JBQzVCTCxpQkFBaUJHLE9BQU9HLEdBQUcsQ0FBQztZQUNoQztRQUNKO1FBRUEsSUFBSVYsVUFBVTtZQUVWLElBQUlJLGdCQUFnQjtnQkFDaEJsQixLQUFLa0IsZUFBZWxCLENBQUM7Z0JBQ3JCQyxLQUFLaUIsZUFBZWpCLENBQUM7WUFDekI7WUFFQSxJQUFJZSxRQUFRQyxnQkFBZ0I7Z0JBQ3hCLE1BQU0sRUFBRWpCLEdBQUd5QixFQUFFLEVBQUV4QixHQUFHeUIsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDRixHQUFHLENBQUM7Z0JBQ2xDLElBQUksQ0FBQ0csU0FBUyxDQUFDM0IsSUFBSXlCLElBQUl4QixJQUFJeUIsSUFBSWI7WUFDbkMsT0FBTztnQkFDSCxJQUFJLENBQUNlLEdBQUcsQ0FBQyxZQUFZO29CQUFFNUI7b0JBQUdDO2dCQUFFLEdBQUdZO1lBQ25DO1lBRUEsT0FBTyxJQUFJO1FBRWYsT0FBTztZQUVILE1BQU1nQixrQkFBa0I1QyxtREFBS0EsQ0FBQyxJQUFJLENBQUN1QyxHQUFHLENBQUM7WUFDdkMsT0FBT1QsaUJBQ0RjLGdCQUFnQkMsVUFBVSxDQUFDWixrQkFDM0JXO1FBQ1Y7SUFDSjtJQUVBRixXQUFXLFNBQVNJLEVBQUUsRUFBRUMsRUFBRSxFQUFFbkIsR0FBRztRQUUzQmtCLEtBQUtBLE1BQU07UUFDWEMsS0FBS0EsTUFBTTtRQUVYLElBQUlELE9BQU8sS0FBS0MsT0FBTyxHQUFHO1lBQ3RCLDZCQUE2QjtZQUM3QixPQUFPLElBQUk7UUFDZjtRQUVBbkIsTUFBTUEsT0FBTyxDQUFDO1FBQ2QseUNBQXlDO1FBQ3pDQSxJQUFJb0IsV0FBVyxHQUFHcEIsSUFBSW9CLFdBQVcsSUFBSSxJQUFJLENBQUNDLEVBQUU7UUFFNUMsSUFBSW5DLFdBQVcsSUFBSSxDQUFDeUIsR0FBRyxDQUFDLGVBQWU7WUFBRXhCLEdBQUc7WUFBR0MsR0FBRztRQUFFO1FBQ3BELElBQUlrQyxLQUFLdEIsSUFBSUksY0FBYztRQUMzQixJQUFJa0IsTUFBTXRCLElBQUlvQixXQUFXLEtBQUssSUFBSSxDQUFDQyxFQUFFLEVBQUU7WUFFbkMsSUFBSSxPQUFPQyxPQUFPLFlBQVk7Z0JBRTFCLElBQUlDLGNBQWNELEdBQUdFLElBQUksQ0FBQyxJQUFJLEVBQUV0QyxTQUFTQyxDQUFDLEdBQUcrQixJQUFJaEMsU0FBU0UsQ0FBQyxHQUFHK0IsSUFBSW5CO2dCQUVsRWtCLEtBQUtLLFlBQVlwQyxDQUFDLEdBQUdELFNBQVNDLENBQUM7Z0JBQy9CZ0MsS0FBS0ksWUFBWW5DLENBQUMsR0FBR0YsU0FBU0UsQ0FBQztZQUVuQyxPQUFRO2dCQUNKLHlFQUF5RTtnQkFDekUsNERBQTREO2dCQUM1RCxzRUFBc0U7Z0JBQ3RFLElBQUlxQyxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDO29CQUFFdkIsTUFBTTtnQkFBSztnQkFDckMsNENBQTRDO2dCQUM1Qyw2QkFBNkI7Z0JBQzdCLFlBQVk7Z0JBQ1osNkJBQTZCO2dCQUM3Qix5QkFBeUI7Z0JBQ3pCLDZCQUE2QjtnQkFDN0Isb0JBQW9CO2dCQUNwQiw2QkFBNkI7Z0JBQzdCLDhEQUE4RDtnQkFDOUQsb0RBQW9EO2dCQUNwRCxrREFBa0Q7Z0JBQ2xELElBQUl3QixLQUFLekMsU0FBU0MsQ0FBQyxHQUFHc0MsS0FBS3RDLENBQUM7Z0JBQzVCLElBQUl5QyxLQUFLMUMsU0FBU0UsQ0FBQyxHQUFHcUMsS0FBS3JDLENBQUM7Z0JBQzVCLDBFQUEwRTtnQkFDMUUsbUNBQW1DO2dCQUNuQyxJQUFJRCxJQUFJMEMsS0FBS0MsR0FBRyxDQUFDUixHQUFHbkMsQ0FBQyxHQUFHd0MsSUFBSUUsS0FBS0UsR0FBRyxDQUFDVCxHQUFHbkMsQ0FBQyxHQUFHbUMsR0FBR2hDLEtBQUssR0FBR3FDLEtBQUtGLEtBQUtuQyxLQUFLLEVBQUVKLFNBQVNDLENBQUMsR0FBRytCO2dCQUNyRixJQUFJOUIsSUFBSXlDLEtBQUtDLEdBQUcsQ0FBQ1IsR0FBR2xDLENBQUMsR0FBR3dDLElBQUlDLEtBQUtFLEdBQUcsQ0FBQ1QsR0FBR2xDLENBQUMsR0FBR2tDLEdBQUcvQixNQUFNLEdBQUdxQyxLQUFLSCxLQUFLbEMsTUFBTSxFQUFFTCxTQUFTRSxDQUFDLEdBQUcrQjtnQkFDdkYsb0VBQW9FO2dCQUNwRUQsS0FBSy9CLElBQUlELFNBQVNDLENBQUM7Z0JBQ25CZ0MsS0FBSy9CLElBQUlGLFNBQVNFLENBQUM7WUFDdkI7UUFDSjtRQUVBLElBQUk0QyxxQkFBcUI7WUFDckI3QyxHQUFHRCxTQUFTQyxDQUFDLEdBQUcrQjtZQUNoQjlCLEdBQUdGLFNBQVNFLENBQUMsR0FBRytCO1FBQ3BCO1FBRUEseUZBQXlGO1FBQ3pGbkIsSUFBSWtCLEVBQUUsR0FBR0E7UUFDVGxCLElBQUltQixFQUFFLEdBQUdBO1FBRVQsSUFBSW5CLElBQUlpQyxVQUFVLEVBQUU7WUFFaEIsSUFBSSxDQUFDeEQseURBQVFBLENBQUN1QixJQUFJaUMsVUFBVSxHQUFHakMsSUFBSWlDLFVBQVUsR0FBRyxDQUFDO1lBRWpELElBQUksQ0FBQ0EsVUFBVSxDQUFDLFlBQVlELG9CQUFvQnJELHVEQUFNQSxDQUFDLENBQUMsR0FBR3FCLElBQUlpQyxVQUFVLEVBQUU7Z0JBQ3ZFQyxlQUFleEQsd0RBQVdBLENBQUN5RCxNQUFNO1lBQ3JDO1lBRUEsMERBQTBEO1lBQzFEdkQsdURBQU1BLENBQUMsSUFBSSxDQUFDd0QsZ0JBQWdCLElBQUksYUFBYWxCLElBQUlDLElBQUluQjtRQUV6RCxPQUFPO1lBRUgsSUFBSSxDQUFDcUMsVUFBVSxDQUFDLGFBQWFyQztZQUM3QixJQUFJLENBQUNlLEdBQUcsQ0FBQyxZQUFZaUIsb0JBQW9CaEM7WUFDekNwQix1REFBTUEsQ0FBQyxJQUFJLENBQUN3RCxnQkFBZ0IsSUFBSSxhQUFhbEIsSUFBSUMsSUFBSW5CO1lBQ3JELElBQUksQ0FBQ3NDLFNBQVMsQ0FBQyxhQUFhdEM7UUFDaEM7UUFFQSxPQUFPLElBQUk7SUFDZjtJQUVBWCxNQUFNLFNBQVNDLEtBQUssRUFBRUMsTUFBTSxFQUFFUyxHQUFHO1FBRTdCLElBQUl1QyxjQUFjLElBQUksQ0FBQzVCLEdBQUcsQ0FBQztRQUMzQixTQUFTO1FBQ1QsZUFBZTtRQUNmLElBQUlyQixVQUFVa0QsV0FBVztZQUNyQixPQUFPO2dCQUNIbEQsT0FBT2lELFlBQVlqRCxLQUFLO2dCQUN4QkMsUUFBUWdELFlBQVloRCxNQUFNO1lBQzlCO1FBQ0o7UUFDQSxTQUFTO1FBQ1Qsd0JBQXdCO1FBQ3hCLElBQUlkLHlEQUFRQSxDQUFDYSxRQUFRO1lBQ2pCVSxNQUFNVDtZQUNOQSxTQUFTZix5REFBUUEsQ0FBQ2MsTUFBTUMsTUFBTSxJQUFJRCxNQUFNQyxNQUFNLEdBQUdnRCxZQUFZaEQsTUFBTTtZQUNuRUQsUUFBUWQseURBQVFBLENBQUNjLE1BQU1BLEtBQUssSUFBSUEsTUFBTUEsS0FBSyxHQUFHaUQsWUFBWWpELEtBQUs7UUFDbkU7UUFFQSxPQUFPLElBQUksQ0FBQ21ELE1BQU0sQ0FBQ25ELE9BQU9DLFFBQVFTO0lBQ3RDO0lBRUF5QyxRQUFRLFNBQVNuRCxLQUFLLEVBQUVDLE1BQU0sRUFBRVMsR0FBRztRQUUvQkEsTUFBTUEsT0FBTyxDQUFDO1FBRWQsSUFBSSxDQUFDcUMsVUFBVSxDQUFDLFVBQVVyQztRQUUxQixJQUFJQSxJQUFJMEMsU0FBUyxFQUFFO1lBRWYsSUFBSUgsY0FBYyxJQUFJLENBQUM1QixHQUFHLENBQUM7WUFFM0IsT0FBUVgsSUFBSTBDLFNBQVM7Z0JBRWpCLEtBQUs7Z0JBQ0wsS0FBSztvQkFDRCxrREFBa0Q7b0JBQ2xEbkQsU0FBU2dELFlBQVloRCxNQUFNO29CQUMzQjtnQkFFSixLQUFLO2dCQUNMLEtBQUs7b0JBQ0QsK0NBQStDO29CQUMvQ0QsUUFBUWlELFlBQVlqRCxLQUFLO29CQUN6QjtZQUNSO1lBRUEsK0RBQStEO1lBQy9ELElBQUlFLFFBQVFsQiw0REFBY0EsQ0FBQyxJQUFJLENBQUNxQyxHQUFHLENBQUMsWUFBWTtZQUVoRCx5REFBeUQ7WUFDekQsSUFBSWMsT0FBTyxJQUFJLENBQUNDLE9BQU87WUFFdkIsSUFBSWlCO1lBRUosSUFBSW5ELE9BQU87Z0JBRVAsSUFBSW9ELFdBQVc7b0JBQ1gsYUFBYTtvQkFDYixTQUFTO29CQUNULFlBQVk7b0JBQ1osT0FBTztvQkFDUCxlQUFlO29CQUNmLFFBQVE7b0JBQ1IsZ0JBQWdCO29CQUNoQixVQUFVO2dCQUNkLENBQUMsQ0FBQzVDLElBQUkwQyxTQUFTLENBQUM7Z0JBRWhCLElBQUkxQyxJQUFJNkMsUUFBUSxFQUFFO29CQUVkLG9EQUFvRDtvQkFDcERELFlBQVlmLEtBQUtpQixLQUFLLENBQUMsQ0FBQ3RELFFBQVEsRUFBQyxJQUFLO29CQUN0Q29ELFlBQVk7Z0JBQ2hCO2dCQUVBLG9GQUFvRjtnQkFDcEYsc0JBQXNCO2dCQUN0QixJQUFJRyxhQUFhdEIsSUFBSSxDQUFDO29CQUFDO29CQUFjO29CQUFVO29CQUFZO2lCQUFTLENBQUNtQixTQUFTLENBQUM7Z0JBRS9FLGtGQUFrRjtnQkFDbEYsd0NBQXdDO2dCQUN4QyxJQUFJSSxrQkFBa0I1RSxtREFBS0EsQ0FBQzJFLFlBQVlFLE1BQU0sQ0FBQ3hCLEtBQUt5QixNQUFNLElBQUksQ0FBQzFEO2dCQUUvRCxpRkFBaUY7Z0JBQ2pGLG9GQUFvRjtnQkFDcEYsNEZBQTRGO2dCQUM1Rix1RkFBdUY7Z0JBQ3ZGLHVDQUF1QztnQkFDdkMsd0ZBQXdGO2dCQUN4RixJQUFJMkQsU0FBU3RCLEtBQUt1QixJQUFJLENBQUMsUUFBUzlELFFBQVVDLFNBQVNBLFVBQVc7Z0JBRTlELCtGQUErRjtnQkFDL0YsdUVBQXVFO2dCQUV2RSxtRkFBbUY7Z0JBQ25GLDRGQUE0RjtnQkFDNUYsRUFBRTtnQkFDRixRQUFRO2dCQUNSLDJEQUEyRDtnQkFDM0QsUUFBUTtnQkFDUixFQUFFO2dCQUNGLElBQUk4RCxRQUFRVCxXQUFXZixLQUFLeUIsRUFBRSxHQUFHO2dCQUVqQyxrR0FBa0c7Z0JBQ2xHLDBHQUEwRztnQkFDMUcsMkVBQTJFO2dCQUMzRUQsU0FBU3hCLEtBQUswQixJQUFJLENBQUNYLFdBQVcsS0FBSyxJQUFJckQsU0FBU0QsUUFBUUEsUUFBUUM7Z0JBRWhFLHdGQUF3RjtnQkFDeEY4RCxTQUFTaEYsbURBQUtBLENBQUNtQjtnQkFFZiw2RkFBNkY7Z0JBQzdGLCtEQUErRDtnQkFDL0QsSUFBSTBELFNBQVM5RSwrQ0FBS0EsQ0FBQ29GLFNBQVMsQ0FBQ0wsUUFBUUUsT0FBT0w7Z0JBRTVDLG1GQUFtRjtnQkFDbkYscUZBQXFGO2dCQUNyRix1QkFBdUI7Z0JBQ3ZCTCxTQUFTdkUsbURBQUtBLENBQUM4RSxRQUFRTyxNQUFNLENBQUNuRSxRQUFRLENBQUMsR0FBR0MsU0FBUyxDQUFDO1lBRXhELE9BQU87Z0JBQ0gsNEVBQTRFO2dCQUM1RW9ELFNBQVNsQixLQUFLaUMsT0FBTztnQkFFckIsT0FBUTFELElBQUkwQyxTQUFTO29CQUNqQixLQUFLO29CQUNMLEtBQUs7d0JBQ0RDLE9BQU9jLE1BQU0sQ0FBQyxHQUFHaEMsS0FBS2xDLE1BQU0sR0FBR0E7d0JBQy9CO29CQUNKLEtBQUs7b0JBQ0wsS0FBSzt3QkFDRG9ELE9BQU9jLE1BQU0sQ0FBQ2hDLEtBQUtuQyxLQUFLLEdBQUVBLE9BQU87d0JBQ2pDO29CQUNKLEtBQUs7d0JBQ0RxRCxPQUFPYyxNQUFNLENBQUNoQyxLQUFLbkMsS0FBSyxHQUFHQSxPQUFPbUMsS0FBS2xDLE1BQU0sR0FBR0E7d0JBQ2hEO2dCQUNSO1lBQ0o7WUFFQSxpREFBaUQ7WUFDakQsSUFBSSxDQUFDd0IsR0FBRyxDQUFDLFFBQVE7Z0JBQUV6QixPQUFPQTtnQkFBT0MsUUFBUUE7WUFBTyxHQUFHUztZQUVuRCxvQ0FBb0M7WUFDcEMsSUFBSSxDQUFDZCxRQUFRLENBQUN5RCxPQUFPeEQsQ0FBQyxFQUFFd0QsT0FBT3ZELENBQUMsRUFBRVk7UUFFdEMsT0FBTztZQUVILHNCQUFzQjtZQUN0QixJQUFJLENBQUNlLEdBQUcsQ0FBQyxRQUFRO2dCQUFFekIsT0FBT0E7Z0JBQU9DLFFBQVFBO1lBQU8sR0FBR1M7UUFDdkQ7UUFFQSxJQUFJLENBQUNzQyxTQUFTLENBQUMsVUFBVXRDO1FBRXpCLE9BQU8sSUFBSTtJQUNmO0lBRUEyRCxPQUFPLFNBQVNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFbEIsTUFBTSxFQUFFM0MsR0FBRztRQUUvQixJQUFJOEQsYUFBYSxJQUFJLENBQUNwQyxPQUFPLEdBQUdpQyxLQUFLLENBQUNDLElBQUlDLElBQUlsQjtRQUM5QyxJQUFJLENBQUNOLFVBQVUsQ0FBQyxTQUFTckM7UUFDekIsSUFBSSxDQUFDZCxRQUFRLENBQUM0RSxXQUFXM0UsQ0FBQyxFQUFFMkUsV0FBVzFFLENBQUMsRUFBRVk7UUFDMUMsSUFBSSxDQUFDeUMsTUFBTSxDQUFDcUIsV0FBV3hFLEtBQUssRUFBRXdFLFdBQVd2RSxNQUFNLEVBQUVTO1FBQ2pELElBQUksQ0FBQ3NDLFNBQVMsQ0FBQztRQUNmLE9BQU8sSUFBSTtJQUNmO0lBRUF5QixXQUFXLFNBQVMvRCxHQUFHO1FBRW5CLE9BQU8sSUFBSSxDQUFDZ0UsYUFBYSxDQUFDaEU7SUFDOUI7SUFFQWdFLGVBQWUsU0FBU2hFLE1BQU0sQ0FBQyxDQUFDO1FBRTVCLG9FQUFvRTtRQUNwRSxzREFBc0Q7UUFDdEQsTUFBTSxFQUFFTSxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3RCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlDLE1BQU07UUFFNUIsTUFBTTBELGdCQUFnQixJQUFJLENBQUM3QixnQkFBZ0IsR0FBRzhCLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS3BFLFNBQVM7UUFDM0UsSUFBSWtFLGNBQWNHLE1BQU0sS0FBSyxHQUFHLE9BQU8sSUFBSTtRQUUzQyxJQUFJLENBQUMvQixVQUFVLENBQUMsY0FBY3JDO1FBRTlCLElBQUlBLElBQUlHLElBQUksRUFBRTtZQUNWLG9EQUFvRDtZQUNwRCx3R0FBd0c7WUFDeEcsdUhBQXVIO1lBQ3ZIdkIsdURBQU1BLENBQUNxRixlQUFlLGlCQUFpQmpFO1FBQzNDO1FBRUEsdURBQXVEO1FBQ3ZELG9DQUFvQztRQUNwQyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDcUUsY0FBYyxDQUFDQyxPQUFPM0YsTUFBTSxDQUFDO1lBQUU0RixVQUFVTjtRQUFjLEdBQUdqRTtRQUUvRCxJQUFJLENBQUNzQyxTQUFTLENBQUM7UUFFZixPQUFPLElBQUk7SUFDZjtJQUVBa0MsV0FBVyxTQUFTeEUsTUFBTSxDQUFDLENBQUM7UUFFeEIsTUFBTSxFQUFFTSxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3RCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlDLE1BQU07UUFFNUIsc0ZBQXNGO1FBQ3RGLGtJQUFrSTtRQUNsSSxJQUFJUCxJQUFJRyxJQUFJLElBQUlILElBQUl5RSxVQUFVLElBQUssS0FBS0EsVUFBVSxLQUFLLElBQUksSUFBTXpFLElBQUl5RSxVQUFVLEtBQUssSUFBSSxDQUFDcEQsRUFBRSxHQUFJLE9BQU8sSUFBSTtRQUUxRyxNQUFNcUQsZ0JBQWdCLElBQUksQ0FBQ2pFLGFBQWE7UUFDeEMsSUFBSSxDQUFDaUUsaUJBQWlCLENBQUNBLGNBQWMzRSxTQUFTLElBQUksT0FBTyxJQUFJO1FBRTdELGlGQUFpRjtRQUNqRixNQUFNNEUsa0JBQWtCRCxjQUFjdEMsZ0JBQWdCLEdBQUc4QixNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtwRSxTQUFTO1FBQ3RGLElBQUk0RSxnQkFBZ0JQLE1BQU0sS0FBSyxHQUFHLE9BQU8sSUFBSTtRQUU3QyxJQUFJLENBQUMvQixVQUFVLENBQUMsY0FBY3JDO1FBRTlCLHlEQUF5RDtRQUN6RCxpR0FBaUc7UUFDakcsb0NBQW9DO1FBQ3BDMEUsY0FBY0wsY0FBYyxDQUFDQyxPQUFPM0YsTUFBTSxDQUFDO1lBQUU0RixVQUFVSTtRQUFnQixHQUFHM0U7UUFFMUUsSUFBSUEsSUFBSUcsSUFBSSxFQUFFO1lBQ1YsNEVBQTRFO1lBQzVFLGlHQUFpRztZQUNqRyx1SEFBdUg7WUFDdkh1RSxjQUFjRixTQUFTLENBQUN4RTtRQUM1QjtRQUVBLElBQUksQ0FBQ3NDLFNBQVMsQ0FBQztRQUVmLE9BQU8sSUFBSTtJQUNmO0lBRUEsK0NBQStDO0lBQy9DK0IsZ0JBQWdCLFNBQVNyRSxNQUFNLENBQUMsQ0FBQztRQUU3QixNQUFNNEUsZUFBZSxJQUFJLENBQUN0RSxLQUFLLENBQUN1RSxZQUFZLENBQUM3RSxJQUFJdUUsUUFBUTtRQUN6RCxrREFBa0Q7UUFDbEQsSUFBSSxDQUFDSyxjQUFjO1FBRW5CLE1BQU0sRUFBRUUsVUFBVSxFQUFFQyxVQUFVLEVBQUUsR0FBRy9FO1FBQ25DLCtDQUErQztRQUMvQyxJQUFJOEUsY0FBY0MsWUFBWTtRQUU5Qiw0REFBNEQ7UUFDNUQsc0NBQXNDO1FBQ3RDLHlFQUF5RTtRQUN6RSxJQUFJLEVBQUU1RixDQUFDLEVBQUVDLENBQUMsRUFBRUUsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR3FGO1FBQzlCLE1BQU0sRUFBRUksSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxFQUFFLEdBQUd0RywrREFBY0EsQ0FBQ21CLElBQUlvRixPQUFPO1FBQy9EakcsS0FBSzZGO1FBQ0w1RixLQUFLOEY7UUFDTDVGLFNBQVMwRixPQUFPQztRQUNoQjFGLFVBQVU0RixTQUFTRDtRQUNuQixJQUFJRyxhQUFhLElBQUk5Ryw4Q0FBSUEsQ0FBQ1ksR0FBR0MsR0FBR0UsT0FBT0M7UUFFdkMsSUFBSXVGLFlBQVk7WUFDWixxSEFBcUg7WUFDckhPLGFBQWEsSUFBSSxDQUFDM0QsT0FBTyxHQUFHNEQsS0FBSyxDQUFDRDtRQUV0QyxPQUFPLElBQUlOLFlBQVk7WUFDbkIsNEhBQTRIO1lBQzVILE1BQU1RLG1CQUFtQixJQUFJLENBQUM3RCxPQUFPLEdBQUc4RCxTQUFTLENBQUNIO1lBQ2xELGdJQUFnSTtZQUNoSSxJQUFJLENBQUNFLGtCQUFrQjtZQUV2QkYsYUFBY0U7UUFDbEI7UUFFQSxpREFBaUQ7UUFDakQsSUFBSSxDQUFDeEUsR0FBRyxDQUFDO1lBQ0w3QixVQUFVO2dCQUFFQyxHQUFHa0csV0FBV2xHLENBQUM7Z0JBQUVDLEdBQUdpRyxXQUFXakcsQ0FBQztZQUFDO1lBQzdDQyxNQUFNO2dCQUFFQyxPQUFPK0YsV0FBVy9GLEtBQUs7Z0JBQUVDLFFBQVE4RixXQUFXOUYsTUFBTTtZQUFDO1FBQy9ELEdBQUdTO0lBQ1A7SUFFQSx1RUFBdUU7SUFDdkUsaUZBQWlGO0lBQ2pGLGlGQUFpRjtJQUNqRiwwQ0FBMEM7SUFDMUNpRCxRQUFRLFNBQVN6RCxLQUFLLEVBQUVxRCxRQUFRLEVBQUVGLE1BQU0sRUFBRTNDLEdBQUc7UUFFekMsSUFBSTJDLFFBQVE7WUFFUixJQUFJTyxTQUFTLElBQUksQ0FBQ3hCLE9BQU8sR0FBR3dCLE1BQU07WUFDbEMsSUFBSTdELE9BQU8sSUFBSSxDQUFDc0IsR0FBRyxDQUFDO1lBQ3BCLElBQUl6QixXQUFXLElBQUksQ0FBQ3lCLEdBQUcsQ0FBQztZQUN4QnVDLE9BQU9ELE1BQU0sQ0FBQ04sUUFBUSxJQUFJLENBQUNoQyxHQUFHLENBQUMsV0FBV25CO1lBQzFDLElBQUltQyxLQUFLdUIsT0FBTy9ELENBQUMsR0FBR0UsS0FBS0MsS0FBSyxHQUFHLElBQUlKLFNBQVNDLENBQUM7WUFDL0MsSUFBSXlDLEtBQUtzQixPQUFPOUQsQ0FBQyxHQUFHQyxLQUFLRSxNQUFNLEdBQUcsSUFBSUwsU0FBU0UsQ0FBQztZQUNoRCxJQUFJLENBQUNpRCxVQUFVLENBQUMsVUFBVTtnQkFBRTdDLE9BQU9BO2dCQUFPcUQsVUFBVUE7Z0JBQVVGLFFBQVFBO1lBQU87WUFDN0UsSUFBSSxDQUFDekQsUUFBUSxDQUFDQSxTQUFTQyxDQUFDLEdBQUd3QyxJQUFJekMsU0FBU0UsQ0FBQyxHQUFHd0MsSUFBSTVCO1lBQ2hELElBQUksQ0FBQ2lELE1BQU0sQ0FBQ3pELE9BQU9xRCxVQUFVLE1BQU03QztZQUNuQyxJQUFJLENBQUNzQyxTQUFTLENBQUM7UUFFbkIsT0FBTztZQUVILElBQUksQ0FBQ3ZCLEdBQUcsQ0FBQyxTQUFTOEIsV0FBV3JELFFBQVEsQ0FBQyxJQUFJLENBQUNtQixHQUFHLENBQUMsV0FBV25CLEtBQUksSUFBSyxLQUFLUTtRQUM1RTtRQUVBLE9BQU8sSUFBSTtJQUNmO0lBRUFSLE9BQU87UUFDSCxPQUFPbEIsNERBQWNBLENBQUMsSUFBSSxDQUFDcUMsR0FBRyxDQUFDLFlBQVk7SUFDL0M7SUFFQWUsU0FBUyxTQUFTMUIsTUFBTSxDQUFDLENBQUM7UUFFdEIsTUFBTSxFQUFFTSxLQUFLLEVBQUVtRixVQUFVLEVBQUUsR0FBRyxJQUFJO1FBQ2xDLE1BQU0sRUFBRXRGLElBQUksRUFBRThDLE1BQU0sRUFBRSxHQUFHakQ7UUFFekIsSUFBSUcsUUFBUUcsT0FBTztZQUNmLCtEQUErRDtZQUMvRCxNQUFNaUUsV0FBVyxJQUFJLENBQUNuQyxnQkFBZ0IsQ0FBQztnQkFBRWpDLE1BQU07Z0JBQU11RixjQUFjO1lBQUs7WUFDeEUsd0JBQXdCO1lBQ3hCbkIsU0FBU29CLElBQUksQ0FBQyxJQUFJO1lBQ2xCLGtFQUFrRTtZQUNsRSxvQ0FBb0M7WUFDcEMsT0FBT3JGLE1BQU11RSxZQUFZLENBQUNOLFVBQVV2RTtRQUN4QztRQUVBLE1BQU0sRUFBRVIsUUFBUSxDQUFDLEVBQUVOLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxFQUFDLEdBQUdrRztRQUNsRSxNQUFNaEUsT0FBTyxJQUFJbEQsOENBQUlBLENBQUNZLEdBQUdDLEdBQUdFLE9BQU9DO1FBQ25DLElBQUkwRCxRQUFRO1lBQ1J4QixLQUFLbUUsa0JBQWtCLENBQUNwRztRQUM1QjtRQUNBLE9BQU9pQztJQUNYO0lBRUFvRSwyQkFBMkIsU0FBU0MsSUFBSSxFQUFFQyxPQUFPO1FBQzdDLHNCQUFzQjtRQUN0QixJQUFJdEUsT0FBTyxJQUFJLENBQUNDLE9BQU87UUFDdkIsSUFBSXdCLFNBQVN6QixLQUFLeUIsTUFBTTtRQUN4QixtQkFBbUI7UUFDbkIsSUFBSThDLFNBQVNGLEtBQUtuRixHQUFHLENBQUNvRjtRQUN0QixJQUFJLENBQUNDLFFBQVEsT0FBTzlDO1FBQ3BCLElBQUkrQyxTQUFTRCxPQUFPRSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxDQUFDRixTQUFTLE9BQU8vQztRQUM3QyxJQUFJa0QsWUFBWSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0osUUFBUTtZQUFDO1NBQVE7UUFDL0MsSUFBSUssaUJBQWlCLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNIO1FBQzVDLElBQUlJLGFBQWEsSUFBSXBJLCtDQUFLQSxDQUFDa0ksY0FBYyxDQUFDTCxPQUFPLEVBQUV4QyxNQUFNLENBQUNoQyxLQUFLa0IsTUFBTTtRQUNyRSxJQUFJbkQsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSUEsT0FBT2dILFdBQVd2RCxNQUFNLENBQUNDLFFBQVEsQ0FBQzFEO1FBQ3RDLE9BQU9nSDtJQUNYO0FBQ0osR0FBRztBQUVIN0gsdURBQU1BLENBQUNJLFFBQVFZLFNBQVMsRUFBRWIsNERBQW9CQSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2RpYS9FbGVtZW50Lm1qcz8zNzQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwubWpzJztcbmltcG9ydCB7IFBvaW50LCB0b1JhZCwgbm9ybWFsaXplQW5nbGUsIFJlY3QgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc051bWJlciwgaXNPYmplY3QsIGludGVycG9sYXRlLCBhc3NpZ24sIGludm9rZSwgbm9ybWFsaXplU2lkZXMgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBlbGVtZW50UG9ydFByb3RvdHlwZSB9IGZyb20gJy4vcG9ydHMubWpzJztcblxuLy8gRWxlbWVudCBiYXNlIG1vZGVsLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IEVsZW1lbnQgPSBDZWxsLmV4dGVuZCh7XG5cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHNpemU6IHsgd2lkdGg6IDEsIGhlaWdodDogMSB9LFxuICAgICAgICBhbmdsZTogMFxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplUG9ydHMoKTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgaW4gcG9ydHMuanNcbiAgICB9LFxuXG4gICAgX3JlZnJlc2hQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih4LCB5LCBvcHQpIHtcblxuICAgICAgICBjb25zdCBpc1NldHRlciA9IGlzTnVtYmVyKHkpO1xuICAgICAgICBvcHQgPSAoaXNTZXR0ZXIgPyBvcHQgOiB4KSB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRSZWxhdGl2ZSwgZGVlcCwgcmVzdHJpY3RlZEFyZWEgfSA9IG9wdDtcblxuXG4gICAgICAgIC8vIG9wdGlvbiBgcGFyZW50UmVsYXRpdmVgIGZvciBzZXR0aW5nIHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIHBhcmVudC5cbiAgICAgICAgbGV0IHBhcmVudFBvc2l0aW9uO1xuICAgICAgICBpZiAocGFyZW50UmVsYXRpdmUpIHtcblxuICAgICAgICAgICAgLy8gR2V0dGluZyB0aGUgcGFyZW50J3MgcG9zaXRpb24gcmVxdWlyZXMgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAvLyBDZWxsLnBhcmVudCgpIGhvbGRzIGNlbGwgaWQgb25seS5cbiAgICAgICAgICAgIGlmICghdGhpcy5ncmFwaCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG11c3QgYmUgcGFydCBvZiBhIGdyYXBoLicpO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudFBvc2l0aW9uID0gcGFyZW50LmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NldHRlcikge1xuXG4gICAgICAgICAgICBpZiAocGFyZW50UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB4ICs9IHBhcmVudFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgeSArPSBwYXJlbnRQb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVlcCB8fCByZXN0cmljdGVkQXJlYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogeDAsIHk6IHkwIH0gPSB0aGlzLmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSh4IC0geDAsIHkgLSB5MCwgb3B0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3Bvc2l0aW9uJywgeyB4LCB5IH0sIG9wdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIEdldHRlciByZXR1cm5zIGEgZ2VvbWV0cnkgcG9pbnQuXG5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRQb3NpdGlvbiA9IFBvaW50KHRoaXMuZ2V0KCdwb3NpdGlvbicpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRSZWxhdGl2ZVxuICAgICAgICAgICAgICAgID8gZWxlbWVudFBvc2l0aW9uLmRpZmZlcmVuY2UocGFyZW50UG9zaXRpb24pXG4gICAgICAgICAgICAgICAgOiBlbGVtZW50UG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHksIG9wdCkge1xuXG4gICAgICAgIHR4ID0gdHggfHwgMDtcbiAgICAgICAgdHkgPSB0eSB8fCAwO1xuXG4gICAgICAgIGlmICh0eCA9PT0gMCAmJiB0eSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTGlrZSBub3RoaW5nIGhhcyBoYXBwZW5lZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICAvLyBQYXNzIHRoZSBpbml0aWF0b3Igb2YgdGhlIHRyYW5zbGF0aW9uLlxuICAgICAgICBvcHQudHJhbnNsYXRlQnkgPSBvcHQudHJhbnNsYXRlQnkgfHwgdGhpcy5pZDtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldCgncG9zaXRpb24nKSB8fCB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdmFyIHJhID0gb3B0LnJlc3RyaWN0ZWRBcmVhO1xuICAgICAgICBpZiAocmEgJiYgb3B0LnRyYW5zbGF0ZUJ5ID09PSB0aGlzLmlkKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmEgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHJhLmNhbGwodGhpcywgcG9zaXRpb24ueCArIHR4LCBwb3NpdGlvbi55ICsgdHksIG9wdCk7XG5cbiAgICAgICAgICAgICAgICB0eCA9IG5ld1Bvc2l0aW9uLnggLSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHR5ID0gbmV3UG9zaXRpb24ueSAtIHBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSByZXN0cmljdGluZyB0aGUgdHJhbnNsYXRpb24gZm9yIHRoZSBlbGVtZW50IGl0c2VsZiBvbmx5LiBXZSBnZXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50IGluY2x1ZGluZyBhbGwgaXRzIGVtYmVkcy5cbiAgICAgICAgICAgICAgICAvLyBBbGwgZW1iZWRzIGhhdmUgdG8gYmUgdHJhbnNsYXRlZCB0aGUgZXhhY3Qgc2FtZSB3YXkgYXMgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIC8vLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLT4gcmEueCArIHJhLndpZHRoXG4gICAgICAgICAgICAgICAgLy8gLSAtIC0gLT4gcG9zaXRpb24ueCAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAtPiBiYm94LnhcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICDilpPilpPilpPilpPilpPilpPilpMgICB8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICDilpHilpHilpHilpHilpHilpHilpHilpPilpPilpPilpPilpPilpPilpNcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIOKWkeKWkeKWkeKWkeKWkeKWkeKWkeKWkeKWkSAgICAgICAgfFxuICAgICAgICAgICAgICAgIC8vICAg4paT4paT4paT4paT4paT4paT4paT4paT4paR4paR4paR4paR4paR4paR4paRXG4gICAgICAgICAgICAgICAgLy8gICDilpPilpPilpPilpPilpPilpPilpPilpMgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gICA8LWR4LT4gICAgICAgICAgICAgICAgICAgICB8IHJlc3RyaWN0ZWQgYXJlYSByaWdodCBib3JkZXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIDwtd2lkdGgtPiAgICAgICAgfCAgIOKWkSB0cmFuc2xhdGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAgIDwtIC0gYmJveC53aWR0aCAtIC0+ICAgICAgIOKWkyBlbWJlZGRlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gcG9zaXRpb24ueCAtIGJib3gueDtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSBwb3NpdGlvbi55IC0gYmJveC55O1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1heGltYWwvbWluaW1hbCBjb29yZGluYXRlcyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZSB0cmFuc2xhdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgY29tcGxpZXMgdGhlIHJlc3RyaWN0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGgubWF4KHJhLnggKyBkeCwgTWF0aC5taW4ocmEueCArIHJhLndpZHRoICsgZHggLSBiYm94LndpZHRoLCBwb3NpdGlvbi54ICsgdHgpKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGgubWF4KHJhLnkgKyBkeSwgTWF0aC5taW4ocmEueSArIHJhLmhlaWdodCArIGR5IC0gYmJveC5oZWlnaHQsIHBvc2l0aW9uLnkgKyB0eSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiB0YWtpbmcgdGhlIHJlc3RyaWN0aW9ucyBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgdHggPSB4IC0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB0eSA9IHkgLSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLnggKyB0eCxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnkgKyB0eVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvIGZpbmQgb3V0IGJ5IGhvdyBtdWNoIGFuIGVsZW1lbnQgd2FzIHRyYW5zbGF0ZWQgaW4gZXZlbnQgJ2NoYW5nZTpwb3NpdGlvbicgaGFuZGxlcnMuXG4gICAgICAgIG9wdC50eCA9IHR4O1xuICAgICAgICBvcHQudHkgPSB0eTtcblxuICAgICAgICBpZiAob3B0LnRyYW5zaXRpb24pIHtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvcHQudHJhbnNpdGlvbikpIG9wdC50cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbigncG9zaXRpb24nLCB0cmFuc2xhdGVkUG9zaXRpb24sIGFzc2lnbih7fSwgb3B0LnRyYW5zaXRpb24sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUZ1bmN0aW9uOiBpbnRlcnBvbGF0ZS5vYmplY3RcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2FsbCBgdHJhbnNsYXRlKClgIG9uIGFsbCB0aGUgZW1iZWRzIGNlbGxzLlxuICAgICAgICAgICAgaW52b2tlKHRoaXMuZ2V0RW1iZWRkZWRDZWxscygpLCAndHJhbnNsYXRlJywgdHgsIHR5LCBvcHQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgndHJhbnNsYXRlJywgb3B0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdwb3NpdGlvbicsIHRyYW5zbGF0ZWRQb3NpdGlvbiwgb3B0KTtcbiAgICAgICAgICAgIGludm9rZSh0aGlzLmdldEVtYmVkZGVkQ2VsbHMoKSwgJ3RyYW5zbGF0ZScsIHR4LCB0eSwgb3B0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCd0cmFuc2xhdGUnLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IHRoaXMuZ2V0KCdzaXplJyk7XG4gICAgICAgIC8vIEdldHRlclxuICAgICAgICAvLyAoKSBzaWduYXR1cmVcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY3VycmVudFNpemUuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHRlclxuICAgICAgICAvLyAoc2l6ZSwgb3B0KSBzaWduYXR1cmVcbiAgICAgICAgaWYgKGlzT2JqZWN0KHdpZHRoKSkge1xuICAgICAgICAgICAgb3B0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gaXNOdW1iZXIod2lkdGguaGVpZ2h0KSA/IHdpZHRoLmhlaWdodCA6IGN1cnJlbnRTaXplLmhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gaXNOdW1iZXIod2lkdGgud2lkdGgpID8gd2lkdGgud2lkdGggOiBjdXJyZW50U2l6ZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcHQpO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3Jlc2l6ZScsIG9wdCk7XG5cbiAgICAgICAgaWYgKG9wdC5kaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gdGhpcy5nZXQoJ3NpemUnKTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHQuZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoYW5nZSBoZWlnaHQgd2hlbiByZXNpemluZyBob3Jpem9udGFsbHkuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGN1cnJlbnRTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoYW5nZSB3aWR0aCB3aGVuIHJlc2l6aW5nIHZlcnRpY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY3VycmVudFNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFuZ2xlIGFuZCBjbGFtcCBpdHMgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlcy5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHRoaXMuZ2V0KCdhbmdsZScpIHx8IDApO1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVjdGFuZ2xlIGluIHNpemUgb2YgdGhlIHVuLXJvdGF0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW47XG5cbiAgICAgICAgICAgIGlmIChhbmdsZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHF1YWRyYW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAndG9wLXJpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcC1sZWZ0JzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdib3R0b20tbGVmdCc6IDIsXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogMixcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbS1yaWdodCc6IDMsXG4gICAgICAgICAgICAgICAgICAgICdib3R0b20nOiAzXG4gICAgICAgICAgICAgICAgfVtvcHQuZGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHQuYWJzb2x1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgdGFraW5nIHRoZSBlbGVtZW50J3Mgcm90YXRpb24gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYW50ICs9IE1hdGguZmxvb3IoKGFuZ2xlICsgNDUpIC8gOTApO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmFudCAlPSA0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBpY2sgdGhlIGNvcm5lciBwb2ludCBvbiB0aGUgZWxlbWVudCwgd2hpY2ggbWVhbnQgdG8gc3RheSBvbiBpdHMgcGxhY2UgYmVmb3JlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSByb3RhdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgZml4ZWRQb2ludCA9IGJib3hbWydib3R0b21MZWZ0JywgJ2Nvcm5lcicsICd0b3BSaWdodCcsICdvcmlnaW4nXVtxdWFkcmFudF1dKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kICBhbiBpbWFnZSBvZiB0aGUgcHJldmlvdXMgaW5kZW50IHBvaW50LiBUaGlzIGlzIHRoZSBwb3NpdGlvbiwgd2hlcmUgaXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gcG9pbnQgYWN0dWFsbHkgbG9jYXRlZCBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgICAgIHZhciBpbWFnZUZpeGVkUG9pbnQgPSBQb2ludChmaXhlZFBvaW50KS5yb3RhdGUoYmJveC5jZW50ZXIoKSwgLWFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5IHBvaW50IG9uIHRoZSBlbGVtZW50IHJvdGF0ZXMgYXJvdW5kIGEgY2lyY2xlIHdpdGggdGhlIGNlbnRyZSBvZiByb3RhdGlvblxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgdGhlIGVsZW1lbnQgd2hpbGUgdGhlIHdob2xlIGVsZW1lbnQgaXMgYmVpbmcgcm90YXRlZC4gVGhhdCBtZWFuc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCBpbiB0aGUgY29ybmVyIG9mIHRoZSBlbGVtZW50IChzdXBwb3NlZCBpdHMgYWx3YXlzIHJlY3QpIHRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCBkb2Vzbid0IGNoYW5nZSBkdXJpbmcgdGhlIHJvdGF0aW9uIGFuZCB0aGVyZWZvcmUgaXQgZXF1YWxzXG4gICAgICAgICAgICAgICAgLy8gdG8gYSBkaXN0YW5jZSBvbiB1bi1yb3RhdGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGZpbmQgdGhlIGRpc3RhbmNlIGFzIERJU1RBTkNFID0gKEVMRU1FTlRXSURUSC8yKV4yICsgKEVMRU1FTlRIRUlHSFQvMileMileMC41LlxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoKHdpZHRoICogd2lkdGgpICsgKGhlaWdodCAqIGhlaWdodCkpIC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBhcmUgbG9va2luZyBmb3IgYW4gYW5nbGUgYmV0d2VlbiB4LWF4aXMgYW5kIHRoZSBsaW5lIHN0YXJ0aW5nIGF0IGltYWdlIG9mIGZpeGVkIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIGVuZGluZyBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LiBXZSBjYWxsIHRoaXMgYW5nbGUgYGFscGhhYC5cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBpbWFnZSBvZiBhIGZpeGVkIHBvaW50IGlzIGxvY2F0ZWQgaW4gbi10aCBxdWFkcmFudC4gRm9yIGVhY2ggcXVhZHJhbnQgcGFzc2VkXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgYW50aS1jbG9ja3dpc2Ugd2UgaGF2ZSB0byBhZGQgOTAgZGVncmVlcy4gTm90ZSB0aGF0IHRoZSBmaXJzdCBxdWFkcmFudCBoYXMgaW5kZXggMC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIDMgfCAyXG4gICAgICAgICAgICAgICAgLy8gLS1jLS0gUXVhZHJhbnQgcG9zaXRpb25zIGFyb3VuZCB0aGUgZWxlbWVudCdzIGNlbnRlciBgY2BcbiAgICAgICAgICAgICAgICAvLyAwIHwgMVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gcXVhZHJhbnQgKiBNYXRoLlBJIC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbiBhbmdsZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgcXVhZHJhbnQgKGxpbmUgcGFyYWxsZWwgd2l0aCB4LWF4aXMgb3IgeS1heGlzXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50KSBhbmQgbGluZSBjcm9zc2luZyB0aGUgaW5kZW50IG9mIHRoZSBmaXhlZCBwb2ludCBhbmQgdGhlIGNlbnRlclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBlbGVtZW50LiBUaGlzIGlzIHRoZSBhbmdsZSB3ZSBuZWVkIGJ1dCBvbiB0aGUgdW4tcm90YXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGFscGhhICs9IE1hdGguYXRhbihxdWFkcmFudCAlIDIgPT0gMCA/IGhlaWdodCAvIHdpZHRoIDogd2lkdGggLyBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGFzdGx5IHdlIGhhdmUgdG8gZGVkdWN0IHRoZSBvcmlnaW5hbCBhbmdsZSB0aGUgZWxlbWVudCB3YXMgcm90YXRlZCBieSBhbmQgdGhhdCdzIGl0LlxuICAgICAgICAgICAgICAgIGFscGhhIC09IHRvUmFkKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIFdpdGggdGhpcyBhbmdsZSBhbmQgZGlzdGFuY2Ugd2UgY2FuIGVhc2lseSBjYWxjdWxhdGUgdGhlIGNlbnRyZSBvZiB0aGUgdW4tcm90YXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmcm9tUG9sYXIgY29uc3RydWN0b3IgYWNjZXB0cyBhbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBQb2ludC5mcm9tUG9sYXIocmFkaXVzLCBhbHBoYSwgaW1hZ2VGaXhlZFBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb24gdGhlIHVuLXJvdGF0ZWQgZWxlbWVudCBoYXMgdG8gYmUgaGFsZiBhIHdpZHRoIG9uIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgLy8gYW5kIGhhbGYgYSBoZWlnaHQgdG8gdGhlIHRvcCBmcm9tIHRoZSBjZW50ZXIuIFRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luIG9mIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIC8vIHdlIHdlcmUgbG9va2luZyBmb3IuXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gUG9pbnQoY2VudGVyKS5vZmZzZXQod2lkdGggLyAtMiwgaGVpZ2h0IC8gLTIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uIGZvciB0aGUgb3JpZ2luIFBvaW50IHdoZW4gdGhlcmUgaXMgbm8gcm90YXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBiYm94LnRvcExlZnQoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9mZnNldCgwLCBiYm94LmhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5vZmZzZXQoYmJveC53aWR0aCAtd2lkdGgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5vZmZzZXQoYmJveC53aWR0aCAtIHdpZHRoLCBiYm94LmhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2l6ZSB0aGUgZWxlbWVudCAoYmVmb3JlIHJlLXBvc2l0aW9uaW5nIGl0KS5cbiAgICAgICAgICAgIHRoaXMuc2V0KCdzaXplJywgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIG9wdCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHJlLXBvc2l0aW9uIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbihvcmlnaW4ueCwgb3JpZ2luLnksIG9wdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gUmVzaXplIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5zZXQoJ3NpemUnLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdyZXNpemUnLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4sIG9wdCkge1xuXG4gICAgICAgIHZhciBzY2FsZWRCQm94ID0gdGhpcy5nZXRCQm94KCkuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3NjYWxlJywgb3B0KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihzY2FsZWRCQm94LngsIHNjYWxlZEJCb3gueSwgb3B0KTtcbiAgICAgICAgdGhpcy5yZXNpemUoc2NhbGVkQkJveC53aWR0aCwgc2NhbGVkQkJveC5oZWlnaHQsIG9wdCk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdzY2FsZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZml0RW1iZWRzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5maXRUb0NoaWxkcmVuKG9wdCk7XG4gICAgfSxcblxuICAgIGZpdFRvQ2hpbGRyZW46IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgLy8gR2V0dGluZyB0aGUgY2hpbGRyZW4ncyBzaXplIGFuZCBwb3NpdGlvbiByZXF1aXJlcyB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgLy8gQ2VsbC5nZXQoJ2VtYmVkcycpIGhvbGRzIGFuIGFycmF5IG9mIGNlbGwgaWRzIG9ubHkuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGggfSA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGgpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgYSBncmFwaC4nKTtcblxuICAgICAgICBjb25zdCBjaGlsZEVsZW1lbnRzID0gdGhpcy5nZXRFbWJlZGRlZENlbGxzKCkuZmlsdGVyKGNlbGwgPT4gY2VsbC5pc0VsZW1lbnQoKSk7XG4gICAgICAgIGlmIChjaGlsZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdmaXQtZW1iZWRzJywgb3B0KTtcblxuICAgICAgICBpZiAob3B0LmRlZXApIHtcbiAgICAgICAgICAgIC8vIGBvcHQuZGVlcCA9IHRydWVgIG1lYW5zIFwiZml0IHRvIGFsbCBkZXNjZW5kYW50c1wiLlxuICAgICAgICAgICAgLy8gQXMgdGhlIGZpcnN0IGFjdGlvbiBvZiB0aGUgZml0dGluZyBhbGdvcml0aG0sIHJlY3Vyc2l2ZWx5IGFwcGx5IGBmaXRUb0NoaWxkcmVuKClgIG9uIGFsbCBkZXNjZW5kYW50cy5cbiAgICAgICAgICAgIC8vIC0gaS5lLiB0aGUgYWxnb3JpdGhtIGlzIGFwcGxpZWQgaW4gcmV2ZXJzZS1kZXB0aCBvcmRlciAtIHN0YXJ0IGZyb20gZGVlcGVzdCBkZXNjZW5kYW50LCB0aGVuIGdvIHVwICg9IHRoaXMgZWxlbWVudCkuXG4gICAgICAgICAgICBpbnZva2UoY2hpbGRFbGVtZW50cywgJ2ZpdFRvQ2hpbGRyZW4nLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG5ldyBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQsIGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBhbGwgY2hpbGRyZW5cbiAgICAgICAgLy8gLSBpbmZsYXRlZCBieSBnaXZlbiBgb3B0LnBhZGRpbmdgXG4gICAgICAgIHRoaXMuX2ZpdFRvRWxlbWVudHMoT2JqZWN0LmFzc2lnbih7IGVsZW1lbnRzOiBjaGlsZEVsZW1lbnRzIH0sIG9wdCkpO1xuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdmaXQtZW1iZWRzJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpdFBhcmVudDogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB7IGdyYXBoIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWdyYXBoKSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbXVzdCBiZSBwYXJ0IG9mIGEgZ3JhcGguJyk7XG5cbiAgICAgICAgLy8gV2hlbiBgb3B0LmRlZXAgPSB0cnVlYCwgd2Ugd2FudCBgb3B0LnRlcm1pbmF0b3JgIHRvIGJlIHRoZSBsYXN0IGFuY2VzdG9yIHByb2Nlc3NlZC5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBgb3B0LnRlcm1pbmF0b3JgLCBpdCBtZWFucyB0aGF0IHRoaXMgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBhcyBwYXJlbnQgc28gd2UgY2FuIGV4aXQgbm93LlxuICAgICAgICBpZiAob3B0LmRlZXAgJiYgb3B0LnRlcm1pbmF0b3IgJiYgKChvcHQudGVybWluYXRvciA9PT0gdGhpcykgfHwgKG9wdC50ZXJtaW5hdG9yID09PSB0aGlzLmlkKSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgaWYgKCFwYXJlbnRFbGVtZW50IHx8ICFwYXJlbnRFbGVtZW50LmlzRWxlbWVudCgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBHZXQgYWxsIGNoaWxkcmVuIG9mIHBhcmVudCBlbGVtZW50IChpLmUuIHRoaXMgZWxlbWVudCArIGFueSBzaWJsaW5nIGVsZW1lbnRzKS5cbiAgICAgICAgY29uc3Qgc2libGluZ0VsZW1lbnRzID0gcGFyZW50RWxlbWVudC5nZXRFbWJlZGRlZENlbGxzKCkuZmlsdGVyKGNlbGwgPT4gY2VsbC5pc0VsZW1lbnQoKSk7XG4gICAgICAgIGlmIChzaWJsaW5nRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ2ZpdC1wYXJlbnQnLCBvcHQpO1xuXG4gICAgICAgIC8vIFNldCBuZXcgc2l6ZSBhbmQgcG9zaXRpb24gb2YgcGFyZW50IGVsZW1lbnQsIGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBhbGwgY2hpbGRyZW4gb2YgcGFyZW50IGVsZW1lbnQgKGkuZS4gdGhpcyBlbGVtZW50ICsgYW55IHNpYmxpbmcgZWxlbWVudHMpXG4gICAgICAgIC8vIC0gaW5mbGF0ZWQgYnkgZ2l2ZW4gYG9wdC5wYWRkaW5nYFxuICAgICAgICBwYXJlbnRFbGVtZW50Ll9maXRUb0VsZW1lbnRzKE9iamVjdC5hc3NpZ24oeyBlbGVtZW50czogc2libGluZ0VsZW1lbnRzIH0sIG9wdCkpO1xuXG4gICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgLy8gYG9wdC5kZWVwID0gdHJ1ZWAgbWVhbnMgXCJmaXQgYWxsIGFuY2VzdG9ycyB0byB0aGVpciByZXNwZWN0aXZlIGNoaWxkcmVuXCIuXG4gICAgICAgICAgICAvLyBBcyB0aGUgbGFzdCBhY3Rpb24gb2YgdGhlIGZpdHRpbmcgYWxnb3JpdGhtLCByZWN1cnNpdmVseSBhcHBseSBgZml0UGFyZW50KClgIG9uIGFsbCBhbmNlc3RvcnMuXG4gICAgICAgICAgICAvLyAtIGkuZS4gdGhlIGFsZ29yaXRobSBpcyBhcHBsaWVkIGluIHJldmVyc2UtZGVwdGggb3JkZXIgLSBzdGFydCBmcm9tIGRlZXBlc3QgZGVzY2VuZGFudCAoPSB0aGlzIGVsZW1lbnQpLCB0aGVuIGdvIHVwLlxuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5maXRQYXJlbnQob3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdmaXQtcGFyZW50Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFzc3VtcHRpb246IFRoaXMgZWxlbWVudCBpcyBwYXJ0IG9mIGEgZ3JhcGguXG4gICAgX2ZpdFRvRWxlbWVudHM6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudHNCQm94ID0gdGhpcy5ncmFwaC5nZXRDZWxsc0JCb3gob3B0LmVsZW1lbnRzKTtcbiAgICAgICAgLy8gSWYgbm8gYG9wdC5lbGVtZW50c2Agd2VyZSBwcm92aWRlZCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKCFlbGVtZW50c0JCb3gpIHJldHVybjtcblxuICAgICAgICBjb25zdCB7IGV4cGFuZE9ubHksIHNocmlua09ubHkgfSA9IG9wdDtcbiAgICAgICAgLy8gVGhpcyBjb21iaW5hdGlvbiBpcyBtZWFuaW5nbGVzcywgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKGV4cGFuZE9ubHkgJiYgc2hyaW5rT25seSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBgb3B0LmVsZW1lbnRzYFxuICAgICAgICAvLyAtIGluZmxhdGVkIGJ5IGBvcHQucGFkZGluZ2AgKGlmIG5vdCBwcm92aWRlZCwgYWxsIGZvdXIgcHJvcGVydGllcyA9IDApXG4gICAgICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGVsZW1lbnRzQkJveDtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IG5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nKTtcbiAgICAgICAgeCAtPSBsZWZ0O1xuICAgICAgICB5IC09IHRvcDtcbiAgICAgICAgd2lkdGggKz0gbGVmdCArIHJpZ2h0O1xuICAgICAgICBoZWlnaHQgKz0gYm90dG9tICsgdG9wO1xuICAgICAgICBsZXQgcmVzdWx0QkJveCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmIChleHBhbmRPbmx5KSB7XG4gICAgICAgICAgICAvLyBOb24tc2hyaW5raW5nIGlzIGVuZm9yY2VkIGJ5IHRha2luZyB1bmlvbiBvZiB0aGlzIGVsZW1lbnQncyBjdXJyZW50IGJib3ggd2l0aCBiYm94IGNhbGN1bGF0ZWQgZnJvbSBgb3B0LmVsZW1lbnRzYC5cbiAgICAgICAgICAgIHJlc3VsdEJCb3ggPSB0aGlzLmdldEJCb3goKS51bmlvbihyZXN1bHRCQm94KTtcblxuICAgICAgICB9IGVsc2UgaWYgKHNocmlua09ubHkpIHtcbiAgICAgICAgICAgIC8vIE5vbi1leHBhbnNpb24gaXMgZW5mb3JjZWQgYnkgdGFraW5nIGludGVyc2VjdGlvbiBvZiB0aGlzIGVsZW1lbnQncyBjdXJyZW50IGJib3ggd2l0aCBiYm94IGNhbGN1bGF0ZWQgZnJvbSBgb3B0LmVsZW1lbnRzYC5cbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbkJCb3ggPSB0aGlzLmdldEJCb3goKS5pbnRlcnNlY3QocmVzdWx0QkJveCk7XG4gICAgICAgICAgICAvLyBJZiBhbGwgY2hpbGRyZW4gYXJlIG91dHNpZGUgdGhpcyBlbGVtZW50J3MgY3VycmVudCBiYm94LCB0aGVuIGBpbnRlcnNlY3Rpb25CQm94YCBpcyBgbnVsbGAgLSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb25CQm94KSByZXR1cm47XG5cbiAgICAgICAgICAgIHJlc3VsdEJCb3ggPSAgaW50ZXJzZWN0aW9uQkJveDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgbmV3IHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcmVzdWx0QkJveC54LCB5OiByZXN1bHRCQm94LnkgfSxcbiAgICAgICAgICAgIHNpemU6IHsgd2lkdGg6IHJlc3VsdEJCb3gud2lkdGgsIGhlaWdodDogcmVzdWx0QkJveC5oZWlnaHQgfVxuICAgICAgICB9LCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSb3RhdGUgZWxlbWVudCBieSBgYW5nbGVgIGRlZ3JlZXMsIG9wdGlvbmFsbHkgYXJvdW5kIGBvcmlnaW5gIHBvaW50LlxuICAgIC8vIElmIGBvcmlnaW5gIGlzIG5vdCBwcm92aWRlZCwgaXQgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICAgIC8vIElmIGBhYnNvbHV0ZWAgaXMgYHRydWVgLCB0aGUgYGFuZ2xlYCBpcyBjb25zaWRlcmVkIGlzIGFic29sdXRlLCBpLmUuIGl0IGlzIG5vdFxuICAgIC8vIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIGFuZ2xlLlxuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGFic29sdXRlLCBvcmlnaW4sIG9wdCkge1xuXG4gICAgICAgIGlmIChvcmlnaW4pIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0QkJveCgpLmNlbnRlcigpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldCgnc2l6ZScpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICBjZW50ZXIucm90YXRlKG9yaWdpbiwgdGhpcy5nZXQoJ2FuZ2xlJykgLSBhbmdsZSk7XG4gICAgICAgICAgICB2YXIgZHggPSBjZW50ZXIueCAtIHNpemUud2lkdGggLyAyIC0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbnRlci55IC0gc2l6ZS5oZWlnaHQgLyAyIC0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncm90YXRlJywgeyBhbmdsZTogYW5nbGUsIGFic29sdXRlOiBhYnNvbHV0ZSwgb3JpZ2luOiBvcmlnaW4gfSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKHBvc2l0aW9uLnggKyBkeCwgcG9zaXRpb24ueSArIGR5LCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoYW5nbGUsIGFic29sdXRlLCBudWxsLCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3JvdGF0ZScpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFic29sdXRlID8gYW5nbGUgOiAodGhpcy5nZXQoJ2FuZ2xlJykgKyBhbmdsZSkgJSAzNjAsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUodGhpcy5nZXQoJ2FuZ2xlJykgfHwgMCk7XG4gICAgfSxcblxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWVwLCByb3RhdGUgfSA9IG9wdDtcblxuICAgICAgICBpZiAoZGVlcCAmJiBncmFwaCkge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgZW1iZWRkZWQgZWxlbWVudHMgdXNpbmcgYnJlYWR0aCBmaXJzdCBhbGdvcml0aG0uXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUsIGJyZWFkdGhGaXJzdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kZWwgaXRzZWxmLlxuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBkZWZhdWx0IG9mIGdldENlbGxzQkJveCgpIGlzIHJvdGF0ZT10cnVlIGFuZCBjYW4ndCBiZVxuICAgICAgICAgICAgLy8gY2hhbmdlZCB3aXRob3V0IGEgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgICAgICByZXR1cm4gZ3JhcGguZ2V0Q2VsbHNCQm94KGVsZW1lbnRzLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBhbmdsZSA9IDAsIHBvc2l0aW9uOiB7IHgsIHkgfSwgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH19ID0gYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgYmJveCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICBiYm94LnJvdGF0ZUFyb3VuZENlbnRlcihhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIGdldFBvaW50RnJvbUNvbm5lY3RlZExpbms6IGZ1bmN0aW9uKGxpbmssIGVuZFR5cGUpIHtcbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSBtb2RlbFxuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB2YXIgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcbiAgICAgICAgLy8gQ2VudGVyIG9mIGEgcG9ydFxuICAgICAgICB2YXIgZW5kRGVmID0gbGluay5nZXQoZW5kVHlwZSk7XG4gICAgICAgIGlmICghZW5kRGVmKSByZXR1cm4gY2VudGVyO1xuICAgICAgICB2YXIgcG9ydElkID0gZW5kRGVmLnBvcnQ7XG4gICAgICAgIGlmICghcG9ydElkIHx8ICF0aGlzLmhhc1BvcnQocG9ydElkKSkgcmV0dXJuIGNlbnRlcjtcbiAgICAgICAgdmFyIHBvcnRHcm91cCA9IHRoaXMucG9ydFByb3AocG9ydElkLCBbJ2dyb3VwJ10pO1xuICAgICAgICB2YXIgcG9ydHNQb3NpdGlvbnMgPSB0aGlzLmdldFBvcnRzUG9zaXRpb25zKHBvcnRHcm91cCk7XG4gICAgICAgIHZhciBwb3J0Q2VudGVyID0gbmV3IFBvaW50KHBvcnRzUG9zaXRpb25zW3BvcnRJZF0pLm9mZnNldChiYm94Lm9yaWdpbigpKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZSgpO1xuICAgICAgICBpZiAoYW5nbGUpIHBvcnRDZW50ZXIucm90YXRlKGNlbnRlciwgLWFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHBvcnRDZW50ZXI7XG4gICAgfVxufSk7XG5cbmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZWxlbWVudFBvcnRQcm90b3R5cGUpO1xuXG4iXSwibmFtZXMiOlsiQ2VsbCIsIlBvaW50IiwidG9SYWQiLCJub3JtYWxpemVBbmdsZSIsIlJlY3QiLCJpc051bWJlciIsImlzT2JqZWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NpZ24iLCJpbnZva2UiLCJub3JtYWxpemVTaWRlcyIsImVsZW1lbnRQb3J0UHJvdG90eXBlIiwiRWxlbWVudCIsImV4dGVuZCIsImRlZmF1bHRzIiwicG9zaXRpb24iLCJ4IiwieSIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFuZ2xlIiwiaW5pdGlhbGl6ZSIsIl9pbml0aWFsaXplUG9ydHMiLCJwcm90b3R5cGUiLCJhcHBseSIsImFyZ3VtZW50cyIsIl9yZWZyZXNoUG9ydHMiLCJpc0VsZW1lbnQiLCJvcHQiLCJpc1NldHRlciIsInBhcmVudFJlbGF0aXZlIiwiZGVlcCIsInJlc3RyaWN0ZWRBcmVhIiwicGFyZW50UG9zaXRpb24iLCJncmFwaCIsIkVycm9yIiwicGFyZW50IiwiZ2V0UGFyZW50Q2VsbCIsImlzTGluayIsImdldCIsIngwIiwieTAiLCJ0cmFuc2xhdGUiLCJzZXQiLCJlbGVtZW50UG9zaXRpb24iLCJkaWZmZXJlbmNlIiwidHgiLCJ0eSIsInRyYW5zbGF0ZUJ5IiwiaWQiLCJyYSIsIm5ld1Bvc2l0aW9uIiwiY2FsbCIsImJib3giLCJnZXRCQm94IiwiZHgiLCJkeSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJ0cmFuc2xhdGVkUG9zaXRpb24iLCJ0cmFuc2l0aW9uIiwidmFsdWVGdW5jdGlvbiIsIm9iamVjdCIsImdldEVtYmVkZGVkQ2VsbHMiLCJzdGFydEJhdGNoIiwic3RvcEJhdGNoIiwiY3VycmVudFNpemUiLCJ1bmRlZmluZWQiLCJyZXNpemUiLCJkaXJlY3Rpb24iLCJvcmlnaW4iLCJxdWFkcmFudCIsImFic29sdXRlIiwiZmxvb3IiLCJmaXhlZFBvaW50IiwiaW1hZ2VGaXhlZFBvaW50Iiwicm90YXRlIiwiY2VudGVyIiwicmFkaXVzIiwic3FydCIsImFscGhhIiwiUEkiLCJhdGFuIiwiZnJvbVBvbGFyIiwib2Zmc2V0IiwidG9wTGVmdCIsInNjYWxlIiwic3giLCJzeSIsInNjYWxlZEJCb3giLCJmaXRFbWJlZHMiLCJmaXRUb0NoaWxkcmVuIiwiY2hpbGRFbGVtZW50cyIsImZpbHRlciIsImNlbGwiLCJsZW5ndGgiLCJfZml0VG9FbGVtZW50cyIsIk9iamVjdCIsImVsZW1lbnRzIiwiZml0UGFyZW50IiwidGVybWluYXRvciIsInBhcmVudEVsZW1lbnQiLCJzaWJsaW5nRWxlbWVudHMiLCJlbGVtZW50c0JCb3giLCJnZXRDZWxsc0JCb3giLCJleHBhbmRPbmx5Iiwic2hyaW5rT25seSIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsInBhZGRpbmciLCJyZXN1bHRCQm94IiwidW5pb24iLCJpbnRlcnNlY3Rpb25CQm94IiwiaW50ZXJzZWN0IiwiYXR0cmlidXRlcyIsImJyZWFkdGhGaXJzdCIsInB1c2giLCJyb3RhdGVBcm91bmRDZW50ZXIiLCJnZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rIiwibGluayIsImVuZFR5cGUiLCJlbmREZWYiLCJwb3J0SWQiLCJwb3J0IiwiaGFzUG9ydCIsInBvcnRHcm91cCIsInBvcnRQcm9wIiwicG9ydHNQb3NpdGlvbnMiLCJnZXRQb3J0c1Bvc2l0aW9ucyIsInBvcnRDZW50ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/Element.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/ElementView.mjs":
/*!******************************************************!*\
  !*** ./node_modules/jointjs/src/dia/ElementView.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementView: () => (/* binding */ ElementView)\n/* harmony export */ });\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/jointjs/src/config/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/CellView.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ports.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/ports.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Flags.TOOLS,\n    UPDATE: \"UPDATE\",\n    TRANSLATE: \"TRANSLATE\",\n    RESIZE: \"RESIZE\",\n    PORTS: \"PORTS\",\n    ROTATE: \"ROTATE\",\n    RENDER: \"RENDER\"\n};\nconst DragActions = {\n    MOVE: \"move\",\n    MAGNET: \"magnet\"\n};\n// Element base view and controller.\n// -------------------------------------------\nconst ElementView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.extend({\n    /**\n     * @abstract\n     */ _removePorts: function() {\n    // implemented in ports.js\n    },\n    /**\n     *\n     * @abstract\n     */ _renderPorts: function() {\n    // implemented in ports.js\n    },\n    className: function() {\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.className.apply(this).split(\" \");\n        classNames.push(\"element\");\n        return classNames.join(\" \");\n    },\n    initialize: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.initialize.apply(this, arguments);\n        this._initializePorts();\n    },\n    presentationAttributes: {\n        \"attrs\": [\n            Flags.UPDATE\n        ],\n        \"position\": [\n            Flags.TRANSLATE,\n            Flags.TOOLS\n        ],\n        \"size\": [\n            Flags.RESIZE,\n            Flags.PORTS,\n            Flags.TOOLS\n        ],\n        \"angle\": [\n            Flags.ROTATE,\n            Flags.TOOLS\n        ],\n        \"markup\": [\n            Flags.RENDER\n        ],\n        \"ports\": [\n            Flags.PORTS\n        ]\n    },\n    initFlag: [\n        Flags.RENDER\n    ],\n    UPDATE_PRIORITY: 0,\n    confirmUpdate: function(flag, opt) {\n        const { useCSSSelectors } = _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [\n                Flags.RENDER,\n                Flags.UPDATE,\n                Flags.RESIZE,\n                Flags.TRANSLATE,\n                Flags.ROTATE,\n                Flags.PORTS,\n                Flags.TOOLS\n            ]);\n        } else {\n            let updateHighlighters = false;\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [\n                    Flags.RESIZE,\n                    Flags.UPDATE\n                ]);\n                if (useCSSSelectors) {\n                    // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n        return flag;\n    },\n    /**\n     * @abstract\n     */ _initializePorts: function() {},\n    update: function(_, renderingOnlyAttrs) {\n        this.cleanNodesCache();\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config;\n        if (useCSSSelectors) this._removePorts();\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n        });\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n    rotatableSelector: \"rotatable\",\n    scalableSelector: \"scalable\",\n    scalableNode: null,\n    rotatableNode: null,\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n        var element = this.model;\n        var markup = element.get(\"markup\") || element.markup;\n        if (!markup) throw new Error(\"dia.ElementView: markup required\");\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === \"string\") return this.renderStringMarkup(markup);\n        throw new Error(\"dia.ElementView: invalid markup\");\n    },\n    renderJSONMarkup: function(markup) {\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n    renderStringMarkup: function(markup) {\n        var vel = this.vel;\n        vel.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne(\".rotatable\");\n        this.scalableNode = vel.findOne(\".scalable\");\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n    render: function() {\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!_config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n    resize: function(opt) {\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n    translate: function() {\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n    rotate: function() {\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n    updateTransformation: function() {\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += \" \" + rotateString;\n        this.vel.attr(\"transform\", transformation);\n    },\n    getTranslateString: function() {\n        var position = this.model.attributes.position;\n        return \"translate(\" + position.x + \",\" + position.y + \")\";\n    },\n    getRotateString: function() {\n        var attributes = this.model.attributes;\n        var angle = attributes.angle;\n        if (!angle) return null;\n        var size = attributes.size;\n        return \"rotate(\" + angle + \",\" + size.width / 2 + \",\" + size.height / 2 + \")\";\n    },\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n    rgRotate: function() {\n        this.rotatableNode.attr(\"transform\", this.getRotateString());\n    },\n    rgTranslate: function() {\n        this.vel.attr(\"transform\", this.getTranslateString());\n    },\n    sgResize: function(opt) {\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName(\"path\").length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({\n            recursive: recursive\n        });\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = size.width / (scalableBBox.width || 1);\n        var sy = size.height / (scalableBBox.height || 1);\n        scalable.attr(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr(\"transform\");\n        if (rotation) {\n            rotatable.attr(\"transform\", rotation + \" rotate(\" + -angle + \",\" + size.width / 2 + \",\" + size.height / 2 + \")\");\n            var rotatableBBox = scalable.getBBox({\n                target: this.paper.cells\n            });\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set(\"position\", {\n                x: rotatableBBox.x,\n                y: rotatableBBox.y\n            }, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)({\n                updateHandled: true\n            }, opt));\n            this.translate();\n            this.rotate();\n        }\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n    // Embedding mode methods.\n    // -----------------------\n    prepareEmbedding: function(data = {}) {\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({\n            deep: true\n        });\n        const connectedLinks = graph.getConnectedLinks(element, {\n            deep: true,\n            includeEnclosed: true\n        });\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach((cell)=>initialZIndices[cell.id] = cell.attributes.z);\n        element.startBatch(\"to-front\");\n        // Bring the model to the front with all his embeds.\n        element.toFront({\n            deep: true,\n            ui: true\n        });\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell)=>Math.max(max, cell.attributes.z || 0), 0);\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link)=>{\n            if (link.attributes.z <= maxZ) {\n                link.set(\"z\", maxZ + 1, {\n                    ui: true\n                });\n            }\n        });\n        element.stopBatch(\"to-front\");\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, {\n                ui: true\n            });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n    processEmbedding: function(data = {}, evt, x, y) {\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n        let candidates;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(findParentBy)) {\n            candidates = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toArray)(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === \"pointer\") {\n            candidates = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toArray)(graph.findModelsFromPoint({\n                x,\n                y\n            }));\n        } else {\n            candidates = graph.findModelsUnderElement(model, {\n                searchBy: findParentBy\n            });\n        }\n        candidates = candidates.filter((el)=>{\n            return el instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_5__.Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n        });\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for(let i = candidates.length - 1; i >= 0; i--){\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, \"container\"), {\n                embedding: true\n            });\n        }\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n    clearEmbedding: function(data) {\n        data || (data = {});\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(candidateView.findProxyNode(null, \"container\"), {\n                embedding: true\n            });\n            data.candidateEmbedView = null;\n        }\n    },\n    finalizeEmbedding: function(data = {}) {\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        if (candidateView) {\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, {\n                ui: true\n            });\n            candidateView.unhighlight(candidateView.findProxyNode(null, \"container\"), {\n                embedding: true\n            });\n            data.candidateEmbedView = null;\n        } else {\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (initialParentId && typeof validateUnembedding === \"function\" && !validateUnembedding.call(paper, this)) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n        paper.model.getConnectedLinks(element, {\n            deep: true\n        }).forEach((link)=>{\n            link.reparent({\n                ui: true\n            });\n        });\n    },\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = \"revert\" } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch(whenNotAllowed){\n            case \"remove\":\n                {\n                    element.remove({\n                        ui: true\n                    });\n                    break;\n                }\n            case \"revert\":\n                {\n                    const { initialParentId, initialPosition, initialZIndices } = data;\n                    // Revert the element's position (and the position of its embedded cells if any)\n                    if (initialPosition) {\n                        const { x, y } = initialPosition;\n                        element.position(x, y, {\n                            deep: true,\n                            ui: true\n                        });\n                    }\n                    // Revert all the z-indices changed during the embedding\n                    if (initialZIndices) {\n                        Object.keys(initialZIndices).forEach((id)=>{\n                            const cell = graph.getCell(id);\n                            if (cell) {\n                                cell.set(\"z\", initialZIndices[id], {\n                                    ui: true\n                                });\n                            }\n                        });\n                    }\n                    // Revert the original parent\n                    const parent = graph.getCell(initialParentId);\n                    if (parent) {\n                        parent.embed(element, {\n                            ui: true\n                        });\n                    }\n                    break;\n                }\n        }\n    },\n    getDelegatedView: function() {\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n        while(view){\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can(\"stopDelegation\")) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n        return null;\n    },\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute(\"port\", el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const [proxyNode] = this.findBySelector(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n    // Interaction. The controller part.\n    // ---------------------------------\n    notifyPointerdown (evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify(\"element:pointerdown\", evt, x, y);\n    },\n    notifyPointermove (evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify(\"element:pointermove\", evt, x, y);\n    },\n    notifyPointerup (evt, x, y) {\n        this.notify(\"element:pointerup\", evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n    pointerdblclick: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify(\"element:pointerdblclick\", evt, x, y);\n    },\n    pointerclick: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify(\"element:pointerclick\", evt, x, y);\n    },\n    contextmenu: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify(\"element:contextmenu\", evt, x, y);\n    },\n    pointerdown: function(evt, x, y) {\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n    pointermove: function(evt, x, y) {\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n        if (targetMagnet) {\n            this.magnetpointermove(evt, targetMagnet, x, y);\n        }\n        switch(action){\n            case DragActions.MAGNET:\n                this.dragMagnet(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n    pointerup: function(evt, x, y) {\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n        if (targetMagnet) {\n            this.magnetpointerup(evt, targetMagnet, x, y);\n        }\n        switch(action){\n            case DragActions.MAGNET:\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointerup(evt, x, y);\n        }\n        if (targetMagnet) {\n            this.magnetpointerclick(evt, targetMagnet, x, y);\n        }\n        this.checkMouseleave(evt);\n    },\n    mouseover: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify(\"element:mouseover\", evt);\n    },\n    mouseout: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify(\"element:mouseout\", evt);\n    },\n    mouseenter: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify(\"element:mouseenter\", evt);\n    },\n    mouseleave: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify(\"element:mouseleave\", evt);\n    },\n    mousewheel: function(evt, x, y, delta) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify(\"element:mousewheel\", evt, x, y, delta);\n    },\n    onmagnet: function(evt, x, y) {\n        const { currentTarget: targetMagnet } = evt;\n        this.magnetpointerdown(evt, targetMagnet, x, y);\n        this.eventData(evt, {\n            targetMagnet\n        });\n        this.dragMagnetStart(evt, x, y);\n    },\n    magnetpointerdown: function(evt, magnet, x, y) {\n        this.notify(\"element:magnet:pointerdown\", evt, magnet, x, y);\n    },\n    magnetpointermove: function(evt, magnet, x, y) {\n        this.notify(\"element:magnet:pointermove\", evt, magnet, x, y);\n    },\n    magnetpointerup: function(evt, magnet, x, y) {\n        this.notify(\"element:magnet:pointerup\", evt, magnet, x, y);\n    },\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n        this.notify(\"element:magnet:pointerdblclick\", evt, magnet, x, y);\n    },\n    magnetcontextmenu: function(evt, magnet, x, y) {\n        this.notify(\"element:magnet:contextmenu\", evt, magnet, x, y);\n    },\n    // Drag Start Handlers\n    dragStart: function(evt, x, y) {\n        if (this.isDefaultInteractionPrevented(evt)) return;\n        var view = this.getDelegatedView();\n        if (!view || !view.can(\"elementMove\")) return;\n        this.eventData(evt, {\n            action: DragActions.MOVE,\n            delegatedView: view\n        });\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n    dragMagnetStart: function(evt, x, y) {\n        const { paper } = this;\n        const isPropagationAlreadyStopped = evt.isPropagationStopped();\n        if (isPropagationAlreadyStopped) {\n            // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, {\n                preventPointerEvents: true\n            });\n        }\n        if (this.isDefaultInteractionPrevented(evt) || !this.can(\"addLinkFromMagnet\")) {\n            // Stop the default action, which is to start dragging a link.\n            return;\n        }\n        const { targetMagnet = evt.currentTarget } = this.eventData(evt);\n        evt.stopPropagation();\n        // Invalid (Passive) magnet. Start dragging the element.\n        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n            if (isPropagationAlreadyStopped) {\n                // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n            // The `element:pointerdown` event is not triggered because\n            // of `preventPointerEvents` flag.\n            } else {\n                // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n            }\n            return;\n        }\n        // Valid magnet. Start dragging a link.\n        if (paper.options.magnetThreshold <= 0) {\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n        this.eventData(evt, {\n            action: DragActions.MAGNET\n        });\n    },\n    // Drag Handlers\n    drag: function(evt, x, y) {\n        var paper = this.paper;\n        var grid = paper.options.gridSize;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n        // Make sure the new element's position always snaps to the current grid\n        var elX = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.snapToGrid)(x + pointerOffset.x, grid);\n        var elY = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.snapToGrid)(y + pointerOffset.y, grid);\n        element.position(elX, elY, {\n            restrictedArea,\n            deep: true,\n            ui: true\n        });\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n        this.eventData(evt, {\n            embedding\n        });\n    },\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n    // Drag End Handlers\n    dragEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify(\"element:magnet:pointerclick\", evt, magnet, x, y);\n    }\n}, {\n    Flags: Flags\n});\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)(ElementView.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_7__.elementViewPortPrototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0VsZW1lbnRWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkM7QUFDbUI7QUFDdEI7QUFDUjtBQUNIO0FBQ3dCO0FBQ0w7QUFFbEQsTUFBTVUsUUFBUTtJQUNWQyxPQUFPUCxtREFBUUEsQ0FBQ00sS0FBSyxDQUFDQyxLQUFLO0lBQzNCQyxRQUFRO0lBQ1JDLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBRUEsTUFBTUMsY0FBYztJQUNoQkMsTUFBTTtJQUNOQyxRQUFRO0FBQ1o7QUFDQSxvQ0FBb0M7QUFDcEMsOENBQThDO0FBRXZDLE1BQU1DLGNBQWNqQixtREFBUUEsQ0FBQ2tCLE1BQU0sQ0FBQztJQUV2Qzs7S0FFQyxHQUNEQyxjQUFjO0lBQ1YsMEJBQTBCO0lBQzlCO0lBRUE7OztLQUdDLEdBQ0RDLGNBQWM7SUFDViwwQkFBMEI7SUFDOUI7SUFFQUMsV0FBVztRQUVQLElBQUlDLGFBQWF0QixtREFBUUEsQ0FBQ3VCLFNBQVMsQ0FBQ0YsU0FBUyxDQUFDRyxLQUFLLENBQUMsSUFBSSxFQUFFQyxLQUFLLENBQUM7UUFFaEVILFdBQVdJLElBQUksQ0FBQztRQUVoQixPQUFPSixXQUFXSyxJQUFJLENBQUM7SUFDM0I7SUFFQUMsWUFBWTtRQUVSNUIsbURBQVFBLENBQUN1QixTQUFTLENBQUNLLFVBQVUsQ0FBQ0osS0FBSyxDQUFDLElBQUksRUFBRUs7UUFFMUMsSUFBSSxDQUFDQyxnQkFBZ0I7SUFDekI7SUFFQUMsd0JBQXdCO1FBQ3BCLFNBQVM7WUFBQ3pCLE1BQU1FLE1BQU07U0FBQztRQUN2QixZQUFZO1lBQUNGLE1BQU1HLFNBQVM7WUFBRUgsTUFBTUMsS0FBSztTQUFDO1FBQzFDLFFBQVE7WUFBQ0QsTUFBTUksTUFBTTtZQUFFSixNQUFNSyxLQUFLO1lBQUVMLE1BQU1DLEtBQUs7U0FBQztRQUNoRCxTQUFTO1lBQUNELE1BQU1NLE1BQU07WUFBRU4sTUFBTUMsS0FBSztTQUFDO1FBQ3BDLFVBQVU7WUFBQ0QsTUFBTU8sTUFBTTtTQUFDO1FBQ3hCLFNBQVM7WUFBQ1AsTUFBTUssS0FBSztTQUFDO0lBQzFCO0lBRUFxQixVQUFVO1FBQUMxQixNQUFNTyxNQUFNO0tBQUM7SUFFeEJvQixpQkFBaUI7SUFFakJDLGVBQWUsU0FBU0MsSUFBSSxFQUFFQyxHQUFHO1FBRTdCLE1BQU0sRUFBRUMsZUFBZSxFQUFFLEdBQUd6QyxxREFBTUE7UUFDbEMsSUFBSSxJQUFJLENBQUMwQyxPQUFPLENBQUNILE1BQU03QixNQUFNSyxLQUFLLEdBQUc7WUFDakMsSUFBSSxDQUFDUSxZQUFZO1lBQ2pCLElBQUksQ0FBQ29CLGdCQUFnQjtRQUN6QjtRQUNBLElBQUlDLHdCQUF3QjtRQUM1QixJQUFJLElBQUksQ0FBQ0YsT0FBTyxDQUFDSCxNQUFNN0IsTUFBTU8sTUFBTSxHQUFHO1lBQ2xDLElBQUksQ0FBQzRCLE1BQU07WUFDWCxJQUFJLENBQUNDLFdBQVcsQ0FBQ047WUFDakIsSUFBSSxDQUFDTyxrQkFBa0IsQ0FBQztZQUN4Qkgsd0JBQXdCO1lBQ3hCTCxPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDVCxNQUFNO2dCQUFDN0IsTUFBTU8sTUFBTTtnQkFBRVAsTUFBTUUsTUFBTTtnQkFBRUYsTUFBTUksTUFBTTtnQkFBRUosTUFBTUcsU0FBUztnQkFBRUgsTUFBTU0sTUFBTTtnQkFBRU4sTUFBTUssS0FBSztnQkFBRUwsTUFBTUMsS0FBSzthQUFDO1FBQ3BJLE9BQU87WUFDSCxJQUFJb0MscUJBQXFCO1lBRXpCLHlDQUF5QztZQUN6QyxJQUFJLElBQUksQ0FBQ0wsT0FBTyxDQUFDSCxNQUFNN0IsTUFBTUksTUFBTSxHQUFHO2dCQUNsQyxJQUFJLENBQUNtQyxNQUFNLENBQUNUO2dCQUNaTyxxQkFBcUI7Z0JBQ3JCLGlEQUFpRDtnQkFDakRSLE9BQU8sSUFBSSxDQUFDUyxVQUFVLENBQUNULE1BQU07b0JBQUM3QixNQUFNSSxNQUFNO29CQUFFSixNQUFNRSxNQUFNO2lCQUFDO2dCQUN6RCxJQUFJNkIsaUJBQWlCO29CQUNqQixpRUFBaUU7b0JBQ2pFRixPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDVCxNQUFNN0IsTUFBTUssS0FBSztnQkFDNUM7WUFDSjtZQUNBLElBQUksSUFBSSxDQUFDMkIsT0FBTyxDQUFDSCxNQUFNN0IsTUFBTUUsTUFBTSxHQUFHO2dCQUNsQyxJQUFJLENBQUNzQyxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUUsTUFBTVg7Z0JBQzlCRCxPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDVCxNQUFNN0IsTUFBTUUsTUFBTTtnQkFDekNtQyxxQkFBcUI7Z0JBQ3JCLElBQUlOLGlCQUFpQjtvQkFDakIsZ0VBQWdFO29CQUNoRUYsT0FBTyxJQUFJLENBQUNTLFVBQVUsQ0FBQ1QsTUFBTTdCLE1BQU1LLEtBQUs7Z0JBQzVDO1lBQ0o7WUFDQSxJQUFJLElBQUksQ0FBQzJCLE9BQU8sQ0FBQ0gsTUFBTTdCLE1BQU1HLFNBQVMsR0FBRztnQkFDckMsSUFBSSxDQUFDdUMsU0FBUztnQkFDZGIsT0FBTyxJQUFJLENBQUNTLFVBQVUsQ0FBQ1QsTUFBTTdCLE1BQU1HLFNBQVM7Z0JBQzVDK0Isd0JBQXdCO1lBQzVCO1lBQ0EsSUFBSSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0gsTUFBTTdCLE1BQU1NLE1BQU0sR0FBRztnQkFDbEMsSUFBSSxDQUFDcUMsTUFBTTtnQkFDWGQsT0FBTyxJQUFJLENBQUNTLFVBQVUsQ0FBQ1QsTUFBTTdCLE1BQU1NLE1BQU07Z0JBQ3pDNEIsd0JBQXdCO1lBQzVCO1lBQ0EsSUFBSSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0gsTUFBTTdCLE1BQU1LLEtBQUssR0FBRztnQkFDakMsSUFBSSxDQUFDUyxZQUFZO2dCQUNqQnVCLHFCQUFxQjtnQkFDckJSLE9BQU8sSUFBSSxDQUFDUyxVQUFVLENBQUNULE1BQU03QixNQUFNSyxLQUFLO1lBQzVDO1lBRUEsSUFBSWdDLG9CQUFvQjtnQkFDcEIsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQztZQUM1QjtRQUNKO1FBRUEsSUFBSUgsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQ0EscUJBQXFCO1FBQzlCO1FBRUEsSUFBSSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0gsTUFBTTdCLE1BQU1DLEtBQUssR0FBRztZQUNqQyxJQUFJLENBQUNtQyxXQUFXLENBQUNOO1lBQ2pCRCxPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDVCxNQUFNN0IsTUFBTUMsS0FBSztRQUM1QztRQUVBLE9BQU80QjtJQUNYO0lBRUE7O0tBRUMsR0FDREwsa0JBQWtCLFlBRWxCO0lBRUFnQixRQUFRLFNBQVNJLENBQUMsRUFBRUMsa0JBQWtCO1FBRWxDLElBQUksQ0FBQ0MsZUFBZTtRQUVwQiw0RUFBNEU7UUFDNUUsTUFBTSxFQUFFZixlQUFlLEVBQUUsR0FBR3pDLHFEQUFNQTtRQUNsQyxJQUFJeUMsaUJBQWlCLElBQUksQ0FBQ2xCLFlBQVk7UUFFdEMsSUFBSTRCLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlNLGFBQWFOLE1BQU1PLElBQUk7UUFDM0IsSUFBSSxDQUFDQywwQkFBMEIsQ0FBQyxJQUFJLENBQUNDLEVBQUUsRUFBRUgsWUFBWTtZQUNqREksVUFBVSxJQUFJckQsOENBQUlBLENBQUMyQyxNQUFNVyxJQUFJO1lBQzdCQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsY0FBYyxJQUFJLENBQUNBLFlBQVk7WUFDL0JDLGVBQWUsSUFBSSxDQUFDQSxhQUFhO1lBQ2pDLDBFQUEwRTtZQUMxRUMsY0FBYyx1QkFBd0JULGFBQWMsT0FBT0Y7UUFDL0Q7UUFFQSxJQUFJZCxpQkFBaUI7WUFDakIsSUFBSSxDQUFDakIsWUFBWTtRQUNyQjtJQUNKO0lBRUEyQyxtQkFBbUI7SUFDbkJDLGtCQUFrQjtJQUNsQkosY0FBYztJQUNkQyxlQUFlO0lBRWYsNEZBQTRGO0lBQzVGLG1DQUFtQztJQUNuQ0ksY0FBYztRQUVWLElBQUlDLFVBQVUsSUFBSSxDQUFDbkIsS0FBSztRQUN4QixJQUFJb0IsU0FBU0QsUUFBUUUsR0FBRyxDQUFDLGFBQWFGLFFBQVFDLE1BQU07UUFDcEQsSUFBSSxDQUFDQSxRQUFRLE1BQU0sSUFBSUUsTUFBTTtRQUM3QixJQUFJQyxNQUFNQyxPQUFPLENBQUNKLFNBQVMsT0FBTyxJQUFJLENBQUNLLGdCQUFnQixDQUFDTDtRQUN4RCxJQUFJLE9BQU9BLFdBQVcsVUFBVSxPQUFPLElBQUksQ0FBQ00sa0JBQWtCLENBQUNOO1FBQy9ELE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUVBRyxrQkFBa0IsU0FBU0wsTUFBTTtRQUU3QixJQUFJTyxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDUixRQUFRLElBQUksQ0FBQ1gsRUFBRTtRQUMzQyxJQUFJRyxZQUFZLElBQUksQ0FBQ0EsU0FBUyxHQUFHZSxJQUFJZixTQUFTO1FBQzlDLElBQUksQ0FBQ0UsYUFBYSxHQUFHM0Qsd0RBQUNBLENBQUN5RCxTQUFTLENBQUMsSUFBSSxDQUFDSSxpQkFBaUIsQ0FBQyxLQUFLO1FBQzdELElBQUksQ0FBQ0gsWUFBWSxHQUFHMUQsd0RBQUNBLENBQUN5RCxTQUFTLENBQUMsSUFBSSxDQUFDSyxnQkFBZ0IsQ0FBQyxLQUFLO1FBQzNELFdBQVc7UUFDWCxJQUFJLENBQUNZLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDSCxJQUFJSSxRQUFRO0lBQ2hDO0lBRUFMLG9CQUFvQixTQUFTTixNQUFNO1FBRS9CLElBQUlTLE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ2xCQSxJQUFJQyxNQUFNLENBQUMzRSx3REFBQ0EsQ0FBQ2lFO1FBQ2IsOEJBQThCO1FBQzlCLElBQUksQ0FBQ04sYUFBYSxHQUFHZSxJQUFJRyxPQUFPLENBQUM7UUFDakMsSUFBSSxDQUFDbkIsWUFBWSxHQUFHZ0IsSUFBSUcsT0FBTyxDQUFDO1FBRWhDLElBQUlwQixZQUFZLElBQUksQ0FBQ0EsU0FBUyxHQUFHLENBQUM7UUFDbENBLFNBQVMsQ0FBQyxJQUFJLENBQUNxQixRQUFRLENBQUMsR0FBRyxJQUFJLENBQUN4QixFQUFFO0lBQ3RDO0lBRUFmLFFBQVE7UUFFSixJQUFJLENBQUNtQyxHQUFHLENBQUNLLEtBQUs7UUFDZCxJQUFJLENBQUNoQixZQUFZO1FBQ2pCLElBQUksSUFBSSxDQUFDTCxZQUFZLEVBQUU7WUFDbkIsdUVBQXVFO1lBQ3ZFLGlEQUFpRDtZQUNqRCxJQUFJLENBQUNkLE1BQU07UUFDZjtRQUNBLElBQUksQ0FBQ0QsTUFBTTtRQUNYLElBQUksSUFBSSxDQUFDZ0IsYUFBYSxFQUFFO1lBQ3BCLHFGQUFxRjtZQUNyRiwwQkFBMEI7WUFDMUIsSUFBSSxDQUFDWixNQUFNO1lBQ1gsSUFBSSxDQUFDRCxTQUFTO1FBQ2xCLE9BQU87WUFDSCxJQUFJLENBQUNrQyxvQkFBb0I7UUFDN0I7UUFDQSxJQUFJLENBQUN0RixxREFBTUEsQ0FBQ3lDLGVBQWUsRUFBRSxJQUFJLENBQUNqQixZQUFZO1FBQzlDLE9BQU8sSUFBSTtJQUNmO0lBRUF5QixRQUFRLFNBQVNULEdBQUc7UUFFaEIsSUFBSSxJQUFJLENBQUN3QixZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUN1QixRQUFRLENBQUMvQztRQUM1QyxJQUFJLElBQUksQ0FBQ1csS0FBSyxDQUFDcUMsVUFBVSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDcEMsTUFBTTtRQUM1QyxJQUFJLENBQUNILE1BQU07SUFDZjtJQUVBRSxXQUFXO1FBRVAsSUFBSSxJQUFJLENBQUNhLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQ3lCLFdBQVc7UUFDL0MsSUFBSSxDQUFDSixvQkFBb0I7SUFDN0I7SUFFQWpDLFFBQVE7UUFFSixJQUFJLElBQUksQ0FBQ1ksYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQzBCLFFBQVE7WUFDYiwwREFBMEQ7WUFDMUQseURBQXlEO1lBQ3pELElBQUksQ0FBQ3pDLE1BQU07WUFDWDtRQUNKO1FBQ0EsSUFBSSxDQUFDb0Msb0JBQW9CO0lBQzdCO0lBRUFBLHNCQUFzQjtRQUVsQixJQUFJTSxpQkFBaUIsSUFBSSxDQUFDQyxrQkFBa0I7UUFDNUMsSUFBSUMsZUFBZSxJQUFJLENBQUNDLGVBQWU7UUFDdkMsSUFBSUQsY0FBY0Ysa0JBQWtCLE1BQU1FO1FBQzFDLElBQUksQ0FBQ2QsR0FBRyxDQUFDdEIsSUFBSSxDQUFDLGFBQWFrQztJQUMvQjtJQUVBQyxvQkFBb0I7UUFFaEIsSUFBSUcsV0FBVyxJQUFJLENBQUM3QyxLQUFLLENBQUNxQyxVQUFVLENBQUNRLFFBQVE7UUFDN0MsT0FBTyxlQUFlQSxTQUFTQyxDQUFDLEdBQUcsTUFBTUQsU0FBU0UsQ0FBQyxHQUFHO0lBQzFEO0lBRUFILGlCQUFpQjtRQUNiLElBQUlQLGFBQWEsSUFBSSxDQUFDckMsS0FBSyxDQUFDcUMsVUFBVTtRQUN0QyxJQUFJQyxRQUFRRCxXQUFXQyxLQUFLO1FBQzVCLElBQUksQ0FBQ0EsT0FBTyxPQUFPO1FBQ25CLElBQUkzQixPQUFPMEIsV0FBVzFCLElBQUk7UUFDMUIsT0FBTyxZQUFZMkIsUUFBUSxNQUFPM0IsS0FBS3FDLEtBQUssR0FBRyxJQUFLLE1BQU9yQyxLQUFLc0MsTUFBTSxHQUFHLElBQUs7SUFDbEY7SUFFQSw2QkFBNkI7SUFDN0IseURBQXlEO0lBRXpEVCxVQUFVO1FBRU4sSUFBSSxDQUFDMUIsYUFBYSxDQUFDUCxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUNxQyxlQUFlO0lBQzdEO0lBRUFMLGFBQWE7UUFFVCxJQUFJLENBQUNWLEdBQUcsQ0FBQ3RCLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQ21DLGtCQUFrQjtJQUN0RDtJQUVBTixVQUFVLFNBQVMvQyxHQUFHO1FBRWxCLElBQUlXLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlzQyxRQUFRdEMsTUFBTXNDLEtBQUs7UUFDdkIsSUFBSTNCLE9BQU9YLE1BQU1XLElBQUk7UUFDckIsSUFBSXVDLFdBQVcsSUFBSSxDQUFDckMsWUFBWTtRQUVoQyxpQ0FBaUM7UUFDakMseUlBQXlJO1FBQ3pJLDRHQUE0RztRQUM1RyxJQUFJc0MsWUFBWTtRQUNoQixJQUFJRCxTQUFTRSxJQUFJLENBQUNDLG9CQUFvQixDQUFDLFFBQVFDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZELDJHQUEyRztZQUMzRywwSEFBMEg7WUFDMUhILFlBQVk7UUFDaEI7UUFDQSxJQUFJSSxlQUFlTCxTQUFTTSxPQUFPLENBQUM7WUFBRUwsV0FBV0E7UUFBVTtRQUUzRCw2SUFBNkk7UUFDN0ksc0ZBQXNGO1FBQ3RGLElBQUlNLEtBQU05QyxLQUFLcUMsS0FBSyxHQUFJTyxDQUFBQSxhQUFhUCxLQUFLLElBQUk7UUFDOUMsSUFBSVUsS0FBTS9DLEtBQUtzQyxNQUFNLEdBQUlNLENBQUFBLGFBQWFOLE1BQU0sSUFBSTtRQUNoREMsU0FBUzNDLElBQUksQ0FBQyxhQUFhLFdBQVdrRCxLQUFLLE1BQU1DLEtBQUs7UUFFdEQsaUlBQWlJO1FBQ2pJLHFHQUFxRztRQUNyRyxpR0FBaUc7UUFDakcsNEdBQTRHO1FBQzVHLHFHQUFxRztRQUNyRyxpSEFBaUg7UUFDakgseUhBQXlIO1FBRXpILG1HQUFtRztRQUNuRyxJQUFJQyxZQUFZLElBQUksQ0FBQzdDLGFBQWE7UUFDbEMsSUFBSThDLFdBQVdELGFBQWFBLFVBQVVwRCxJQUFJLENBQUM7UUFDM0MsSUFBSXFELFVBQVU7WUFFVkQsVUFBVXBELElBQUksQ0FBQyxhQUFhcUQsV0FBVyxhQUFjLENBQUN0QixRQUFTLE1BQU8zQixLQUFLcUMsS0FBSyxHQUFHLElBQUssTUFBT3JDLEtBQUtzQyxNQUFNLEdBQUcsSUFBSztZQUNsSCxJQUFJWSxnQkFBZ0JYLFNBQVNNLE9BQU8sQ0FBQztnQkFBRU0sUUFBUSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsS0FBSztZQUFDO1lBRWhFLDZFQUE2RTtZQUM3RWhFLE1BQU1pRSxHQUFHLENBQUMsWUFBWTtnQkFBRW5CLEdBQUdlLGNBQWNmLENBQUM7Z0JBQUVDLEdBQUdjLGNBQWNkLENBQUM7WUFBQyxHQUFHakcsdURBQU1BLENBQUM7Z0JBQUVvSCxlQUFlO1lBQUssR0FBRzdFO1lBQ2xHLElBQUksQ0FBQ1ksU0FBUztZQUNkLElBQUksQ0FBQ0MsTUFBTTtRQUNmO1FBRUEsdUZBQXVGO1FBQ3ZGLGtEQUFrRDtRQUNsRCxJQUFJLENBQUNILE1BQU07SUFDZjtJQUVBLDBCQUEwQjtJQUMxQiwwQkFBMEI7SUFFMUJvRSxrQkFBa0IsU0FBU0MsT0FBTyxDQUFDLENBQUM7UUFFaEMsTUFBTWpELFVBQVVpRCxLQUFLcEUsS0FBSyxJQUFJLElBQUksQ0FBQ0EsS0FBSztRQUN4QyxNQUFNK0QsUUFBUUssS0FBS0wsS0FBSyxJQUFJLElBQUksQ0FBQ0EsS0FBSztRQUN0QyxNQUFNTSxRQUFRTixNQUFNL0QsS0FBSztRQUV6QixNQUFNc0Usa0JBQWtCRixLQUFLRSxlQUFlLEdBQUcsQ0FBQztRQUNoRCxNQUFNQyxnQkFBZ0JwRCxRQUFRcUQsZ0JBQWdCLENBQUM7WUFBRUMsTUFBTTtRQUFLO1FBQzVELE1BQU1DLGlCQUFpQkwsTUFBTU0saUJBQWlCLENBQUN4RCxTQUFTO1lBQUVzRCxNQUFNO1lBQU1HLGlCQUFpQjtRQUFLO1FBRTVGLDhEQUE4RDtRQUM5RCxrQ0FBa0M7UUFDbEM7WUFDSXpEO2VBQ0dvRDtlQUNBRztTQUNOLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsT0FBUVIsZUFBZSxDQUFDUSxLQUFLQyxFQUFFLENBQUMsR0FBR0QsS0FBS3pDLFVBQVUsQ0FBQzJDLENBQUM7UUFFOUQ3RCxRQUFROEQsVUFBVSxDQUFDO1FBRW5CLG9EQUFvRDtRQUNwRDlELFFBQVErRCxPQUFPLENBQUM7WUFBRVQsTUFBTTtZQUFNVSxJQUFJO1FBQUs7UUFFdkMsNEdBQTRHO1FBQzVHLDRHQUE0RztRQUM1RyxNQUFNQyxPQUFPZixNQUFNZ0IsV0FBVyxHQUFHQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS1QsT0FBU1UsS0FBS0QsR0FBRyxDQUFDQSxLQUFLVCxLQUFLekMsVUFBVSxDQUFDMkMsQ0FBQyxJQUFJLElBQUk7UUFFOUYsMkVBQTJFO1FBQzNFLGlGQUFpRjtRQUNqRix3REFBd0Q7UUFDeEROLGVBQWVHLE9BQU8sQ0FBQyxDQUFDWTtZQUNwQixJQUFJQSxLQUFLcEQsVUFBVSxDQUFDMkMsQ0FBQyxJQUFJSSxNQUFNO2dCQUMzQkssS0FBS3hCLEdBQUcsQ0FBQyxLQUFLbUIsT0FBTyxHQUFHO29CQUFFRCxJQUFJO2dCQUFLO1lBQ3ZDO1FBQ0o7UUFFQWhFLFFBQVF1RSxTQUFTLENBQUM7UUFFbEIseUVBQXlFO1FBQ3pFLE1BQU1DLFdBQVd4RSxRQUFReUUsTUFBTTtRQUMvQixJQUFJRCxVQUFVO1lBQ1YsTUFBTUMsU0FBU3ZCLE1BQU13QixPQUFPLENBQUNGO1lBQzdCQyxPQUFPRSxPQUFPLENBQUMzRSxTQUFTO2dCQUFFZ0UsSUFBSTtZQUFLO1lBQ25DZixLQUFLMkIsZUFBZSxHQUFHSjtRQUMzQixPQUFPO1lBQ0h2QixLQUFLMkIsZUFBZSxHQUFHO1FBQzNCO0lBQ0o7SUFFQUMsa0JBQWtCLFNBQVM1QixPQUFPLENBQUMsQ0FBQyxFQUFFNkIsR0FBRyxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDO1FBRTNDLE1BQU0vQyxRQUFRb0UsS0FBS3BFLEtBQUssSUFBSSxJQUFJLENBQUNBLEtBQUs7UUFDdEMsTUFBTStELFFBQVFLLEtBQUtMLEtBQUssSUFBSSxJQUFJLENBQUNBLEtBQUs7UUFDdEMsTUFBTU0sUUFBUU4sTUFBTS9ELEtBQUs7UUFDekIsTUFBTSxFQUFFa0csWUFBWSxFQUFFQyxlQUFlLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdyQyxNQUFNc0MsT0FBTztRQUUxRSxJQUFJQztRQUNKLElBQUl2SiwyREFBVUEsQ0FBQ21KLGVBQWU7WUFDMUJJLGFBQWF0Six3REFBT0EsQ0FBQ2tKLGFBQWFLLElBQUksQ0FBQ2xDLE9BQU8sSUFBSSxFQUFFNEIsS0FBS25ELEdBQUdDO1FBQ2hFLE9BQU8sSUFBSW1ELGlCQUFpQixXQUFXO1lBQ25DSSxhQUFhdEosd0RBQU9BLENBQUNxSCxNQUFNbUMsbUJBQW1CLENBQUM7Z0JBQUUxRDtnQkFBR0M7WUFBRTtRQUMxRCxPQUFPO1lBQ0h1RCxhQUFhakMsTUFBTW9DLHNCQUFzQixDQUFDekcsT0FBTztnQkFBRTBHLFVBQVVSO1lBQWE7UUFDOUU7UUFFQUksYUFBYUEsV0FBV0ssTUFBTSxDQUFDLENBQUNsRztZQUM1QixPQUFPLGNBQWV2RCwyQ0FBSUEsSUFBTThDLE1BQU0rRSxFQUFFLEtBQUt0RSxHQUFHc0UsRUFBRSxJQUFLLENBQUN0RSxHQUFHbUcsWUFBWSxDQUFDNUc7UUFDNUU7UUFFQSxJQUFJbUcsaUJBQWlCO1lBQ2pCLDhDQUE4QztZQUM5Q0csYUFBYUEsV0FBV08sS0FBSyxDQUFDLENBQUM7UUFDbkM7UUFFQSxJQUFJQyxtQkFBbUI7UUFDdkIsTUFBTUMsb0JBQW9CM0MsS0FBSzRDLGtCQUFrQjtRQUVqRCxvRkFBb0Y7UUFDcEYsSUFBSyxJQUFJQyxJQUFJWCxXQUFXaEQsTUFBTSxHQUFHLEdBQUcyRCxLQUFLLEdBQUdBLElBQUs7WUFDN0MsTUFBTUMsWUFBWVosVUFBVSxDQUFDVyxFQUFFO1lBQy9CLElBQUlGLHFCQUFxQkEsa0JBQWtCL0csS0FBSyxDQUFDK0UsRUFBRSxJQUFJbUMsVUFBVW5DLEVBQUUsRUFBRTtnQkFDakUsNkJBQTZCO2dCQUM3QitCLG1CQUFtQkM7Z0JBQ25CO1lBQ0osT0FBTztnQkFDSCxNQUFNSSxPQUFPRCxVQUFVRSxRQUFRLENBQUNyRDtnQkFDaEMsSUFBSSxDQUFDaEgsMkRBQVVBLENBQUNxSixzQkFBc0JBLGtCQUFrQkcsSUFBSSxDQUFDeEMsT0FBTyxJQUFJLEVBQUVvRCxPQUFPO29CQUM3RSw0QkFBNEI7b0JBQzVCTCxtQkFBbUJLO29CQUNuQjtnQkFDSjtZQUNKO1FBQ0o7UUFFQSxJQUFJTCxvQkFBb0JBLG9CQUFvQkMsbUJBQW1CO1lBQzNELHFEQUFxRDtZQUNyRCxJQUFJLENBQUNNLGNBQWMsQ0FBQ2pEO1lBQ3BCQSxLQUFLNEMsa0JBQWtCLEdBQUdGLGlCQUFpQlEsU0FBUyxDQUNoRFIsaUJBQWlCUyxhQUFhLENBQUMsTUFBTSxjQUNyQztnQkFBRUMsV0FBVztZQUFLO1FBRTFCO1FBRUEsSUFBSSxDQUFDVixvQkFBb0JDLG1CQUFtQjtZQUN4QywrREFBK0Q7WUFDL0QsSUFBSSxDQUFDTSxjQUFjLENBQUNqRDtRQUN4QjtJQUNKO0lBRUFpRCxnQkFBZ0IsU0FBU2pELElBQUk7UUFFekJBLFFBQVNBLENBQUFBLE9BQU8sQ0FBQztRQUVqQixJQUFJcUQsZ0JBQWdCckQsS0FBSzRDLGtCQUFrQjtRQUMzQyxJQUFJUyxlQUFlO1lBQ2YsK0RBQStEO1lBQy9EQSxjQUFjQyxXQUFXLENBQ3JCRCxjQUFjRixhQUFhLENBQUMsTUFBTSxjQUNsQztnQkFBRUMsV0FBVztZQUFLO1lBRXRCcEQsS0FBSzRDLGtCQUFrQixHQUFHO1FBQzlCO0lBQ0o7SUFFQVcsbUJBQW1CLFNBQVN2RCxPQUFPLENBQUMsQ0FBQztRQUVqQyxNQUFNcUQsZ0JBQWdCckQsS0FBSzRDLGtCQUFrQjtRQUM3QyxNQUFNN0YsVUFBVWlELEtBQUtwRSxLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLO1FBQ3hDLE1BQU0rRCxRQUFRSyxLQUFLTCxLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLO1FBRXRDLElBQUkwRCxlQUFlO1lBRWYscUZBQXFGO1lBQ3JGQSxjQUFjekgsS0FBSyxDQUFDNEgsS0FBSyxDQUFDekcsU0FBUztnQkFBRWdFLElBQUk7WUFBSztZQUM5Q3NDLGNBQWNDLFdBQVcsQ0FBQ0QsY0FBY0YsYUFBYSxDQUFDLE1BQU0sY0FBYztnQkFBRUMsV0FBVztZQUFLO1lBRTVGcEQsS0FBSzRDLGtCQUFrQixHQUFHO1FBRTlCLE9BQU87WUFFSCxNQUFNLEVBQUVhLG1CQUFtQixFQUFFLEdBQUc5RCxNQUFNc0MsT0FBTztZQUM3QyxNQUFNLEVBQUVOLGVBQWUsRUFBRSxHQUFHM0I7WUFDNUIsNERBQTREO1lBQzVELDREQUE0RDtZQUM1RCxvQ0FBb0M7WUFDcEMsSUFDSTJCLG1CQUNBLE9BQU84Qix3QkFBd0IsY0FDL0IsQ0FBQ0Esb0JBQW9CdEIsSUFBSSxDQUFDeEMsT0FBTyxJQUFJLEdBQ3ZDO2dCQUNFLElBQUksQ0FBQytELGdCQUFnQixDQUFDMUQ7Z0JBQ3RCO1lBQ0o7UUFDSjtRQUVBTCxNQUFNL0QsS0FBSyxDQUFDMkUsaUJBQWlCLENBQUN4RCxTQUFTO1lBQUVzRCxNQUFNO1FBQUssR0FBR0ksT0FBTyxDQUFDWSxDQUFBQTtZQUMzREEsS0FBS3NDLFFBQVEsQ0FBQztnQkFBRTVDLElBQUk7WUFBSztRQUM3QjtJQUNKO0lBRUEyQyxrQkFBa0IsU0FBUzFELElBQUk7UUFDM0IsTUFBTSxFQUFFcEUsS0FBSyxFQUFFZ0ksaUJBQWlCLFFBQVEsRUFBRSxHQUFHNUQ7UUFDN0MsTUFBTWpELFVBQVVuQixTQUFTLElBQUksQ0FBQ0EsS0FBSztRQUNuQyxNQUFNK0QsUUFBUUssS0FBS0wsS0FBSyxJQUFJLElBQUksQ0FBQ0EsS0FBSztRQUN0QyxNQUFNTSxRQUFRTixNQUFNL0QsS0FBSztRQUN6QixPQUFRZ0k7WUFDSixLQUFLO2dCQUFVO29CQUNYN0csUUFBUThHLE1BQU0sQ0FBQzt3QkFBRTlDLElBQUk7b0JBQUs7b0JBQzFCO2dCQUNKO1lBQ0EsS0FBSztnQkFBVTtvQkFDWCxNQUFNLEVBQUVZLGVBQWUsRUFBRW1DLGVBQWUsRUFBRTVELGVBQWUsRUFBRSxHQUFHRjtvQkFDOUQsZ0ZBQWdGO29CQUNoRixJQUFJOEQsaUJBQWlCO3dCQUNqQixNQUFNLEVBQUVwRixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHbUY7d0JBQ2pCL0csUUFBUTBCLFFBQVEsQ0FBQ0MsR0FBR0MsR0FBRzs0QkFBRTBCLE1BQU07NEJBQU1VLElBQUk7d0JBQUs7b0JBQ2xEO29CQUNBLHdEQUF3RDtvQkFDeEQsSUFBSWIsaUJBQWlCO3dCQUNqQjZELE9BQU9DLElBQUksQ0FBQzlELGlCQUFpQk8sT0FBTyxDQUFDRSxDQUFBQTs0QkFDakMsTUFBTUQsT0FBT1QsTUFBTXdCLE9BQU8sQ0FBQ2Q7NEJBQzNCLElBQUlELE1BQU07Z0NBQ05BLEtBQUtiLEdBQUcsQ0FBQyxLQUFLSyxlQUFlLENBQUNTLEdBQUcsRUFBRTtvQ0FBRUksSUFBSTtnQ0FBSzs0QkFDbEQ7d0JBQ0o7b0JBQ0o7b0JBQ0EsNkJBQTZCO29CQUM3QixNQUFNUyxTQUFTdkIsTUFBTXdCLE9BQU8sQ0FBQ0U7b0JBQzdCLElBQUlILFFBQVE7d0JBQ1JBLE9BQU9nQyxLQUFLLENBQUN6RyxTQUFTOzRCQUFFZ0UsSUFBSTt3QkFBSztvQkFDckM7b0JBQ0E7Z0JBQ0o7UUFDSjtJQUNKO0lBRUFrRCxrQkFBa0I7UUFFZCxJQUFJbEIsT0FBTyxJQUFJO1FBQ2YsSUFBSW5ILFFBQVFtSCxLQUFLbkgsS0FBSztRQUN0QixJQUFJK0QsUUFBUW9ELEtBQUtwRCxLQUFLO1FBRXRCLE1BQU9vRCxLQUFNO1lBQ1QsSUFBSW5ILE1BQU1zSSxNQUFNLElBQUk7WUFDcEIsSUFBSSxDQUFDdEksTUFBTXVJLFVBQVUsTUFBTXBCLEtBQUtxQixHQUFHLENBQUMsbUJBQW1CLE9BQU9yQjtZQUM5RG5ILFFBQVFBLE1BQU15SSxhQUFhO1lBQzNCdEIsT0FBT3BELE1BQU0yRSxlQUFlLENBQUMxSTtRQUNqQztRQUVBLE9BQU87SUFDWDtJQUVBdUgsZUFBZSxTQUFTOUcsRUFBRSxFQUFFa0ksSUFBSTtRQUM1QmxJLE1BQU9BLENBQUFBLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ25CLE1BQU1tSSxlQUFlbkksR0FBR29JLFlBQVksQ0FBQyxDQUFDLEVBQUVGLEtBQUssU0FBUyxDQUFDO1FBQ3ZELElBQUlDLGNBQWM7WUFDZCxNQUFNRSxPQUFPLElBQUksQ0FBQ0MsYUFBYSxDQUFDLFFBQVF0STtZQUN4QyxJQUFJcUksTUFBTTtnQkFDTixNQUFNRSxnQkFBZ0IsSUFBSSxDQUFDQyxZQUFZLENBQUNILE1BQU1GO2dCQUM5QyxJQUFJSSxlQUFlLE9BQU9BO1lBQzlCLE9BQU87Z0JBQ0gsTUFBTSxDQUFDRSxVQUFVLEdBQUcsSUFBSSxDQUFDQyxjQUFjLENBQUNQO2dCQUN4QyxJQUFJTSxXQUFXLE9BQU9BO1lBQzFCO1FBQ0o7UUFDQSxPQUFPekk7SUFDWDtJQUVBLG9DQUFvQztJQUNwQyxvQ0FBb0M7SUFFcEMySSxtQkFBa0JuRCxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFDdkI5RixtREFBUUEsQ0FBQ3VCLFNBQVMsQ0FBQzZLLFdBQVcsQ0FBQzlDLElBQUksQ0FBQyxJQUFJLEVBQUVOLEtBQUtuRCxHQUFHQztRQUNsRCxJQUFJLENBQUN1RyxNQUFNLENBQUMsdUJBQXVCckQsS0FBS25ELEdBQUdDO0lBQy9DO0lBRUF3RyxtQkFBa0J0RCxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFDdkI5RixtREFBUUEsQ0FBQ3VCLFNBQVMsQ0FBQ2dMLFdBQVcsQ0FBQ2pELElBQUksQ0FBQyxJQUFJLEVBQUVOLEtBQUtuRCxHQUFHQztRQUNsRCxJQUFJLENBQUN1RyxNQUFNLENBQUMsdUJBQXVCckQsS0FBS25ELEdBQUdDO0lBQy9DO0lBRUEwRyxpQkFBZ0J4RCxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFDckIsSUFBSSxDQUFDdUcsTUFBTSxDQUFDLHFCQUFxQnJELEtBQUtuRCxHQUFHQztRQUN6QzlGLG1EQUFRQSxDQUFDdUIsU0FBUyxDQUFDa0wsU0FBUyxDQUFDbkQsSUFBSSxDQUFDLElBQUksRUFBRU4sS0FBS25ELEdBQUdDO0lBQ3BEO0lBRUE0RyxpQkFBaUIsU0FBUzFELEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUUvQjlGLG1EQUFRQSxDQUFDdUIsU0FBUyxDQUFDbUwsZUFBZSxDQUFDbEwsS0FBSyxDQUFDLElBQUksRUFBRUs7UUFDL0MsSUFBSSxDQUFDd0ssTUFBTSxDQUFDLDJCQUEyQnJELEtBQUtuRCxHQUFHQztJQUNuRDtJQUVBNkcsY0FBYyxTQUFTM0QsR0FBRyxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDO1FBRTVCOUYsbURBQVFBLENBQUN1QixTQUFTLENBQUNvTCxZQUFZLENBQUNuTCxLQUFLLENBQUMsSUFBSSxFQUFFSztRQUM1QyxJQUFJLENBQUN3SyxNQUFNLENBQUMsd0JBQXdCckQsS0FBS25ELEdBQUdDO0lBQ2hEO0lBRUE4RyxhQUFhLFNBQVM1RCxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFFM0I5RixtREFBUUEsQ0FBQ3VCLFNBQVMsQ0FBQ3FMLFdBQVcsQ0FBQ3BMLEtBQUssQ0FBQyxJQUFJLEVBQUVLO1FBQzNDLElBQUksQ0FBQ3dLLE1BQU0sQ0FBQyx1QkFBdUJyRCxLQUFLbkQsR0FBR0M7SUFDL0M7SUFFQXNHLGFBQWEsU0FBU3BELEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUUzQixJQUFJLENBQUNxRyxpQkFBaUIsQ0FBQ25ELEtBQUtuRCxHQUFHQztRQUMvQixJQUFJLENBQUMrRyxTQUFTLENBQUM3RCxLQUFLbkQsR0FBR0M7SUFDM0I7SUFFQXlHLGFBQWEsU0FBU3ZELEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUUzQixNQUFNcUIsT0FBTyxJQUFJLENBQUMyRixTQUFTLENBQUM5RDtRQUM1QixNQUFNLEVBQUUrRCxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUc5RjtRQUVoRCxJQUFJNEYsY0FBYztZQUNkLElBQUksQ0FBQ0csaUJBQWlCLENBQUNsRSxLQUFLK0QsY0FBY2xILEdBQUdDO1FBQ2pEO1FBRUEsT0FBUWtIO1lBQ0osS0FBS2xNLFlBQVlFLE1BQU07Z0JBQ25CLElBQUksQ0FBQ21NLFVBQVUsQ0FBQ25FLEtBQUtuRCxHQUFHQztnQkFDeEI7WUFDSixLQUFLaEYsWUFBWUMsSUFBSTtnQkFDaEJrTSxDQUFBQSxpQkFBaUIsSUFBSSxFQUFFRyxJQUFJLENBQUNwRSxLQUFLbkQsR0FBR0M7WUFDekMsK0JBQStCO1lBQy9CO2dCQUNJLElBQUlxQixLQUFLa0csb0JBQW9CLEVBQUU7Z0JBQy9CLElBQUksQ0FBQ2YsaUJBQWlCLENBQUN0RCxLQUFLbkQsR0FBR0M7Z0JBQy9CO1FBQ1I7UUFFQSxtREFBbUQ7UUFDbkQsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ2dILFNBQVMsQ0FBQzlELEtBQUs3QjtJQUN4QjtJQUVBc0YsV0FBVyxTQUFTekQsR0FBRyxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDO1FBRXpCLE1BQU1xQixPQUFPLElBQUksQ0FBQzJGLFNBQVMsQ0FBQzlEO1FBQzVCLE1BQU0sRUFBRStELFlBQVksRUFBRUMsTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBRzlGO1FBRWhELElBQUk0RixjQUFjO1lBQ2QsSUFBSSxDQUFDTyxlQUFlLENBQUN0RSxLQUFLK0QsY0FBY2xILEdBQUdDO1FBQy9DO1FBRUEsT0FBUWtIO1lBQ0osS0FBS2xNLFlBQVlFLE1BQU07Z0JBQ25CLElBQUksQ0FBQ3VNLGFBQWEsQ0FBQ3ZFLEtBQUtuRCxHQUFHQztnQkFDM0I7WUFDSixLQUFLaEYsWUFBWUMsSUFBSTtnQkFDaEJrTSxDQUFBQSxpQkFBaUIsSUFBSSxFQUFFTyxPQUFPLENBQUN4RSxLQUFLbkQsR0FBR0M7WUFDNUMsK0JBQStCO1lBQy9CO2dCQUNJLElBQUlxQixLQUFLa0csb0JBQW9CLEVBQUU7Z0JBQy9CLElBQUksQ0FBQ2IsZUFBZSxDQUFDeEQsS0FBS25ELEdBQUdDO1FBQ3JDO1FBRUEsSUFBSWlILGNBQWM7WUFDZCxJQUFJLENBQUNVLGtCQUFrQixDQUFDekUsS0FBSytELGNBQWNsSCxHQUFHQztRQUNsRDtRQUVBLElBQUksQ0FBQzRILGVBQWUsQ0FBQzFFO0lBQ3pCO0lBRUEyRSxXQUFXLFNBQVMzRSxHQUFHO1FBRW5CaEosbURBQVFBLENBQUN1QixTQUFTLENBQUNvTSxTQUFTLENBQUNuTSxLQUFLLENBQUMsSUFBSSxFQUFFSztRQUN6QyxJQUFJLENBQUN3SyxNQUFNLENBQUMscUJBQXFCckQ7SUFDckM7SUFFQTRFLFVBQVUsU0FBUzVFLEdBQUc7UUFFbEJoSixtREFBUUEsQ0FBQ3VCLFNBQVMsQ0FBQ3FNLFFBQVEsQ0FBQ3BNLEtBQUssQ0FBQyxJQUFJLEVBQUVLO1FBQ3hDLElBQUksQ0FBQ3dLLE1BQU0sQ0FBQyxvQkFBb0JyRDtJQUNwQztJQUVBNkUsWUFBWSxTQUFTN0UsR0FBRztRQUVwQmhKLG1EQUFRQSxDQUFDdUIsU0FBUyxDQUFDc00sVUFBVSxDQUFDck0sS0FBSyxDQUFDLElBQUksRUFBRUs7UUFDMUMsSUFBSSxDQUFDd0ssTUFBTSxDQUFDLHNCQUFzQnJEO0lBQ3RDO0lBRUE4RSxZQUFZLFNBQVM5RSxHQUFHO1FBRXBCaEosbURBQVFBLENBQUN1QixTQUFTLENBQUN1TSxVQUFVLENBQUN0TSxLQUFLLENBQUMsSUFBSSxFQUFFSztRQUMxQyxJQUFJLENBQUN3SyxNQUFNLENBQUMsc0JBQXNCckQ7SUFDdEM7SUFFQStFLFlBQVksU0FBUy9FLEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQyxFQUFFa0ksS0FBSztRQUVqQ2hPLG1EQUFRQSxDQUFDdUIsU0FBUyxDQUFDd00sVUFBVSxDQUFDdk0sS0FBSyxDQUFDLElBQUksRUFBRUs7UUFDMUMsSUFBSSxDQUFDd0ssTUFBTSxDQUFDLHNCQUFzQnJELEtBQUtuRCxHQUFHQyxHQUFHa0k7SUFDakQ7SUFFQUMsVUFBVSxTQUFTakYsR0FBRyxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDO1FBRXhCLE1BQU0sRUFBRW9JLGVBQWVuQixZQUFZLEVBQUUsR0FBRy9EO1FBQ3hDLElBQUksQ0FBQ21GLGlCQUFpQixDQUFDbkYsS0FBSytELGNBQWNsSCxHQUFHQztRQUM3QyxJQUFJLENBQUNnSCxTQUFTLENBQUM5RCxLQUFLO1lBQUUrRDtRQUFhO1FBQ25DLElBQUksQ0FBQ3FCLGVBQWUsQ0FBQ3BGLEtBQUtuRCxHQUFHQztJQUNqQztJQUVBcUksbUJBQW1CLFNBQVNuRixHQUFHLEVBQUVxRixNQUFNLEVBQUV4SSxDQUFDLEVBQUVDLENBQUM7UUFFekMsSUFBSSxDQUFDdUcsTUFBTSxDQUFDLDhCQUE4QnJELEtBQUtxRixRQUFReEksR0FBR0M7SUFDOUQ7SUFFQW9ILG1CQUFtQixTQUFTbEUsR0FBRyxFQUFFcUYsTUFBTSxFQUFFeEksQ0FBQyxFQUFFQyxDQUFDO1FBRXpDLElBQUksQ0FBQ3VHLE1BQU0sQ0FBQyw4QkFBOEJyRCxLQUFLcUYsUUFBUXhJLEdBQUdDO0lBQzlEO0lBRUF3SCxpQkFBaUIsU0FBU3RFLEdBQUcsRUFBRXFGLE1BQU0sRUFBRXhJLENBQUMsRUFBRUMsQ0FBQztRQUV2QyxJQUFJLENBQUN1RyxNQUFNLENBQUMsNEJBQTRCckQsS0FBS3FGLFFBQVF4SSxHQUFHQztJQUM1RDtJQUVBd0ksdUJBQXVCLFNBQVN0RixHQUFHLEVBQUVxRixNQUFNLEVBQUV4SSxDQUFDLEVBQUVDLENBQUM7UUFFN0MsSUFBSSxDQUFDdUcsTUFBTSxDQUFDLGtDQUFrQ3JELEtBQUtxRixRQUFReEksR0FBR0M7SUFDbEU7SUFFQXlJLG1CQUFtQixTQUFTdkYsR0FBRyxFQUFFcUYsTUFBTSxFQUFFeEksQ0FBQyxFQUFFQyxDQUFDO1FBRXpDLElBQUksQ0FBQ3VHLE1BQU0sQ0FBQyw4QkFBOEJyRCxLQUFLcUYsUUFBUXhJLEdBQUdDO0lBQzlEO0lBRUEsc0JBQXNCO0lBRXRCK0csV0FBVyxTQUFTN0QsR0FBRyxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDO1FBRXpCLElBQUksSUFBSSxDQUFDMEksNkJBQTZCLENBQUN4RixNQUFNO1FBRTdDLElBQUlrQixPQUFPLElBQUksQ0FBQ2tCLGdCQUFnQjtRQUNoQyxJQUFJLENBQUNsQixRQUFRLENBQUNBLEtBQUtxQixHQUFHLENBQUMsZ0JBQWdCO1FBRXZDLElBQUksQ0FBQ3VCLFNBQVMsQ0FBQzlELEtBQUs7WUFDaEJnRSxRQUFRbE0sWUFBWUMsSUFBSTtZQUN4QmtNLGVBQWUvQztRQUNuQjtRQUVBLE1BQU10RSxXQUFXc0UsS0FBS25ILEtBQUssQ0FBQzZDLFFBQVE7UUFDcENzRSxLQUFLNEMsU0FBUyxDQUFDOUQsS0FBSztZQUNoQmlDLGlCQUFpQnJGO1lBQ2pCNkksZUFBZTdJLFNBQVM4SSxVQUFVLENBQUM3SSxHQUFHQztZQUN0QzZJLGdCQUFnQixJQUFJLENBQUM3SCxLQUFLLENBQUM4SCxpQkFBaUIsQ0FBQzFFLE1BQU1yRSxHQUFHQztRQUMxRDtJQUNKO0lBRUFzSSxpQkFBaUIsU0FBU3BGLEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUUvQixNQUFNLEVBQUVnQixLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQ3RCLE1BQU0rSCw4QkFBOEI3RixJQUFJOEYsb0JBQW9CO1FBQzVELElBQUlELDZCQUE2QjtZQUM3Qix3REFBd0Q7WUFDeEQsNkNBQTZDO1lBQzdDLCtDQUErQztZQUMvQyx1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDL0IsU0FBUyxDQUFDOUQsS0FBSztnQkFBRXFFLHNCQUFzQjtZQUFLO1FBQ3JEO1FBRUEsSUFBSSxJQUFJLENBQUNtQiw2QkFBNkIsQ0FBQ3hGLFFBQVEsQ0FBQyxJQUFJLENBQUN1QyxHQUFHLENBQUMsc0JBQXNCO1lBQzNFLDhEQUE4RDtZQUM5RDtRQUNKO1FBRUEsTUFBTSxFQUFFd0IsZUFBZS9ELElBQUlrRixhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUNwQixTQUFTLENBQUM5RDtRQUM1REEsSUFBSStGLGVBQWU7UUFFbkIsd0RBQXdEO1FBQ3hELElBQUksQ0FBQ2pJLE1BQU1zQyxPQUFPLENBQUM0RixjQUFjLENBQUMxRixJQUFJLENBQUN4QyxPQUFPLElBQUksRUFBRWlHLGNBQWMvRCxNQUFNO1lBQ3BFLElBQUk2Riw2QkFBNkI7Z0JBQzdCLGtFQUFrRTtnQkFDbEUsa0NBQWtDO2dCQUNsQyxJQUFJLENBQUNoQyxTQUFTLENBQUM3RCxLQUFLbkQsR0FBR0M7WUFDdkIsMkRBQTJEO1lBQzNELGtDQUFrQztZQUN0QyxPQUFPO2dCQUNILDhCQUE4QjtnQkFDOUIsNENBQTRDO2dCQUM1QyxJQUFJLENBQUNzRyxXQUFXLENBQUNwRCxLQUFLbkQsR0FBR0M7WUFDN0I7WUFDQTtRQUNKO1FBRUEsdUNBQXVDO1FBQ3ZDLElBQUlnQixNQUFNc0MsT0FBTyxDQUFDNkYsZUFBZSxJQUFJLEdBQUc7WUFDcEMsSUFBSSxDQUFDQyxhQUFhLENBQUNsRyxLQUFLK0QsY0FBY2xILEdBQUdDO1FBQzdDO1FBQ0EsSUFBSSxDQUFDZ0gsU0FBUyxDQUFDOUQsS0FBSztZQUFFZ0UsUUFBUWxNLFlBQVlFLE1BQU07UUFBQztJQUNyRDtJQUVBLGdCQUFnQjtJQUVoQm9NLE1BQU0sU0FBU3BFLEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUVwQixJQUFJZ0IsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSXFJLE9BQU9ySSxNQUFNc0MsT0FBTyxDQUFDZ0csUUFBUTtRQUNqQyxJQUFJbEwsVUFBVSxJQUFJLENBQUNuQixLQUFLO1FBQ3hCLElBQUlvRSxPQUFPLElBQUksQ0FBQzJGLFNBQVMsQ0FBQzlEO1FBQzFCLElBQUksRUFBRXlGLGFBQWEsRUFBRUUsY0FBYyxFQUFFcEUsU0FBUyxFQUFFLEdBQUdwRDtRQUVuRCx3RUFBd0U7UUFDeEUsSUFBSWtJLE1BQU1oUCx3REFBVUEsQ0FBQ3dGLElBQUk0SSxjQUFjNUksQ0FBQyxFQUFFc0o7UUFDMUMsSUFBSUcsTUFBTWpQLHdEQUFVQSxDQUFDeUYsSUFBSTJJLGNBQWMzSSxDQUFDLEVBQUVxSjtRQUUxQ2pMLFFBQVEwQixRQUFRLENBQUN5SixLQUFLQyxLQUFLO1lBQUVYO1lBQWdCbkgsTUFBTTtZQUFNVSxJQUFJO1FBQUs7UUFFbEUsSUFBSXBCLE1BQU1zQyxPQUFPLENBQUNtRyxhQUFhLEVBQUU7WUFDN0IsSUFBSSxDQUFDaEYsV0FBVztnQkFDWiwrREFBK0Q7Z0JBQy9ELDBEQUEwRDtnQkFDMUQsMENBQTBDO2dCQUMxQyxJQUFJLENBQUNyRCxnQkFBZ0IsQ0FBQ0M7Z0JBQ3RCb0QsWUFBWTtZQUNoQjtZQUNBLElBQUksQ0FBQ3hCLGdCQUFnQixDQUFDNUIsTUFBTTZCLEtBQUtuRCxHQUFHQztRQUN4QztRQUVBLElBQUksQ0FBQ2dILFNBQVMsQ0FBQzlELEtBQUs7WUFDaEJ1QjtRQUNKO0lBQ0o7SUFFQTRDLFlBQVksU0FBU25FLEdBQUcsRUFBRW5ELENBQUMsRUFBRUMsQ0FBQztRQUMxQixJQUFJLENBQUMwSixRQUFRLENBQUN4RyxLQUFLbkQsR0FBR0M7SUFDMUI7SUFFQSxvQkFBb0I7SUFFcEIwSCxTQUFTLFNBQVN4RSxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFFdkIsSUFBSXFCLE9BQU8sSUFBSSxDQUFDMkYsU0FBUyxDQUFDOUQ7UUFDMUIsSUFBSTdCLEtBQUtvRCxTQUFTLEVBQUUsSUFBSSxDQUFDRyxpQkFBaUIsQ0FBQ3ZEO0lBQy9DO0lBRUFvRyxlQUFlLFNBQVN2RSxHQUFHLEVBQUVuRCxDQUFDLEVBQUVDLENBQUM7UUFDN0IsSUFBSSxDQUFDMkosV0FBVyxDQUFDekcsS0FBS25ELEdBQUdDO0lBQzdCO0lBRUEySCxvQkFBb0IsU0FBU3pFLEdBQUcsRUFBRXFGLE1BQU0sRUFBRXhJLENBQUMsRUFBRUMsQ0FBQztRQUMxQyxJQUFJZ0IsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSUEsTUFBTWdHLFNBQVMsQ0FBQzlELEtBQUswRyxVQUFVLEdBQUc1SSxNQUFNc0MsT0FBTyxDQUFDdUcsY0FBYyxFQUFFO1FBQ3BFLElBQUksQ0FBQ3RELE1BQU0sQ0FBQywrQkFBK0JyRCxLQUFLcUYsUUFBUXhJLEdBQUdDO0lBQy9EO0FBRUosR0FBRztJQUVDeEYsT0FBT0E7QUFDWCxHQUFHO0FBRUhULHVEQUFNQSxDQUFDb0IsWUFBWU0sU0FBUyxFQUFFcEIsZ0VBQXdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2RpYS9FbGVtZW50Vmlldy5tanM/YzVmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcvaW5kZXgubWpzJztcbmltcG9ydCB7IGFzc2lnbiwgaXNGdW5jdGlvbiwgdG9BcnJheSB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IENlbGxWaWV3IH0gZnJvbSAnLi9DZWxsVmlldy5tanMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgZWxlbWVudFZpZXdQb3J0UHJvdG90eXBlIH0gZnJvbSAnLi9wb3J0cy5tanMnO1xuaW1wb3J0IHsgUmVjdCwgc25hcFRvR3JpZCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6IENlbGxWaWV3LkZsYWdzLlRPT0xTLFxuICAgIFVQREFURTogJ1VQREFURScsXG4gICAgVFJBTlNMQVRFOiAnVFJBTlNMQVRFJyxcbiAgICBSRVNJWkU6ICdSRVNJWkUnLFxuICAgIFBPUlRTOiAnUE9SVFMnLFxuICAgIFJPVEFURTogJ1JPVEFURScsXG4gICAgUkVOREVSOiAnUkVOREVSJ1xufTtcblxuY29uc3QgRHJhZ0FjdGlvbnMgPSB7XG4gICAgTU9WRTogJ21vdmUnLFxuICAgIE1BR05FVDogJ21hZ25ldCcsXG59O1xuLy8gRWxlbWVudCBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBFbGVtZW50VmlldyA9IENlbGxWaWV3LmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfcmVtb3ZlUG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpbXBsZW1lbnRlZCBpbiBwb3J0cy5qc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW5kZXJQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIGNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBDZWxsVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lLmFwcGx5KHRoaXMpLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdlbGVtZW50Jyk7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQb3J0cygpO1xuICAgIH0sXG5cbiAgICBwcmVzZW50YXRpb25BdHRyaWJ1dGVzOiB7XG4gICAgICAgICdhdHRycyc6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICAncG9zaXRpb24nOiBbRmxhZ3MuVFJBTlNMQVRFLCBGbGFncy5UT09MU10sXG4gICAgICAgICdzaXplJzogW0ZsYWdzLlJFU0laRSwgRmxhZ3MuUE9SVFMsIEZsYWdzLlRPT0xTXSxcbiAgICAgICAgJ2FuZ2xlJzogW0ZsYWdzLlJPVEFURSwgRmxhZ3MuVE9PTFNdLFxuICAgICAgICAnbWFya3VwJzogW0ZsYWdzLlJFTkRFUl0sXG4gICAgICAgICdwb3J0cyc6IFtGbGFncy5QT1JUU10sXG4gICAgfSxcblxuICAgIGluaXRGbGFnOiBbRmxhZ3MuUkVOREVSXSxcblxuICAgIFVQREFURV9QUklPUklUWTogMCxcblxuICAgIGNvbmZpcm1VcGRhdGU6IGZ1bmN0aW9uKGZsYWcsIG9wdCkge1xuXG4gICAgICAgIGNvbnN0IHsgdXNlQ1NTU2VsZWN0b3JzIH0gPSBjb25maWc7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVQb3J0cygpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybUhpZ2hsaWdodGVycyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlJFTkRFUikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIFtGbGFncy5SRU5ERVIsIEZsYWdzLlVQREFURSwgRmxhZ3MuUkVTSVpFLCBGbGFncy5UUkFOU0xBVEUsIEZsYWdzLlJPVEFURSwgRmxhZ3MuUE9SVFMsIEZsYWdzLlRPT0xTXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFNraXAgdGhpcyBicmFuY2ggaWYgcmVuZGVyIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlJFU0laRSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZShvcHQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVzaXplIG1ldGhvZCBpcyBjYWxsaW5nIGB1cGRhdGUoKWAgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgW0ZsYWdzLlJFU0laRSwgRmxhZ3MuVVBEQVRFXSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZUNTU1NlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBgcmVzaXplKClgIHJlbmRlcmVkIHRoZSBwb3J0cyB3aGVuIHVzZUNTU1NlbGVjdG9ycyBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlVQREFURSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLm1vZGVsLCBudWxsLCBvcHQpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuVVBEQVRFKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh1c2VDU1NTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHVwZGF0ZSgpYCB3aWxsIHJlbmRlciBwb3J0cyB3aGVuIHVzZUNTU1NlbGVjdG9ycyBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlRSQU5TTEFURSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuVFJBTlNMQVRFKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1IaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5ST1RBVEUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUoKTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlJPVEFURSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXBkYXRlSGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybUhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1IaWdobGlnaHRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuVE9PTFMpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlRPT0xTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKF8sIHJlbmRlcmluZ09ubHlBdHRycykge1xuXG4gICAgICAgIHRoaXMuY2xlYW5Ob2Rlc0NhY2hlKCk7XG5cbiAgICAgICAgLy8gV2hlbiBDU1Mgc2VsZWN0b3Igc3RyaW5ncyBhcmUgdXNlZCwgbWFrZSBzdXJlIG5vIHJ1bGUgbWF0Y2hlcyBwb3J0IG5vZGVzLlxuICAgICAgICBjb25zdCB7IHVzZUNTU1NlbGVjdG9ycyB9ID0gY29uZmlnO1xuICAgICAgICBpZiAodXNlQ1NTU2VsZWN0b3JzKSB0aGlzLl9yZW1vdmVQb3J0cygpO1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBtb2RlbEF0dHJzID0gbW9kZWwuYXR0cigpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKHRoaXMuZWwsIG1vZGVsQXR0cnMsIHtcbiAgICAgICAgICAgIHJvb3RCQm94OiBuZXcgUmVjdChtb2RlbC5zaXplKCkpLFxuICAgICAgICAgICAgc2VsZWN0b3JzOiB0aGlzLnNlbGVjdG9ycyxcbiAgICAgICAgICAgIHNjYWxhYmxlTm9kZTogdGhpcy5zY2FsYWJsZU5vZGUsXG4gICAgICAgICAgICByb3RhdGFibGVOb2RlOiB0aGlzLnJvdGF0YWJsZU5vZGUsXG4gICAgICAgICAgICAvLyBVc2UgcmVuZGVyaW5nIG9ubHkgYXR0cmlidXRlcyBpZiB0aGV5IGRpZmZlcnMgZnJvbSB0aGUgbW9kZWwgYXR0cmlidXRlc1xuICAgICAgICAgICAgcm9BdHRyaWJ1dGVzOiAocmVuZGVyaW5nT25seUF0dHJzID09PSBtb2RlbEF0dHJzKSA/IG51bGwgOiByZW5kZXJpbmdPbmx5QXR0cnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVzZUNTU1NlbGVjdG9ycykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByb3RhdGFibGVTZWxlY3RvcjogJ3JvdGF0YWJsZScsXG4gICAgc2NhbGFibGVTZWxlY3RvcjogJ3NjYWxhYmxlJyxcbiAgICBzY2FsYWJsZU5vZGU6IG51bGwsXG4gICAgcm90YXRhYmxlTm9kZTogbnVsbCxcblxuICAgIC8vIGBwcm90b3R5cGUubWFya3VwYCBpcyByZW5kZXJlZCBieSBkZWZhdWx0LiBTZXQgdGhlIGBtYXJrdXBgIGF0dHJpYnV0ZSBvbiB0aGUgbW9kZWwgaWYgdGhlXG4gICAgLy8gZGVmYXVsdCBtYXJrdXAgaXMgbm90IGRlc2lyYWJsZS5cbiAgICByZW5kZXJNYXJrdXA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG1hcmt1cCA9IGVsZW1lbnQuZ2V0KCdtYXJrdXAnKSB8fCBlbGVtZW50Lm1hcmt1cDtcbiAgICAgICAgaWYgKCFtYXJrdXApIHRocm93IG5ldyBFcnJvcignZGlhLkVsZW1lbnRWaWV3OiBtYXJrdXAgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFya3VwKSkgcmV0dXJuIHRoaXMucmVuZGVySlNPTk1hcmt1cChtYXJrdXApO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLnJlbmRlclN0cmluZ01hcmt1cChtYXJrdXApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5FbGVtZW50VmlldzogaW52YWxpZCBtYXJrdXAnKTtcbiAgICB9LFxuXG4gICAgcmVuZGVySlNPTk1hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMucGFyc2VET01KU09OKG1hcmt1cCwgdGhpcy5lbCk7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycyA9IGRvYy5zZWxlY3RvcnM7XG4gICAgICAgIHRoaXMucm90YXRhYmxlTm9kZSA9IFYoc2VsZWN0b3JzW3RoaXMucm90YXRhYmxlU2VsZWN0b3JdKSB8fCBudWxsO1xuICAgICAgICB0aGlzLnNjYWxhYmxlTm9kZSA9IFYoc2VsZWN0b3JzW3RoaXMuc2NhbGFibGVTZWxlY3Rvcl0pIHx8IG51bGw7XG4gICAgICAgIC8vIEZyYWdtZW50XG4gICAgICAgIHRoaXMudmVsLmFwcGVuZChkb2MuZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICByZW5kZXJTdHJpbmdNYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIHZhciB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgdmVsLmFwcGVuZChWKG1hcmt1cCkpO1xuICAgICAgICAvLyBDYWNoZSB0cmFuc2Zvcm1hdGlvbiBncm91cHNcbiAgICAgICAgdGhpcy5yb3RhdGFibGVOb2RlID0gdmVsLmZpbmRPbmUoJy5yb3RhdGFibGUnKTtcbiAgICAgICAgdGhpcy5zY2FsYWJsZU5vZGUgPSB2ZWwuZmluZE9uZSgnLnNjYWxhYmxlJyk7XG5cbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzID0ge307XG4gICAgICAgIHNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yXSA9IHRoaXMuZWw7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy52ZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXJrdXAoKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGFibGVOb2RlKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgdXBkYXRlIGlzIG5lY2Vzc2FyeSBmb3IgZWxlbWVudHMgd2l0aCB0aGUgc2NhbGFibGUgZ3JvdXAgb25seVxuICAgICAgICAgICAgLy8gTm90ZSB0aGUgcmVzaXplKCkgdHJpZ2dlcnMgdGhlIG90aGVyIGB1cGRhdGVgLlxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5yb3RhdGFibGVOb2RlKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCBvbiBgdGhpcy5lbGAgd2hpbGUgdGhlIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBvbiBgdGhpcy5yb3RhdGFibGVOb2RlYFxuICAgICAgICAgICAgdGhpcy5yb3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcudXNlQ1NTU2VsZWN0b3JzKSB0aGlzLl9yZW5kZXJQb3J0cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBpZiAodGhpcy5zY2FsYWJsZU5vZGUpIHJldHVybiB0aGlzLnNnUmVzaXplKG9wdCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuYW5nbGUpIHRoaXMucm90YXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucm90YXRhYmxlTm9kZSkgcmV0dXJuIHRoaXMucmdUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1hdGlvbigpO1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmdSb3RhdGUoKTtcbiAgICAgICAgICAgIC8vIEl0J3MgbmVjZXNzYXJ5IHRvIGNhbGwgdGhlIHVwZGF0ZSBmb3IgdGhlIG5vZGVzIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSByb3RhdGFibGUgZ3JvdXAgcmVmZXJlbmNpbmcgbm9kZXMgaW5zaWRlIHRoZSBncm91cFxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVRyYW5zZm9ybWF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0ZVN0cmluZygpO1xuICAgICAgICB2YXIgcm90YXRlU3RyaW5nID0gdGhpcy5nZXRSb3RhdGVTdHJpbmcoKTtcbiAgICAgICAgaWYgKHJvdGF0ZVN0cmluZykgdHJhbnNmb3JtYXRpb24gKz0gJyAnICsgcm90YXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnZlbC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1hdGlvbik7XG4gICAgfSxcblxuICAgIGdldFRyYW5zbGF0ZVN0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5tb2RlbC5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ueCArICcsJyArIHBvc2l0aW9uLnkgKyAnKSc7XG4gICAgfSxcblxuICAgIGdldFJvdGF0ZVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5tb2RlbC5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgYW5nbGUgPSBhdHRyaWJ1dGVzLmFuZ2xlO1xuICAgICAgICBpZiAoIWFuZ2xlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHNpemUgPSBhdHRyaWJ1dGVzLnNpemU7XG4gICAgICAgIHJldHVybiAncm90YXRlKCcgKyBhbmdsZSArICcsJyArIChzaXplLndpZHRoIC8gMikgKyAnLCcgKyAoc2l6ZS5oZWlnaHQgLyAyKSArICcpJztcbiAgICB9LFxuXG4gICAgLy8gUm90YXRhYmxlICYgU2NhbGFibGUgR3JvdXBcbiAgICAvLyBhbHdheXMgc2xvd2VyLCBrZXB0IG1haW5seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICAgIHJnUm90YXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnJvdGF0YWJsZU5vZGUuYXR0cigndHJhbnNmb3JtJywgdGhpcy5nZXRSb3RhdGVTdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIHJnVHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnZlbC5hdHRyKCd0cmFuc2Zvcm0nLCB0aGlzLmdldFRyYW5zbGF0ZVN0cmluZygpKTtcbiAgICB9LFxuXG4gICAgc2dSZXNpemU6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBhbmdsZSA9IG1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIHZhciBzaXplID0gbW9kZWwuc2l6ZSgpO1xuICAgICAgICB2YXIgc2NhbGFibGUgPSB0aGlzLnNjYWxhYmxlTm9kZTtcblxuICAgICAgICAvLyBHZXR0aW5nIHNjYWxhYmxlIGdyb3VwJ3MgYmJveC5cbiAgICAgICAgLy8gRHVlIHRvIGEgYnVnIGluIHdlYmtpdCdzIG5hdGl2ZSBTVkcgLmdldEJCb3ggaW1wbGVtZW50YXRpb24sIHRoZSBiYm94IG9mIGdyb3VwcyB3aXRoIHBhdGggY2hpbGRyZW4gaW5jbHVkZXMgdGhlIHBhdGhzJyBjb250cm9sIHBvaW50cy5cbiAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhlIGlzc3VlLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBwYXRoIGVsZW1lbnRzIGluc2lkZSB0aGUgc2NhbGFibGUgZ3JvdXAuXG4gICAgICAgIHZhciByZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjYWxhYmxlLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhdGgnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBzY2FsYWJsZSBoYXMgYXQgbGVhc3Qgb25lIGRlc2NlbmRhbnQgdGhhdCBpcyBhIHBhdGgsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIHJlY3Vyc2l2ZSBiYm94IGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhdGggZGVzY2VuZGFudHMsIGdyb3VwIGJib3ggY2FsY3VsYXRpb24gd29ya3MgYW5kIHNvIHdlIGNhbiB1c2UgdGhlIChmYXN0ZXIpIG5hdGl2ZSBmdW5jdGlvbiBkaXJlY3RseS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxhYmxlQkJveCA9IHNjYWxhYmxlLmdldEJCb3goeyByZWN1cnNpdmU6IHJlY3Vyc2l2ZSB9KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYHNjYWxhYmxlQmJveC53aWR0aGAgYW5kIGBzY2FsYWJsZUJib3guaGVpZ2h0YCBhcmUgbm90IHplcm8gd2hpY2ggY2FuIGhhcHBlbiBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFueSBjb250ZW50LiBCeSBtYWtpbmdcbiAgICAgICAgLy8gdGhlIHdpZHRoL2hlaWdodCAxLCB3ZSBwcmV2ZW50IEhUTUwgZXJyb3JzIG9mIHRoZSB0eXBlIGBzY2FsZShJbmZpbml0eSwgSW5maW5pdHkpYC5cbiAgICAgICAgdmFyIHN4ID0gKHNpemUud2lkdGggLyAoc2NhbGFibGVCQm94LndpZHRoIHx8IDEpKTtcbiAgICAgICAgdmFyIHN5ID0gKHNpemUuaGVpZ2h0IC8gKHNjYWxhYmxlQkJveC5oZWlnaHQgfHwgMSkpO1xuICAgICAgICBzY2FsYWJsZS5hdHRyKCd0cmFuc2Zvcm0nLCAnc2NhbGUoJyArIHN4ICsgJywnICsgc3kgKyAnKScpO1xuXG4gICAgICAgIC8vIE5vdyB0aGUgaW50ZXJlc3RpbmcgcGFydC4gVGhlIGdvYWwgaXMgdG8gYmUgYWJsZSB0byBzdG9yZSB0aGUgb2JqZWN0IGdlb21ldHJ5IHZpYSBqdXN0IGB4YCwgYHlgLCBgYW5nbGVgLCBgd2lkdGhgIGFuZCBgaGVpZ2h0YFxuICAgICAgICAvLyBPcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnMgaXMgc2lnbmlmaWNhbnQgYnV0IHdlIHdhbnQgdG8gcmVjb25zdHJ1Y3QgdGhlIG9iamVjdCBhbHdheXMgaW4gdGhlIG9yZGVyOlxuICAgICAgICAvLyByZXNpemUoKSwgcm90YXRlKCksIHRyYW5zbGF0ZSgpIG5vIG1hdHRlciBvZiBob3cgdGhlIG9iamVjdCB3YXMgdHJhbnNmb3JtZWQuIEZvciB0aGF0IHRvIHdvcmssXG4gICAgICAgIC8vIHdlIG11c3QgYWRqdXN0IHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IHdoZW5ldmVyIHdlIHJlc2l6ZSBpdCAoYmVjYXVzZSB0aGUgb3JpZ2luIG9mIHRoZVxuICAgICAgICAvLyByb3RhdGlvbiBjaGFuZ2VzKS4gVGhlIG5ldyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBhcmUgY29tcHV0ZWQgYnkgY2FuY2VsaW5nIHRoZSBwcmV2aW91cyByb3RhdGlvblxuICAgICAgICAvLyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgcmVzaXplZCBvYmplY3QgKHdoaWNoIGlzIGEgZGlmZmVyZW50IG9yaWdpbiB0aGVuIHRoZSBvcmlnaW4gb2YgdGhlIHByZXZpb3VzIHJvdGF0aW9uKVxuICAgICAgICAvLyBhbmQgZ2V0dGluZyB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LiBUaGVuIHdlIGNsZWFuIHVwIHRoZSByb3RhdGlvbiBiYWNrIHRvIHdoYXQgaXQgb3JpZ2luYWxseSB3YXMuXG5cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSByb3RhdGlvbiBidXQgbm93IGFyb3VuZCBhIGRpZmZlcmVudCBvcmlnaW4sIHdoaWNoIGlzIHRoZSBjZW50ZXIgb2YgdGhlIHNjYWxlZCBvYmplY3QuXG4gICAgICAgIHZhciByb3RhdGFibGUgPSB0aGlzLnJvdGF0YWJsZU5vZGU7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHJvdGF0YWJsZSAmJiByb3RhdGFibGUuYXR0cigndHJhbnNmb3JtJyk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuXG4gICAgICAgICAgICByb3RhdGFibGUuYXR0cigndHJhbnNmb3JtJywgcm90YXRpb24gKyAnIHJvdGF0ZSgnICsgKC1hbmdsZSkgKyAnLCcgKyAoc2l6ZS53aWR0aCAvIDIpICsgJywnICsgKHNpemUuaGVpZ2h0IC8gMikgKyAnKScpO1xuICAgICAgICAgICAgdmFyIHJvdGF0YWJsZUJCb3ggPSBzY2FsYWJsZS5nZXRCQm94KHsgdGFyZ2V0OiB0aGlzLnBhcGVyLmNlbGxzIH0pO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBuZXcgeCwgeSBhbmQgcGVyZm9ybSByb3RhdGUoKSBhZ2FpbiBhZ2FpbnN0IHRoZSBuZXcgcm90YXRpb24gb3JpZ2luLlxuICAgICAgICAgICAgbW9kZWwuc2V0KCdwb3NpdGlvbicsIHsgeDogcm90YXRhYmxlQkJveC54LCB5OiByb3RhdGFibGVCQm94LnkgfSwgYXNzaWduKHsgdXBkYXRlSGFuZGxlZDogdHJ1ZSB9LCBvcHQpKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG11c3QgYWx3YXlzIGJlIGNhbGxlZCBvbiBub24tcm90YXRlZCBlbGVtZW50LiBPdGhlcndpc2UsIHJlbGF0aXZlIHBvc2l0aW9uaW5nXG4gICAgICAgIC8vIHdvdWxkIHdvcmsgd2l0aCB3cm9uZyAocm90YXRlZCkgYm91bmRpbmcgYm94ZXMuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIC8vIEVtYmVkZGluZyBtb2RlIG1ldGhvZHMuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZXBhcmVFbWJlZGRpbmc6IGZ1bmN0aW9uKGRhdGEgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhLm1vZGVsIHx8IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IHBhcGVyID0gZGF0YS5wYXBlciB8fCB0aGlzLnBhcGVyO1xuICAgICAgICBjb25zdCBncmFwaCA9IHBhcGVyLm1vZGVsO1xuXG4gICAgICAgIGNvbnN0IGluaXRpYWxaSW5kaWNlcyA9IGRhdGEuaW5pdGlhbFpJbmRpY2VzID0ge307XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkQ2VsbHMgPSBlbGVtZW50LmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRMaW5rcyA9IGdyYXBoLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIHsgZGVlcDogdHJ1ZSwgaW5jbHVkZUVuY2xvc2VkOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIE5vdGU6IGFuIGVtYmVkZGVkIGNlbGwgY2FuIGJlIGEgY29ubmVjdCBsaW5rLCBidXQgaXQncyBmaW5lXG4gICAgICAgIC8vIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2VsbCB0d2ljZS5cbiAgICAgICAgW1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIC4uLmVtYmVkZGVkQ2VsbHMsXG4gICAgICAgICAgICAuLi5jb25uZWN0ZWRMaW5rc1xuICAgICAgICBdLmZvckVhY2goY2VsbCA9PiBpbml0aWFsWkluZGljZXNbY2VsbC5pZF0gPSBjZWxsLmF0dHJpYnV0ZXMueik7XG5cbiAgICAgICAgZWxlbWVudC5zdGFydEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgIC8vIEJyaW5nIHRoZSBtb2RlbCB0byB0aGUgZnJvbnQgd2l0aCBhbGwgaGlzIGVtYmVkcy5cbiAgICAgICAgZWxlbWVudC50b0Zyb250KHsgZGVlcDogdHJ1ZSwgdWk6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGF0IHRoaXMgcG9pbnQgY2VsbHMgaW4gdGhlIGNvbGxlY3Rpb24gYXJlIG5vdCBzb3J0ZWQgYnkgeiBpbmRleCAoaXQncyBydW5uaW5nIGluIHRoZSBiYXRjaCwgc2VlXG4gICAgICAgIC8vIHRoZSBkaWEuR3JhcGguX3NvcnRPbkNoYW5nZVopLCBzbyB3ZSBjYW4ndCBhc3N1bWUgdGhhdCB0aGUgbGFzdCBjZWxsIGluIHRoZSBjb2xsZWN0aW9uIGhhcyB0aGUgaGlnaGVzdCB6LlxuICAgICAgICBjb25zdCBtYXhaID0gZ3JhcGguZ2V0RWxlbWVudHMoKS5yZWR1Y2UoKG1heCwgY2VsbCkgPT4gTWF0aC5tYXgobWF4LCBjZWxsLmF0dHJpYnV0ZXMueiB8fCAwKSwgMCk7XG5cbiAgICAgICAgLy8gTW92ZSB0byBmcm9udCBhbHNvIGFsbCB0aGUgaW5ib3VuZCBhbmQgb3V0Ym91bmQgbGlua3MgdGhhdCBhcmUgY29ubmVjdGVkXG4gICAgICAgIC8vIHRvIGFueSBvZiB0aGUgZWxlbWVudCBkZXNjZW5kYW50LiBJZiB3ZSBicmluZyB0byBmcm9udCBvbmx5IGVtYmVkZGVkIGVsZW1lbnRzLFxuICAgICAgICAvLyBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlbSB3b3VsZCBzdGF5IGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICBjb25uZWN0ZWRMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAobGluay5hdHRyaWJ1dGVzLnogPD0gbWF4Wikge1xuICAgICAgICAgICAgICAgIGxpbmsuc2V0KCd6JywgbWF4WiArIDEsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQuc3RvcEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgIC8vIEJlZm9yZSB3ZSBzdGFydCBsb29raW5nIGZvciBzdWl0YWJsZSBwYXJlbnQgd2UgcmVtb3ZlIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgY29uc3QgcGFyZW50SWQgPSBlbGVtZW50LnBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGdyYXBoLmdldENlbGwocGFyZW50SWQpO1xuICAgICAgICAgICAgcGFyZW50LnVuZW1iZWQoZWxlbWVudCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRhdGEuaW5pdGlhbFBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmluaXRpYWxQYXJlbnRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvY2Vzc0VtYmVkZGluZzogZnVuY3Rpb24oZGF0YSA9IHt9LCBldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCBtb2RlbCA9IGRhdGEubW9kZWwgfHwgdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgcGFwZXIgPSBkYXRhLnBhcGVyIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgICAgIGNvbnN0IHsgZmluZFBhcmVudEJ5LCBmcm9udFBhcmVudE9ubHksIHZhbGlkYXRlRW1iZWRkaW5nIH0gPSBwYXBlci5vcHRpb25zO1xuXG4gICAgICAgIGxldCBjYW5kaWRhdGVzO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmaW5kUGFyZW50QnkpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdG9BcnJheShmaW5kUGFyZW50QnkuY2FsbChncmFwaCwgdGhpcywgZXZ0LCB4LCB5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmluZFBhcmVudEJ5ID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0b0FycmF5KGdyYXBoLmZpbmRNb2RlbHNGcm9tUG9pbnQoeyB4LCB5IH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBncmFwaC5maW5kTW9kZWxzVW5kZXJFbGVtZW50KG1vZGVsLCB7IHNlYXJjaEJ5OiBmaW5kUGFyZW50QnkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoKGVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGVsIGluc3RhbmNlb2YgQ2VsbCkgJiYgKG1vZGVsLmlkICE9PSBlbC5pZCkgJiYgIWVsLmlzRW1iZWRkZWRJbihtb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmcm9udFBhcmVudE9ubHkpIHtcbiAgICAgICAgICAgIC8vIHBpY2sgdGhlIGVsZW1lbnQgd2l0aCB0aGUgaGlnaGVzdCBgemAgaW5kZXhcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLnNsaWNlKC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdDYW5kaWRhdGVWaWV3ID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJldkNhbmRpZGF0ZVZpZXcgPSBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldztcblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIGNhbmRpZGF0ZXMgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBvbmUgKGhhcyB0aGUgaGlnaGVzdCB6LWluZGV4KS5cbiAgICAgICAgZm9yIChsZXQgaSA9IGNhbmRpZGF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAocHJldkNhbmRpZGF0ZVZpZXcgJiYgcHJldkNhbmRpZGF0ZVZpZXcubW9kZWwuaWQgPT0gY2FuZGlkYXRlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuZGlkYXRlIHJlbWFpbnMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBuZXdDYW5kaWRhdGVWaWV3ID0gcHJldkNhbmRpZGF0ZVZpZXc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjYW5kaWRhdGUuZmluZFZpZXcocGFwZXIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih2YWxpZGF0ZUVtYmVkZGluZykgfHwgdmFsaWRhdGVFbWJlZGRpbmcuY2FsbChwYXBlciwgdGhpcywgdmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCB0byB0aGUgbmV3IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgICAgICBuZXdDYW5kaWRhdGVWaWV3ID0gdmlldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NhbmRpZGF0ZVZpZXcgJiYgbmV3Q2FuZGlkYXRlVmlldyAhPSBwcmV2Q2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gQSBuZXcgY2FuZGlkYXRlIHZpZXcgZm91bmQuIEhpZ2hsaWdodCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldyA9IG5ld0NhbmRpZGF0ZVZpZXcuaGlnaGxpZ2h0KFxuICAgICAgICAgICAgICAgIG5ld0NhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksXG4gICAgICAgICAgICAgICAgeyBlbWJlZGRpbmc6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3Q2FuZGlkYXRlVmlldyAmJiBwcmV2Q2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gTm8gY2FuZGlkYXRlIHZpZXcgZm91bmQuIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBjYW5kaWRhdGUuXG4gICAgICAgICAgICB0aGlzLmNsZWFyRW1iZWRkaW5nKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFyRW1iZWRkaW5nOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHt9KTtcblxuICAgICAgICB2YXIgY2FuZGlkYXRlVmlldyA9IGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3O1xuICAgICAgICBpZiAoY2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gTm8gY2FuZGlkYXRlIHZpZXcgZm91bmQuIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBjYW5kaWRhdGUuXG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3LnVuaGlnaGxpZ2h0KFxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksXG4gICAgICAgICAgICAgICAgeyBlbWJlZGRpbmc6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5hbGl6ZUVtYmVkZGluZzogZnVuY3Rpb24oZGF0YSA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlVmlldyA9IGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZGF0YS5tb2RlbCB8fCB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBwYXBlciA9IGRhdGEucGFwZXIgfHwgdGhpcy5wYXBlcjtcblxuICAgICAgICBpZiAoY2FuZGlkYXRlVmlldykge1xuXG4gICAgICAgICAgICAvLyBXZSBmaW5pc2hlZCBlbWJlZGRpbmcuIENhbmRpZGF0ZSB2aWV3IGlzIGNob3NlbiB0byBiZWNvbWUgdGhlIHBhcmVudCBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3Lm1vZGVsLmVtYmVkKGVsZW1lbnQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3LnVuaGlnaGxpZ2h0KGNhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksIHsgZW1iZWRkaW5nOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldyA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgeyB2YWxpZGF0ZVVuZW1iZWRkaW5nIH0gPSBwYXBlci5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgeyBpbml0aWFsUGFyZW50SWQgfSA9IGRhdGE7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgb3JpZ2luYWxseSBlbWJlZGRlZCBpbnRvIGFub3RoZXIgZWxlbWVudC5cbiAgICAgICAgICAgIC8vIFRoZSBpbnRlcmFjdGlvbiB3b3VsZCB1bmVtYmVkIHRoZSBlbGVtZW50LiBMZXQncyB2YWxpZGF0ZVxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgY2FuIGJlIHVuZW1iZWRkZWQuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaW5pdGlhbFBhcmVudElkICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbGlkYXRlVW5lbWJlZGRpbmcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAhdmFsaWRhdGVVbmVtYmVkZGluZy5jYWxsKHBhcGVyLCB0aGlzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWxsb3dVbmVtYmVkKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcGVyLm1vZGVsLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIHsgZGVlcDogdHJ1ZSB9KS5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgbGluay5yZXBhcmVudCh7IHVpOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2Rpc2FsbG93VW5lbWJlZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjb25zdCB7IG1vZGVsLCB3aGVuTm90QWxsb3dlZCA9ICdyZXZlcnQnIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbW9kZWwgfHwgdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgcGFwZXIgPSBkYXRhLnBhcGVyIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgICAgIHN3aXRjaCAod2hlbk5vdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSh7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmV2ZXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5pdGlhbFBhcmVudElkLCBpbml0aWFsUG9zaXRpb24sIGluaXRpYWxaSW5kaWNlcyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGVsZW1lbnQncyBwb3NpdGlvbiAoYW5kIHRoZSBwb3NpdGlvbiBvZiBpdHMgZW1iZWRkZWQgY2VsbHMgaWYgYW55KVxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24oeCwgeSwgeyBkZWVwOiB0cnVlLCB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IGFsbCB0aGUgei1pbmRpY2VzIGNoYW5nZWQgZHVyaW5nIHRoZSBlbWJlZGRpbmdcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFpJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluaXRpYWxaSW5kaWNlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZ3JhcGguZ2V0Q2VsbChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgaW5pdGlhbFpJbmRpY2VzW2lkXSwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgb3JpZ2luYWwgcGFyZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ3JhcGguZ2V0Q2VsbChpbml0aWFsUGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVtYmVkKGVsZW1lbnQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldERlbGVnYXRlZFZpZXc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgdmFyIHBhcGVyID0gdmlldy5wYXBlcjtcblxuICAgICAgICB3aGlsZSAodmlldykge1xuICAgICAgICAgICAgaWYgKG1vZGVsLmlzTGluaygpKSBicmVhaztcbiAgICAgICAgICAgIGlmICghbW9kZWwuaXNFbWJlZGRlZCgpIHx8IHZpZXcuY2FuKCdzdG9wRGVsZWdhdGlvbicpKSByZXR1cm4gdmlldztcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWwuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICAgICAgdmlldyA9IHBhcGVyLmZpbmRWaWV3QnlNb2RlbChtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZmluZFByb3h5Tm9kZTogZnVuY3Rpb24oZWwsIHR5cGUpIHtcbiAgICAgICAgZWwgfHwgKGVsID0gdGhpcy5lbCk7XG4gICAgICAgIGNvbnN0IG5vZGVTZWxlY3RvciA9IGVsLmdldEF0dHJpYnV0ZShgJHt0eXBlfS1zZWxlY3RvcmApO1xuICAgICAgICBpZiAobm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5maW5kQXR0cmlidXRlKCdwb3J0JywgZWwpO1xuICAgICAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eVBvcnROb2RlID0gdGhpcy5maW5kUG9ydE5vZGUocG9ydCwgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlQb3J0Tm9kZSkgcmV0dXJuIHByb3h5UG9ydE5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwcm94eU5vZGVdID0gdGhpcy5maW5kQnlTZWxlY3Rvcihub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eU5vZGUpIHJldHVybiBwcm94eU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbi4gVGhlIGNvbnRyb2xsZXIgcGFydC5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIG5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmRvd24uY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVyZG93bicsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG5vdGlmeVBvaW50ZXJtb3ZlKGV2dCwgeCwgeSkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcm1vdmUuY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVybW92ZScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG5vdGlmeVBvaW50ZXJ1cChldnQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcnVwJywgZXZ0LCB4LCB5KTtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJ1cC5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJkYmxjbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVyZGJsY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyY2xpY2s6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyY2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcmNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5jb250ZXh0bWVudS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpjb250ZXh0bWVudScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0KGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgY29uc3QgeyB0YXJnZXRNYWduZXQsIGFjdGlvbiwgZGVsZWdhdGVkVmlldyB9ID0gZGF0YTtcblxuICAgICAgICBpZiAodGFyZ2V0TWFnbmV0KSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldHBvaW50ZXJtb3ZlKGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERyYWdBY3Rpb25zLk1BR05FVDpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNYWduZXQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FjdGlvbnMuTU9WRTpcbiAgICAgICAgICAgICAgICAoZGVsZWdhdGVkVmlldyB8fCB0aGlzKS5kcmFnKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQ6IG5vLWZhbGx0aHJvdWdoPWZhbHNlXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnByZXZlbnRQb2ludGVyRXZlbnRzKSBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJtb3ZlKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgdmlldyBkYXRhIGlzIHBhc3NlZCBhbG9uZy5cbiAgICAgICAgLy8gSXQgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBpbiB0aGUgaGFuZGxlcnMgYWJvdmUuXG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgZGF0YSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0TWFnbmV0LCBhY3Rpb24sIGRlbGVnYXRlZFZpZXcgfSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hZ25ldCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRwb2ludGVydXAoZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FjdGlvbnMuTUFHTkVUOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ01hZ25ldEVuZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEcmFnQWN0aW9ucy5NT1ZFOlxuICAgICAgICAgICAgICAgIChkZWxlZ2F0ZWRWaWV3IHx8IHRoaXMpLmRyYWdFbmQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIC8vIGVzbGludDogbm8tZmFsbHRocm91Z2g9ZmFsc2VcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucHJldmVudFBvaW50ZXJFdmVudHMpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcnVwKGV2dCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0TWFnbmV0KSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldHBvaW50ZXJjbGljayhldnQsIHRhcmdldE1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrTW91c2VsZWF2ZShldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW92ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bW91c2VvdmVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZW91dCcsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZWVudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1vdXNlZW50ZXInLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VsZWF2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZWxlYXZlJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0LCB4LCB5LCBkZWx0YSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZXdoZWVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1vdXNld2hlZWwnLCBldnQsIHgsIHksIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgb25tYWduZXQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRhcmdldDogdGFyZ2V0TWFnbmV0IH0gPSBldnQ7XG4gICAgICAgIHRoaXMubWFnbmV0cG9pbnRlcmRvd24oZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgdGFyZ2V0TWFnbmV0IH0pO1xuICAgICAgICB0aGlzLmRyYWdNYWduZXRTdGFydChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcmRvd24nLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1hZ25ldDpwb2ludGVybW92ZScsIGV2dCwgbWFnbmV0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcnVwOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1hZ25ldDpwb2ludGVydXAnLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6Y29udGV4dG1lbnUnLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgU3RhcnQgSGFuZGxlcnNcblxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5nZXREZWxlZ2F0ZWRWaWV3KCk7XG4gICAgICAgIGlmICghdmlldyB8fCAhdmlldy5jYW4oJ2VsZW1lbnRNb3ZlJykpIHJldHVybjtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGFjdGlvbjogRHJhZ0FjdGlvbnMuTU9WRSxcbiAgICAgICAgICAgIGRlbGVnYXRlZFZpZXc6IHZpZXdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2aWV3Lm1vZGVsLnBvc2l0aW9uKCk7XG4gICAgICAgIHZpZXcuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHBvaW50ZXJPZmZzZXQ6IHBvc2l0aW9uLmRpZmZlcmVuY2UoeCwgeSksXG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYTogdGhpcy5wYXBlci5nZXRSZXN0cmljdGVkQXJlYSh2aWV3LCB4LCB5KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZHJhZ01hZ25ldFN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc1Byb3BhZ2F0aW9uQWxyZWFkeVN0b3BwZWQgPSBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgICAgaWYgKGlzUHJvcGFnYXRpb25BbHJlYWR5U3RvcHBlZCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gdGhlIHByb3BhZ2F0aW9uIHdhcyBhbHJlYWR5IHN0b3BwZWRcbiAgICAgICAgICAgIC8vIG9uIHRoZSBgZWxlbWVudDptYWduZXQ6cG9pbnRlcmRvd25gIGV2ZW50LlxuICAgICAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgYW55IGBlbGVtZW50OnBvaW50ZXIqYCBldmVudHNcbiAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCBzdGFydCB0aGUgbWFnbmV0IGRyYWdnaW5nLlxuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IHByZXZlbnRQb2ludGVyRXZlbnRzOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSB8fCAhdGhpcy5jYW4oJ2FkZExpbmtGcm9tTWFnbmV0JykpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYWN0aW9uLCB3aGljaCBpcyB0byBzdGFydCBkcmFnZ2luZyBhIGxpbmsuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHRhcmdldE1hZ25ldCA9IGV2dC5jdXJyZW50VGFyZ2V0IH0gPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgLy8gSW52YWxpZCAoUGFzc2l2ZSkgbWFnbmV0LiBTdGFydCBkcmFnZ2luZyB0aGUgZWxlbWVudC5cbiAgICAgICAgaWYgKCFwYXBlci5vcHRpb25zLnZhbGlkYXRlTWFnbmV0LmNhbGwocGFwZXIsIHRoaXMsIHRhcmdldE1hZ25ldCwgZXZ0KSkge1xuICAgICAgICAgICAgaWYgKGlzUHJvcGFnYXRpb25BbHJlYWR5U3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBlbGVtZW50OnBvaW50ZXJkb3duYCBhbmQgc3RhcnQgZWxlbWVudCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wYWdhdGlvbiB3YXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgZWxlbWVudDpwb2ludGVyZG93bmAgZXZlbnQgaXMgbm90IHRyaWdnZXJlZCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gb2YgYHByZXZlbnRQb2ludGVyRXZlbnRzYCBmbGFnLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlc2V0IHRoZSBhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyB0byBgTU9WRWAgc28gdGhhdCB0aGUgZWxlbWVudCBpcyBkcmFnZ2VkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkIG1hZ25ldC4gU3RhcnQgZHJhZ2dpbmcgYSBsaW5rLlxuICAgICAgICBpZiAocGFwZXIub3B0aW9ucy5tYWduZXRUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnTGlua1N0YXJ0KGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgYWN0aW9uOiBEcmFnQWN0aW9ucy5NQUdORVQgfSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgSGFuZGxlcnNcblxuICAgIGRyYWc6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBncmlkID0gcGFwZXIub3B0aW9ucy5ncmlkU2l6ZTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHZhciB7IHBvaW50ZXJPZmZzZXQsIHJlc3RyaWN0ZWRBcmVhLCBlbWJlZGRpbmcgfSA9IGRhdGE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXcgZWxlbWVudCdzIHBvc2l0aW9uIGFsd2F5cyBzbmFwcyB0byB0aGUgY3VycmVudCBncmlkXG4gICAgICAgIHZhciBlbFggPSBzbmFwVG9HcmlkKHggKyBwb2ludGVyT2Zmc2V0LngsIGdyaWQpO1xuICAgICAgICB2YXIgZWxZID0gc25hcFRvR3JpZCh5ICsgcG9pbnRlck9mZnNldC55LCBncmlkKTtcblxuICAgICAgICBlbGVtZW50LnBvc2l0aW9uKGVsWCwgZWxZLCB7IHJlc3RyaWN0ZWRBcmVhLCBkZWVwOiB0cnVlLCB1aTogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAocGFwZXIub3B0aW9ucy5lbWJlZGRpbmdNb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWVtYmVkZGluZykge1xuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIGVsZW1lbnQgZm9yIGVtYmVkZGluZyBvbmx5IGlmIHRoZSBwb2ludGVyIG1vdmVzLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZG8gdW5uZWNlc3NhcnkgYWN0aW9uIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpZiBhbiB1c2VyIG9ubHkgY2xpY2tzL2RibGNsaWNrcyBvbiBpdC5cbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VtYmVkZGluZyhkYXRhLCBldnQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBlbWJlZGRpbmdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRyYWdNYWduZXQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuICAgICAgICB0aGlzLmRyYWdMaW5rKGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgRW5kIEhhbmRsZXJzXG5cbiAgICBkcmFnRW5kOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGlmIChkYXRhLmVtYmVkZGluZykgdGhpcy5maW5hbGl6ZUVtYmVkZGluZyhkYXRhKTtcbiAgICB9LFxuXG4gICAgZHJhZ01hZ25ldEVuZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuZHJhZ0xpbmtFbmQoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICBpZiAocGFwZXIuZXZlbnREYXRhKGV2dCkubW91c2Vtb3ZlZCA+IHBhcGVyLm9wdGlvbnMuY2xpY2tUaHJlc2hvbGQpIHJldHVybjtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bWFnbmV0OnBvaW50ZXJjbGljaycsIGV2dCwgbWFnbmV0LCB4LCB5KTtcbiAgICB9XG5cbn0sIHtcblxuICAgIEZsYWdzOiBGbGFncyxcbn0pO1xuXG5hc3NpZ24oRWxlbWVudFZpZXcucHJvdG90eXBlLCBlbGVtZW50Vmlld1BvcnRQcm90b3R5cGUpO1xuIl0sIm5hbWVzIjpbImNvbmZpZyIsImFzc2lnbiIsImlzRnVuY3Rpb24iLCJ0b0FycmF5IiwiQ2VsbFZpZXciLCJDZWxsIiwiViIsImVsZW1lbnRWaWV3UG9ydFByb3RvdHlwZSIsIlJlY3QiLCJzbmFwVG9HcmlkIiwiRmxhZ3MiLCJUT09MUyIsIlVQREFURSIsIlRSQU5TTEFURSIsIlJFU0laRSIsIlBPUlRTIiwiUk9UQVRFIiwiUkVOREVSIiwiRHJhZ0FjdGlvbnMiLCJNT1ZFIiwiTUFHTkVUIiwiRWxlbWVudFZpZXciLCJleHRlbmQiLCJfcmVtb3ZlUG9ydHMiLCJfcmVuZGVyUG9ydHMiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVzIiwicHJvdG90eXBlIiwiYXBwbHkiLCJzcGxpdCIsInB1c2giLCJqb2luIiwiaW5pdGlhbGl6ZSIsImFyZ3VtZW50cyIsIl9pbml0aWFsaXplUG9ydHMiLCJwcmVzZW50YXRpb25BdHRyaWJ1dGVzIiwiaW5pdEZsYWciLCJVUERBVEVfUFJJT1JJVFkiLCJjb25maXJtVXBkYXRlIiwiZmxhZyIsIm9wdCIsInVzZUNTU1NlbGVjdG9ycyIsImhhc0ZsYWciLCJfY2xlYW5Qb3J0c0NhY2hlIiwidHJhbnNmb3JtSGlnaGxpZ2h0ZXJzIiwicmVuZGVyIiwidXBkYXRlVG9vbHMiLCJ1cGRhdGVIaWdobGlnaHRlcnMiLCJyZW1vdmVGbGFnIiwicmVzaXplIiwidXBkYXRlIiwibW9kZWwiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJfIiwicmVuZGVyaW5nT25seUF0dHJzIiwiY2xlYW5Ob2Rlc0NhY2hlIiwibW9kZWxBdHRycyIsImF0dHIiLCJ1cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlcyIsImVsIiwicm9vdEJCb3giLCJzaXplIiwic2VsZWN0b3JzIiwic2NhbGFibGVOb2RlIiwicm90YXRhYmxlTm9kZSIsInJvQXR0cmlidXRlcyIsInJvdGF0YWJsZVNlbGVjdG9yIiwic2NhbGFibGVTZWxlY3RvciIsInJlbmRlck1hcmt1cCIsImVsZW1lbnQiLCJtYXJrdXAiLCJnZXQiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsInJlbmRlckpTT05NYXJrdXAiLCJyZW5kZXJTdHJpbmdNYXJrdXAiLCJkb2MiLCJwYXJzZURPTUpTT04iLCJ2ZWwiLCJhcHBlbmQiLCJmcmFnbWVudCIsImZpbmRPbmUiLCJzZWxlY3RvciIsImVtcHR5IiwidXBkYXRlVHJhbnNmb3JtYXRpb24iLCJzZ1Jlc2l6ZSIsImF0dHJpYnV0ZXMiLCJhbmdsZSIsInJnVHJhbnNsYXRlIiwicmdSb3RhdGUiLCJ0cmFuc2Zvcm1hdGlvbiIsImdldFRyYW5zbGF0ZVN0cmluZyIsInJvdGF0ZVN0cmluZyIsImdldFJvdGF0ZVN0cmluZyIsInBvc2l0aW9uIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInNjYWxhYmxlIiwicmVjdXJzaXZlIiwibm9kZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibGVuZ3RoIiwic2NhbGFibGVCQm94IiwiZ2V0QkJveCIsInN4Iiwic3kiLCJyb3RhdGFibGUiLCJyb3RhdGlvbiIsInJvdGF0YWJsZUJCb3giLCJ0YXJnZXQiLCJwYXBlciIsImNlbGxzIiwic2V0IiwidXBkYXRlSGFuZGxlZCIsInByZXBhcmVFbWJlZGRpbmciLCJkYXRhIiwiZ3JhcGgiLCJpbml0aWFsWkluZGljZXMiLCJlbWJlZGRlZENlbGxzIiwiZ2V0RW1iZWRkZWRDZWxscyIsImRlZXAiLCJjb25uZWN0ZWRMaW5rcyIsImdldENvbm5lY3RlZExpbmtzIiwiaW5jbHVkZUVuY2xvc2VkIiwiZm9yRWFjaCIsImNlbGwiLCJpZCIsInoiLCJzdGFydEJhdGNoIiwidG9Gcm9udCIsInVpIiwibWF4WiIsImdldEVsZW1lbnRzIiwicmVkdWNlIiwibWF4IiwiTWF0aCIsImxpbmsiLCJzdG9wQmF0Y2giLCJwYXJlbnRJZCIsInBhcmVudCIsImdldENlbGwiLCJ1bmVtYmVkIiwiaW5pdGlhbFBhcmVudElkIiwicHJvY2Vzc0VtYmVkZGluZyIsImV2dCIsImZpbmRQYXJlbnRCeSIsImZyb250UGFyZW50T25seSIsInZhbGlkYXRlRW1iZWRkaW5nIiwib3B0aW9ucyIsImNhbmRpZGF0ZXMiLCJjYWxsIiwiZmluZE1vZGVsc0Zyb21Qb2ludCIsImZpbmRNb2RlbHNVbmRlckVsZW1lbnQiLCJzZWFyY2hCeSIsImZpbHRlciIsImlzRW1iZWRkZWRJbiIsInNsaWNlIiwibmV3Q2FuZGlkYXRlVmlldyIsInByZXZDYW5kaWRhdGVWaWV3IiwiY2FuZGlkYXRlRW1iZWRWaWV3IiwiaSIsImNhbmRpZGF0ZSIsInZpZXciLCJmaW5kVmlldyIsImNsZWFyRW1iZWRkaW5nIiwiaGlnaGxpZ2h0IiwiZmluZFByb3h5Tm9kZSIsImVtYmVkZGluZyIsImNhbmRpZGF0ZVZpZXciLCJ1bmhpZ2hsaWdodCIsImZpbmFsaXplRW1iZWRkaW5nIiwiZW1iZWQiLCJ2YWxpZGF0ZVVuZW1iZWRkaW5nIiwiX2Rpc2FsbG93VW5lbWJlZCIsInJlcGFyZW50Iiwid2hlbk5vdEFsbG93ZWQiLCJyZW1vdmUiLCJpbml0aWFsUG9zaXRpb24iLCJPYmplY3QiLCJrZXlzIiwiZ2V0RGVsZWdhdGVkVmlldyIsImlzTGluayIsImlzRW1iZWRkZWQiLCJjYW4iLCJnZXRQYXJlbnRDZWxsIiwiZmluZFZpZXdCeU1vZGVsIiwidHlwZSIsIm5vZGVTZWxlY3RvciIsImdldEF0dHJpYnV0ZSIsInBvcnQiLCJmaW5kQXR0cmlidXRlIiwicHJveHlQb3J0Tm9kZSIsImZpbmRQb3J0Tm9kZSIsInByb3h5Tm9kZSIsImZpbmRCeVNlbGVjdG9yIiwibm90aWZ5UG9pbnRlcmRvd24iLCJwb2ludGVyZG93biIsIm5vdGlmeSIsIm5vdGlmeVBvaW50ZXJtb3ZlIiwicG9pbnRlcm1vdmUiLCJub3RpZnlQb2ludGVydXAiLCJwb2ludGVydXAiLCJwb2ludGVyZGJsY2xpY2siLCJwb2ludGVyY2xpY2siLCJjb250ZXh0bWVudSIsImRyYWdTdGFydCIsImV2ZW50RGF0YSIsInRhcmdldE1hZ25ldCIsImFjdGlvbiIsImRlbGVnYXRlZFZpZXciLCJtYWduZXRwb2ludGVybW92ZSIsImRyYWdNYWduZXQiLCJkcmFnIiwicHJldmVudFBvaW50ZXJFdmVudHMiLCJtYWduZXRwb2ludGVydXAiLCJkcmFnTWFnbmV0RW5kIiwiZHJhZ0VuZCIsIm1hZ25ldHBvaW50ZXJjbGljayIsImNoZWNrTW91c2VsZWF2ZSIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJtb3VzZXdoZWVsIiwiZGVsdGEiLCJvbm1hZ25ldCIsImN1cnJlbnRUYXJnZXQiLCJtYWduZXRwb2ludGVyZG93biIsImRyYWdNYWduZXRTdGFydCIsIm1hZ25ldCIsIm1hZ25ldHBvaW50ZXJkYmxjbGljayIsIm1hZ25ldGNvbnRleHRtZW51IiwiaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQiLCJwb2ludGVyT2Zmc2V0IiwiZGlmZmVyZW5jZSIsInJlc3RyaWN0ZWRBcmVhIiwiZ2V0UmVzdHJpY3RlZEFyZWEiLCJpc1Byb3BhZ2F0aW9uQWxyZWFkeVN0b3BwZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BQcm9wYWdhdGlvbiIsInZhbGlkYXRlTWFnbmV0IiwibWFnbmV0VGhyZXNob2xkIiwiZHJhZ0xpbmtTdGFydCIsImdyaWQiLCJncmlkU2l6ZSIsImVsWCIsImVsWSIsImVtYmVkZGluZ01vZGUiLCJkcmFnTGluayIsImRyYWdMaW5rRW5kIiwibW91c2Vtb3ZlZCIsImNsaWNrVGhyZXNob2xkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/ElementView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/Graph.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/dia/Graph.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ \"(ssr)/./node_modules/backbone/backbone.js\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/getRectPoint.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Link.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Link.mjs\");\n/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Element.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Element.mjs\");\n/* harmony import */ var _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/wrappers.mjs */ \"(ssr)/./node_modules/jointjs/src/util/wrappers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/cloneCells.mjs\");\n\n\n\n\n\n\n\nconst GraphCells = backbone__WEBPACK_IMPORTED_MODULE_0__.Collection.extend({\n    initialize: function(models, opt) {\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */ this.cellNamespace = typeof joint !== \"undefined\" && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(joint, \"shapes\") ? joint.shapes : null;\n        /* eslint-enable no-undef */ }\n        this.graph = opt.graph;\n    },\n    model: function(attrs, opt) {\n        var collection = opt.collection;\n        var namespace = collection.cellNamespace;\n        // Find the model class in the namespace or use the default one.\n        var ModelClass = attrs.type === \"link\" ? _Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link : _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.getByPath(namespace, attrs.type, \".\") || _Element_mjs__WEBPACK_IMPORTED_MODULE_4__.Element;\n        var cell = new ModelClass(attrs, opt);\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n        if (!opt.dry) {\n            cell.graph = collection.graph;\n        }\n        return cell;\n    },\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n        return model.get(\"z\") || 0;\n    }\n});\nconst Graph = backbone__WEBPACK_IMPORTED_MODULE_0__.Model.extend({\n    initialize: function(attrs, opt) {\n        opt = opt || {};\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        backbone__WEBPACK_IMPORTED_MODULE_0__.Model.prototype.set.call(this, \"cells\", cells);\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on(\"all\", this.trigger, this);\n        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on(\"change:z\", this._sortOnChangeZ, this);\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n        this._batches = {};\n        cells.on(\"add\", this._restructureOnAdd, this);\n        cells.on(\"remove\", this._restructureOnRemove, this);\n        cells.on(\"reset\", this._restructureOnReset, this);\n        cells.on(\"change:source\", this._restructureOnChangeSource, this);\n        cells.on(\"change:target\", this._restructureOnChangeTarget, this);\n        cells.on(\"remove\", this._removeCell, this);\n    },\n    _sortOnChangeZ: function() {\n        this.get(\"cells\").sort();\n    },\n    _restructureOnAdd: function(cell) {\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n    _restructureOnRemove: function(cell) {\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n    _restructureOnReset: function(cells) {\n        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n        cells = cells.models;\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n        cells.forEach(this._restructureOnAdd, this);\n    },\n    _restructureOnChangeSource: function(link) {\n        var prevSource = link.previous(\"source\");\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n    _restructureOnChangeTarget: function(link) {\n        var prevTarget = link.previous(\"target\");\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get(\"target\");\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n        return this._out && this._out[node] || {};\n    },\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n        return this._in && this._in[node] || {};\n    },\n    toJSON: function() {\n        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = backbone__WEBPACK_IMPORTED_MODULE_0__.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get(\"cells\").toJSON();\n        return json;\n    },\n    fromJSON: function(json, opt) {\n        if (!json.cells) {\n            throw new Error(\"Graph JSON must contain cells array.\");\n        }\n        return this.set(json, opt);\n    },\n    set: function(key, val, opt) {\n        var attrs;\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === \"object\") {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty(\"cells\")) {\n            this.resetCells(attrs.cells, opt);\n            attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit(attrs, \"cells\");\n        }\n        // The rest of the attributes are applied via original set method.\n        return backbone__WEBPACK_IMPORTED_MODULE_0__.Model.prototype.set.call(this, attrs, opt);\n    },\n    clear: function(opt) {\n        opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, {\n            clear: true\n        });\n        var collection = this.get(\"cells\");\n        if (collection.length === 0) return this;\n        this.startBatch(\"clear\", opt);\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n        do {\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n        }while (cells.length > 0);\n        this.stopBatch(\"clear\");\n        return this;\n    },\n    _prepareCell: function(cell, opt) {\n        var attrs;\n        if (cell instanceof backbone__WEBPACK_IMPORTED_MODULE_0__.Model) {\n            attrs = cell.attributes;\n            if (!cell.graph && (!opt || !opt.dry)) {\n                // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            }\n        } else {\n            // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n        }\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString(attrs.type)) {\n            throw new TypeError(\"dia.Graph: cell type must be a string.\");\n        }\n        return cell;\n    },\n    minZIndex: function() {\n        var firstCell = this.get(\"cells\").first();\n        return firstCell ? firstCell.get(\"z\") || 0 : 0;\n    },\n    maxZIndex: function() {\n        var lastCell = this.get(\"cells\").last();\n        return lastCell ? lastCell.get(\"z\") || 0 : 0;\n    },\n    addCell: function(cell, opt) {\n        if (Array.isArray(cell)) {\n            return this.addCells(cell, opt);\n        }\n        if (cell instanceof backbone__WEBPACK_IMPORTED_MODULE_0__.Model) {\n            if (!cell.has(\"z\")) {\n                cell.set(\"z\", this.maxZIndex() + 1);\n            }\n        } else if (cell.z === undefined) {\n            cell.z = this.maxZIndex() + 1;\n        }\n        this.get(\"cells\").add(this._prepareCell(cell, opt), opt || {});\n        return this;\n    },\n    addCells: function(cells, opt) {\n        if (cells.length === 0) return this;\n        cells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n        this.startBatch(\"add\", opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch(\"add\", opt);\n        return this;\n    },\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n        var preparedCells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get(\"cells\").reset(preparedCells, opt);\n        return this;\n    },\n    removeCells: function(cells, opt) {\n        if (cells.length) {\n            this.startBatch(\"remove\");\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, \"remove\", opt);\n            this.stopBatch(\"remove\");\n        }\n        return this;\n    },\n    _removeCell: function(cell, collection, options) {\n        options = options || {};\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n                this.disconnectLinks(cell, options);\n            } else {\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get(\"cells\").remove(cell, {\n            silent: true\n        });\n        if (cell.graph === this) {\n            // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        }\n    },\n    // Get a cell by `id`.\n    getCell: function(id) {\n        return this.get(\"cells\").get(id);\n    },\n    getCells: function() {\n        return this.get(\"cells\").toArray();\n    },\n    getElements: function() {\n        return this.get(\"cells\").filter((cell)=>cell.isElement());\n    },\n    getLinks: function() {\n        return this.get(\"cells\").filter((cell)=>cell.isLink());\n    },\n    getFirstCell: function() {\n        return this.get(\"cells\").first();\n    },\n    getLastCell: function() {\n        return this.get(\"cells\").last();\n    },\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n        opt = opt || {};\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n        function addOutbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getOutboundEdges(model.id), (function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }).bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n        function addInbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getInboundEdges(model.id), (function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }).bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n            var embeddedCells = model.getEmbeddedCells({\n                deep: true\n            });\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getOutboundEdges(cell.id), (function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                                return;\n                            }\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }).bind(this));\n                }\n                if (inbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getInboundEdges(cell.id), (function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                                return;\n                            }\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }).bind(this));\n                }\n            }, this);\n        }\n        return links;\n    },\n    getNeighbors: function(model, opt) {\n        opt || (opt = {});\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n        var neighbors = this.getConnectedLinks(model, opt).reduce((function(res, link) {\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, \"id\") && !res[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, \"id\") && !res[target.id]) {\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n            return res;\n        }).bind(this), {});\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(neighbors);\n    },\n    getCommonAncestor: function() {\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n            var ancestors = [];\n            var parentId = cell.get(\"parent\");\n            while(parentId){\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get(\"parent\");\n            }\n            return ancestors;\n        }, this);\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n        var commonAncestor = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n        return this.getCell(commonAncestor);\n    },\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, {\n            outbound: true\n        }));\n        return res;\n    },\n    cloneCells: _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n        opt = opt || {};\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({\n                    deep: true\n                });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n        return subgraph;\n    },\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, {\n            inbound: true\n        }));\n        return res;\n    },\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n        const visited = {};\n        const distance = {};\n        const queue = [];\n        queue.push(element);\n        distance[element.id] = 0;\n        while(queue.length > 0){\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for(let i = 0, n = neighbors.length; i < n; i++){\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n        const visited = {};\n        const distance = {};\n        const queue = [];\n        queue.push(element);\n        distance[element.id] = 0;\n        while(queue.length > 0){\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for(let i = 0, n = neighbors.length; i < n; i++){\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n        var sources = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, (function(exists, node) {\n            if (!this._in[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }).bind(this));\n        return sources;\n    },\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n        var sinks = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, (function(exists, node) {\n            if (!this._out[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }).bind(this));\n        return sinks;\n    },\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n        return !this._in[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[element.id]);\n    },\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n        return !this._out[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[element.id]);\n    },\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, {\n            outbound: true\n        });\n        return isSuccessor;\n    },\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, {\n            inbound: true\n        });\n        return isPredecessor;\n    },\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n        opt = opt || {};\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n        var isNeighbor = false;\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n            var { source, target } = link.attributes;\n            // Discard if it is a point.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, \"id\") && source.id === elementB.id) {\n                isNeighbor = true;\n                return false;\n            }\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, \"id\") && target.id === elementB.id) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n        return isNeighbor;\n    },\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n        this.getConnectedLinks(model).forEach(function(link) {\n            link.set(link.attributes.source.id === model.id ? \"source\" : \"target\", {\n                x: 0,\n                y: 0\n            }, opt);\n        });\n    },\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(this.getConnectedLinks(model), \"remove\", opt);\n    },\n    // Find all elements at given point\n    findModelsFromPoint: function(p) {\n        return this.getElements().filter((el)=>el.getBBox({\n                rotate: true\n            }).containsPoint(p));\n    },\n    // Find all elements in given area\n    findModelsInArea: function(rect, opt = {}) {\n        const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Rect(rect);\n        const { strict = false } = opt;\n        const method = strict ? \"containsRect\" : \"intersect\";\n        return this.getElements().filter((el)=>r[method](el.getBBox({\n                rotate: true\n            })));\n    },\n    // Find all elements under the given element.\n    findModelsUnderElement: function(element, opt = {}) {\n        const { searchBy = \"bbox\" } = opt;\n        const bbox = element.getBBox().rotateAroundCenter(element.angle());\n        const elements = searchBy === \"bbox\" ? this.findModelsInArea(bbox) : this.findModelsFromPoint(_util_index_mjs__WEBPACK_IMPORTED_MODULE_7__.getRectPoint(bbox, searchBy));\n        // don't account element itself or any of its descendants\n        return elements.filter((el)=>element.id !== el.id && !el.isEmbeddedIn(element));\n    },\n    // Return bounding box of all elements.\n    getBBox: function() {\n        return this.getCellsBBox(this.getCells());\n    },\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({\n                rotate\n            });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n    translate: function(dx, dy, opt) {\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, \"translate\", dx, dy, opt);\n        return this;\n    },\n    resize: function(width, height, opt) {\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n    resizeCells: function(width, height, cells, opt) {\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, \"scale\", sx, sy, bbox.origin(), opt);\n        }\n        return this;\n    },\n    startBatch: function(name, data) {\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n        return this.trigger(\"batch:start\", _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, {\n            batchName: name\n        }));\n    },\n    stopBatch: function(name, data) {\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n        return this.trigger(\"batch:stop\", _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, {\n            batchName: name\n        }));\n    },\n    hasActiveBatch: function(name) {\n        const batches = this._batches;\n        let names;\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [\n                name\n            ];\n        }\n        return names.some((batch)=>batches[batch] > 0);\n    }\n}, {\n    validations: {\n        multiLinks: function(graph, link) {\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n            if (source.id && target.id) {\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, {\n                        outbound: true\n                    });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n                    });\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n});\n(0,_util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrapWith)(Graph.prototype, [\n    \"resetCells\",\n    \"addCells\",\n    \"removeCells\"\n], _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrappers.cells);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0dyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ1U7QUFDTjtBQUVGO0FBQ007QUFDa0I7QUFDWDtBQUUvQyxNQUFNUSxhQUFhUixnREFBbUIsQ0FBQ1UsTUFBTSxDQUFDO0lBRTFDQyxZQUFZLFNBQVNDLE1BQU0sRUFBRUMsR0FBRztRQUU1QixrRUFBa0U7UUFDbEUsSUFBSUEsSUFBSUMsYUFBYSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsYUFBYSxHQUFHRCxJQUFJQyxhQUFhO1FBQzFDLE9BQU87WUFDSCwyQkFBMkIsR0FDM0IsSUFBSSxDQUFDQSxhQUFhLEdBQUcsT0FBT0MsVUFBVSxlQUFlZCxnREFBUSxDQUFDYyxPQUFPLFlBQVlBLE1BQU1FLE1BQU0sR0FBRztRQUNoRywwQkFBMEIsR0FDOUI7UUFHQSxJQUFJLENBQUNDLEtBQUssR0FBR0wsSUFBSUssS0FBSztJQUMxQjtJQUVBQyxPQUFPLFNBQVNDLEtBQUssRUFBRVAsR0FBRztRQUV0QixJQUFJUSxhQUFhUixJQUFJUSxVQUFVO1FBQy9CLElBQUlDLFlBQVlELFdBQVdQLGFBQWE7UUFFeEMsZ0VBQWdFO1FBQ2hFLElBQUlTLGFBQWEsTUFBT0MsSUFBSSxLQUFLLFNBQzNCckIsMkNBQUlBLEdBQ0pGLHNEQUFjLENBQUNxQixXQUFXRixNQUFNSSxJQUFJLEVBQUUsUUFBUXBCLGlEQUFPQTtRQUUzRCxJQUFJc0IsT0FBTyxJQUFJSCxXQUFXSCxPQUFPUDtRQUNqQyxtR0FBbUc7UUFDbkcsaUhBQWlIO1FBQ2pILElBQUksQ0FBQ0EsSUFBSWMsR0FBRyxFQUFFO1lBQ1ZELEtBQUtSLEtBQUssR0FBR0csV0FBV0gsS0FBSztRQUNqQztRQUVBLE9BQU9RO0lBQ1g7SUFFQSxxRUFBcUU7SUFDckVFLFlBQVksU0FBU1QsS0FBSztRQUV0QixPQUFPQSxNQUFNVSxHQUFHLENBQUMsUUFBUTtJQUM3QjtBQUNKO0FBR08sTUFB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QUFRQyxJQUFJLEtBQUsvTSxPQUFPK00sSUFBSTtvQkFFdkQ7b0JBRUEsSUFBSUosVUFBVXBMLE1BQU0sR0FBRyxHQUFHO3dCQUN0QixPQUFPO29CQUNYO2dCQUNKO1lBQ0o7WUFFQSxPQUFPO1FBQ1g7UUFFQXlMLGFBQWEsU0FBU0MsTUFBTSxFQUFFOU0sSUFBSTtZQUM5QixJQUFJLEVBQUVKLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdHLEtBQUtGLFVBQVU7WUFDeEMsT0FBT0YsT0FBT0QsRUFBRSxJQUFJRSxPQUFPRixFQUFFO1FBQ2pDO0lBQ0o7QUFFSixHQUFHO0FBRUgvQyw0REFBUUEsQ0FBQ3dCLE1BQU1JLFNBQVMsRUFBRTtJQUFDO0lBQWM7SUFBWTtDQUFjLEVBQUU3Qix3REFBUUEsQ0FBQzJCLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvR3JhcGgubWpzP2QwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhY2tib25lIGZyb20gJ2JhY2tib25lJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL0xpbmsubWpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuL0VsZW1lbnQubWpzJztcbmltcG9ydCB7IHdyYXBwZXJzLCB3cmFwV2l0aCB9IGZyb20gJy4uL3V0aWwvd3JhcHBlcnMubWpzJztcbmltcG9ydCB7IGNsb25lQ2VsbHMgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmNvbnN0IEdyYXBoQ2VsbHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIFNldCB0aGUgb3B0aW9uYWwgbmFtZXNwYWNlIHdoZXJlIGFsbCBtb2RlbCBjbGFzc2VzIGFyZSBkZWZpbmVkLlxuICAgICAgICBpZiAob3B0LmNlbGxOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbE5hbWVzcGFjZSA9IG9wdC5jZWxsTmFtZXNwYWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgICAgIHRoaXMuY2VsbE5hbWVzcGFjZSA9IHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgdXRpbC5oYXMoam9pbnQsICdzaGFwZXMnKSA/IGpvaW50LnNoYXBlcyA6IG51bGw7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuZ3JhcGggPSBvcHQuZ3JhcGg7XG4gICAgfSxcblxuICAgIG1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0KSB7XG5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBvcHQuY29sbGVjdGlvbjtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGNvbGxlY3Rpb24uY2VsbE5hbWVzcGFjZTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBtb2RlbCBjbGFzcyBpbiB0aGUgbmFtZXNwYWNlIG9yIHVzZSB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICAgIHZhciBNb2RlbENsYXNzID0gKGF0dHJzLnR5cGUgPT09ICdsaW5rJylcbiAgICAgICAgICAgID8gTGlua1xuICAgICAgICAgICAgOiB1dGlsLmdldEJ5UGF0aChuYW1lc3BhY2UsIGF0dHJzLnR5cGUsICcuJykgfHwgRWxlbWVudDtcblxuICAgICAgICB2YXIgY2VsbCA9IG5ldyBNb2RlbENsYXNzKGF0dHJzLCBvcHQpO1xuICAgICAgICAvLyBBZGQgYSByZWZlcmVuY2UgdG8gdGhlIGdyYXBoLiBJdCBpcyBuZWNlc3NhcnkgdG8gZG8gdGhpcyBoZXJlIGJlY2F1c2UgdGhpcyBpcyB0aGUgZWFybGllc3QgcGxhY2VcbiAgICAgICAgLy8gd2hlcmUgYSBuZXcgbW9kZWwgaXMgY3JlYXRlZCBmcm9tIGEgcGxhaW4gSlMgb2JqZWN0LiBGb3Igb3RoZXIgb2JqZWN0cywgc2VlIGBqb2ludC5kaWEuR3JhcGg+Pl9wcmVwYXJlQ2VsbCgpYC5cbiAgICAgICAgaWYgKCFvcHQuZHJ5KSB7XG4gICAgICAgICAgICBjZWxsLmdyYXBoID0gY29sbGVjdGlvbi5ncmFwaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvLyBgY29tcGFyYXRvcmAgbWFrZXMgaXQgZWFzeSB0byBzb3J0IGNlbGxzIGJhc2VkIG9uIHRoZWlyIGB6YCBpbmRleC5cbiAgICBjb21wYXJhdG9yOiBmdW5jdGlvbihtb2RlbCkge1xuXG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQoJ3onKSB8fCAwO1xuICAgIH1cbn0pO1xuXG5cbmV4cG9ydCBjb25zdCBHcmFwaCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIC8vIFBhc3NpbmcgYGNlbGxNb2RlbGAgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIGdyYXBoIGFsbG93cyBmb3JcbiAgICAgICAgLy8gc2V0dGluZyBtb2RlbHMgYmFzZWQgb24gYXR0cmlidXRlIG9iamVjdHMuIFRoaXMgaXMgZXNwZWNpYWxseSBoYW5keVxuICAgICAgICAvLyB3aGVuIHByb2Nlc3NpbmcgSlNPTiBncmFwaHMgdGhhdCBhcmUgaW4gYSBkaWZmZXJlbnQgdGhhbiBKb2ludEpTIGZvcm1hdC5cbiAgICAgICAgdmFyIGNlbGxzID0gbmV3IEdyYXBoQ2VsbHMoW10sIHtcbiAgICAgICAgICAgIG1vZGVsOiBvcHQuY2VsbE1vZGVsLFxuICAgICAgICAgICAgY2VsbE5hbWVzcGFjZTogb3B0LmNlbGxOYW1lc3BhY2UsXG4gICAgICAgICAgICBncmFwaDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsICdjZWxscycsIGNlbGxzKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCB0aGUgZXZlbnRzIGZpcmVkIGluIHRoZSBgY2VsbHNgIGNvbGxlY3Rpb24gYXZhaWxhYmxlLlxuICAgICAgICAvLyB0byB0aGUgb3V0c2lkZSB3b3JsZC5cbiAgICAgICAgY2VsbHMub24oJ2FsbCcsIHRoaXMudHJpZ2dlciwgdGhpcyk7XG5cbiAgICAgICAgLy8gQmFja2JvbmUgYXV0b21hdGljYWxseSBkb2Vzbid0IHRyaWdnZXIgcmUtc29ydCBpZiBtb2RlbHMgYXR0cmlidXRlcyBhcmUgY2hhbmdlZCBsYXRlciB3aGVuXG4gICAgICAgIC8vIHRoZXkncmUgYWxyZWFkeSBpbiB0aGUgY29sbGVjdGlvbi4gVGhlcmVmb3JlLCB3ZSdyZSB0cmlnZ2VyaW5nIHNvcnQgbWFudWFsbHkgaGVyZS5cbiAgICAgICAgdGhpcy5vbignY2hhbmdlOnonLCB0aGlzLl9zb3J0T25DaGFuZ2VaLCB0aGlzKTtcblxuICAgICAgICAvLyBgam9pbnQuZGlhLkdyYXBoYCBrZWVwcyBhbiBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSAoYW4gYWRqYWNlbmN5IGxpc3QpXG4gICAgICAgIC8vIGZvciBmYXN0IGdyYXBoIHF1ZXJpZXMuIEFsbCBjaGFuZ2VzIHRoYXQgYWZmZWN0IHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyYXBoXG4gICAgICAgIC8vIG11c3QgYmUgcmVmbGVjdGVkIGluIHRoZSBgYWxgIG9iamVjdC4gVGhpcyBvYmplY3QgcHJvdmlkZXMgZmFzdCBhbnN3ZXJzIHRvXG4gICAgICAgIC8vIHF1ZXN0aW9ucyBzdWNoIGFzIFwid2hhdCBhcmUgdGhlIG5laWdoYm91cnMgb2YgdGhpcyBub2RlXCIgb3IgXCJ3aGF0XG4gICAgICAgIC8vIGFyZSB0aGUgc2libGluZyBsaW5rcyBvZiB0aGlzIGxpbmtcIi5cblxuICAgICAgICAvLyBPdXRnb2luZyBlZGdlcyBwZXIgbm9kZS4gTm90ZSB0aGF0IHdlIHVzZSBhIGhhc2gtdGFibGUgZm9yIHRoZSBsaXN0XG4gICAgICAgIC8vIG9mIG91dGdvaW5nIGVkZ2VzIGZvciBhIGZhc3RlciBsb29rdXAuXG4gICAgICAgIC8vIFtub2RlSWRdIC0+IE9iamVjdCBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX291dCA9IHt9O1xuICAgICAgICAvLyBJbmdvaW5nIGVkZ2VzIHBlciBub2RlLlxuICAgICAgICAvLyBbbm9kZUlkXSAtPiBPYmplY3QgW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgICAgICB0aGlzLl9pbiA9IHt9O1xuICAgICAgICAvLyBgX25vZGVzYCBpcyB1c2VmdWwgZm9yIHF1aWNrIGxvb2t1cCBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBncmFwaCwgd2l0aG91dFxuICAgICAgICAvLyBoYXZpbmcgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgY2VsbHMgYXJyYXkuXG4gICAgICAgIC8vIFtub2RlIElEXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX25vZGVzID0ge307XG4gICAgICAgIC8vIGBfZWRnZXNgIGlzIHVzZWZ1bCBmb3IgcXVpY2sgbG9va3VwIG9mIGFsbCB0aGUgbGlua3MgaW4gdGhlIGdyYXBoLCB3aXRob3V0XG4gICAgICAgIC8vIGhhdmluZyB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSBjZWxscyBhcnJheS5cbiAgICAgICAgLy8gW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgICAgICB0aGlzLl9lZGdlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2JhdGNoZXMgPSB7fTtcblxuICAgICAgICBjZWxscy5vbignYWRkJywgdGhpcy5fcmVzdHJ1Y3R1cmVPbkFkZCwgdGhpcyk7XG4gICAgICAgIGNlbGxzLm9uKCdyZW1vdmUnLCB0aGlzLl9yZXN0cnVjdHVyZU9uUmVtb3ZlLCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ3Jlc2V0JywgdGhpcy5fcmVzdHJ1Y3R1cmVPblJlc2V0LCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ2NoYW5nZTpzb3VyY2UnLCB0aGlzLl9yZXN0cnVjdHVyZU9uQ2hhbmdlU291cmNlLCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ2NoYW5nZTp0YXJnZXQnLCB0aGlzLl9yZXN0cnVjdHVyZU9uQ2hhbmdlVGFyZ2V0LCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ3JlbW92ZScsIHRoaXMuX3JlbW92ZUNlbGwsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfc29ydE9uQ2hhbmdlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5nZXQoJ2NlbGxzJykuc29ydCgpO1xuICAgIH0sXG5cbiAgICBfcmVzdHJ1Y3R1cmVPbkFkZDogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIGlmIChjZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGdlc1tjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gY2VsbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCkge1xuICAgICAgICAgICAgICAgICh0aGlzLl9vdXRbc291cmNlLmlkXSB8fCAodGhpcy5fb3V0W3NvdXJjZS5pZF0gPSB7fSkpW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICAodGhpcy5faW5bdGFyZ2V0LmlkXSB8fCAodGhpcy5faW5bdGFyZ2V0LmlkXSA9IHt9KSlbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uUmVtb3ZlOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lZGdlc1tjZWxsLmlkXTtcbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBjZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmIHRoaXMuX291dFtzb3VyY2UuaWRdICYmIHRoaXMuX291dFtzb3VyY2UuaWRdW2NlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX291dFtzb3VyY2UuaWRdW2NlbGwuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCAmJiB0aGlzLl9pblt0YXJnZXQuaWRdICYmIHRoaXMuX2luW3RhcmdldC5pZF1bY2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faW5bdGFyZ2V0LmlkXVtjZWxsLmlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ub2Rlc1tjZWxsLmlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVzdHJ1Y3R1cmVPblJlc2V0OiBmdW5jdGlvbihjZWxscykge1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBpbnRvIGFuIGFycmF5IG9mIGNlbGxzLiBUaGUgb3JpZ2luYWwgYGNlbGxzYCBpcyBHcmFwaENlbGxzIEJhY2tib25lIGNvbGxlY3Rpb24uXG4gICAgICAgIGNlbGxzID0gY2VsbHMubW9kZWxzO1xuXG4gICAgICAgIHRoaXMuX291dCA9IHt9O1xuICAgICAgICB0aGlzLl9pbiA9IHt9O1xuICAgICAgICB0aGlzLl9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLl9lZGdlcyA9IHt9O1xuXG4gICAgICAgIGNlbGxzLmZvckVhY2godGhpcy5fcmVzdHJ1Y3R1cmVPbkFkZCwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uQ2hhbmdlU291cmNlOiBmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgdmFyIHByZXZTb3VyY2UgPSBsaW5rLnByZXZpb3VzKCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKHByZXZTb3VyY2UuaWQgJiYgdGhpcy5fb3V0W3ByZXZTb3VyY2UuaWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3V0W3ByZXZTb3VyY2UuaWRdW2xpbmsuaWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBsaW5rLmF0dHJpYnV0ZXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLmlkKSB7XG4gICAgICAgICAgICAodGhpcy5fb3V0W3NvdXJjZS5pZF0gfHwgKHRoaXMuX291dFtzb3VyY2UuaWRdID0ge30pKVtsaW5rLmlkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Jlc3RydWN0dXJlT25DaGFuZ2VUYXJnZXQ6IGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICB2YXIgcHJldlRhcmdldCA9IGxpbmsucHJldmlvdXMoJ3RhcmdldCcpO1xuICAgICAgICBpZiAocHJldlRhcmdldC5pZCAmJiB0aGlzLl9pbltwcmV2VGFyZ2V0LmlkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luW3ByZXZUYXJnZXQuaWRdW2xpbmsuaWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXQgPSBsaW5rLmdldCgndGFyZ2V0Jyk7XG4gICAgICAgIGlmICh0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICh0aGlzLl9pblt0YXJnZXQuaWRdIHx8ICh0aGlzLl9pblt0YXJnZXQuaWRdID0ge30pKVtsaW5rLmlkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFsbCBvdXRib3VuZCBlZGdlcyBmb3IgdGhlIG5vZGUuIFJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICAvLyBvZiB0aGUgZm9ybTogW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgIGdldE91dGJvdW5kRWRnZXM6IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX291dCAmJiB0aGlzLl9vdXRbbm9kZV0pIHx8IHt9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYWxsIGluYm91bmQgZWRnZXMgZm9yIHRoZSBub2RlLiBSZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgLy8gb2YgdGhlIGZvcm06IFtlZGdlSWRdIC0+IHRydWVcbiAgICBnZXRJbmJvdW5kRWRnZXM6IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX2luICYmIHRoaXMuX2luW25vZGVdKSB8fCB7fTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBCYWNrYm9uZSBkb2VzIG5vdCByZWN1cnNpdmVseSBjYWxsIGB0b0pTT04oKWAgb24gYXR0cmlidXRlcyB0aGF0IGFyZSB0aGVtc2VsdmVzIG1vZGVscy9jb2xsZWN0aW9ucy5cbiAgICAgICAgLy8gSXQganVzdCBjbG9uZXMgdGhlIGF0dHJpYnV0ZXMuIFRoZXJlZm9yZSwgd2UgbXVzdCBjYWxsIGB0b0pTT04oKWAgb24gdGhlIGNlbGxzIGNvbGxlY3Rpb24gZXhwbGljaXRseS5cbiAgICAgICAgdmFyIGpzb24gPSBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUudG9KU09OLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGpzb24uY2VsbHMgPSB0aGlzLmdldCgnY2VsbHMnKS50b0pTT04oKTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uLCBvcHQpIHtcblxuICAgICAgICBpZiAoIWpzb24uY2VsbHMpIHtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmFwaCBKU09OIG11c3QgY29udGFpbiBjZWxscyBhcnJheS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldChqc29uLCBvcHQpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHQpIHtcblxuICAgICAgICB2YXIgYXR0cnM7XG5cbiAgICAgICAgLy8gSGFuZGxlIGJvdGggYGtleWAsIHZhbHVlIGFuZCB7a2V5OiB2YWx1ZX0gc3R5bGUgYXJndW1lbnRzLlxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICAgICAgb3B0ID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBgY2VsbHNgIGF0dHJpYnV0ZSBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgdmlhIHJlc2V0Q2VsbHMoKS5cbiAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KCdjZWxscycpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q2VsbHMoYXR0cnMuY2VsbHMsIG9wdCk7XG4gICAgICAgICAgICBhdHRycyA9IHV0aWwub21pdChhdHRycywgJ2NlbGxzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgYXR0cmlidXRlcyBhcmUgYXBwbGllZCB2aWEgb3JpZ2luYWwgc2V0IG1ldGhvZC5cbiAgICAgICAgcmV0dXJuIEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5zZXQuY2FsbCh0aGlzLCBhdHRycywgb3B0KTtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IHV0aWwuYXNzaWduKHt9LCBvcHQsIHsgY2xlYXI6IHRydWUgfSk7XG5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmdldCgnY2VsbHMnKTtcblxuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgnY2xlYXInLCBvcHQpO1xuXG4gICAgICAgIC8vIFRoZSBlbGVtZW50cyBjb21lIGFmdGVyIHRoZSBsaW5rcy5cbiAgICAgICAgdmFyIGNlbGxzID0gY29sbGVjdGlvbi5zb3J0QnkoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuaXNMaW5rKCkgPyAxIDogMjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIHRoZSBjZWxscyBvbmUgYnkgb25lLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFsbCB0aGUgbGlua3MgYXJlIHJlbW92ZWQgZmlyc3QsIHNvIGl0J3NcbiAgICAgICAgICAgIC8vIHNhZmUgdG8gcmVtb3ZlIHRoZSBlbGVtZW50cyB3aXRob3V0IHJlbW92aW5nIHRoZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIC8vIGxpbmtzIGZpcnN0LlxuICAgICAgICAgICAgY2VsbHMuc2hpZnQoKS5yZW1vdmUob3B0KTtcblxuICAgICAgICB9IHdoaWxlIChjZWxscy5sZW5ndGggPiAwKTtcblxuICAgICAgICB0aGlzLnN0b3BCYXRjaCgnY2xlYXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVDZWxsOiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcblxuICAgICAgICB2YXIgYXR0cnM7XG4gICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpIHtcbiAgICAgICAgICAgIGF0dHJzID0gY2VsbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKCFjZWxsLmdyYXBoICYmICghb3B0IHx8ICFvcHQuZHJ5KSkge1xuICAgICAgICAgICAgICAgIC8vIEFuIGVsZW1lbnQgY2FuIG5vdCBiZSBtZW1iZXIgb2YgbW9yZSB0aGFuIG9uZSBncmFwaC5cbiAgICAgICAgICAgICAgICAvLyBBIGNlbGwgc3RvcHMgYmVpbmcgdGhlIG1lbWJlciBvZiB0aGUgZ3JhcGggYWZ0ZXIgaXQncyBleHBsaWNpdGx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY2VsbC5ncmFwaCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBsYWluIEpTIG9iamVjdCwgd2UgaGF2ZSB0byBzZXQgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gdGhlIGBncmFwaGAgcmlnaHQgYWZ0ZXIgdGhlIGFjdHVhbCBtb2RlbCBpcyBjcmVhdGVkLiBUaGlzIGhhcHBlbnMgaW4gdGhlIGBtb2RlbCgpYCBmdW5jdGlvblxuICAgICAgICAgICAgLy8gb2YgYGpvaW50LmRpYS5HcmFwaENlbGxzYC5cbiAgICAgICAgICAgIGF0dHJzID0gY2VsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhhdHRycy50eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLkdyYXBoOiBjZWxsIHR5cGUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICBtaW5aSW5kZXg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBmaXJzdENlbGwgPSB0aGlzLmdldCgnY2VsbHMnKS5maXJzdCgpO1xuICAgICAgICByZXR1cm4gZmlyc3RDZWxsID8gKGZpcnN0Q2VsbC5nZXQoJ3onKSB8fCAwKSA6IDA7XG4gICAgfSxcblxuICAgIG1heFpJbmRleDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGxhc3RDZWxsID0gdGhpcy5nZXQoJ2NlbGxzJykubGFzdCgpO1xuICAgICAgICByZXR1cm4gbGFzdENlbGwgPyAobGFzdENlbGwuZ2V0KCd6JykgfHwgMCkgOiAwO1xuICAgIH0sXG5cbiAgICBhZGRDZWxsOiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjZWxsKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDZWxscyhjZWxsLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuXG4gICAgICAgICAgICBpZiAoIWNlbGwuaGFzKCd6JykpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnNldCgneicsIHRoaXMubWF4WkluZGV4KCkgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGNlbGwueiA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGNlbGwueiA9IHRoaXMubWF4WkluZGV4KCkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXQoJ2NlbGxzJykuYWRkKHRoaXMuX3ByZXBhcmVDZWxsKGNlbGwsIG9wdCksIG9wdCB8fCB7fSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZENlbGxzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG5cbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgY2VsbHMgPSB1dGlsLmZsYXR0ZW5EZWVwKGNlbGxzKTtcbiAgICAgICAgb3B0Lm1heFBvc2l0aW9uID0gb3B0LnBvc2l0aW9uID0gY2VsbHMubGVuZ3RoIC0gMTtcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ2FkZCcsIG9wdCk7XG4gICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGRDZWxsKGNlbGwsIG9wdCk7XG4gICAgICAgICAgICBvcHQucG9zaXRpb24tLTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdhZGQnLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIGFkZGluZyBhIGxvdCBvZiBjZWxscywgaXQgaXMgbXVjaCBtb3JlIGVmZmljaWVudCB0b1xuICAgIC8vIHJlc2V0IHRoZSBlbnRpcmUgY2VsbHMgY29sbGVjdGlvbiBpbiBvbmUgZ28uXG4gICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gICAgcmVzZXRDZWxsczogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuXG4gICAgICAgIHZhciBwcmVwYXJlZENlbGxzID0gdXRpbC50b0FycmF5KGNlbGxzKS5tYXAoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVDZWxsKGNlbGwsIG9wdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLmdldCgnY2VsbHMnKS5yZXNldChwcmVwYXJlZENlbGxzLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVDZWxsczogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuXG4gICAgICAgIGlmIChjZWxscy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdyZW1vdmUnKTtcbiAgICAgICAgICAgIHV0aWwuaW52b2tlKGNlbGxzLCAncmVtb3ZlJywgb3B0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCdyZW1vdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlQ2VsbDogZnVuY3Rpb24oY2VsbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgLy8gQXBwbGljYXRpb25zIG1pZ2h0IHByb3ZpZGUgYSBgZGlzY29ubmVjdExpbmtzYCBvcHRpb24gc2V0IHRvIGB0cnVlYCBpbiBvcmRlciB0b1xuICAgICAgICAgICAgLy8gZGlzY29ubmVjdCBsaW5rcyB3aGVuIGEgY2VsbCBpcyByZW1vdmVkIHJhdGhlciB0aGVuIHJlbW92aW5nIHRoZW0uIFRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBpcyB0byByZW1vdmUgYWxsIHRoZSBhc3NvY2lhdGVkIGxpbmtzLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzY29ubmVjdExpbmtzKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaW5rcyhjZWxsLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlua3MoY2VsbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lsZW50bHkgcmVtb3ZlIHRoZSBjZWxsIGZyb20gdGhlIGNlbGxzIGNvbGxlY3Rpb24uIFNpbGVudGx5LCBiZWNhdXNlXG4gICAgICAgIC8vIGBqb2ludC5kaWEuQ2VsbC5wcm90b3R5cGUucmVtb3ZlYCBhbHJlYWR5IHRyaWdnZXJzIHRoZSBgcmVtb3ZlYCBldmVudCB3aGljaCBpc1xuICAgICAgICAvLyB0aGVuIHByb3BhZ2F0ZWQgdG8gdGhlIGdyYXBoIG1vZGVsLiBJZiB3ZSBkaWRuJ3QgcmVtb3ZlIHRoZSBjZWxsIHNpbGVudGx5LCB0d28gYHJlbW92ZWAgZXZlbnRzXG4gICAgICAgIC8vIHdvdWxkIGJlIHRyaWdnZXJlZCBvbiB0aGUgZ3JhcGggbW9kZWwuXG4gICAgICAgIHRoaXMuZ2V0KCdjZWxscycpLnJlbW92ZShjZWxsLCB7IHNpbGVudDogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAoY2VsbC5ncmFwaCA9PT0gdGhpcykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGdyYXBoIHJlZmVyZW5jZSBvbmx5IGlmIHRoZSBjZWxsIGlzIHRoZSBtZW1iZXIgb2YgdGhpcyBncmFwaC5cbiAgICAgICAgICAgIGNlbGwuZ3JhcGggPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhIGNlbGwgYnkgYGlkYC5cbiAgICBnZXRDZWxsOiBmdW5jdGlvbihpZCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS5nZXQoaWQpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjZWxscycpLnRvQXJyYXkoKTtcbiAgICB9LFxuXG4gICAgZ2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzRWxlbWVudCgpKTtcbiAgICB9LFxuXG4gICAgZ2V0TGlua3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzTGluaygpKTtcbiAgICB9LFxuXG4gICAgZ2V0Rmlyc3RDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykuZmlyc3QoKTtcbiAgICB9LFxuXG4gICAgZ2V0TGFzdENlbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS5sYXN0KCk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgaW5ib3VuZCBhbmQgb3V0Ym91bmQgbGlua3MgY29ubmVjdGVkIHRvIHRoZSBjZWxsIGBtb2RlbGAuXG4gICAgZ2V0Q29ubmVjdGVkTGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIGluZGlyZWN0ID0gb3B0LmluZGlyZWN0O1xuICAgICAgICB2YXIgaW5ib3VuZCA9IG9wdC5pbmJvdW5kO1xuICAgICAgICB2YXIgb3V0Ym91bmQgPSBvcHQub3V0Ym91bmQ7XG4gICAgICAgIGlmICgoaW5ib3VuZCA9PT0gdW5kZWZpbmVkKSAmJiAob3V0Ym91bmQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluYm91bmQgPSBvdXRib3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZmluYWwgYXJyYXkgb2YgY29ubmVjdGVkIGxpbmsgbW9kZWxzXG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICAvLyBhIGhhc2ggdGFibGUgb2YgY29ubmVjdGVkIGVkZ2VzIG9mIHRoZSBmb3JtOiBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIC8vIHVzZWQgZm9yIHF1aWNrIGxvb2t1cHMgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBhZGRlZCBhIGxpbmtcbiAgICAgICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgICBhZGRPdXRib3VuZHModGhpcywgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmJvdW5kKSB7XG4gICAgICAgICAgICBhZGRJbmJvdW5kcyh0aGlzLCBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRPdXRib3VuZHMoZ3JhcGgsIG1vZGVsKSB7XG4gICAgICAgICAgICB1dGlsLmZvckluKGdyYXBoLmdldE91dGJvdW5kRWRnZXMobW9kZWwuaWQpLCBmdW5jdGlvbihfLCBlZGdlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBsaW5rcyB0aGF0IHdlcmUgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgIC8vICh0aG9zZSBtdXN0IGJlIHNlbGYtbG9vcCBsaW5rcylcbiAgICAgICAgICAgICAgICAvLyAoYmVjYXVzZSB0aGV5IGFyZSBpbmJvdW5kIGFuZCBvdXRib3VuZCBlZGdlcyBvZiB0aGUgc2FtZSB0d28gZWxlbWVudHMpXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VdKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBncmFwaC5nZXRDZWxsKGVkZ2UpO1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgZWRnZXNbZWRnZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5ib3VuZCkgYWRkSW5ib3VuZHMoZ3JhcGgsIGxpbmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIGFkZE91dGJvdW5kcyhncmFwaCwgbGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKGdyYXBoKSk7XG4gICAgICAgICAgICBpZiAoaW5kaXJlY3QgJiYgbW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Q2VsbCA9IG1vZGVsLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0Q2VsbCAmJiBvdXRDZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbb3V0Q2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gob3V0Q2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPdXRib3VuZHMoZ3JhcGgsIG91dENlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkSW5ib3VuZHMoZ3JhcGgsIG1vZGVsKSB7XG4gICAgICAgICAgICB1dGlsLmZvckluKGdyYXBoLmdldEluYm91bmRFZGdlcyhtb2RlbC5pZCksIGZ1bmN0aW9uKF8sIGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGxpbmtzIHRoYXQgd2VyZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgLy8gKHRob3NlIG11c3QgYmUgc2VsZi1sb29wIGxpbmtzKVxuICAgICAgICAgICAgICAgIC8vIChiZWNhdXNlIHRoZXkgYXJlIGluYm91bmQgYW5kIG91dGJvdW5kIGVkZ2VzIG9mIHRoZSBzYW1lIHR3byBlbGVtZW50cylcbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbZWRnZV0pIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IGdyYXBoLmdldENlbGwoZWRnZSk7XG4gICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICBlZGdlc1tlZGdlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGluZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJvdW5kKSBhZGRJbmJvdW5kcyhncmFwaCwgbGluayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCkgYWRkT3V0Ym91bmRzKGdyYXBoLCBsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQoZ3JhcGgpKTtcbiAgICAgICAgICAgIGlmIChpbmRpcmVjdCAmJiBtb2RlbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbkNlbGwgPSBtb2RlbC5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKGluQ2VsbCAmJiBpbkNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlc1tpbkNlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGluQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmJvdW5kcyhncmFwaCwgaW5DZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGBkZWVwYCBvcHRpb24gaXMgYHRydWVgLCBjaGVjayBhbHNvIGFsbCB0aGUgbGlua3MgdGhhdCBhcmUgY29ubmVjdGVkIHRvIGFueSBvZiB0aGUgZGVzY2VuZGFudCBjZWxsc1xuICAgICAgICBpZiAob3B0LmRlZXApIHtcblxuICAgICAgICAgICAgdmFyIGVtYmVkZGVkQ2VsbHMgPSBtb2RlbC5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIGZpcnN0IHJvdW5kLCB3ZSBjb2xsZWN0IGFsbCB0aGUgZW1iZWRkZWQgZWxlbWVudHNcbiAgICAgICAgICAgIHZhciBlbWJlZGRlZEVsZW1lbnRzID0ge307XG4gICAgICAgICAgICBlbWJlZGRlZENlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYmVkZGVkRWxlbWVudHNbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbWJlZGRlZENlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzTGluaygpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZm9ySW4odGhpcy5nZXRPdXRib3VuZEVkZ2VzKGNlbGwuaWQpLCBmdW5jdGlvbihleGlzdHMsIGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbZWRnZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZUNlbGwgPSB0aGlzLmdldENlbGwoZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGVkZ2VDZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gc291cmNlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJZCA9IHRhcmdldC5pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGBpbmNsdWRlRW5jbG9zZWRgIG9wdGlvbiBpcyBmYWxzeSwgc2tpcCBlbmNsb3NlZCBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0LmluY2x1ZGVFbmNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc291cmNlSWQgJiYgZW1iZWRkZWRFbGVtZW50c1tzb3VyY2VJZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0YXJnZXRJZCAmJiBlbWJlZGRlZEVsZW1lbnRzW3RhcmdldElkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2godGhpcy5nZXRDZWxsKGVkZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tlZGdlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZm9ySW4odGhpcy5nZXRJbmJvdW5kRWRnZXMoY2VsbC5pZCksIGZ1bmN0aW9uKGV4aXN0cywgZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlc1tlZGdlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlQ2VsbCA9IHRoaXMuZ2V0Q2VsbChlZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gZWRnZUNlbGwuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldElkID0gdGFyZ2V0LmlkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYGluY2x1ZGVFbmNsb3NlZGAgb3B0aW9uIGlzIGZhbHN5LCBza2lwIGVuY2xvc2VkIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQuaW5jbHVkZUVuY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChzb3VyY2VJZCAmJiBlbWJlZGRlZEVsZW1lbnRzW3NvdXJjZUlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHRhcmdldElkICYmIGVtYmVkZGVkRWxlbWVudHNbdGFyZ2V0SWRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaCh0aGlzLmdldENlbGwoZWRnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2VkZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9LFxuXG4gICAgZ2V0TmVpZ2hib3JzOiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgdmFyIGluYm91bmQgPSBvcHQuaW5ib3VuZDtcbiAgICAgICAgdmFyIG91dGJvdW5kID0gb3B0Lm91dGJvdW5kO1xuICAgICAgICBpZiAoaW5ib3VuZCA9PT0gdW5kZWZpbmVkICYmIG91dGJvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluYm91bmQgPSBvdXRib3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCwgb3B0KS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBsaW5rKSB7XG5cbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB2YXIgbG9vcCA9IGxpbmsuaGFzTG9vcChvcHQpO1xuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIGl0IGlzIGEgcG9pbnQsIG9yIGlmIHRoZSBuZWlnaGJvciB3YXMgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChpbmJvdW5kICYmIHV0aWwuaGFzKHNvdXJjZSwgJ2lkJykgJiYgIXJlc1tzb3VyY2UuaWRdKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IHRoaXMuZ2V0Q2VsbChzb3VyY2UuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wIHx8IChzb3VyY2VFbGVtZW50ICYmIHNvdXJjZUVsZW1lbnQgIT09IG1vZGVsICYmICghb3B0LmRlZXAgfHwgIXNvdXJjZUVsZW1lbnQuaXNFbWJlZGRlZEluKG1vZGVsKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbc291cmNlLmlkXSA9IHNvdXJjZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgaXQgaXMgYSBwb2ludCwgb3IgaWYgdGhlIG5laWdoYm9yIHdhcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHV0aWwuaGFzKHRhcmdldCwgJ2lkJykgJiYgIXJlc1t0YXJnZXQuaWRdKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0Q2VsbCh0YXJnZXQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wIHx8ICh0YXJnZXRFbGVtZW50ICYmIHRhcmdldEVsZW1lbnQgIT09IG1vZGVsICYmICghb3B0LmRlZXAgfHwgIXRhcmdldEVsZW1lbnQuaXNFbWJlZGRlZEluKG1vZGVsKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbdGFyZ2V0LmlkXSA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0uYmluZCh0aGlzKSwge30pO1xuXG4gICAgICAgIGlmIChtb2RlbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgaWYgKGluYm91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ2VsbCA9IG1vZGVsLmdldFNvdXJjZUNlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlQ2VsbCAmJiBzb3VyY2VDZWxsLmlzRWxlbWVudCgpICYmICFuZWlnaGJvcnNbc291cmNlQ2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzW3NvdXJjZUNlbGwuaWRdID0gc291cmNlQ2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2VsbCA9IG1vZGVsLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbCAmJiB0YXJnZXRDZWxsLmlzRWxlbWVudCgpICYmICFuZWlnaGJvcnNbdGFyZ2V0Q2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzW3RhcmdldENlbGwuaWRdID0gdGFyZ2V0Q2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC50b0FycmF5KG5laWdoYm9ycyk7XG4gICAgfSxcblxuICAgIGdldENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbigvKiBjZWxscyAqLykge1xuXG4gICAgICAgIHZhciBjZWxsc0FuY2VzdG9ycyA9IEFycmF5LmZyb20oYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgICAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBjZWxsLmdldCgncGFyZW50Jyk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRJZCkge1xuXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudElkID0gdGhpcy5nZXRDZWxsKHBhcmVudElkKS5nZXQoJ3BhcmVudCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGNlbGxzQW5jZXN0b3JzID0gY2VsbHNBbmNlc3RvcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNvbW1vbkFuY2VzdG9yID0gdXRpbC50b0FycmF5KGNlbGxzQW5jZXN0b3JzLnNoaWZ0KCkpLmZpbmQoZnVuY3Rpb24oYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsc0FuY2VzdG9ycy5ldmVyeShmdW5jdGlvbihjZWxsQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxBbmNlc3RvcnMuaW5jbHVkZXMoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGwoY29tbW9uQW5jZXN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSB3aG9sZSBicmFuY2ggc3RhcnRpbmcgYXQgYGVsZW1lbnRgLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gSWYgYG9wdC5icmVhZHRoRmlyc3RgIGlzIGB0cnVlYCwgdXNlIHRoZSBCcmVhZHRoLWZpcnN0IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZSB1c2UgRGVwdGgtZmlyc3Qgc2VhcmNoLlxuICAgIGdldFN1Y2Nlc3NvcnM6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAvLyBNb2RpZnkgdGhlIG9wdGlvbnMgc28gdGhhdCBpdCBpbmNsdWRlcyB0aGUgYG91dGJvdW5kYCBuZWlnaGJvcnMgb25seS4gSW4gb3RoZXIgd29yZHMsIHNlYXJjaCBmb3J3YXJkcy5cbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXRpbC5hc3NpZ24oe30sIG9wdCwgeyBvdXRib3VuZDogdHJ1ZSB9KSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGNsb25lQ2VsbHM6IGNsb25lQ2VsbHMsXG4gICAgLy8gQ2xvbmUgdGhlIHdob2xlIHN1YmdyYXBoIChpbmNsdWRpbmcgYWxsIHRoZSBjb25uZWN0ZWQgbGlua3Mgd2hvc2Ugc291cmNlL3RhcmdldCBpcyBpbiB0aGUgc3ViZ3JhcGgpLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCBhbHNvIHRha2UgaW50byBhY2NvdW50IGFsbCB0aGUgZW1iZWRkZWQgY2VsbHMgb2YgYWxsIHRoZSBzdWJncmFwaCBjZWxscy5cbiAgICAvLyBSZXR1cm4gYSBtYXAgb2YgdGhlIGZvcm06IFtvcmlnaW5hbCBjZWxsIElEXSAtPiBbY2xvbmVdLlxuICAgIGNsb25lU3ViZ3JhcGg6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICB2YXIgc3ViZ3JhcGggPSB0aGlzLmdldFN1YmdyYXBoKGNlbGxzLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUNlbGxzKHN1YmdyYXBoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGBjZWxsc2AgYW5kIGFsbCB0aGUgY29ubmVjdGVkIGxpbmtzIHRoYXQgY29ubmVjdCBjZWxscyBpbiB0aGUgYGNlbGxzYCBhcnJheS5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgcmV0dXJuIGFsbCB0aGUgY2VsbHMgaW5jbHVkaW5nIGFsbCB0aGVpciBlbWJlZGRlZCBjZWxsc1xuICAgIC8vIGFuZCBhbGwgdGhlIGxpbmtzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIHJldHVybmVkIGNlbGxzLlxuICAgIC8vIEZvciBleGFtcGxlLCBmb3IgYSBzaW5nbGUgc2hhbGxvdyBlbGVtZW50LCB0aGUgcmVzdWx0IGlzIHRoYXQgdmVyeSBzYW1lIGVsZW1lbnQuXG4gICAgLy8gRm9yIHR3byBlbGVtZW50cyBjb25uZWN0ZWQgd2l0aCBhIGxpbms6IGBBIC0tLSBMIC0tLT4gQmAsIHRoZSByZXN1bHQgZm9yXG4gICAgLy8gYGdldFN1YmdyYXBoKFtBLCBCXSlgIGlzIGBbQSwgTCwgQl1gLiBUaGUgc2FtZSBnb2VzIGZvciBgZ2V0U3ViZ3JhcGgoW0xdKWAsIHRoZSByZXN1bHQgaXMgYWdhaW4gYFtBLCBMLCBCXWAuXG4gICAgZ2V0U3ViZ3JhcGg6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHN1YmdyYXBoID0gW107XG4gICAgICAgIC8vIGBjZWxsTWFwYCBpcyB1c2VkIGZvciBhIHF1aWNrIGxvb2t1cCBvZiBleGlzdGVuY2Ugb2YgYSBjZWxsIGluIHRoZSBgY2VsbHNgIGFycmF5LlxuICAgICAgICB2YXIgY2VsbE1hcCA9IHt9O1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmtzID0gW107XG5cbiAgICAgICAgdXRpbC50b0FycmF5KGNlbGxzKS5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIGlmICghY2VsbE1hcFtjZWxsLmlkXSkge1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgY2VsbE1hcFtjZWxsLmlkXSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtYmVkcyA9IGNlbGwuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZW1iZWRzLmZvckVhY2goZnVuY3Rpb24oZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsTWFwW2VtYmVkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChlbWJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWFwW2VtYmVkLmlkXSA9IGVtYmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYmVkLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChlbWJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZW1iZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgLy8gRm9yIGxpbmtzLCByZXR1cm4gdGhlaXIgc291cmNlICYgdGFyZ2V0IChpZiB0aGV5IGFyZSBlbGVtZW50cyAtIG5vdCBwb2ludHMpLlxuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgJiYgIWNlbGxNYXBbc291cmNlLmlkXSkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gdGhpcy5nZXRDZWxsKHNvdXJjZS5pZCk7XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjZWxsTWFwW3NvdXJjZUVsZW1lbnQuaWRdID0gc291cmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCAmJiAhY2VsbE1hcFt0YXJnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldENlbGwodGFyZ2V0LmlkKTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5wdXNoKHRoaXMuZ2V0Q2VsbCh0YXJnZXQuaWQpKTtcbiAgICAgICAgICAgICAgICBjZWxsTWFwW3RhcmdldEVsZW1lbnQuaWRdID0gdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEZvciBlbGVtZW50cywgaW5jbHVkZSB0aGVpciBjb25uZWN0ZWQgbGlua3MgaWYgdGhlaXIgc291cmNlL3RhcmdldCBpcyBpbiB0aGUgc3ViZ3JhcGg7XG4gICAgICAgICAgICB2YXIgbGlua3MgPSB0aGlzLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIG9wdCk7XG4gICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbE1hcFtsaW5rLmlkXSAmJiBzb3VyY2UuaWQgJiYgY2VsbE1hcFtzb3VyY2UuaWRdICYmIHRhcmdldC5pZCAmJiBjZWxsTWFwW3RhcmdldC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbE1hcFtsaW5rLmlkXSA9IGxpbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBzdWJncmFwaDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgdGhlIHByZWRlY2Vzc29ycyBvZiBgZWxlbWVudGAuIFRoaXMgaXMgYSByZXZlcnNlIG9wZXJhdGlvbiBvZiBgZ2V0U3VjY2Vzc29ycygpYC5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgdG9vLlxuICAgIC8vIElmIGBvcHQuYnJlYWR0aEZpcnN0YCBpcyBgdHJ1ZWAsIHVzZSB0aGUgQnJlYWR0aC1maXJzdCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2UgdXNlIERlcHRoLWZpcnN0IHNlYXJjaC5cbiAgICBnZXRQcmVkZWNlc3NvcnM6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAvLyBNb2RpZnkgdGhlIG9wdGlvbnMgc28gdGhhdCBpdCBpbmNsdWRlcyB0aGUgYGluYm91bmRgIG5laWdoYm9ycyBvbmx5LiBJbiBvdGhlciB3b3Jkcywgc2VhcmNoIGJhY2t3YXJkcy5cbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXRpbC5hc3NpZ24oe30sIG9wdCwgeyBpbmJvdW5kOiB0cnVlIH0pKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgLy8gUGVyZm9ybSBzZWFyY2ggb24gdGhlIGdyYXBoLlxuICAgIC8vIElmIGBvcHQuYnJlYWR0aEZpcnN0YCBpcyBgdHJ1ZWAsIHVzZSB0aGUgQnJlYWR0aC1maXJzdCBTZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2UgdXNlIERlcHRoLWZpcnN0IHNlYXJjaC5cbiAgICAvLyBCeSBzZXR0aW5nIGBvcHQuaW5ib3VuZGAgdG8gYHRydWVgLCB5b3UgY2FuIHJldmVyc2UgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VhcmNoLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gYGl0ZXJhdGVlYCBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBmb3JtIGBmdW5jdGlvbihlbGVtZW50KSB7fWAuXG4gICAgLy8gSWYgYGl0ZXJhdGVlYCBleHBsaWNpdGx5IHJldHVybnMgYGZhbHNlYCwgdGhlIHNlYXJjaGluZyBzdG9wcy5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGVsZW1lbnQsIGl0ZXJhdGVlLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIGlmIChvcHQuYnJlYWR0aEZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmJmcyhlbGVtZW50LCBpdGVyYXRlZSwgb3B0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGZzKGVsZW1lbnQsIGl0ZXJhdGVlLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJyZWFkdGgtZmlyc3Qgc2VhcmNoLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gSWYgYG9wdC5pbmJvdW5kYCBpcyBgdHJ1ZWAsIHJldmVyc2UgdGhlIHNlYXJjaCBkaXJlY3Rpb24gKGl0J3MgbGlrZSByZXZlcnNpbmcgYWxsIHRoZSBsaW5rIGRpcmVjdGlvbnMpLlxuICAgIC8vIGBpdGVyYXRlZWAgaXMgYSBmdW5jdGlvbiBvZiB0aGUgZm9ybSBgZnVuY3Rpb24oZWxlbWVudCwgZGlzdGFuY2UpIHt9YC5cbiAgICAvLyB3aGVyZSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnRseSB2aXNpdGVkIGVsZW1lbnQgYW5kIGBkaXN0YW5jZWAgaXMgdGhlIGRpc3RhbmNlIG9mIHRoYXQgZWxlbWVudFxuICAgIC8vIGZyb20gdGhlIHJvb3QgYGVsZW1lbnRgIHBhc3NlZCB0aGUgYGJmcygpYCwgaS5lLiB0aGUgZWxlbWVudCB3ZSBzdGFydGVkIHRoZSBzZWFyY2ggZnJvbS5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGBkaXN0YW5jZWAgaXMgbm90IHRoZSBzaG9ydGVzdCBvciBsb25nZXN0IGRpc3RhbmNlLCBpdCBpcyBzaW1wbHkgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAgICAvLyBjcm9zc2VkIHRpbGwgd2UgdmlzaXRlZCB0aGUgYGVsZW1lbnRgIGZvciB0aGUgZmlyc3QgdGltZS4gSXQgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIHRyZWUgZ3JhcGhzLlxuICAgIC8vIElmIGBpdGVyYXRlZWAgZXhwbGljaXRseSByZXR1cm5zIGBmYWxzZWAsIHRoZSBzZWFyY2hpbmcgc3RvcHMuXG4gICAgYmZzOiBmdW5jdGlvbihlbGVtZW50LCBpdGVyYXRlZSwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG5cbiAgICAgICAgcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgZGlzdGFuY2VbZWxlbWVudC5pZF0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtuZXh0LmlkXSkgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkW25leHQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRlZS5jYWxsKHRoaXMsIG5leHQsIGRpc3RhbmNlW25leHQuaWRdKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMobmV4dCwgb3B0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlW25laWdoYm9yLmlkXSA9IGRpc3RhbmNlW25leHQuaWRdICsgMTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEZXB0aC1maXJzdCBzZWFyY2guXG4gICAgLy8gSWYgYG9wdC5kZWVwYCBpcyBgdHJ1ZWAsIHRha2UgaW50byBhY2NvdW50IGVtYmVkZGVkIGVsZW1lbnRzIHRvby5cbiAgICAvLyBJZiBgb3B0LmluYm91bmRgIGlzIGB0cnVlYCwgcmV2ZXJzZSB0aGUgc2VhcmNoIGRpcmVjdGlvbiAoaXQncyBsaWtlIHJldmVyc2luZyBhbGwgdGhlIGxpbmsgZGlyZWN0aW9ucykuXG4gICAgLy8gYGl0ZXJhdGVlYCBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBmb3JtIGBmdW5jdGlvbihlbGVtZW50LCBkaXN0YW5jZSkge31gLlxuICAgIC8vIElmIGBpdGVyYXRlZWAgZXhwbGljaXRseSByZXR1cm5zIGBmYWxzZWAsIHRoZSBzZWFyY2ggc3RvcHMuXG4gICAgZGZzOiBmdW5jdGlvbihlbGVtZW50LCBpdGVyYXRlZSwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG5cbiAgICAgICAgcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgZGlzdGFuY2VbZWxlbWVudC5pZF0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtuZXh0LmlkXSkgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkW25leHQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRlZS5jYWxsKHRoaXMsIG5leHQsIGRpc3RhbmNlW25leHQuaWRdKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMobmV4dCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlW25laWdoYm9yLmlkXSA9IGRpc3RhbmNlW25leHQuaWRdICsgMTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5zcGxpY2UobGFzdEluZGV4LCAwLCBuZWlnaGJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCB0aGUgcm9vdHMgb2YgdGhlIGdyYXBoLiBUaW1lIGNvbXBsZXhpdHk6IE8ofFZ8KS5cbiAgICBnZXRTb3VyY2VzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICB1dGlsLmZvckluKHRoaXMuX25vZGVzLCBmdW5jdGlvbihleGlzdHMsIG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5bbm9kZV0gfHwgdXRpbC5pc0VtcHR5KHRoaXMuX2luW25vZGVdKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLmdldENlbGwobm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gc291cmNlcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCB0aGUgbGVhZnMgb2YgdGhlIGdyYXBoLiBUaW1lIGNvbXBsZXhpdHk6IE8ofFZ8KS5cbiAgICBnZXRTaW5rczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNpbmtzID0gW107XG4gICAgICAgIHV0aWwuZm9ySW4odGhpcy5fbm9kZXMsIGZ1bmN0aW9uKGV4aXN0cywgbm9kZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXRbbm9kZV0gfHwgdXRpbC5pc0VtcHR5KHRoaXMuX291dFtub2RlXSkpIHtcbiAgICAgICAgICAgICAgICBzaW5rcy5wdXNoKHRoaXMuZ2V0Q2VsbChub2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBzaW5rcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpZiBgZWxlbWVudGAgaXMgYSByb290LiBUaW1lIGNvbXBsZXhpdHk6IE8oMSkuXG4gICAgaXNTb3VyY2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgICByZXR1cm4gIXRoaXMuX2luW2VsZW1lbnQuaWRdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9pbltlbGVtZW50LmlkXSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaWYgYGVsZW1lbnRgIGlzIGEgbGVhZi4gVGltZSBjb21wbGV4aXR5OiBPKDEpLlxuICAgIGlzU2luazogZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5fb3V0W2VsZW1lbnQuaWRdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9vdXRbZWxlbWVudC5pZF0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYHRydWVgIGlzIGBlbGVtZW50QmAgaXMgYSBzdWNjZXNzb3Igb2YgYGVsZW1lbnRBYC4gUmV0dXJuIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIGlzU3VjY2Vzc29yOiBmdW5jdGlvbihlbGVtZW50QSwgZWxlbWVudEIpIHtcblxuICAgICAgICB2YXIgaXNTdWNjZXNzb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudEEsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBlbGVtZW50QiAmJiBlbGVtZW50ICE9PSBlbGVtZW50QSkge1xuICAgICAgICAgICAgICAgIGlzU3VjY2Vzc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBpc1N1Y2Nlc3NvcjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpcyBgZWxlbWVudEJgIGlzIGEgcHJlZGVjZXNzb3Igb2YgYGVsZW1lbnRBYC4gUmV0dXJuIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIGlzUHJlZGVjZXNzb3I6IGZ1bmN0aW9uKGVsZW1lbnRBLCBlbGVtZW50Qikge1xuXG4gICAgICAgIHZhciBpc1ByZWRlY2Vzc29yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VhcmNoKGVsZW1lbnRBLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gZWxlbWVudEIgJiYgZWxlbWVudCAhPT0gZWxlbWVudEEpIHtcbiAgICAgICAgICAgICAgICBpc1ByZWRlY2Vzc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgaW5ib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGlzUHJlZGVjZXNzb3I7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaXMgYGVsZW1lbnRCYCBpcyBhIG5laWdoYm9yIG9mIGBlbGVtZW50QWAuIFJldHVybiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAvLyBgb3B0LmRlZXBgIGNvbnRyb2xzIHdoZXRoZXIgdG8gdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgYXMgd2VsbC4gU2VlIGBnZXROZWlnaGJvcnMoKWBcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIElmIGBvcHQub3V0Ym91bmRgIGlzIHNldCB0byBgdHJ1ZWAsIHJldHVybiBgdHJ1ZWAgb25seSBpZiBgZWxlbWVudEJgIGlzIGEgc3VjY2Vzc29yIG5laWdoYm9yLlxuICAgIC8vIFNpbWlsYXJseSwgaWYgYG9wdC5pbmJvdW5kYCBpcyBzZXQgdG8gYHRydWVgLCByZXR1cm4gYHRydWVgIG9ubHkgaWYgYGVsZW1lbnRCYCBpcyBhIHByZWRlY2Vzc29yIG5laWdoYm9yLlxuICAgIGlzTmVpZ2hib3I6IGZ1bmN0aW9uKGVsZW1lbnRBLCBlbGVtZW50Qiwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBpbmJvdW5kID0gb3B0LmluYm91bmQ7XG4gICAgICAgIHZhciBvdXRib3VuZCA9IG9wdC5vdXRib3VuZDtcbiAgICAgICAgaWYgKChpbmJvdW5kID09PSB1bmRlZmluZWQpICYmIChvdXRib3VuZCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgaW5ib3VuZCA9IG91dGJvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc05laWdoYm9yID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhlbGVtZW50QSwgb3B0KS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgLy8gRGlzY2FyZCBpZiBpdCBpcyBhIHBvaW50LlxuICAgICAgICAgICAgaWYgKGluYm91bmQgJiYgdXRpbC5oYXMoc291cmNlLCAnaWQnKSAmJiAoc291cmNlLmlkID09PSBlbGVtZW50Qi5pZCkpIHtcbiAgICAgICAgICAgICAgICBpc05laWdoYm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgaXQgaXMgYSBwb2ludCwgb3IgaWYgdGhlIG5laWdoYm9yIHdhcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHV0aWwuaGFzKHRhcmdldCwgJ2lkJykgJiYgKHRhcmdldC5pZCA9PT0gZWxlbWVudEIuaWQpKSB7XG4gICAgICAgICAgICAgICAgaXNOZWlnaGJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNOZWlnaGJvcjtcbiAgICB9LFxuXG4gICAgLy8gRGlzY29ubmVjdCBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlIGNlbGwgYG1vZGVsYC5cbiAgICBkaXNjb25uZWN0TGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICB0aGlzLmdldENvbm5lY3RlZExpbmtzKG1vZGVsKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgbGluay5zZXQoKGxpbmsuYXR0cmlidXRlcy5zb3VyY2UuaWQgPT09IG1vZGVsLmlkID8gJ3NvdXJjZScgOiAndGFyZ2V0JyksIHsgeDogMCwgeTogMCB9LCBvcHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGxpbmtzIGNvbm5lY3RlZCB0byB0aGUgY2VsbCBgbW9kZWxgIGNvbXBsZXRlbHkuXG4gICAgcmVtb3ZlTGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICB1dGlsLmludm9rZSh0aGlzLmdldENvbm5lY3RlZExpbmtzKG1vZGVsKSwgJ3JlbW92ZScsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIGVsZW1lbnRzIGF0IGdpdmVuIHBvaW50XG4gICAgZmluZE1vZGVsc0Zyb21Qb2ludDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50cygpLmZpbHRlcihlbCA9PiBlbC5nZXRCQm94KHsgcm90YXRlOiB0cnVlIH0pLmNvbnRhaW5zUG9pbnQocCkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBlbGVtZW50cyBpbiBnaXZlbiBhcmVhXG4gICAgZmluZE1vZGVsc0luQXJlYTogZnVuY3Rpb24ocmVjdCwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgciA9IG5ldyBnLlJlY3QocmVjdCk7XG4gICAgICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdDtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gc3RyaWN0ID8gJ2NvbnRhaW5zUmVjdCcgOiAnaW50ZXJzZWN0JztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHMoKS5maWx0ZXIoZWwgPT4gclttZXRob2RdKGVsLmdldEJCb3goeyByb3RhdGU6IHRydWUgfSkpKTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgZWxlbWVudHMgdW5kZXIgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgZmluZE1vZGVsc1VuZGVyRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hCeSA9ICdiYm94JyB9ID0gb3B0O1xuICAgICAgICBjb25zdCBiYm94ID0gZWxlbWVudC5nZXRCQm94KCkucm90YXRlQXJvdW5kQ2VudGVyKGVsZW1lbnQuYW5nbGUoKSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gKHNlYXJjaEJ5ID09PSAnYmJveCcpXG4gICAgICAgICAgICA/IHRoaXMuZmluZE1vZGVsc0luQXJlYShiYm94KVxuICAgICAgICAgICAgOiB0aGlzLmZpbmRNb2RlbHNGcm9tUG9pbnQodXRpbC5nZXRSZWN0UG9pbnQoYmJveCwgc2VhcmNoQnkpKTtcbiAgICAgICAgLy8gZG9uJ3QgYWNjb3VudCBlbGVtZW50IGl0c2VsZiBvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZWwgPT4gZWxlbWVudC5pZCAhPT0gZWwuaWQgJiYgIWVsLmlzRW1iZWRkZWRJbihlbGVtZW50KSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBib3VuZGluZyBib3ggb2YgYWxsIGVsZW1lbnRzLlxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxzQkJveCh0aGlzLmdldENlbGxzKCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiBhbGwgY2VsbHMgaW4gYXJyYXkgcHJvdmlkZWQuXG4gICAgZ2V0Q2VsbHNCQm94OiBmdW5jdGlvbihjZWxscywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgeyByb3RhdGUgPSB0cnVlIH0gPSBvcHQ7XG4gICAgICAgIHJldHVybiB1dGlsLnRvQXJyYXkoY2VsbHMpLnJlZHVjZShmdW5jdGlvbihtZW1vLCBjZWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gY2VsbC5nZXRCQm94KHsgcm90YXRlIH0pO1xuICAgICAgICAgICAgaWYgKCFyZWN0KSByZXR1cm4gbWVtbztcbiAgICAgICAgICAgIGlmIChtZW1vKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8udW5pb24ocmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oZHgsIGR5LCBvcHQpIHtcblxuICAgICAgICAvLyBEb24ndCB0cmFuc2xhdGUgY2VsbHMgdGhhdCBhcmUgZW1iZWRkZWQgaW4gYW55IG90aGVyIGNlbGwuXG4gICAgICAgIHZhciBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKS5maWx0ZXIoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuICFjZWxsLmlzRW1iZWRkZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXRpbC5pbnZva2UoY2VsbHMsICd0cmFuc2xhdGUnLCBkeCwgZHksIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplQ2VsbHMod2lkdGgsIGhlaWdodCwgdGhpcy5nZXRDZWxscygpLCBvcHQpO1xuICAgIH0sXG5cbiAgICByZXNpemVDZWxsczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgY2VsbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIGBnZXRCQm94YCBtZXRob2QgcmV0dXJucyBgbnVsbGAgaWYgbm8gZWxlbWVudHMgcHJvdmlkZWQuXG4gICAgICAgIC8vIGkuZS4gY2VsbHMgY2FuIGJlIGFuIGFycmF5IG9mIGxpbmtzXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRDZWxsc0JCb3goY2VsbHMpO1xuICAgICAgICBpZiAoYmJveCkge1xuICAgICAgICAgICAgdmFyIHN4ID0gTWF0aC5tYXgod2lkdGggLyBiYm94LndpZHRoLCAwKTtcbiAgICAgICAgICAgIHZhciBzeSA9IE1hdGgubWF4KGhlaWdodCAvIGJib3guaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgIHV0aWwuaW52b2tlKGNlbGxzLCAnc2NhbGUnLCBzeCwgc3ksIGJib3gub3JpZ2luKCksIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9iYXRjaGVzW25hbWVdID0gKHRoaXMuX2JhdGNoZXNbbmFtZV0gfHwgMCkgKyAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2JhdGNoOnN0YXJ0JywgdXRpbC5hc3NpZ24oe30sIGRhdGEsIHsgYmF0Y2hOYW1lOiBuYW1lIH0pKTtcbiAgICB9LFxuXG4gICAgc3RvcEJhdGNoOiBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG5cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHRoaXMuX2JhdGNoZXNbbmFtZV0gPSAodGhpcy5fYmF0Y2hlc1tuYW1lXSB8fCAwKSAtIDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignYmF0Y2g6c3RvcCcsIHV0aWwuYXNzaWduKHt9LCBkYXRhLCB7IGJhdGNoTmFtZTogbmFtZSB9KSk7XG4gICAgfSxcblxuICAgIGhhc0FjdGl2ZUJhdGNoOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuX2JhdGNoZXM7XG4gICAgICAgIGxldCBuYW1lcztcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmFtZXMgPSBPYmplY3Qua2V5cyhiYXRjaGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lcyA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lcyA9IFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lcy5zb21lKChiYXRjaCkgPT4gYmF0Y2hlc1tiYXRjaF0gPiAwKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIHZhbGlkYXRpb25zOiB7XG5cbiAgICAgICAgbXVsdGlMaW5rczogZnVuY3Rpb24oZ3JhcGgsIGxpbmspIHtcblxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IG11bHRpcGxlIGxpbmtzIHRvIGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCB0YXJnZXQuXG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmIHRhcmdldC5pZCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1vZGVsID0gbGluay5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU1vZGVsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RlZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3Moc291cmNlTW9kZWwsIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW1lTGlua3MgPSBjb25uZWN0ZWRMaW5rcy5maWx0ZXIoZnVuY3Rpb24oX2xpbmspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgc291cmNlOiBfc291cmNlLCB0YXJnZXQ6IF90YXJnZXQgfSA9IF9saW5rLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NvdXJjZSAmJiBfc291cmNlLmlkID09PSBzb3VyY2UuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIV9zb3VyY2UucG9ydCB8fCAoX3NvdXJjZS5wb3J0ID09PSBzb3VyY2UucG9ydCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldCAmJiBfdGFyZ2V0LmlkID09PSB0YXJnZXQuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIV90YXJnZXQucG9ydCB8fCAoX3RhcmdldC5wb3J0ID09PSB0YXJnZXQucG9ydCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lTGlua3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBsaW5rUGlubmluZzogZnVuY3Rpb24oX2dyYXBoLCBsaW5rKSB7XG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5pZCAmJiB0YXJnZXQuaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG53cmFwV2l0aChHcmFwaC5wcm90b3R5cGUsIFsncmVzZXRDZWxscycsICdhZGRDZWxscycsICdyZW1vdmVDZWxscyddLCB3cmFwcGVycy5jZWxscyk7XG4iXSwibmFtZXMiOlsiQmFja2JvbmUiLCJ1dGlsIiwiZyIsIkxpbmsiLCJFbGVtZW50Iiwid3JhcHBlcnMiLCJ3cmFwV2l0aCIsImNsb25lQ2VsbHMiLCJHcmFwaENlbGxzIiwiQ29sbGVjdGlvbiIsImV4dGVuZCIsImluaXRpYWxpemUiLCJtb2RlbHMiLCJvcHQiLCJjZWxsTmFtZXNwYWNlIiwiam9pbnQiLCJoYXMiLCJzaGFwZXMiLCJncmFwaCIsIm1vZGVsIiwiYXR0cnMiLCJjb2xsZWN0aW9uIiwibmFtZXNwYWNlIiwiTW9kZWxDbGFzcyIsInR5cGUiLCJnZXRCeVBhdGgiLCJjZWxsIiwiZHJ5IiwiY29tcGFyYXRvciIsImdldCIsIkdyYXBoIiwiTW9kZWwiLCJjZWxscyIsImNlbGxNb2RlbCIsInByb3RvdHlwZSIsInNldCIsImNhbGwiLCJvbiIsInRyaWdnZXIiLCJfc29ydE9uQ2hhbmdlWiIsIl9vdXQiLCJfaW4iLCJfbm9kZXMiLCJfZWRnZXMiLCJfYmF0Y2hlcyIsIl9yZXN0cnVjdHVyZU9uQWRkIiwiX3Jlc3RydWN0dXJlT25SZW1vdmUiLCJfcmVzdHJ1Y3R1cmVPblJlc2V0IiwiX3Jlc3RydWN0dXJlT25DaGFuZ2VTb3VyY2UiLCJfcmVzdHJ1Y3R1cmVPbkNoYW5nZVRhcmdldCIsIl9yZW1vdmVDZWxsIiwic29ydCIsImlzTGluayIsImlkIiwic291cmNlIiwidGFyZ2V0IiwiYXR0cmlidXRlcyIsImZvckVhY2giLCJsaW5rIiwicHJldlNvdXJjZSIsInByZXZpb3VzIiwicHJldlRhcmdldCIsImdldE91dGJvdW5kRWRnZXMiLCJub2RlIiwiZ2V0SW5ib3VuZEVkZ2VzIiwidG9KU09OIiwianNvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwiZnJvbUpTT04iLCJFcnJvciIsImtleSIsInZhbCIsImhhc093blByb3BlcnR5IiwicmVzZXRDZWxscyIsIm9taXQiLCJjbGVhciIsImFzc2lnbiIsImxlbmd0aCIsInN0YXJ0QmF0Y2giLCJzb3J0QnkiLCJzaGlmdCIsInJlbW92ZSIsInN0b3BCYXRjaCIsIl9wcmVwYXJlQ2VsbCIsImlzU3RyaW5nIiwiVHlwZUVycm9yIiwibWluWkluZGV4IiwiZmlyc3RDZWxsIiwiZmlyc3QiLCJtYXhaSW5kZXgiLCJsYXN0Q2VsbCIsImxhc3QiLCJhZGRDZWxsIiwiQXJyYXkiLCJpc0FycmF5IiwiYWRkQ2VsbHMiLCJ6IiwidW5kZWZpbmVkIiwiYWRkIiwiZmxhdHRlbkRlZXAiLCJtYXhQb3NpdGlvbiIsInBvc2l0aW9uIiwicHJlcGFyZWRDZWxscyIsInRvQXJyYXkiLCJtYXAiLCJyZXNldCIsInJlbW92ZUNlbGxzIiwiaW52b2tlIiwib3B0aW9ucyIsImRpc2Nvbm5lY3RMaW5rcyIsInJlbW92ZUxpbmtzIiwic2lsZW50IiwiZ2V0Q2VsbCIsImdldENlbGxzIiwiZ2V0RWxlbWVudHMiLCJmaWx0ZXIiLCJpc0VsZW1lbnQiLCJnZXRMaW5rcyIsImdldEZpcnN0Q2VsbCIsImdldExhc3RDZWxsIiwiZ2V0Q29ubmVjdGVkTGlua3MiLCJpbmRpcmVjdCIsImluYm91bmQiLCJvdXRib3VuZCIsImxpbmtzIiwiZWRnZXMiLCJhZGRPdXRib3VuZHMiLCJhZGRJbmJvdW5kcyIsImZvckluIiwiXyIsImVkZ2UiLCJwdXNoIiwiYmluZCIsIm91dENlbGwiLCJnZXRUYXJnZXRDZWxsIiwiaW5DZWxsIiwiZ2V0U291cmNlQ2VsbCIsImRlZXAiLCJlbWJlZGRlZENlbGxzIiwiZ2V0RW1iZWRkZWRDZWxscyIsImVtYmVkZGVkRWxlbWVudHMiLCJleGlzdHMiLCJlZGdlQ2VsbCIsInNvdXJjZUlkIiwidGFyZ2V0SWQiLCJpbmNsdWRlRW5jbG9zZWQiLCJnZXROZWlnaGJvcnMiLCJuZWlnaGJvcnMiLCJyZWR1Y2UiLCJyZXMiLCJsb29wIiwiaGFzTG9vcCIsInNvdXJjZUVsZW1lbnQiLCJpc0VtYmVkZGVkSW4iLCJ0YXJnZXRFbGVtZW50Iiwic291cmNlQ2VsbCIsInRhcmdldENlbGwiLCJnZXRDb21tb25BbmNlc3RvciIsImNlbGxzQW5jZXN0b3JzIiwiZnJvbSIsImFuY2VzdG9ycyIsInBhcmVudElkIiwiYSIsImIiLCJjb21tb25BbmNlc3RvciIsImZpbmQiLCJhbmNlc3RvciIsImV2ZXJ5IiwiY2VsbEFuY2VzdG9ycyIsImluY2x1ZGVzIiwiZ2V0U3VjY2Vzc29ycyIsImVsZW1lbnQiLCJzZWFyY2giLCJlbCIsImNsb25lU3ViZ3JhcGgiLCJzdWJncmFwaCIsImdldFN1YmdyYXBoIiwiY2VsbE1hcCIsImVsZW1lbnRzIiwiZW1iZWRzIiwiZW1iZWQiLCJnZXRQcmVkZWNlc3NvcnMiLCJpdGVyYXRlZSIsImJyZWFkdGhGaXJzdCIsImJmcyIsImRmcyIsInZpc2l0ZWQiLCJkaXN0YW5jZSIsInF1ZXVlIiwibmV4dCIsImkiLCJuIiwibmVpZ2hib3IiLCJwb3AiLCJsYXN0SW5kZXgiLCJzcGxpY2UiLCJnZXRTb3VyY2VzIiwic291cmNlcyIsImlzRW1wdHkiLCJnZXRTaW5rcyIsInNpbmtzIiwiaXNTb3VyY2UiLCJpc1NpbmsiLCJpc1N1Y2Nlc3NvciIsImVsZW1lbnRBIiwiZWxlbWVudEIiLCJpc1ByZWRlY2Vzc29yIiwiaXNOZWlnaGJvciIsIngiLCJ5IiwiZmluZE1vZGVsc0Zyb21Qb2ludCIsInAiLCJnZXRCQm94Iiwicm90YXRlIiwiY29udGFpbnNQb2ludCIsImZpbmRNb2RlbHNJbkFyZWEiLCJyZWN0IiwiciIsIlJlY3QiLCJzdHJpY3QiLCJtZXRob2QiLCJmaW5kTW9kZWxzVW5kZXJFbGVtZW50Iiwic2VhcmNoQnkiLCJiYm94Iiwicm90YXRlQXJvdW5kQ2VudGVyIiwiYW5nbGUiLCJnZXRSZWN0UG9pbnQiLCJnZXRDZWxsc0JCb3giLCJtZW1vIiwidW5pb24iLCJ0cmFuc2xhdGUiLCJkeCIsImR5IiwiaXNFbWJlZGRlZCIsInJlc2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwicmVzaXplQ2VsbHMiLCJzeCIsIk1hdGgiLCJtYXgiLCJzeSIsIm9yaWdpbiIsIm5hbWUiLCJkYXRhIiwiYmF0Y2hOYW1lIiwiaGFzQWN0aXZlQmF0Y2giLCJiYXRjaGVzIiwibmFtZXMiLCJPYmplY3QiLCJrZXlzIiwic29tZSIsImJhdGNoIiwidmFsaWRhdGlvbnMiLCJtdWx0aUxpbmtzIiwic291cmNlTW9kZWwiLCJjb25uZWN0ZWRMaW5rcyIsInNhbWVMaW5rcyIsIl9saW5rIiwiX3NvdXJjZSIsIl90YXJnZXQiLCJwb3J0IiwibGlua1Bpbm5pbmciLCJfZ3JhcGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/Graph.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/jointjs/src/dia/HighlighterView.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HighlighterView: () => (/* binding */ HighlighterView)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/jointjs/src/mvc/View.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n\n\nfunction toArray(obj) {\n    if (!obj) return [];\n    if (Array.isArray(obj)) return obj;\n    return [\n        obj\n    ];\n}\nconst HighlighterView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: \"g\",\n    svgElement: true,\n    className: \"highlight\",\n    HIGHLIGHT_FLAG: 1,\n    UPDATE_PRIORITY: 3,\n    DETACHABLE: false,\n    UPDATABLE: true,\n    MOUNTABLE: true,\n    cellView: null,\n    nodeSelector: null,\n    node: null,\n    updateRequested: false,\n    postponedUpdate: false,\n    transformGroup: null,\n    detachedTransformGroup: null,\n    requestUpdate (cellView, nodeSelector) {\n        const { paper } = cellView;\n        this.cellView = cellView;\n        this.nodeSelector = nodeSelector;\n        if (paper) {\n            this.updateRequested = true;\n            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n        }\n    },\n    confirmUpdate () {\n        // The cellView is now rendered/updated since it has a higher update priority.\n        this.updateRequested = false;\n        const { cellView, nodeSelector } = this;\n        if (!cellView.isMounted()) {\n            this.postponedUpdate = true;\n            return 0;\n        }\n        this.update(cellView, nodeSelector);\n        this.mount();\n        this.transform();\n        return 0;\n    },\n    findNode (cellView, nodeSelector = null) {\n        let el;\n        if (typeof nodeSelector === \"string\") {\n            [el] = cellView.findBySelector(nodeSelector);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(nodeSelector)) {\n            const isLink = cellView.model.isLink();\n            const { label = null, port, selector } = nodeSelector;\n            if (isLink && label !== null) {\n                // Link Label Selector\n                el = cellView.findLabelNode(label, selector);\n            } else if (!isLink && port) {\n                // Element Port Selector\n                el = cellView.findPortNode(port, selector);\n            } else {\n                // Cell Selector\n                [el] = cellView.findBySelector(selector);\n            }\n        } else if (nodeSelector) {\n            el = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toNode(nodeSelector);\n            if (!(el instanceof SVGElement)) el = null;\n        }\n        return el ? el : null;\n    },\n    getNodeMatrix (cellView, node) {\n        const { options } = this;\n        const { layer } = options;\n        const { rotatableNode } = cellView;\n        const nodeMatrix = cellView.getNodeMatrix(node);\n        if (rotatableNode) {\n            if (layer) {\n                if (rotatableNode.contains(node)) {\n                    return nodeMatrix;\n                }\n                // The node is outside of the rotatable group.\n                // Compensate the rotation set by transformGroup.\n                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n            } else {\n                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n            }\n        }\n        return nodeMatrix;\n    },\n    mount () {\n        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;\n        if (!MOUNTABLE || transformGroup) return;\n        if (postponedUpdate) {\n            // The cellView was not mounted when the update was requested.\n            // The update was postponed until the cellView is mounted.\n            this.update(cellView, nodeSelector);\n            this.transform();\n            return;\n        }\n        const { vel: cellViewRoot, paper } = cellView;\n        const { layer: layerName } = options;\n        if (layerName) {\n            let vGroup;\n            if (detachedTransformGroup) {\n                vGroup = detachedTransformGroup;\n                this.detachedTransformGroup = null;\n            } else {\n                vGroup = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"g\").addClass(\"highlight-transform\").append(el);\n            }\n            this.transformGroup = vGroup;\n            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n        } else {\n            // TODO: prepend vs append\n            if (!el.parentNode || el.nextSibling) {\n                // Not appended yet or not the last child\n                cellViewRoot.append(el);\n            }\n        }\n    },\n    unmount () {\n        const { MOUNTABLE, transformGroup, vel } = this;\n        if (!MOUNTABLE) return;\n        if (transformGroup) {\n            this.transformGroup = null;\n            this.detachedTransformGroup = transformGroup;\n            transformGroup.remove();\n        } else {\n            vel.remove();\n        }\n    },\n    transform () {\n        const { transformGroup, cellView, updateRequested } = this;\n        if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n        const translateMatrix = cellView.getRootTranslateMatrix();\n        const rotateMatrix = cellView.getRootRotateMatrix();\n        const transformMatrix = translateMatrix.multiply(rotateMatrix);\n        transformGroup.attr(\"transform\", _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformMatrix));\n    },\n    update () {\n        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;\n        if (updateRequested) return;\n        this.postponedUpdate = false;\n        const node = this.node = this.findNode(cellView, nodeSelector);\n        if (prevNode) {\n            this.unhighlight(cellView, prevNode);\n        }\n        if (node) {\n            this.highlight(cellView, node);\n            this.mount();\n        } else {\n            this.unmount();\n            cellView.notify(\"cell:highlight:invalid\", id, this);\n        }\n    },\n    onRemove () {\n        const { node, cellView, id, constructor } = this;\n        if (node) {\n            this.unhighlight(cellView, node);\n        }\n        this.unmount();\n        constructor._removeRef(cellView, id);\n    },\n    highlight (_cellView, _node) {\n    // to be overridden\n    },\n    unhighlight (_cellView, _node) {\n    // to be overridden\n    },\n    // Update Attributes\n    listenToUpdateAttributes (cellView) {\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, \"UPDATE_ATTRIBUTES\");\n        if (!Array.isArray(attributes) || attributes.length === 0) return;\n        this.listenTo(cellView.model, \"change\", this.onCellAttributeChange);\n    },\n    onCellAttributeChange () {\n        const { cellView } = this;\n        if (!cellView) return;\n        const { model, paper } = cellView;\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, \"UPDATE_ATTRIBUTES\");\n        if (!attributes.some((attribute)=>model.hasChanged(attribute))) return;\n        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n    }\n}, {\n    _views: {},\n    // Used internally by CellView highlight()\n    highlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.add(cellView, node, id, opt);\n    },\n    // Used internally by CellView unhighlight()\n    unhighlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.remove(cellView, id);\n    },\n    get (cellView, id = null) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (id === null) {\n            // all highlighters\n            const views = [];\n            if (!refs) return views;\n            for(let hid in refs){\n                const ref = refs[hid];\n                if (ref instanceof this) {\n                    views.push(ref);\n                }\n            }\n            return views;\n        } else {\n            // single highlighter\n            if (!refs) return null;\n            if (id in refs) {\n                const ref = refs[id];\n                if (ref instanceof this) return ref;\n            }\n            return null;\n        }\n    },\n    add (cellView, nodeSelector, id, opt = {}) {\n        if (!id) throw new Error(\"dia.HighlighterView: An ID required.\");\n        // Search the existing view amongst all the highlighters\n        const previousView = HighlighterView.get(cellView, id);\n        if (previousView) previousView.remove();\n        const view = new this(opt);\n        view.id = id;\n        this._addRef(cellView, id, view);\n        view.requestUpdate(cellView, nodeSelector);\n        view.listenToUpdateAttributes(cellView);\n        return view;\n    },\n    _addRef (cellView, id, view) {\n        const { cid } = cellView;\n        const { _views } = this;\n        let refs = _views[cid];\n        if (!refs) refs = _views[cid] = {};\n        refs[id] = view;\n    },\n    _removeRef (cellView, id) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (!refs) return;\n        if (id) delete refs[id];\n        for(let _ in refs)return;\n        delete _views[cid];\n    },\n    remove (cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach((view)=>{\n            view.remove();\n        });\n    },\n    removeAll (paper, id = null) {\n        const { _views } = this;\n        for(let cid in _views){\n            for(let hid in _views[cid]){\n                const view = _views[cid][hid];\n                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n                    view.remove();\n                }\n            }\n        }\n    },\n    update (cellView, id = null, dirty = false) {\n        toArray(this.get(cellView, id)).forEach((view)=>{\n            if (dirty || view.UPDATABLE) view.update();\n        });\n    },\n    transform (cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach((view)=>{\n            if (view.UPDATABLE) view.transform();\n        });\n    },\n    unmount (cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach((view)=>view.unmount());\n    },\n    mount (cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach((view)=>view.mount());\n    },\n    uniqueId (node, opt = \"\") {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ensureId(node) + JSON.stringify(opt);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0hpZ2hsaWdodGVyVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNUO0FBQzBCO0FBRXpELFNBQVNJLFFBQVFDLEdBQUc7SUFDaEIsSUFBSSxDQUFDQSxLQUFLLE9BQU8sRUFBRTtJQUNuQixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLE1BQU0sT0FBT0E7SUFDL0IsT0FBTztRQUFDQTtLQUFJO0FBQ2hCO0FBRU8sTUFBTUcsa0JBQWtCUixnREFBUSxDQUFDVSxNQUFNLENBQUM7SUFFM0NDLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxXQUFXO0lBRVhDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxZQUFZO0lBQ1pDLFdBQVc7SUFDWEMsV0FBVztJQUVYQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsTUFBTTtJQUNOQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsZ0JBQWdCO0lBQ2hCQyx3QkFBd0I7SUFFeEJDLGVBQWNQLFFBQVEsRUFBRUMsWUFBWTtRQUNoQyxNQUFNLEVBQUVPLEtBQUssRUFBRSxHQUFHUjtRQUNsQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBO1FBQ3BCLElBQUlPLE9BQU87WUFDUCxJQUFJLENBQUNMLGVBQWUsR0FBRztZQUN2QkssTUFBTUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ2QsY0FBYyxFQUFFLElBQUksQ0FBQ0MsZUFBZTtRQUMzRTtJQUNKO0lBRUFjO1FBQ0ksOEVBQThFO1FBQzlFLElBQUksQ0FBQ1AsZUFBZSxHQUFHO1FBQ3ZCLE1BQU0sRUFBRUgsUUFBUSxFQUFFQyxZQUFZLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDLElBQUksQ0FBQ0QsU0FBU1csU0FBUyxJQUFJO1lBQ3ZCLElBQUksQ0FBQ1AsZUFBZSxHQUFHO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ1EsTUFBTSxDQUFD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LEtBQUtpQyxPQUFPLENBQUNILENBQUFBLE9BQVFBLEtBQUt2QyxPQUFPO0lBQ2hFO0lBRUFuQyxPQUFNYixRQUFRLEVBQUV5RCxLQUFLLElBQUk7UUFDckJ4RSxRQUFRLElBQUksQ0FBQzZGLEdBQUcsQ0FBQzlFLFVBQVV5RCxLQUFLaUMsT0FBTyxDQUFDSCxDQUFBQSxPQUFRQSxLQUFLMUUsS0FBSztJQUM5RDtJQUVBK0QsVUFBUzFFLElBQUksRUFBRXlFLE1BQU0sRUFBRTtRQUNuQixPQUFPN0Ysb0RBQUNBLENBQUMrRyxRQUFRLENBQUMzRixRQUFRNEYsS0FBS0MsU0FBUyxDQUFDcEI7SUFDN0M7QUFFSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0hpZ2hsaWdodGVyVmlldy5tanM/MGMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBtdmMgZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0LCByZXN1bHQgfSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIFtvYmpdO1xufVxuXG5leHBvcnQgY29uc3QgSGlnaGxpZ2h0ZXJWaWV3ID0gbXZjLlZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIGNsYXNzTmFtZTogJ2hpZ2hsaWdodCcsXG5cbiAgICBISUdITElHSFRfRkxBRzogMSxcbiAgICBVUERBVEVfUFJJT1JJVFk6IDMsXG4gICAgREVUQUNIQUJMRTogZmFsc2UsXG4gICAgVVBEQVRBQkxFOiB0cnVlLFxuICAgIE1PVU5UQUJMRTogdHJ1ZSxcblxuICAgIGNlbGxWaWV3OiBudWxsLFxuICAgIG5vZGVTZWxlY3RvcjogbnVsbCxcbiAgICBub2RlOiBudWxsLFxuICAgIHVwZGF0ZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgcG9zdHBvbmVkVXBkYXRlOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1Hcm91cDogbnVsbCxcbiAgICBkZXRhY2hlZFRyYW5zZm9ybUdyb3VwOiBudWxsLFxuXG4gICAgcmVxdWVzdFVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIgfSA9IGNlbGxWaWV3O1xuICAgICAgICB0aGlzLmNlbGxWaWV3ID0gY2VsbFZpZXc7XG4gICAgICAgIHRoaXMubm9kZVNlbGVjdG9yID0gbm9kZVNlbGVjdG9yO1xuICAgICAgICBpZiAocGFwZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcGVyLnJlcXVlc3RWaWV3VXBkYXRlKHRoaXMsIHRoaXMuSElHSExJR0hUX0ZMQUcsIHRoaXMuVVBEQVRFX1BSSU9SSVRZKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25maXJtVXBkYXRlKCkge1xuICAgICAgICAvLyBUaGUgY2VsbFZpZXcgaXMgbm93IHJlbmRlcmVkL3VwZGF0ZWQgc2luY2UgaXQgaGFzIGEgaGlnaGVyIHVwZGF0ZSBwcmlvcml0eS5cbiAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjZWxsVmlldywgbm9kZVNlbGVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWNlbGxWaWV3LmlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3Rwb25lZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZmluZE5vZGUoY2VsbFZpZXcsIG5vZGVTZWxlY3RvciA9IG51bGwpIHtcbiAgICAgICAgbGV0IGVsO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFtlbF0gPSBjZWxsVmlldy5maW5kQnlTZWxlY3Rvcihub2RlU2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qobm9kZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY29uc3QgaXNMaW5rID0gY2VsbFZpZXcubW9kZWwuaXNMaW5rKCk7XG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsID0gbnVsbCwgcG9ydCwgc2VsZWN0b3IgfSA9IG5vZGVTZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChpc0xpbmsgJiYgbGFiZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5rIExhYmVsIFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWwgPSBjZWxsVmlldy5maW5kTGFiZWxOb2RlKGxhYmVsLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0xpbmsgJiYgcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgUG9ydCBTZWxlY3RvclxuICAgICAgICAgICAgICAgIGVsID0gY2VsbFZpZXcuZmluZFBvcnROb2RlKHBvcnQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2VsbCBTZWxlY3RvclxuICAgICAgICAgICAgICAgIFtlbF0gPSBjZWxsVmlldy5maW5kQnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBlbCA9IFYudG9Ob2RlKG5vZGVTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIShlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSBlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsID8gZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXROb2RlTWF0cml4KGNlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyByb3RhdGFibGVOb2RlIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3Qgbm9kZU1hdHJpeCA9IGNlbGxWaWV3LmdldE5vZGVNYXRyaXgobm9kZSk7XG4gICAgICAgIGlmIChyb3RhdGFibGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocm90YXRhYmxlTm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU1hdHJpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5vZGUgaXMgb3V0c2lkZSBvZiB0aGUgcm90YXRhYmxlIGdyb3VwLlxuICAgICAgICAgICAgICAgIC8vIENvbXBlbnNhdGUgdGhlIHJvdGF0aW9uIHNldCBieSB0cmFuc2Zvcm1Hcm91cC5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbFZpZXcuZ2V0Um9vdFJvdGF0ZU1hdHJpeCgpLmludmVyc2UoKS5tdWx0aXBseShub2RlTWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxWaWV3LmdldE5vZGVSb3RhdGVNYXRyaXgobm9kZSkubXVsdGlwbHkobm9kZU1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVNYXRyaXg7XG4gICAgfSxcblxuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IE1PVU5UQUJMRSwgY2VsbFZpZXcsIGVsLCBvcHRpb25zLCB0cmFuc2Zvcm1Hcm91cCwgZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cCwgcG9zdHBvbmVkVXBkYXRlLCBub2RlU2VsZWN0b3IgfSA9IHRoaXM7XG4gICAgICAgIGlmICghTU9VTlRBQkxFIHx8IHRyYW5zZm9ybUdyb3VwKSByZXR1cm47XG4gICAgICAgIGlmIChwb3N0cG9uZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjZWxsVmlldyB3YXMgbm90IG1vdW50ZWQgd2hlbiB0aGUgdXBkYXRlIHdhcyByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAvLyBUaGUgdXBkYXRlIHdhcyBwb3N0cG9uZWQgdW50aWwgdGhlIGNlbGxWaWV3IGlzIG1vdW50ZWQuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB2ZWw6IGNlbGxWaWV3Um9vdCwgcGFwZXIgfSA9IGNlbGxWaWV3O1xuICAgICAgICBjb25zdCB7IGxheWVyOiBsYXllck5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChsYXllck5hbWUpIHtcbiAgICAgICAgICAgIGxldCB2R3JvdXA7XG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZHcm91cCA9IGRldGFjaGVkVHJhbnNmb3JtR3JvdXA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hlZFRyYW5zZm9ybUdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdkdyb3VwID0gVignZycpLmFkZENsYXNzKCdoaWdobGlnaHQtdHJhbnNmb3JtJykuYXBwZW5kKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtR3JvdXAgPSB2R3JvdXA7XG4gICAgICAgICAgICBwYXBlci5nZXRMYXllclZpZXcobGF5ZXJOYW1lKS5pbnNlcnRTb3J0ZWROb2RlKHZHcm91cC5ub2RlLCBvcHRpb25zLnopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogcHJlcGVuZCB2cyBhcHBlbmRcbiAgICAgICAgICAgIGlmICghZWwucGFyZW50Tm9kZSB8fCBlbC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhcHBlbmRlZCB5ZXQgb3Igbm90IHRoZSBsYXN0IGNoaWxkXG4gICAgICAgICAgICAgICAgY2VsbFZpZXdSb290LmFwcGVuZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBNT1VOVEFCTEUsIHRyYW5zZm9ybUdyb3VwLCB2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmICghTU9VTlRBQkxFKSByZXR1cm47XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Hcm91cCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRldGFjaGVkVHJhbnNmb3JtR3JvdXAgPSB0cmFuc2Zvcm1Hcm91cDtcbiAgICAgICAgICAgIHRyYW5zZm9ybUdyb3VwLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm1Hcm91cCwgY2VsbFZpZXcsIHVwZGF0ZVJlcXVlc3RlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1Hcm91cCB8fCBjZWxsVmlldy5tb2RlbC5pc0xpbmsoKSB8fCB1cGRhdGVSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlTWF0cml4ID0gY2VsbFZpZXcuZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCgpO1xuICAgICAgICBjb25zdCByb3RhdGVNYXRyaXggPSBjZWxsVmlldy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeC5tdWx0aXBseShyb3RhdGVNYXRyaXgpO1xuICAgICAgICB0cmFuc2Zvcm1Hcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybU1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZTogcHJldk5vZGUsIGNlbGxWaWV3LCBub2RlU2VsZWN0b3IsIHVwZGF0ZVJlcXVlc3RlZCwgaWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICh1cGRhdGVSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5wb3N0cG9uZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZSA9IHRoaXMuZmluZE5vZGUoY2VsbFZpZXcsIG5vZGVTZWxlY3Rvcik7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy51bmhpZ2hsaWdodChjZWxsVmlldywgcHJldk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChjZWxsVmlldywgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnQoKTtcbiAgICAgICAgICAgIGNlbGxWaWV3Lm5vdGlmeSgnY2VsbDpoaWdobGlnaHQ6aW52YWxpZCcsIGlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblJlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgeyBub2RlLCBjZWxsVmlldywgaWQsIGNvbnN0cnVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy51bmhpZ2hsaWdodChjZWxsVmlldywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bm1vdW50KCk7XG4gICAgICAgIGNvbnN0cnVjdG9yLl9yZW1vdmVSZWYoY2VsbFZpZXcsIGlkKTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0KF9jZWxsVmlldywgX25vZGUpIHtcbiAgICAgICAgLy8gdG8gYmUgb3ZlcnJpZGRlblxuICAgIH0sXG5cbiAgICB1bmhpZ2hsaWdodChfY2VsbFZpZXcsIF9ub2RlKSB7XG4gICAgICAgIC8vIHRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIEF0dHJpYnV0ZXNcblxuICAgIGxpc3RlblRvVXBkYXRlQXR0cmlidXRlcyhjZWxsVmlldykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzdWx0KHRoaXMsICdVUERBVEVfQVRUUklCVVRFUycpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykgfHwgYXR0cmlidXRlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhjZWxsVmlldy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMub25DZWxsQXR0cmlidXRlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgb25DZWxsQXR0cmlidXRlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB7IGNlbGxWaWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWNlbGxWaWV3KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHBhcGVyIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdCh0aGlzLCAnVVBEQVRFX0FUVFJJQlVURVMnKTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnNvbWUoYXR0cmlidXRlID0+IG1vZGVsLmhhc0NoYW5nZWQoYXR0cmlidXRlKSkpIHJldHVybjtcbiAgICAgICAgcGFwZXIucmVxdWVzdFZpZXdVcGRhdGUodGhpcywgdGhpcy5ISUdITElHSFRfRkxBRywgdGhpcy5VUERBVEVfUFJJT1JJVFkpO1xuICAgIH1cblxufSwge1xuXG4gICAgX3ZpZXdzOiB7fSxcblxuICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBDZWxsVmlldyBoaWdobGlnaHQoKVxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG5vZGUsIG9wdCkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMudW5pcXVlSWQobm9kZSwgb3B0KTtcbiAgICAgICAgdGhpcy5hZGQoY2VsbFZpZXcsIG5vZGUsIGlkLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgQ2VsbFZpZXcgdW5oaWdobGlnaHQoKVxuICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihjZWxsVmlldywgbm9kZSwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy51bmlxdWVJZChub2RlLCBvcHQpO1xuICAgICAgICB0aGlzLnJlbW92ZShjZWxsVmlldywgaWQpO1xuICAgIH0sXG5cbiAgICBnZXQoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGNpZCB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZzID0gX3ZpZXdzW2NpZF07XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWxsIGhpZ2hsaWdodGVyc1xuICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBbXTtcbiAgICAgICAgICAgIGlmICghcmVmcykgcmV0dXJuIHZpZXdzO1xuICAgICAgICAgICAgZm9yIChsZXQgaGlkIGluIHJlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSByZWZzW2hpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2aWV3cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBoaWdobGlnaHRlclxuICAgICAgICAgICAgaWYgKCFyZWZzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChpZCBpbiByZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHRoaXMpIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGQoY2VsbFZpZXcsIG5vZGVTZWxlY3RvciwgaWQsIG9wdCA9IHt9KSB7XG4gICAgICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignZGlhLkhpZ2hsaWdodGVyVmlldzogQW4gSUQgcmVxdWlyZWQuJyk7XG4gICAgICAgIC8vIFNlYXJjaCB0aGUgZXhpc3RpbmcgdmlldyBhbW9uZ3N0IGFsbCB0aGUgaGlnaGxpZ2h0ZXJzXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmlldyA9IEhpZ2hsaWdodGVyVmlldy5nZXQoY2VsbFZpZXcsIGlkKTtcbiAgICAgICAgaWYgKHByZXZpb3VzVmlldykgcHJldmlvdXNWaWV3LnJlbW92ZSgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IHRoaXMob3B0KTtcbiAgICAgICAgdmlldy5pZCA9IGlkO1xuICAgICAgICB0aGlzLl9hZGRSZWYoY2VsbFZpZXcsIGlkLCB2aWV3KTtcbiAgICAgICAgdmlldy5yZXF1ZXN0VXBkYXRlKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IpO1xuICAgICAgICB2aWV3Lmxpc3RlblRvVXBkYXRlQXR0cmlidXRlcyhjZWxsVmlldyk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICBfYWRkUmVmKGNlbGxWaWV3LCBpZCwgdmlldykge1xuICAgICAgICBjb25zdCB7IGNpZCB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVmcyA9IF92aWV3c1tjaWRdO1xuICAgICAgICBpZiAoIXJlZnMpIHJlZnMgPSBfdmlld3NbY2lkXSA9IHt9O1xuICAgICAgICByZWZzW2lkXSA9IHZpZXc7XG4gICAgfSxcblxuICAgIF9yZW1vdmVSZWYoY2VsbFZpZXcsIGlkKSB7XG4gICAgICAgIGNvbnN0IHsgY2lkIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3QgeyBfdmlld3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlZnMgPSBfdmlld3NbY2lkXTtcbiAgICAgICAgaWYgKCFyZWZzKSByZXR1cm47XG4gICAgICAgIGlmIChpZCkgZGVsZXRlIHJlZnNbaWRdO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlZnMpIHJldHVybjtcbiAgICAgICAgZGVsZXRlIF92aWV3c1tjaWRdO1xuICAgIH0sXG5cbiAgICByZW1vdmUoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICB0b0FycmF5KHRoaXMuZ2V0KGNlbGxWaWV3LCBpZCkpLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsKHBhcGVyLCBpZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBfdmlld3MgfSA9IHRoaXM7XG5cbiAgICAgICAgZm9yIChsZXQgY2lkIGluIF92aWV3cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaGlkIGluIF92aWV3c1tjaWRdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IF92aWV3c1tjaWRdW2hpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodmlldy5jZWxsVmlldy5wYXBlciA9PT0gcGFwZXIgJiYgdmlldyBpbnN0YW5jZW9mIHRoaXMgJiYgKGlkID09PSBudWxsIHx8IGhpZCA9PT0gaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZShjZWxsVmlldywgaWQgPSBudWxsLCBkaXJ0eSA9IGZhbHNlKSB7XG4gICAgICAgIHRvQXJyYXkodGhpcy5nZXQoY2VsbFZpZXcsIGlkKSkuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGlmIChkaXJ0eSB8fCB2aWV3LlVQREFUQUJMRSkgdmlldy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybShjZWxsVmlldywgaWQgPSBudWxsKSB7XG4gICAgICAgIHRvQXJyYXkodGhpcy5nZXQoY2VsbFZpZXcsIGlkKSkuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LlVQREFUQUJMRSkgdmlldy50cmFuc2Zvcm0oKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVubW91bnQoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICB0b0FycmF5KHRoaXMuZ2V0KGNlbGxWaWV3LCBpZCkpLmZvckVhY2godmlldyA9PiB2aWV3LnVubW91bnQoKSk7XG4gICAgfSxcblxuICAgIG1vdW50KGNlbGxWaWV3LCBpZCA9IG51bGwpIHtcbiAgICAgICAgdG9BcnJheSh0aGlzLmdldChjZWxsVmlldywgaWQpKS5mb3JFYWNoKHZpZXcgPT4gdmlldy5tb3VudCgpKTtcbiAgICB9LFxuXG4gICAgdW5pcXVlSWQobm9kZSwgb3B0ID0gJycpIHtcbiAgICAgICAgcmV0dXJuIFYuZW5zdXJlSWQobm9kZSkgKyBKU09OLnN0cmluZ2lmeShvcHQpO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOlsibXZjIiwiViIsImlzUGxhaW5PYmplY3QiLCJyZXN1bHQiLCJ0b0FycmF5Iiwib2JqIiwiQXJyYXkiLCJpc0FycmF5IiwiSGlnaGxpZ2h0ZXJWaWV3IiwiVmlldyIsImV4dGVuZCIsInRhZ05hbWUiLCJzdmdFbGVtZW50IiwiY2xhc3NOYW1lIiwiSElHSExJR0hUX0ZMQUciLCJVUERBVEVfUFJJT1JJVFkiLCJERVRBQ0hBQkxFIiwiVVBEQVRBQkxFIiwiTU9VTlRBQkxFIiwiY2VsbFZpZXciLCJub2RlU2VsZWN0b3IiLCJub2RlIiwidXBkYXRlUmVxdWVzdGVkIiwicG9zdHBvbmVkVXBkYXRlIiwidHJhbnNmb3JtR3JvdXAiLCJkZXRhY2hlZFRyYW5zZm9ybUdyb3VwIiwicmVxdWVzdFVwZGF0ZSIsInBhcGVyIiwicmVxdWVzdFZpZXdVcGRhdGUiLCJjb25maXJtVXBkYXRlIiwiaXNNb3VudGVkIiwidXBkYXRlIiwibW91bnQiLCJ0cmFuc2Zvcm0iLCJmaW5kTm9kZSIsImVsIiwiZmluZEJ5U2VsZWN0b3IiLCJpc0xpbmsiLCJtb2RlbCIsImxhYmVsIiwicG9ydCIsInNlbGVjdG9yIiwiZmluZExhYmVsTm9kZSIsImZpbmRQb3J0Tm9kZSIsInRvTm9kZSIsIlNWR0VsZW1lbnQiLCJnZXROb2RlTWF0cml4Iiwib3B0aW9ucyIsImxheWVyIiwicm90YXRhYmxlTm9kZSIsIm5vZGVNYXRyaXgiLCJjb250YWlucyIsImdldFJvb3RSb3RhdGVNYXRyaXgiLCJpbnZlcnNlIiwibXVsdGlwbHkiLCJnZXROb2RlUm90YXRlTWF0cml4IiwidmVsIiwiY2VsbFZpZXdSb290IiwibGF5ZXJOYW1lIiwidkdyb3VwIiwiYWRkQ2xhc3MiLCJhcHBlbmQiLCJnZXRMYXllclZpZXciLCJpbnNlcnRTb3J0ZWROb2RlIiwieiIsInBhcmVudE5vZGUiLCJuZXh0U2libGluZyIsInVubW91bnQiLCJyZW1vdmUiLCJ0cmFuc2xhdGVNYXRyaXgiLCJnZXRSb290VHJhbnNsYXRlTWF0cml4Iiwicm90YXRlTWF0cml4IiwidHJhbnNmb3JtTWF0cml4IiwiYXR0ciIsIm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nIiwicHJldk5vZGUiLCJpZCIsInVuaGlnaGxpZ2h0IiwiaGlnaGxpZ2h0Iiwibm90aWZ5Iiwib25SZW1vdmUiLCJjb25zdHJ1Y3RvciIsIl9yZW1vdmVSZWYiLCJfY2VsbFZpZXciLCJfbm9kZSIsImxpc3RlblRvVXBkYXRlQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJsZW5ndGgiLCJsaXN0ZW5UbyIsIm9uQ2VsbEF0dHJpYnV0ZUNoYW5nZSIsInNvbWUiLCJhdHRyaWJ1dGUiLCJoYXNDaGFuZ2VkIiwiX3ZpZXdzIiwib3B0IiwidW5pcXVlSWQiLCJhZGQiLCJnZXQiLCJjaWQiLCJyZWZzIiwidmlld3MiLCJoaWQiLCJyZWYiLCJwdXNoIiwiRXJyb3IiLCJwcmV2aW91c1ZpZXciLCJ2aWV3IiwiX2FkZFJlZiIsIl8iLCJmb3JFYWNoIiwicmVtb3ZlQWxsIiwiZGlydHkiLCJlbnN1cmVJZCIsIkpTT04iLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/Link.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/dia/Link.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link)\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n\n\n\n// Link base model.\n// --------------------------\nconst Link = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n    // The default markup for links.\n    markup: [\n        '<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n        '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n        '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n        '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>',\n        '<g class=\"labels\"/>',\n        '<g class=\"marker-vertices\"/>',\n        '<g class=\"marker-arrowheads\"/>',\n        '<g class=\"link-tools\"/>'\n    ].join(\"\"),\n    toolMarkup: [\n        '<g class=\"link-tool\">',\n        '<g class=\"tool-remove\" event=\"remove\">',\n        '<circle r=\"11\" />',\n        '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />',\n        \"<title>Remove link.</title>\",\n        \"</g>\",\n        '<g class=\"tool-options\" event=\"link:options\">',\n        '<circle r=\"11\" transform=\"translate(25)\"/>',\n        '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>',\n        \"<title>Link options.</title>\",\n        \"</g>\",\n        \"</g>\"\n    ].join(\"\"),\n    doubleToolMarkup: undefined,\n    // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).\n    // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for\n    // dragging vertices (changing their position). The latter is used for removing vertices.\n    vertexMarkup: [\n        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n        \"<title>Remove vertex.</title>\",\n        \"</path>\",\n        \"</g>\"\n    ].join(\"\"),\n    arrowheadMarkup: [\n        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n        '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />',\n        \"</g>\"\n    ].join(\"\"),\n    // may be overwritten by user to change default label (its markup, size, attrs, position)\n    defaultLabel: undefined,\n    // deprecated\n    // may be overwritten by user to change default label markup\n    // lower priority than defaultLabel.markup\n    labelMarkup: undefined,\n    // private\n    _builtins: {\n        defaultLabel: {\n            // builtin default markup:\n            // used if neither defaultLabel.markup\n            // nor label.markup is set\n            markup: [\n                {\n                    tagName: \"rect\",\n                    selector: \"rect\" // faster than tagName CSS selector\n                },\n                {\n                    tagName: \"text\",\n                    selector: \"text\" // faster than tagName CSS selector\n                }\n            ],\n            // builtin default attributes:\n            // applied only if builtin default markup is used\n            attrs: {\n                text: {\n                    fill: \"#000000\",\n                    fontSize: 14,\n                    textAnchor: \"middle\",\n                    yAlignment: \"middle\",\n                    pointerEvents: \"none\"\n                },\n                rect: {\n                    ref: \"text\",\n                    fill: \"#ffffff\",\n                    rx: 3,\n                    ry: 3,\n                    refWidth: 1,\n                    refHeight: 1,\n                    refX: 0,\n                    refY: 0\n                }\n            },\n            // builtin default position:\n            // used if neither defaultLabel.position\n            // nor label.position is set\n            position: {\n                distance: 0.5\n            }\n        }\n    },\n    defaults: {\n        type: \"link\",\n        source: {},\n        target: {}\n    },\n    isLink: function() {\n        return true;\n    },\n    disconnect: function(opt) {\n        return this.set({\n            source: {\n                x: 0,\n                y: 0\n            },\n            target: {\n                x: 0,\n                y: 0\n            }\n        }, opt);\n    },\n    source: function(source, args, opt) {\n        // getter\n        if (source === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get(\"source\"));\n        }\n        // setter\n        var setSource;\n        var setOpt;\n        // `source` is a cell\n        // take only its `id` and combine with `args`\n        var isCellProvided = source instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) {\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.id = source.id;\n            setOpt = opt;\n            return this.set(\"source\", setSource, setOpt);\n        }\n        // `source` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(source);\n        if (isPointProvided) {\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.x = source.x;\n            setSource.y = source.y;\n            setOpt = opt;\n            return this.set(\"source\", setSource, setOpt);\n        }\n        // `source` is an object\n        // no checking\n        // two arguments\n        setSource = source;\n        setOpt = args;\n        return this.set(\"source\", setSource, setOpt);\n    },\n    target: function(target, args, opt) {\n        // getter\n        if (target === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get(\"target\"));\n        }\n        // setter\n        var setTarget;\n        var setOpt;\n        // `target` is a cell\n        // take only its `id` argument and combine with `args`\n        var isCellProvided = target instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) {\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.id = target.id;\n            setOpt = opt;\n            return this.set(\"target\", setTarget, setOpt);\n        }\n        // `target` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(target);\n        if (isPointProvided) {\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.x = target.x;\n            setTarget.y = target.y;\n            setOpt = opt;\n            return this.set(\"target\", setTarget, setOpt);\n        }\n        // `target` is an object\n        // no checking\n        // two arguments\n        setTarget = target;\n        setOpt = args;\n        return this.set(\"target\", setTarget, setOpt);\n    },\n    router: function(name, args, opt) {\n        // getter\n        if (name === undefined) {\n            var router = this.get(\"router\");\n            if (!router) {\n                if (this.get(\"manhattan\")) return {\n                    name: \"orthogonal\"\n                }; // backwards compatibility\n                return null;\n            }\n            if (typeof router === \"object\") return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(router);\n            return router; // e.g. a function\n        }\n        // setter\n        var isRouterProvided = typeof name === \"object\" || typeof name === \"function\";\n        var localRouter = isRouterProvided ? name : {\n            name: name,\n            args: args\n        };\n        var localOpt = isRouterProvided ? args : opt;\n        return this.set(\"router\", localRouter, localOpt);\n    },\n    connector: function(name, args, opt) {\n        // getter\n        if (name === undefined) {\n            var connector = this.get(\"connector\");\n            if (!connector) {\n                if (this.get(\"smooth\")) return {\n                    name: \"smooth\"\n                }; // backwards compatibility\n                return null;\n            }\n            if (typeof connector === \"object\") return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(connector);\n            return connector; // e.g. a function\n        }\n        // setter\n        var isConnectorProvided = typeof name === \"object\" || typeof name === \"function\";\n        var localConnector = isConnectorProvided ? name : {\n            name: name,\n            args: args\n        };\n        var localOpt = isConnectorProvided ? args : opt;\n        return this.set(\"connector\", localConnector, localOpt);\n    },\n    // Labels API\n    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n    label: function(idx, label, opt) {\n        var labels = this.labels();\n        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n        if (idx < 0) idx = labels.length + idx;\n        // getter\n        if (arguments.length <= 1) return this.prop([\n            \"labels\",\n            idx\n        ]);\n        // setter\n        return this.prop([\n            \"labels\",\n            idx\n        ], label, opt);\n    },\n    labels: function(labels, opt) {\n        // getter\n        if (arguments.length === 0) {\n            labels = this.get(\"labels\");\n            if (!Array.isArray(labels)) return [];\n            return labels.slice();\n        }\n        // setter\n        if (!Array.isArray(labels)) labels = [];\n        return this.set(\"labels\", labels, opt);\n    },\n    hasLabels: function() {\n        const { labels } = this.attributes;\n        return Array.isArray(labels) && labels.length > 0;\n    },\n    insertLabel: function(idx, label, opt) {\n        if (!label) throw new Error(\"dia.Link: no label provided\");\n        var labels = this.labels();\n        var n = labels.length;\n        idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n        if (idx < 0) idx = n + idx + 1;\n        labels.splice(idx, 0, label);\n        return this.labels(labels, opt);\n    },\n    // convenience function\n    // add label to end of labels array\n    appendLabel: function(label, opt) {\n        return this.insertLabel(-1, label, opt);\n    },\n    removeLabel: function(idx, opt) {\n        var labels = this.labels();\n        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n        labels.splice(idx, 1);\n        return this.labels(labels, opt);\n    },\n    // Vertices API\n    vertex: function(idx, vertex, opt) {\n        var vertices = this.vertices();\n        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n        if (idx < 0) idx = vertices.length + idx;\n        // getter\n        if (arguments.length <= 1) return this.prop([\n            \"vertices\",\n            idx\n        ]);\n        // setter\n        var setVertex = this._normalizeVertex(vertex);\n        return this.prop([\n            \"vertices\",\n            idx\n        ], setVertex, opt);\n    },\n    vertices: function(vertices, opt) {\n        // getter\n        if (arguments.length === 0) {\n            vertices = this.get(\"vertices\");\n            if (!Array.isArray(vertices)) return [];\n            return vertices.slice();\n        }\n        // setter\n        if (!Array.isArray(vertices)) vertices = [];\n        var setVertices = [];\n        for(var i = 0; i < vertices.length; i++){\n            var vertex = vertices[i];\n            var setVertex = this._normalizeVertex(vertex);\n            setVertices.push(setVertex);\n        }\n        return this.set(\"vertices\", setVertices, opt);\n    },\n    insertVertex: function(idx, vertex, opt) {\n        if (!vertex) throw new Error(\"dia.Link: no vertex provided\");\n        var vertices = this.vertices();\n        var n = vertices.length;\n        idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n        if (idx < 0) idx = n + idx + 1;\n        var setVertex = this._normalizeVertex(vertex);\n        vertices.splice(idx, 0, setVertex);\n        return this.vertices(vertices, opt);\n    },\n    removeVertex: function(idx, opt) {\n        var vertices = this.vertices();\n        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n        vertices.splice(idx, 1);\n        return this.vertices(vertices, opt);\n    },\n    _normalizeVertex: function(vertex) {\n        // is vertex a point-like object?\n        // for example, a g.Point\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(vertex);\n        if (isPointProvided) return {\n            x: vertex.x,\n            y: vertex.y\n        };\n        // else: return vertex unchanged\n        return vertex;\n    },\n    // Transformations\n    translate: function(tx, ty, opt) {\n        // enrich the option object\n        opt = opt || {};\n        opt.translateBy = opt.translateBy || this.id;\n        opt.tx = tx;\n        opt.ty = ty;\n        return this.applyToPoints(function(p) {\n            return {\n                x: (p.x || 0) + tx,\n                y: (p.y || 0) + ty\n            };\n        }, opt);\n    },\n    scale: function(sx, sy, origin, opt) {\n        return this.applyToPoints(function(p) {\n            return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(p).scale(sx, sy, origin).toJSON();\n        }, opt);\n    },\n    applyToPoints: function(fn, opt) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\n            throw new TypeError(\"dia.Link: applyToPoints expects its first parameter to be a function.\");\n        }\n        var attrs = {};\n        var { source, target } = this.attributes;\n        if (!source.id) {\n            attrs.source = fn(source);\n        }\n        if (!target.id) {\n            attrs.target = fn(target);\n        }\n        var vertices = this.vertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(fn);\n        }\n        return this.set(attrs, opt);\n    },\n    getSourcePoint: function() {\n        var sourceCell = this.getSourceCell();\n        if (!sourceCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.source());\n        return sourceCell.getPointFromConnectedLink(this, \"source\");\n    },\n    getTargetPoint: function() {\n        var targetCell = this.getTargetCell();\n        if (!targetCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.target());\n        return targetCell.getPointFromConnectedLink(this, \"target\");\n    },\n    getPointFromConnectedLink: function() {\n        return this.getPolyline().pointAt(0.5);\n    },\n    getPolyline: function() {\n        const points = [\n            this.getSourcePoint(),\n            ...this.vertices().map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point),\n            this.getTargetPoint()\n        ];\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n    },\n    getBBox: function() {\n        return this.getPolyline().bbox();\n    },\n    reparent: function(opt) {\n        var newParent;\n        if (this.graph) {\n            var source = this.getSourceElement();\n            var target = this.getTargetElement();\n            var prevParent = this.getParentCell();\n            if (source && target) {\n                if (source === target || source.isEmbeddedIn(target)) {\n                    newParent = target;\n                } else if (target.isEmbeddedIn(source)) {\n                    newParent = source;\n                } else {\n                    newParent = this.graph.getCommonAncestor(source, target);\n                }\n            }\n            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n                // Unembed the link if source and target has no common ancestor\n                // or common ancestor changed\n                prevParent.unembed(this, opt);\n            }\n            if (newParent) {\n                newParent.embed(this, opt);\n            }\n        }\n        return newParent;\n    },\n    hasLoop: function(opt) {\n        opt = opt || {};\n        var { source, target } = this.attributes;\n        var sourceId = source.id;\n        var targetId = target.id;\n        if (!sourceId || !targetId) {\n            // Link \"pinned\" to the paper does not have a loop.\n            return false;\n        }\n        var loop = sourceId === targetId;\n        // Note that there in the deep mode a link can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        if (!loop && opt.deep && this.graph) {\n            var sourceElement = this.getSourceCell();\n            var targetElement = this.getTargetCell();\n            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n        }\n        return loop;\n    },\n    // unlike source(), this method returns null if source is a point\n    getSourceCell: function() {\n        const { graph, attributes } = this;\n        var source = attributes.source;\n        return source && source.id && graph && graph.getCell(source.id) || null;\n    },\n    getSourceElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getSourceCell();\n        }while (cell && cell.isLink());\n        return cell;\n    },\n    // unlike target(), this method returns null if target is a point\n    getTargetCell: function() {\n        const { graph, attributes } = this;\n        var target = attributes.target;\n        return target && target.id && graph && graph.getCell(target.id) || null;\n    },\n    getTargetElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getTargetCell();\n        }while (cell && cell.isLink());\n        return cell;\n    },\n    // Returns the common ancestor for the source element,\n    // target element and the link itself.\n    getRelationshipAncestor: function() {\n        var connectionAncestor;\n        if (this.graph) {\n            var cells = [\n                this,\n                this.getSourceElement(),\n                this.getTargetElement() // null if target is a point\n            ].filter(function(item) {\n                return !!item;\n            });\n            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n        }\n        return connectionAncestor || null;\n    },\n    // Is source, target and the link itself embedded in a given cell?\n    isRelationshipEmbeddedIn: function(cell) {\n        var cellId = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(cell) ? cell : cell.id;\n        var ancestor = this.getRelationshipAncestor();\n        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n    },\n    // Get resolved default label.\n    _getDefaultLabel: function() {\n        var defaultLabel = this.get(\"defaultLabel\") || this.defaultLabel || {};\n        var label = {};\n        label.markup = defaultLabel.markup || this.get(\"labelMarkup\") || this.labelMarkup;\n        label.position = defaultLabel.position;\n        label.attrs = defaultLabel.attrs;\n        label.size = defaultLabel.size;\n        return label;\n    }\n}, {\n    endsEqual: function(a, b) {\n        var portsEqual = a.port === b.port || !a.port && !b.port;\n        return a.id === b.id && portsEqual;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0xpbmsubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtDO0FBQ3VEO0FBQ3hDO0FBRWpELG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFFdEIsTUFBTVEsT0FBT1IsMkNBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUU1QixnQ0FBZ0M7SUFDaENDLFFBQVE7UUFDSjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0gsQ0FBQ0MsSUFBSSxDQUFDO0lBRVBDLFlBQVk7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSCxDQUFDRCxJQUFJLENBQUM7SUFFUEUsa0JBQWtCQztJQUVsQix5SUFBeUk7SUFDekkscUdBQXFHO0lBQ3JHLHlGQUF5RjtJQUN6RkMsY0FBYztRQUNWO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0gsQ0FBQ0osSUFBSSxDQUFDO0lBRVBLLGlCQUFpQjtRQUNiO1FBQ0E7UUFDQTtLQUNILENBQUNMLElBQUksQ0FBQztJQUVQLHlGQUF5RjtJQUN6Rk0sY0FBY0g7SUFFZCxhQUFhO0lBQ2IsNERBQTREO0lBQzVELDBDQUEwQztJQUMxQ0ksYUFBYUo7SUFFYixVQUFVO0lBQ1ZLLFdBQVc7UUFDUEYsY0FBYztZQUNWLDBCQUEwQjtZQUMxQixzQ0FBc0M7WUFDdEMsMEJBQTBCO1lBQzFCUCxRQUFRO2dCQUNKO29CQUNJVSxTQUFTO29CQUNUQyxVQUFVLE9BQU8sbUNBQW1DO2dCQUN4RDtnQkFBRztvQkFDQ0QsU0FBUztvQkFDVEMsVUFBVSxPQUFPLG1DQUFtQztnQkFDeEQ7YUFDSDtZQUNELDhCQUE4QjtZQUM5QixpREFBaUQ7WUFDakRDLE9BQU87Z0JBQ0hDLE1BQU07b0JBQ0ZDLE1BQU07b0JBQ05DLFVBQVU7b0JBQ1ZDLFlBQVk7b0JBQ1pDLFlBQVk7b0JBQ1pDLGVBQWU7Z0JBQ25CO2dCQUNB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QjtRQUN4RTtRQUVBLE9BQU9ELHNCQUFzQjtJQUNqQztJQUVBLGtFQUFrRTtJQUNsRUssMEJBQTBCLFNBQVNSLElBQUk7UUFFbkMsSUFBSVMsU0FBUywwREFBVVQsU0FBU3BJLHlEQUFRQSxDQUFDb0ksUUFBU0EsT0FBT0EsS0FBS25GLEVBQUU7UUFDaEUsSUFBSTZGLFdBQVcsSUFBSSxDQUFDUix1QkFBdUI7UUFFM0MsT0FBTyxDQUFDLENBQUNRLFlBQWFBLENBQUFBLFNBQVM3RixFQUFFLEtBQUs0RixVQUFVQyxTQUFTdEIsWUFBWSxDQUFDcUIsT0FBTTtJQUNoRjtJQUVBLDhCQUE4QjtJQUM5QkUsa0JBQWtCO1FBRWQsSUFBSW5JLGVBQWUsSUFBSSxDQUFDaUMsR0FBRyxDQUFDLG1CQUFtQixJQUFJLENBQUNqQyxZQUFZLElBQUksQ0FBQztRQUVyRSxJQUFJZ0QsUUFBUSxDQUFDO1FBQ2JBLE1BQU12RCxNQUFNLEdBQUdPLGFBQWFQLE1BQU0sSUFBSSxJQUFJLENBQUN3QyxHQUFHLENBQUMsa0JBQWtCLElBQUksQ0FBQ2hDLFdBQVc7UUFDakYrQyxNQUFNNUIsUUFBUSxHQUFHcEIsYUFBYW9CLFFBQVE7UUFDdEM0QixNQUFNM0MsS0FBSyxHQUFHTCxhQUFhSyxLQUFLO1FBQ2hDMkMsTUFBTW9GLElBQUksR0FBR3BJLGFBQWFvSSxJQUFJO1FBRTlCLE9BQU9wRjtJQUNYO0FBQ0osR0FBRztJQUVDcUYsV0FBVyxTQUFTQyxDQUFDLEVBQUVDLENBQUM7UUFFcEIsSUFBSUMsYUFBYUYsRUFBRUcsSUFBSSxLQUFLRixFQUFFRSxJQUFJLElBQUksQ0FBQ0gsRUFBRUcsSUFBSSxJQUFJLENBQUNGLEVBQUVFLElBQUk7UUFDeEQsT0FBT0gsRUFBRWpHLEVBQUUsS0FBS2tHLEVBQUVsRyxFQUFFLElBQUltRztJQUM1QjtBQUNKLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvTGluay5tanM/NmU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsLm1qcyc7XG5pbXBvcnQgeyBjbG9uZSwgaXNQbGFpbk9iamVjdCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgUG9pbnQsIFBvbHlsaW5lIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG4vLyBMaW5rIGJhc2UgbW9kZWwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgTGluayA9IENlbGwuZXh0ZW5kKHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1hcmt1cCBmb3IgbGlua3MuXG4gICAgbWFya3VwOiBbXG4gICAgICAgICc8cGF0aCBjbGFzcz1cImNvbm5lY3Rpb25cIiBzdHJva2U9XCJibGFja1wiIGQ9XCJNIDAgMCAwIDBcIi8+JyxcbiAgICAgICAgJzxwYXRoIGNsYXNzPVwibWFya2VyLXNvdXJjZVwiIGZpbGw9XCJibGFja1wiIHN0cm9rZT1cImJsYWNrXCIgZD1cIk0gMCAwIDAgMFwiLz4nLFxuICAgICAgICAnPHBhdGggY2xhc3M9XCJtYXJrZXItdGFyZ2V0XCIgZmlsbD1cImJsYWNrXCIgc3Ryb2tlPVwiYmxhY2tcIiBkPVwiTSAwIDAgMCAwXCIvPicsXG4gICAgICAgICc8cGF0aCBjbGFzcz1cImNvbm5lY3Rpb24td3JhcFwiIGQ9XCJNIDAgMCAwIDBcIi8+JyxcbiAgICAgICAgJzxnIGNsYXNzPVwibGFiZWxzXCIvPicsXG4gICAgICAgICc8ZyBjbGFzcz1cIm1hcmtlci12ZXJ0aWNlc1wiLz4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJtYXJrZXItYXJyb3doZWFkc1wiLz4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJsaW5rLXRvb2xzXCIvPidcbiAgICBdLmpvaW4oJycpLFxuXG4gICAgdG9vbE1hcmt1cDogW1xuICAgICAgICAnPGcgY2xhc3M9XCJsaW5rLXRvb2xcIj4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJ0b29sLXJlbW92ZVwiIGV2ZW50PVwicmVtb3ZlXCI+JyxcbiAgICAgICAgJzxjaXJjbGUgcj1cIjExXCIgLz4nLFxuICAgICAgICAnPHBhdGggdHJhbnNmb3JtPVwic2NhbGUoLjgpIHRyYW5zbGF0ZSgtMTYsIC0xNilcIiBkPVwiTTI0Ljc3OCwyMS40MTkgMTkuMjc2LDE1LjkxNyAyNC43NzcsMTAuNDE1IDIxLjk0OSw3LjU4NSAxNi40NDcsMTMuMDg3IDEwLjk0NSw3LjU4NSA4LjExNywxMC40MTUgMTMuNjE4LDE1LjkxNyA4LjExNiwyMS40MTkgMTAuOTQ2LDI0LjI0OCAxNi40NDcsMTguNzQ2IDIxLjk0OCwyNC4yNDh6XCIgLz4nLFxuICAgICAgICAnPHRpdGxlPlJlbW92ZSBsaW5rLjwvdGl0bGU+JyxcbiAgICAgICAgJzwvZz4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJ0b29sLW9wdGlvbnNcIiBldmVudD1cImxpbms6b3B0aW9uc1wiPicsXG4gICAgICAgICc8Y2lyY2xlIHI9XCIxMVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyNSlcIi8+JyxcbiAgICAgICAgJzxwYXRoIGZpbGw9XCJ3aGl0ZVwiIHRyYW5zZm9ybT1cInNjYWxlKC41NSkgdHJhbnNsYXRlKDI5LCAtMTYpXCIgZD1cIk0zMS4yMjksMTcuNzM2YzAuMDY0LTAuNTcxLDAuMTA0LTEuMTQ4LDAuMTA0LTEuNzM2cy0wLjA0LTEuMTY2LTAuMTA0LTEuNzM3bC00LjM3Ny0xLjU1N2MtMC4yMTgtMC43MTYtMC41MDQtMS40MDEtMC44NTEtMi4wNWwxLjk5My00LjE5MmMtMC43MjUtMC45MS0xLjU0OS0xLjczNC0yLjQ1OC0yLjQ1OWwtNC4xOTMsMS45OTRjLTAuNjQ3LTAuMzQ3LTEuMzM0LTAuNjMyLTIuMDQ5LTAuODQ5bC0xLjU1OC00LjM3OEMxNy4xNjUsMC43MDgsMTYuNTg4LDAuNjY3LDE2LDAuNjY3cy0xLjE2NiwwLjA0MS0xLjczNywwLjEwNUwxMi43MDcsNS4xNWMtMC43MTYsMC4yMTctMS40MDEsMC41MDItMi4wNSwwLjg0OUw2LjQ2NCw0LjAwNUM1LjU1NCw0LjczLDQuNzMsNS41NTQsNC4wMDUsNi40NjRsMS45OTQsNC4xOTJjLTAuMzQ3LDAuNjQ4LTAuNjMyLDEuMzM0LTAuODQ5LDIuMDVsLTQuMzc4LDEuNTU3QzAuNzA4LDE0LjgzNCwwLjY2NywxNS40MTIsMC42NjcsMTZzMC4wNDEsMS4xNjUsMC4xMDUsMS43MzZsNC4zNzgsMS41NThjMC4yMTcsMC43MTUsMC41MDIsMS40MDEsMC44NDksMi4wNDlsLTEuOTk0LDQuMTkzYzAuNzI1LDAuOTA5LDEuNTQ5LDEuNzMzLDIuNDU5LDIuNDU4bDQuMTkyLTEuOTkzYzAuNjQ4LDAuMzQ3LDEuMzM0LDAuNjMzLDIuMDUsMC44NTFsMS41NTcsNC4zNzdjMC41NzEsMC4wNjQsMS4xNDgsMC4xMDQsMS43MzcsMC4xMDRjMC41ODgsMCwxLjE2NS0wLjA0LDEuNzM2LTAuMTA0bDEuNTU4LTQuMzc3YzAuNzE1LTAuMjE4LDEuMzk5LTAuNTA0LDIuMDQ5LTAuODUxbDQuMTkzLDEuOTkzYzAuOTA5LTAuNzI1LDEuNzMzLTEuNTQ5LDIuNDU4LTIuNDU4bC0xLjk5My00LjE5M2MwLjM0Ny0wLjY0NywwLjYzMy0xLjMzNCwwLjg1MS0yLjA0OUwzMS4yMjksMTcuNzM2ek0xNiwyMC44NzFjLTIuNjksMC00Ljg3Mi0yLjE4Mi00Ljg3Mi00Ljg3MWMwLTIuNjksMi4xODItNC44NzIsNC44NzItNC44NzJjMi42ODksMCw0Ljg3MSwyLjE4Miw0Ljg3MSw0Ljg3MkMyMC44NzEsMTguNjg5LDE4LjY4OSwyMC44NzEsMTYsMjAuODcxelwiLz4nLFxuICAgICAgICAnPHRpdGxlPkxpbmsgb3B0aW9ucy48L3RpdGxlPicsXG4gICAgICAgICc8L2c+JyxcbiAgICAgICAgJzwvZz4nXG4gICAgXS5qb2luKCcnKSxcblxuICAgIGRvdWJsZVRvb2xNYXJrdXA6IHVuZGVmaW5lZCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1hcmt1cCBmb3Igc2hvd2luZy9yZW1vdmluZyB2ZXJ0aWNlcy4gVGhlc2UgZWxlbWVudHMgYXJlIHRoZSBjaGlsZHJlbiBvZiB0aGUgLm1hcmtlci12ZXJ0aWNlcyBlbGVtZW50IChzZWUgYHRoaXMubWFya3VwYCkuXG4gICAgLy8gT25seSAubWFya2VyLXZlcnRleCBhbmQgLm1hcmtlci12ZXJ0ZXgtcmVtb3ZlIGVsZW1lbnQgaGF2ZSBzcGVjaWFsIG1lYW5pbmcuIFRoZSBmb3JtZXIgaXMgdXNlZCBmb3JcbiAgICAvLyBkcmFnZ2luZyB2ZXJ0aWNlcyAoY2hhbmdpbmcgdGhlaXIgcG9zaXRpb24pLiBUaGUgbGF0dGVyIGlzIHVzZWQgZm9yIHJlbW92aW5nIHZlcnRpY2VzLlxuICAgIHZlcnRleE1hcmt1cDogW1xuICAgICAgICAnPGcgY2xhc3M9XCJtYXJrZXItdmVydGV4LWdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDwlPSB4ICU+LCA8JT0geSAlPilcIj4nLFxuICAgICAgICAnPGNpcmNsZSBjbGFzcz1cIm1hcmtlci12ZXJ0ZXhcIiBpZHg9XCI8JT0gaWR4ICU+XCIgcj1cIjEwXCIgLz4nLFxuICAgICAgICAnPHBhdGggY2xhc3M9XCJtYXJrZXItdmVydGV4LXJlbW92ZS1hcmVhXCIgaWR4PVwiPCU9IGlkeCAlPlwiIGQ9XCJNMTYsNS4zMzNjLTcuNzMyLDAtMTQsNC43MDEtMTQsMTAuNWMwLDEuOTgyLDAuNzQxLDMuODMzLDIuMDE2LDUuNDE0TDIsMjUuNjY3bDUuNjEzLTEuNDQxYzIuMzM5LDEuMzE3LDUuMjM3LDIuMTA3LDguMzg3LDIuMTA3YzcuNzMyLDAsMTQtNC43MDEsMTQtMTAuNUMzMCwxMC4wMzQsMjMuNzMyLDUuMzMzLDE2LDUuMzMzelwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg1LCAtMzMpXCIvPicsXG4gICAgICAgICc8cGF0aCBjbGFzcz1cIm1hcmtlci12ZXJ0ZXgtcmVtb3ZlXCIgaWR4PVwiPCU9IGlkeCAlPlwiIHRyYW5zZm9ybT1cInNjYWxlKC44KSB0cmFuc2xhdGUoOS41LCAtMzcpXCIgZD1cIk0yNC43NzgsMjEuNDE5IDE5LjI3NiwxNS45MTcgMjQuNzc3LDEwLjQxNSAyMS45NDksNy41ODUgMTYuNDQ3LDEzLjA4NyAxMC45NDUsNy41ODUgOC4xMTcsMTAuNDE1IDEzLjYxOCwxNS45MTcgOC4xMTYsMjEuNDE5IDEwLjk0NiwyNC4yNDggMTYuNDQ3LDE4Ljc0NiAyMS45NDgsMjQuMjQ4elwiPicsXG4gICAgICAgICc8dGl0bGU+UmVtb3ZlIHZlcnRleC48L3RpdGxlPicsXG4gICAgICAgICc8L3BhdGg+JyxcbiAgICAgICAgJzwvZz4nXG4gICAgXS5qb2luKCcnKSxcblxuICAgIGFycm93aGVhZE1hcmt1cDogW1xuICAgICAgICAnPGcgY2xhc3M9XCJtYXJrZXItYXJyb3doZWFkLWdyb3VwIG1hcmtlci1hcnJvd2hlYWQtZ3JvdXAtPCU9IGVuZCAlPlwiPicsXG4gICAgICAgICc8cGF0aCBjbGFzcz1cIm1hcmtlci1hcnJvd2hlYWRcIiBlbmQ9XCI8JT0gZW5kICU+XCIgZD1cIk0gMjYgMCBMIDAgMTMgTCAyNiAyNiB6XCIgLz4nLFxuICAgICAgICAnPC9nPidcbiAgICBdLmpvaW4oJycpLFxuXG4gICAgLy8gbWF5IGJlIG92ZXJ3cml0dGVuIGJ5IHVzZXIgdG8gY2hhbmdlIGRlZmF1bHQgbGFiZWwgKGl0cyBtYXJrdXAsIHNpemUsIGF0dHJzLCBwb3NpdGlvbilcbiAgICBkZWZhdWx0TGFiZWw6IHVuZGVmaW5lZCxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAvLyBtYXkgYmUgb3ZlcndyaXR0ZW4gYnkgdXNlciB0byBjaGFuZ2UgZGVmYXVsdCBsYWJlbCBtYXJrdXBcbiAgICAvLyBsb3dlciBwcmlvcml0eSB0aGFuIGRlZmF1bHRMYWJlbC5tYXJrdXBcbiAgICBsYWJlbE1hcmt1cDogdW5kZWZpbmVkLFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9idWlsdGluczoge1xuICAgICAgICBkZWZhdWx0TGFiZWw6IHtcbiAgICAgICAgICAgIC8vIGJ1aWx0aW4gZGVmYXVsdCBtYXJrdXA6XG4gICAgICAgICAgICAvLyB1c2VkIGlmIG5laXRoZXIgZGVmYXVsdExhYmVsLm1hcmt1cFxuICAgICAgICAgICAgLy8gbm9yIGxhYmVsLm1hcmt1cCBpcyBzZXRcbiAgICAgICAgICAgIG1hcmt1cDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3JlY3QnIC8vIGZhc3RlciB0aGFuIHRhZ05hbWUgQ1NTIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndGV4dCcgLy8gZmFzdGVyIHRoYW4gdGFnTmFtZSBDU1Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gYnVpbHRpbiBkZWZhdWx0IGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAvLyBhcHBsaWVkIG9ubHkgaWYgYnVpbHRpbiBkZWZhdWx0IG1hcmt1cCBpcyB1c2VkXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICB5QWxpZ25tZW50OiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgIHJ4OiAzLFxuICAgICAgICAgICAgICAgICAgICByeTogMyxcbiAgICAgICAgICAgICAgICAgICAgcmVmV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHJlZkhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgcmVmWDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVmWTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBidWlsdGluIGRlZmF1bHQgcG9zaXRpb246XG4gICAgICAgICAgICAvLyB1c2VkIGlmIG5laXRoZXIgZGVmYXVsdExhYmVsLnBvc2l0aW9uXG4gICAgICAgICAgICAvLyBub3IgbGFiZWwucG9zaXRpb24gaXMgc2V0XG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAwLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWZhdWx0czoge1xuICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgIHNvdXJjZToge30sXG4gICAgICAgIHRhcmdldDoge31cbiAgICB9LFxuXG4gICAgaXNMaW5rOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHNvdXJjZTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICB0YXJnZXQ6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH0sIG9wdCk7XG4gICAgfSxcblxuICAgIHNvdXJjZTogZnVuY3Rpb24oc291cmNlLCBhcmdzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5nZXQoJ3NvdXJjZScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgc2V0U291cmNlO1xuICAgICAgICB2YXIgc2V0T3B0O1xuXG4gICAgICAgIC8vIGBzb3VyY2VgIGlzIGEgY2VsbFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGBpZGAgYW5kIGNvbWJpbmUgd2l0aCBgYXJnc2BcbiAgICAgICAgdmFyIGlzQ2VsbFByb3ZpZGVkID0gc291cmNlIGluc3RhbmNlb2YgQ2VsbDtcbiAgICAgICAgaWYgKGlzQ2VsbFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0U291cmNlID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRTb3VyY2UuaWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgICAgICBzZXRPcHQgPSBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3NvdXJjZScsIHNldFNvdXJjZSwgc2V0T3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBzb3VyY2VgIGlzIGEgcG9pbnQtbGlrZSBvYmplY3RcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgZy5Qb2ludFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGB4YCBhbmQgYHlgIGFuZCBjb21iaW5lIHdpdGggYGFyZ3NgXG4gICAgICAgIHZhciBpc1BvaW50UHJvdmlkZWQgPSAhaXNQbGFpbk9iamVjdChzb3VyY2UpO1xuICAgICAgICBpZiAoaXNQb2ludFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0U291cmNlID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRTb3VyY2UueCA9IHNvdXJjZS54O1xuICAgICAgICAgICAgc2V0U291cmNlLnkgPSBzb3VyY2UueTtcbiAgICAgICAgICAgIHNldE9wdCA9IG9wdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCgnc291cmNlJywgc2V0U291cmNlLCBzZXRPcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHNvdXJjZWAgaXMgYW4gb2JqZWN0XG4gICAgICAgIC8vIG5vIGNoZWNraW5nXG4gICAgICAgIC8vIHR3byBhcmd1bWVudHNcbiAgICAgICAgc2V0U291cmNlID0gc291cmNlO1xuICAgICAgICBzZXRPcHQgPSBhcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3NvdXJjZScsIHNldFNvdXJjZSwgc2V0T3B0KTtcbiAgICB9LFxuXG4gICAgdGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSh0aGlzLmdldCgndGFyZ2V0JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHZhciBzZXRUYXJnZXQ7XG4gICAgICAgIHZhciBzZXRPcHQ7XG5cbiAgICAgICAgLy8gYHRhcmdldGAgaXMgYSBjZWxsXG4gICAgICAgIC8vIHRha2Ugb25seSBpdHMgYGlkYCBhcmd1bWVudCBhbmQgY29tYmluZSB3aXRoIGBhcmdzYFxuICAgICAgICB2YXIgaXNDZWxsUHJvdmlkZWQgPSB0YXJnZXQgaW5zdGFuY2VvZiBDZWxsO1xuICAgICAgICBpZiAoaXNDZWxsUHJvdmlkZWQpIHsgLy8gdGhyZWUgYXJndW1lbnRzXG4gICAgICAgICAgICBzZXRUYXJnZXQgPSBjbG9uZShhcmdzKSB8fCB7fTtcbiAgICAgICAgICAgIHNldFRhcmdldC5pZCA9IHRhcmdldC5pZDtcbiAgICAgICAgICAgIHNldE9wdCA9IG9wdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCgndGFyZ2V0Jywgc2V0VGFyZ2V0LCBzZXRPcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHRhcmdldGAgaXMgYSBwb2ludC1saWtlIG9iamVjdFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBnLlBvaW50XG4gICAgICAgIC8vIHRha2Ugb25seSBpdHMgYHhgIGFuZCBgeWAgYW5kIGNvbWJpbmUgd2l0aCBgYXJnc2BcbiAgICAgICAgdmFyIGlzUG9pbnRQcm92aWRlZCA9ICFpc1BsYWluT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGlmIChpc1BvaW50UHJvdmlkZWQpIHsgLy8gdGhyZWUgYXJndW1lbnRzXG4gICAgICAgICAgICBzZXRUYXJnZXQgPSBjbG9uZShhcmdzKSB8fCB7fTtcbiAgICAgICAgICAgIHNldFRhcmdldC54ID0gdGFyZ2V0Lng7XG4gICAgICAgICAgICBzZXRUYXJnZXQueSA9IHRhcmdldC55O1xuICAgICAgICAgICAgc2V0T3B0ID0gb3B0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCd0YXJnZXQnLCBzZXRUYXJnZXQsIHNldE9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgdGFyZ2V0YCBpcyBhbiBvYmplY3RcbiAgICAgICAgLy8gbm8gY2hlY2tpbmdcbiAgICAgICAgLy8gdHdvIGFyZ3VtZW50c1xuICAgICAgICBzZXRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHNldE9wdCA9IGFyZ3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNldCgndGFyZ2V0Jywgc2V0VGFyZ2V0LCBzZXRPcHQpO1xuICAgIH0sXG5cbiAgICByb3V0ZXI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5nZXQoJ3JvdXRlcicpO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoJ21hbmhhdHRhbicpKSByZXR1cm4geyBuYW1lOiAnb3J0aG9nb25hbCcgfTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGVyID09PSAnb2JqZWN0JykgcmV0dXJuIGNsb25lKHJvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyOyAvLyBlLmcuIGEgZnVuY3Rpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgaXNSb3V0ZXJQcm92aWRlZCA9ICgodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB8fCAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpKTtcbiAgICAgICAgdmFyIGxvY2FsUm91dGVyID0gaXNSb3V0ZXJQcm92aWRlZCA/IG5hbWUgOiB7IG5hbWU6IG5hbWUsIGFyZ3M6IGFyZ3MgfTtcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0gaXNSb3V0ZXJQcm92aWRlZCA/IGFyZ3MgOiBvcHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdyb3V0ZXInLCBsb2NhbFJvdXRlciwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICBjb25uZWN0b3I6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy5nZXQoJ2Nvbm5lY3RvcicpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoJ3Ntb290aCcpKSByZXR1cm4geyBuYW1lOiAnc21vb3RoJyB9OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0b3IgPT09ICdvYmplY3QnKSByZXR1cm4gY2xvbmUoY29ubmVjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3I7IC8vIGUuZy4gYSBmdW5jdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHZhciBpc0Nvbm5lY3RvclByb3ZpZGVkID0gKCh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpKTtcbiAgICAgICAgdmFyIGxvY2FsQ29ubmVjdG9yID0gaXNDb25uZWN0b3JQcm92aWRlZCA/IG5hbWUgOiB7IG5hbWU6IG5hbWUsIGFyZ3M6IGFyZ3MgfTtcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0gaXNDb25uZWN0b3JQcm92aWRlZCA/IGFyZ3MgOiBvcHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdjb25uZWN0b3InLCBsb2NhbENvbm5lY3RvciwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBMYWJlbHMgQVBJXG5cbiAgICAvLyBBIGNvbnZlbmllbnQgd2F5IHRvIHNldCBsYWJlbHMuIEN1cnJlbnRseSBzZXQgdmFsdWVzIHdpbGwgYmUgbWl4aW5lZCB3aXRoIGB2YWx1ZWAgaWYgdXNlZCBhcyBhIHNldHRlci5cbiAgICBsYWJlbDogZnVuY3Rpb24oaWR4LCBsYWJlbCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzKCk7XG5cbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IDA7XG4gICAgICAgIGlmIChpZHggPCAwKSBpZHggPSBsYWJlbHMubGVuZ3RoICsgaWR4O1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSByZXR1cm4gdGhpcy5wcm9wKFsnbGFiZWxzJywgaWR4XSk7XG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wKFsnbGFiZWxzJywgaWR4XSwgbGFiZWwsIG9wdCk7XG4gICAgfSxcblxuICAgIGxhYmVsczogZnVuY3Rpb24obGFiZWxzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxhYmVscyA9IHRoaXMuZ2V0KCdsYWJlbHMnKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSBsYWJlbHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdsYWJlbHMnLCBsYWJlbHMsIG9wdCk7XG4gICAgfSxcblxuICAgIGhhc0xhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzIH0gPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGxhYmVscykgJiYgbGFiZWxzLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIGluc2VydExhYmVsOiBmdW5jdGlvbihpZHgsIGxhYmVsLCBvcHQpIHtcblxuICAgICAgICBpZiAoIWxhYmVsKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rOiBubyBsYWJlbCBwcm92aWRlZCcpO1xuXG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscygpO1xuICAgICAgICB2YXIgbiA9IGxhYmVscy5sZW5ndGg7XG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiBuO1xuICAgICAgICBpZiAoaWR4IDwgMCkgaWR4ID0gbiArIGlkeCArIDE7XG5cbiAgICAgICAgbGFiZWxzLnNwbGljZShpZHgsIDAsIGxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzKGxhYmVscywgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAvLyBhZGQgbGFiZWwgdG8gZW5kIG9mIGxhYmVscyBhcnJheVxuICAgIGFwcGVuZExhYmVsOiBmdW5jdGlvbihsYWJlbCwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0TGFiZWwoLTEsIGxhYmVsLCBvcHQpO1xuICAgIH0sXG5cbiAgICByZW1vdmVMYWJlbDogZnVuY3Rpb24oaWR4LCBvcHQpIHtcblxuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHMoKTtcbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IC0xO1xuXG4gICAgICAgIGxhYmVscy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzKGxhYmVscywgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gVmVydGljZXMgQVBJXG5cbiAgICB2ZXJ0ZXg6IGZ1bmN0aW9uKGlkeCwgdmVydGV4LCBvcHQpIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzKCk7XG5cbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IDA7XG4gICAgICAgIGlmIChpZHggPCAwKSBpZHggPSB2ZXJ0aWNlcy5sZW5ndGggKyBpZHg7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHJldHVybiB0aGlzLnByb3AoWyd2ZXJ0aWNlcycsIGlkeF0pO1xuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgc2V0VmVydGV4ID0gdGhpcy5fbm9ybWFsaXplVmVydGV4KHZlcnRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3AoWyd2ZXJ0aWNlcycsIGlkeF0sIHNldFZlcnRleCwgb3B0KTtcbiAgICB9LFxuXG4gICAgdmVydGljZXM6IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZlcnRpY2VzID0gdGhpcy5nZXQoJ3ZlcnRpY2VzJyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVydGljZXMpKSByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVydGljZXMpKSB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICB2YXIgc2V0VmVydGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHNldFZlcnRleCA9IHRoaXMuX25vcm1hbGl6ZVZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgICAgICAgc2V0VmVydGljZXMucHVzaChzZXRWZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNldCgndmVydGljZXMnLCBzZXRWZXJ0aWNlcywgb3B0KTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0VmVydGV4OiBmdW5jdGlvbihpZHgsIHZlcnRleCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKCF2ZXJ0ZXgpIHRocm93IG5ldyBFcnJvcignZGlhLkxpbms6IG5vIHZlcnRleCBwcm92aWRlZCcpO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMoKTtcbiAgICAgICAgdmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiBuO1xuICAgICAgICBpZiAoaWR4IDwgMCkgaWR4ID0gbiArIGlkeCArIDE7XG5cbiAgICAgICAgdmFyIHNldFZlcnRleCA9IHRoaXMuX25vcm1hbGl6ZVZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UoaWR4LCAwLCBzZXRWZXJ0ZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcyh2ZXJ0aWNlcywgb3B0KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVmVydGV4OiBmdW5jdGlvbihpZHgsIG9wdCkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMoKTtcbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IC0xO1xuXG4gICAgICAgIHZlcnRpY2VzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcyh2ZXJ0aWNlcywgb3B0KTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZVZlcnRleDogZnVuY3Rpb24odmVydGV4KSB7XG5cbiAgICAgICAgLy8gaXMgdmVydGV4IGEgcG9pbnQtbGlrZSBvYmplY3Q/XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCBhIGcuUG9pbnRcbiAgICAgICAgdmFyIGlzUG9pbnRQcm92aWRlZCA9ICFpc1BsYWluT2JqZWN0KHZlcnRleCk7XG4gICAgICAgIGlmIChpc1BvaW50UHJvdmlkZWQpIHJldHVybiB7IHg6IHZlcnRleC54LCB5OiB2ZXJ0ZXgueSB9O1xuXG4gICAgICAgIC8vIGVsc2U6IHJldHVybiB2ZXJ0ZXggdW5jaGFuZ2VkXG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgfSxcblxuICAgIC8vIFRyYW5zZm9ybWF0aW9uc1xuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHksIG9wdCkge1xuXG4gICAgICAgIC8vIGVucmljaCB0aGUgb3B0aW9uIG9iamVjdFxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIG9wdC50cmFuc2xhdGVCeSA9IG9wdC50cmFuc2xhdGVCeSB8fCB0aGlzLmlkO1xuICAgICAgICBvcHQudHggPSB0eDtcbiAgICAgICAgb3B0LnR5ID0gdHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1BvaW50cyhmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiAocC54IHx8IDApICsgdHgsIHk6IChwLnkgfHwgMCkgKyB0eSB9O1xuICAgICAgICB9LCBvcHQpO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4sIG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9Qb2ludHMoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50KHApLnNjYWxlKHN4LCBzeSwgb3JpZ2luKS50b0pTT04oKTtcbiAgICAgICAgfSwgb3B0KTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1BvaW50czogZnVuY3Rpb24oZm4sIG9wdCkge1xuXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5MaW5rOiBhcHBseVRvUG9pbnRzIGV4cGVjdHMgaXRzIGZpcnN0IHBhcmFtZXRlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJzID0ge307XG5cbiAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCFzb3VyY2UuaWQpIHtcbiAgICAgICAgICAgIGF0dHJzLnNvdXJjZSA9IGZuKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgIGF0dHJzLnRhcmdldCA9IGZuKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzKCk7XG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhdHRycy52ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChmbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIG9wdCk7XG4gICAgfSxcblxuICAgIGdldFNvdXJjZVBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvdXJjZUNlbGwgPSB0aGlzLmdldFNvdXJjZUNlbGwoKTtcbiAgICAgICAgaWYgKCFzb3VyY2VDZWxsKSByZXR1cm4gbmV3IFBvaW50KHRoaXMuc291cmNlKCkpO1xuICAgICAgICByZXR1cm4gc291cmNlQ2VsbC5nZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rKHRoaXMsICdzb3VyY2UnKTtcbiAgICB9LFxuXG4gICAgZ2V0VGFyZ2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFyZ2V0Q2VsbCA9IHRoaXMuZ2V0VGFyZ2V0Q2VsbCgpO1xuICAgICAgICBpZiAoIXRhcmdldENlbGwpIHJldHVybiBuZXcgUG9pbnQodGhpcy50YXJnZXQoKSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRDZWxsLmdldFBvaW50RnJvbUNvbm5lY3RlZExpbmsodGhpcywgJ3RhcmdldCcpO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rOiBmdW5jdGlvbigvKiBsaW5rLCBlbmRUeXBlICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBvbHlsaW5lKCkucG9pbnRBdCgwLjUpO1xuICAgIH0sXG5cbiAgICBnZXRQb2x5bGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgICAgICAgIHRoaXMuZ2V0U291cmNlUG9pbnQoKSxcbiAgICAgICAgICAgIC4uLnRoaXMudmVydGljZXMoKS5tYXAoUG9pbnQpLFxuICAgICAgICAgICAgdGhpcy5nZXRUYXJnZXRQb2ludCgpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUocG9pbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0QkJveDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBvbHlsaW5lKCkuYmJveCgpO1xuICAgIH0sXG5cbiAgICByZXBhcmVudDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIG5ld1BhcmVudDtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuXG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICB2YXIgcHJldlBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCgpO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlICYmIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCB8fCBzb3VyY2UuaXNFbWJlZGRlZEluKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmlzRW1iZWRkZWRJbihzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQgPSB0aGlzLmdyYXBoLmdldENvbW1vbkFuY2VzdG9yKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2UGFyZW50ICYmICghbmV3UGFyZW50IHx8IG5ld1BhcmVudC5pZCAhPT0gcHJldlBhcmVudC5pZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmVtYmVkIHRoZSBsaW5rIGlmIHNvdXJjZSBhbmQgdGFyZ2V0IGhhcyBubyBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAvLyBvciBjb21tb24gYW5jZXN0b3IgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHByZXZQYXJlbnQudW5lbWJlZCh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmVtYmVkKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UGFyZW50O1xuICAgIH0sXG5cbiAgICBoYXNMb29wOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNvdXJjZUlkID0gc291cmNlLmlkO1xuICAgICAgICB2YXIgdGFyZ2V0SWQgPSB0YXJnZXQuaWQ7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VJZCB8fCAhdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIC8vIExpbmsgXCJwaW5uZWRcIiB0byB0aGUgcGFwZXIgZG9lcyBub3QgaGF2ZSBhIGxvb3AuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9vcCA9IHNvdXJjZUlkID09PSB0YXJnZXRJZDtcblxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgaW4gdGhlIGRlZXAgbW9kZSBhIGxpbmsgY2FuIGhhdmUgYSBsb29wLFxuICAgICAgICAvLyBldmVuIGlmIGl0IGNvbm5lY3RzIG9ubHkgYSBwYXJlbnQgYW5kIGl0cyBlbWJlZC5cbiAgICAgICAgLy8gQSBsb29wIFwidGFyZ2V0IGVxdWFscyBzb3VyY2VcIiBpcyB2YWxpZCBpbiBib3RoIHNoYWxsb3cgYW5kIGRlZXAgbW9kZS5cbiAgICAgICAgaWYgKCFsb29wICYmIG9wdC5kZWVwICYmIHRoaXMuZ3JhcGgpIHtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZUVsZW1lbnQgPSB0aGlzLmdldFNvdXJjZUNlbGwoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRDZWxsKCk7XG5cbiAgICAgICAgICAgIGxvb3AgPSBzb3VyY2VFbGVtZW50LmlzRW1iZWRkZWRJbih0YXJnZXRFbGVtZW50KSB8fCB0YXJnZXRFbGVtZW50LmlzRW1iZWRkZWRJbihzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb29wO1xuICAgIH0sXG5cbiAgICAvLyB1bmxpa2Ugc291cmNlKCksIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbCBpZiBzb3VyY2UgaXMgYSBwb2ludFxuICAgIGdldFNvdXJjZUNlbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGgsIGF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhdHRyaWJ1dGVzLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIChzb3VyY2UgJiYgc291cmNlLmlkICYmIGdyYXBoICYmIGdyYXBoLmdldENlbGwoc291cmNlLmlkKSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0U291cmNlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcztcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbY2VsbC5pZF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmlzaXRlZFtjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgIH0gd2hpbGUgKGNlbGwgJiYgY2VsbC5pc0xpbmsoKSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvLyB1bmxpa2UgdGFyZ2V0KCksIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbCBpZiB0YXJnZXQgaXMgYSBwb2ludFxuICAgIGdldFRhcmdldENlbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGgsIGF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBhdHRyaWJ1dGVzLnRhcmdldDtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQgJiYgdGFyZ2V0LmlkICYmIGdyYXBoICYmIGdyYXBoLmdldENlbGwodGFyZ2V0LmlkKSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0VGFyZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcztcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbY2VsbC5pZF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmlzaXRlZFtjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC5nZXRUYXJnZXRDZWxsKCk7XG4gICAgICAgIH0gd2hpbGUgKGNlbGwgJiYgY2VsbC5pc0xpbmsoKSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBjb21tb24gYW5jZXN0b3IgZm9yIHRoZSBzb3VyY2UgZWxlbWVudCxcbiAgICAvLyB0YXJnZXQgZWxlbWVudCBhbmQgdGhlIGxpbmsgaXRzZWxmLlxuICAgIGdldFJlbGF0aW9uc2hpcEFuY2VzdG9yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY29ubmVjdGlvbkFuY2VzdG9yO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG5cbiAgICAgICAgICAgIHZhciBjZWxscyA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U291cmNlRWxlbWVudCgpLCAvLyBudWxsIGlmIHNvdXJjZSBpcyBhIHBvaW50XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUYXJnZXRFbGVtZW50KCkgLy8gbnVsbCBpZiB0YXJnZXQgaXMgYSBwb2ludFxuICAgICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWl0ZW07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbkFuY2VzdG9yID0gdGhpcy5ncmFwaC5nZXRDb21tb25BbmNlc3Rvci5hcHBseSh0aGlzLmdyYXBoLCBjZWxscyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkFuY2VzdG9yIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8vIElzIHNvdXJjZSwgdGFyZ2V0IGFuZCB0aGUgbGluayBpdHNlbGYgZW1iZWRkZWQgaW4gYSBnaXZlbiBjZWxsP1xuICAgIGlzUmVsYXRpb25zaGlwRW1iZWRkZWRJbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIHZhciBjZWxsSWQgPSAoaXNTdHJpbmcoY2VsbCkgfHwgaXNOdW1iZXIoY2VsbCkpID8gY2VsbCA6IGNlbGwuaWQ7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMuZ2V0UmVsYXRpb25zaGlwQW5jZXN0b3IoKTtcblxuICAgICAgICByZXR1cm4gISFhbmNlc3RvciAmJiAoYW5jZXN0b3IuaWQgPT09IGNlbGxJZCB8fCBhbmNlc3Rvci5pc0VtYmVkZGVkSW4oY2VsbElkKSk7XG4gICAgfSxcblxuICAgIC8vIEdldCByZXNvbHZlZCBkZWZhdWx0IGxhYmVsLlxuICAgIF9nZXREZWZhdWx0TGFiZWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSB0aGlzLmdldCgnZGVmYXVsdExhYmVsJykgfHwgdGhpcy5kZWZhdWx0TGFiZWwgfHwge307XG5cbiAgICAgICAgdmFyIGxhYmVsID0ge307XG4gICAgICAgIGxhYmVsLm1hcmt1cCA9IGRlZmF1bHRMYWJlbC5tYXJrdXAgfHwgdGhpcy5nZXQoJ2xhYmVsTWFya3VwJykgfHwgdGhpcy5sYWJlbE1hcmt1cDtcbiAgICAgICAgbGFiZWwucG9zaXRpb24gPSBkZWZhdWx0TGFiZWwucG9zaXRpb247XG4gICAgICAgIGxhYmVsLmF0dHJzID0gZGVmYXVsdExhYmVsLmF0dHJzO1xuICAgICAgICBsYWJlbC5zaXplID0gZGVmYXVsdExhYmVsLnNpemU7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbn0sIHtcblxuICAgIGVuZHNFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICAgIHZhciBwb3J0c0VxdWFsID0gYS5wb3J0ID09PSBiLnBvcnQgfHwgIWEucG9ydCAmJiAhYi5wb3J0O1xuICAgICAgICByZXR1cm4gYS5pZCA9PT0gYi5pZCAmJiBwb3J0c0VxdWFsO1xuICAgIH1cbn0pO1xuXG4iXSwibmFtZXMiOlsiQ2VsbCIsImNsb25lIiwiaXNQbGFpbk9iamVjdCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiUG9pbnQiLCJQb2x5bGluZSIsIkxpbmsiLCJleHRlbmQiLCJtYXJrdXAiLCJqb2luIiwidG9vbE1hcmt1cCIsImRvdWJsZVRvb2xNYXJrdXAiLCJ1bmRlZmluZWQiLCJ2ZXJ0ZXhNYXJrdXAiLCJhcnJvd2hlYWRNYXJrdXAiLCJkZWZhdWx0TGFiZWwiLCJsYWJlbE1hcmt1cCIsIl9idWlsdGlucyIsInRhZ05hbWUiLCJzZWxlY3RvciIsImF0dHJzIiwidGV4dCIsImZpbGwiLCJmb250U2l6ZSIsInRleHRBbmNob3IiLCJ5QWxpZ25tZW50IiwicG9pbnRlckV2ZW50cyIsInJlY3QiLCJyZWYiLCJyeCIsInJ5IiwicmVmV2lkdGgiLCJyZWZIZWlnaHQiLCJyZWZYIiwicmVmWSIsInBvc2l0aW9uIiwiZGlzdGFuY2UiLCJkZWZhdWx0cyIsInR5cGUiLCJzb3VyY2UiLCJ0YXJnZXQiLCJpc0xpbmsiLCJkaXNjb25uZWN0Iiwib3B0Iiwic2V0IiwieCIsInkiLCJhcmdzIiwiZ2V0Iiwic2V0U291cmNlIiwic2V0T3B0IiwiaXNDZWxsUHJvdmlkZWQiLCJpZCIsImlzUG9pbnRQcm92aWRlZCIsInNldFRhcmdldCIsInJvdXRlciIsIm5hbWUiLCJpc1JvdXRlclByb3ZpZGVkIiwibG9jYWxSb3V0ZXIiLCJsb2NhbE9wdCIsImNvbm5lY3RvciIsImlzQ29ubmVjdG9yUHJvdmlkZWQiLCJsb2NhbENvbm5lY3RvciIsImxhYmVsIiwiaWR4IiwibGFiZWxzIiwiaXNGaW5pdGUiLCJsZW5ndGgiLCJhcmd1bWVudHMiLCJwcm9wIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJoYXNMYWJlbHMiLCJhdHRyaWJ1dGVzIiwiaW5zZXJ0TGFiZWwiLCJFcnJvciIsIm4iLCJzcGxpY2UiLCJhcHBlbmRMYWJlbCIsInJlbW92ZUxhYmVsIiwidmVydGV4IiwidmVydGljZXMiLCJzZXRWZXJ0ZXgiLCJfbm9ybWFsaXplVmVydGV4Iiwic2V0VmVydGljZXMiLCJpIiwicHVzaCIsImluc2VydFZlcnRleCIsInJlbW92ZVZlcnRleCIsInRyYW5zbGF0ZSIsInR4IiwidHkiLCJ0cmFuc2xhdGVCeSIsImFwcGx5VG9Qb2ludHMiLCJwIiwic2NhbGUiLCJzeCIsInN5Iiwib3JpZ2luIiwidG9KU09OIiwiZm4iLCJUeXBlRXJyb3IiLCJtYXAiLCJnZXRTb3VyY2VQb2ludCIsInNvdXJjZUNlbGwiLCJnZXRTb3VyY2VDZWxsIiwiZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayIsImdldFRhcmdldFBvaW50IiwidGFyZ2V0Q2VsbCIsImdldFRhcmdldENlbGwiLCJnZXRQb2x5bGluZSIsInBvaW50QXQiLCJwb2ludHMiLCJnZXRCQm94IiwiYmJveCIsInJlcGFyZW50IiwibmV3UGFyZW50IiwiZ3JhcGgiLCJnZXRTb3VyY2VFbGVtZW50IiwiZ2V0VGFyZ2V0RWxlbWVudCIsInByZXZQYXJlbnQiLCJnZXRQYXJlbnRDZWxsIiwiaXNFbWJlZGRlZEluIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJ1bmVtYmVkIiwiZW1iZWQiLCJoYXNMb29wIiwic291cmNlSWQiLCJ0YXJnZXRJZCIsImxvb3AiLCJkZWVwIiwic291cmNlRWxlbWVudCIsInRhcmdldEVsZW1lbnQiLCJnZXRDZWxsIiwiY2VsbCIsInZpc2l0ZWQiLCJnZXRSZWxhdGlvbnNoaXBBbmNlc3RvciIsImNvbm5lY3Rpb25BbmNlc3RvciIsImNlbGxzIiwiZmlsdGVyIiwiaXRlbSIsImFwcGx5IiwiaXNSZWxhdGlvbnNoaXBFbWJlZGRlZEluIiwiY2VsbElkIiwiYW5jZXN0b3IiLCJfZ2V0RGVmYXVsdExhYmVsIiwic2l6ZSIsImVuZHNFcXVhbCIsImEiLCJiIiwicG9ydHNFcXVhbCIsInBvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/Link.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/LinkView.mjs":
/*!***************************************************!*\
  !*** ./node_modules/jointjs/src/dia/LinkView.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkView: () => (/* binding */ LinkView)\n/* harmony export */ });\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/CellView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Link.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Link.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _routers_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../routers/index.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/index.mjs\");\n/* harmony import */ var _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../connectors/index.mjs */ \"(ssr)/./node_modules/jointjs/src/connectors/index.mjs\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.Flags.TOOLS,\n    RENDER: \"RENDER\",\n    UPDATE: \"UPDATE\",\n    LEGACY_TOOLS: \"LEGACY_TOOLS\",\n    LABELS: \"LABELS\",\n    VERTICES: \"VERTICES\",\n    SOURCE: \"SOURCE\",\n    TARGET: \"TARGET\",\n    CONNECTOR: \"CONNECTOR\"\n};\n// Link base view and controller.\n// ----------------------------------------\nconst LinkView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.extend({\n    className: function() {\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.className.apply(this).split(\" \");\n        classNames.push(\"link\");\n        return classNames.join(\" \");\n    },\n    options: {\n        shortLinkLength: 105,\n        doubleLinkTools: false,\n        longLinkLength: 155,\n        linkToolsOffset: 40,\n        doubleLinkToolsOffset: 65,\n        sampleInterval: 50\n    },\n    _labelCache: null,\n    _labelSelectors: null,\n    _markerCache: null,\n    _V: null,\n    _dragData: null,\n    metrics: null,\n    decimalsRounding: 2,\n    initialize: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.initialize.apply(this, arguments);\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n        // a cache of label selectors\n        this._labelSelectors = {};\n        // keeps markers bboxes and positions again for quicker access\n        this._markerCache = {};\n        // cache of default markup nodes\n        this._V = {};\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n    presentationAttributes: {\n        markup: [\n            Flags.RENDER\n        ],\n        attrs: [\n            Flags.UPDATE\n        ],\n        router: [\n            Flags.UPDATE\n        ],\n        connector: [\n            Flags.CONNECTOR\n        ],\n        smooth: [\n            Flags.UPDATE\n        ],\n        manhattan: [\n            Flags.UPDATE\n        ],\n        toolMarkup: [\n            Flags.LEGACY_TOOLS\n        ],\n        labels: [\n            Flags.LABELS\n        ],\n        labelMarkup: [\n            Flags.LABELS\n        ],\n        vertices: [\n            Flags.VERTICES,\n            Flags.UPDATE\n        ],\n        vertexMarkup: [\n            Flags.VERTICES\n        ],\n        source: [\n            Flags.SOURCE,\n            Flags.UPDATE\n        ],\n        target: [\n            Flags.TARGET,\n            Flags.UPDATE\n        ]\n    },\n    initFlag: [\n        Flags.RENDER,\n        Flags.SOURCE,\n        Flags.TARGET,\n        Flags.TOOLS\n    ],\n    UPDATE_PRIORITY: 1,\n    confirmUpdate: function(flags, opt) {\n        opt || (opt = {});\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties(\"source\")) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties(\"target\")) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n        const { paper, sourceView, targetView } = this;\n        if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [\n                Flags.RENDER,\n                Flags.UPDATE,\n                Flags.VERTICES,\n                Flags.LABELS,\n                Flags.TOOLS,\n                Flags.LEGACY_TOOLS,\n                Flags.CONNECTOR\n            ]);\n            return flags;\n        }\n        let updateHighlighters = false;\n        if (this.hasFlag(flags, Flags.VERTICES)) {\n            this.renderVertexMarkers();\n            flags = this.removeFlag(flags, Flags.VERTICES);\n        }\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n        let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n        if (updateLegacyTools) {\n            this.renderTools();\n            flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);\n        }\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [\n                Flags.UPDATE,\n                Flags.TOOLS,\n                Flags.CONNECTOR\n            ]);\n            updateLabels = false;\n            updateLegacyTools = false;\n            updateHighlighters = true;\n        }\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n        if (updateLegacyTools) {\n            this.updateToolsPosition();\n        }\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n        return flags;\n    },\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n    isLabelsRenderRequired: function(opt = {}) {\n        const previousLabels = this.model.previous(\"labels\");\n        if (!previousLabels) return true;\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (\"propertyPathArray\" in opt && \"propertyValue\" in opt) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return \"markup\" in Object(opt.propertyValue);\n                    } else if (pathArray[2] !== \"markup\") {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    },\n    onLabelsChange: function(_link, _labels, opt) {\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n    // Rendering.\n    // ----------\n    render: function() {\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n        return this;\n    },\n    renderMarkup: function() {\n        var link = this.model;\n        var markup = link.get(\"markup\") || link.markup;\n        if (!markup) throw new Error(\"dia.LinkView: markup required\");\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === \"string\") return this.renderStringMarkup(markup);\n        throw new Error(\"dia.LinkView: invalid markup\");\n    },\n    renderJSONMarkup: function(markup) {\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n    renderStringMarkup: function(markup) {\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [\n            children\n        ];\n        // Cache all children elements for quicker access.\n        var cache = this._V; // vectorized markup;\n        for(var i = 0, n = children.length; i < n; i++){\n            var child = children[i];\n            var className = child.attr(\"class\");\n            if (className) {\n                // Strip the joint class name prefix, if there is one.\n                className = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.removeClassNamePrefix)(className);\n                cache[jquery__WEBPACK_IMPORTED_MODULE_0__.camelCase(className)] = child;\n            }\n        }\n        // partial rendering\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        this.vel.append(children);\n    },\n    _getLabelMarkup: function(labelMarkup) {\n        if (!labelMarkup) return undefined;\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === \"string\") return this._getLabelStringMarkup(labelMarkup);\n        throw new Error(\"dia.linkView: invalid label markup\");\n    },\n    _getLabelStringMarkup: function(labelMarkup) {\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(labelMarkup);\n        var fragment = document.createDocumentFragment();\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n        } else {\n            for(var i = 0, n = children.length; i < n; i++){\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n        return {\n            fragment: fragment,\n            selectors: {}\n        }; // no selectors\n    },\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n        if (!markup) return undefined;\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error(\"dia.LinkView: invalid label markup.\");\n        var vNode;\n        var childNodes = fragment.childNodes;\n        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== \"G\") {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"g\").append(fragment);\n        } else {\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(childNodes[0]);\n        }\n        vNode.addClass(\"label\");\n        return {\n            node: vNode.node,\n            selectors: markup.selectors\n        };\n    },\n    renderLabels: function() {\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n        if (vLabels) {\n            vLabels.empty();\n        } else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"g\").addClass(\"labels\");\n            if (this.options.labelsLayer) {\n                vLabels.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.addClassNamePrefix)((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result)(this, \"className\")));\n                vLabels.attr(\"model-id\", model.id);\n            }\n        }\n        for(var i = 0; i < labelsCount; i++){\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n            } else {\n                var builtinDefaultLabel = model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n            labelNode.setAttribute(\"label-idx\", i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error(\"dia.LinkView: ambiguous label root selector.\");\n            selectors[rootSelector] = labelNode;\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n        this.updateLabels();\n        return this;\n    },\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get(\"z\"));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n    findLabelNode: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return null;\n        const labelSelectors = this._labelSelectors[labelIndex];\n        const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n        return node;\n    },\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n        if (hasCustomMarkup) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelAttrs, labelAttrs);\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n            return defaultLabelSize;\n        }\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelSize, labelSize);\n    },\n    updateLabels: function() {\n        if (!this._V.labels) return this;\n        var model = this.model;\n        var labels = model.get(\"labels\") || [];\n        var canLabelMove = this.can(\"labelMove\");\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n        for(var i = 0, n = labels.length; i < n; i++){\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute(\"cursor\", canLabelMove ? \"move\" : \"default\");\n            var selectors = this._labelSelectors[i];\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n            var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n            var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(size),\n                selectors: selectors\n            });\n        }\n        return this;\n    },\n    renderTools: function() {\n        if (!this._V.linkTools) return this;\n        // Tools are a group of clickable elements that manipulate the whole link.\n        // A good example of this is the remove tool that removes the whole link.\n        // Tools appear after hovering the link close to the `source` element/point of the link\n        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n        var $tools = jquery__WEBPACK_IMPORTED_MODULE_0__(this._V.linkTools.node).empty();\n        var toolTemplate = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.template)(this.model.get(\"toolMarkup\") || this.model.toolMarkup);\n        var tool = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(toolTemplate());\n        $tools.append(tool.node);\n        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n        this._toolCache = tool;\n        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n        // link as well but only if the link is longer than `longLinkLength`.\n        if (this.options.doubleLinkTools) {\n            var tool2;\n            if (this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup) {\n                toolTemplate = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.template)(this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup);\n                tool2 = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(toolTemplate());\n            } else {\n                tool2 = tool.clone();\n            }\n            $tools.append(tool2.node);\n            this._tool2Cache = tool2;\n        }\n        return this;\n    },\n    renderVertexMarkers: function() {\n        if (!this._V.markerVertices) return this;\n        var $markerVertices = jquery__WEBPACK_IMPORTED_MODULE_0__(this._V.markerVertices.node).empty();\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.template)(this.model.get(\"vertexMarkup\") || this.model.vertexMarkup);\n        this.model.vertices().forEach(function(vertex, idx) {\n            $markerVertices.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markupTemplate((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)({\n                idx: idx\n            }, vertex))).node);\n        });\n        return this;\n    },\n    renderArrowheadMarkers: function() {\n        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n        if (!this._V.markerArrowheads) return this;\n        var $markerArrowheads = jquery__WEBPACK_IMPORTED_MODULE_0__(this._V.markerArrowheads.node);\n        $markerArrowheads.empty();\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.template)(this.model.get(\"arrowheadMarkup\") || this.model.arrowheadMarkup);\n        this._V.sourceArrowhead = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markupTemplate({\n            end: \"source\"\n        }));\n        this._V.targetArrowhead = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markupTemplate({\n            end: \"target\"\n        }));\n        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n        return this;\n    },\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n        const SIMPLIFY_THRESHOLD = 0.001;\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [\n            this.sourceAnchor,\n            ...vertices,\n            this.targetAnchor\n        ];\n        const numRoutePoints = routePoints.length;\n        // put routePoints into a polyline and try to simplify\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(routePoints);\n        polyline.simplify({\n            threshold: SIMPLIFY_THRESHOLD\n        });\n        const polylinePoints = polyline.points.map((point)=>point.toJSON()); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return numRoutePoints - numPolylinePoints;\n    },\n    updateDefaultConnectionPath: function() {\n        var cache = this._V;\n        if (cache.connection) {\n            cache.connection.attr(\"d\", this.getSerializedConnection());\n        }\n        if (cache.connectionWrap) {\n            cache.connectionWrap.attr(\"d\", this.getSerializedConnection());\n        }\n        if (cache.markerSource && cache.markerTarget) {\n            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n        }\n    },\n    getEndView: function(type) {\n        switch(type){\n            case \"source\":\n                return this.sourceView || null;\n            case \"target\":\n                return this.targetView || null;\n            default:\n                throw new Error(\"dia.LinkView: type parameter required.\");\n        }\n    },\n    getEndAnchor: function(type) {\n        switch(type){\n            case \"source\":\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourceAnchor);\n            case \"target\":\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetAnchor);\n            default:\n                throw new Error(\"dia.LinkView: type parameter required.\");\n        }\n    },\n    getEndConnectionPoint: function(type) {\n        switch(type){\n            case \"source\":\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourcePoint);\n            case \"target\":\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetPoint);\n            default:\n                throw new Error(\"dia.LinkView: type parameter required.\");\n        }\n    },\n    getEndMagnet: function(type) {\n        switch(type){\n            case \"source\":\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case \"target\":\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error(\"dia.LinkView: type parameter required.\");\n        }\n        return null;\n    },\n    // Updating.\n    // ---------\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and marker points.\n        this._translateConnectionPoints(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n    updateDOM () {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), {\n            selectors\n        });\n        // legacy link path update\n        this.updateDefaultConnectionPath();\n        // update the label position etc.\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 3b. Find Marker Connection Point - Backwards Compatibility\n        const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n        // 4. Find Connection\n        const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n        this.path = path;\n    },\n    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        // Move the source point by the width of the marker taking into account\n        // its scale around x-axis. Note that scale is the only transform that\n        // makes sense to be set in `.marker-source` attributes object\n        // as all other transforms (translate/rotate) will be replaced\n        // by the `translateAndAutoOrient()` function.\n        var cache = this._markerCache;\n        // cache source and target points\n        var sourceMarkerPoint, targetMarkerPoint;\n        if (this._V.markerSource) {\n            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n            sourceMarkerPoint = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point)(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();\n        }\n        if (this._V.markerTarget) {\n            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n            targetMarkerPoint = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point)(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();\n        }\n        // if there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint\n        };\n    },\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstDef);\n        }\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n        }\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n    findAnchors: function(vertices) {\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered(\"target\", lastVertex, \"source\", firstVertex);\n        }\n        // Usual order\n        return this.findAnchorsOrdered(\"source\", firstVertex, \"target\", lastVertex);\n    },\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get(\"source\");\n        var targetDef = model.get(\"target\");\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = this.sourceMagnet || sourceView.el;\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, \"source\");\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = this.targetMagnet || targetView.el;\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, \"target\");\n        } else {\n            targetPoint = targetAnchor;\n        }\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n                    // Backwards compatibility\n                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n                    // on the link, then try to find a connection point that makes the link perpendicular\n                    // even though the link won't point to the center of the targeted object.\n                    anchorDef = {\n                        name: \"perpendicular\"\n                    };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n        if (!anchorDef) throw new Error(\"Anchor required.\");\n        var anchorFn;\n        if (typeof anchorDef === \"function\") {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? \"linkAnchorNamespace\" : \"anchorNamespace\";\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== \"function\") throw new Error(\"Unknown anchor: \" + anchorName);\n        }\n        var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n        if (!anchor) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point();\n        return anchor.round(this.decimalsRounding);\n    },\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n        // Backwards compatibility\n        if (typeof paperOptions.linkConnectionPoint === \"function\") {\n            var linkConnectionMagnet = magnet === view.el ? undefined : magnet;\n            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n            if (connectionPoint) return connectionPoint;\n        }\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === \"function\") {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== \"function\") throw new Error(\"Unknown connection point: \" + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n    _translateConnectionPoints: function(tx, ty) {\n        var cache = this._markerCache;\n        cache.sourcePoint.offset(tx, ty);\n        cache.targetPoint.offset(tx, ty);\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n    },\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n        var model = this.model;\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n        if (typeof labelPosition === \"number\") return {\n            distance: labelPosition,\n            offset: null,\n            angle: 0,\n            args: null\n        };\n        return labelPosition;\n    },\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n    updateLabelPositions: function() {\n        if (!this._V.labels) return this;\n        var path = this.path;\n        if (!path) return this;\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n        var model = this.model;\n        var labels = model.get(\"labels\") || [];\n        if (!labels.length) return this;\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n        for(var idx = 0, n = labels.length; idx < n; idx++){\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute(\"transform\", _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n        return this;\n    },\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for(let selector in selectors){\n            const { id } = selectors[selector];\n            if (id && id in metrics) delete metrics[id].magnetMatrix;\n        }\n    },\n    updateToolsPosition: function() {\n        if (!this._V.linkTools) return this;\n        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n        // Note that the offset is hardcoded here. The offset should be always\n        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n        var scale = \"\";\n        var offset = this.options.linkToolsOffset;\n        var connectionLength = this.getConnectionLength();\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (!Number.isNaN(connectionLength)) {\n            // If the link is too short, make the tools half the size and the offset twice as low.\n            if (connectionLength < this.options.shortLinkLength) {\n                scale = \"scale(.5)\";\n                offset /= 2;\n            }\n            var toolPosition = this.getPointAtLength(offset);\n            this._toolCache.attr(\"transform\", \"translate(\" + toolPosition.x + \", \" + toolPosition.y + \") \" + scale);\n            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n                this._tool2Cache.attr(\"transform\", \"translate(\" + toolPosition.x + \", \" + toolPosition.y + \") \" + scale);\n                this._tool2Cache.attr(\"display\", \"inline\");\n            } else if (this.options.doubleLinkTools) {\n                this._tool2Cache.attr(\"display\", \"none\");\n            }\n        }\n        return this;\n    },\n    updateArrowheadMarkers: function() {\n        if (!this._V.markerArrowheads) return this;\n        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n        if (jquery__WEBPACK_IMPORTED_MODULE_0__.css(this._V.markerArrowheads.node, \"display\") === \"none\") return this;\n        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n        this._V.sourceArrowhead.scale(sx);\n        this._V.targetArrowhead.scale(sx);\n        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n        return this;\n    },\n    updateEndProperties: function(endType) {\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error(\"LinkView: invalid \" + endType + \" cell.\");\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n    updateEndMagnet: function(endType) {\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n        // Make the markers \"point\" to their sticky points being auto-oriented towards\n        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n        var route = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toArray)(this.route);\n        if (sourceArrow) {\n            sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);\n        }\n        if (targetArrow) {\n            targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);\n        }\n    },\n    _getLabelPositionProperty: function(idx) {\n        return this.model.label(idx).position || {};\n    },\n    _getLabelPositionAngle: function(idx) {\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.angle || 0;\n    },\n    _getLabelPositionArgs: function(idx) {\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n    _getDefaultLabelPositionArgs: function() {\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== \"number\") {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === \"number\") {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === \"number\") {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n        // append label to labels array\n        var label = {\n            position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n        };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = typeof x !== \"number\";\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n        var vertex = {\n            x: localX,\n            y: localY\n        };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === \"function\") {\n                    callback();\n                }\n            };\n        }\n        var duration, isReversed, selector;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isObject)(opt)) {\n            duration = opt.duration;\n            isReversed = opt.direction === \"reverse\";\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n        duration = duration || 1000;\n        var animationAttributes = {\n            dur: duration + \"ms\",\n            repeatCount: 1,\n            calcMode: \"linear\",\n            fill: \"freeze\"\n        };\n        if (isReversed) {\n            animationAttributes.keyPoints = \"1;0\";\n            animationAttributes.keyTimes = \"0;1\";\n        }\n        var vToken = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(token);\n        var connection;\n        if (typeof selector === \"string\") {\n            // Use custom connection path.\n            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = cache.connection ? cache.connection.node : this.el.querySelector(\"path\");\n        }\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error(\"dia.LinkView: token animation requires a valid connection path.\");\n        }\n        vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n    findRoute: function(vertices) {\n        vertices || (vertices = []);\n        var namespace = this.paper.options.routerNamespace || _routers_index_mjs__WEBPACK_IMPORTED_MODULE_9__;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point); // no router specified\n        }\n        var routerFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(router) ? router : namespace[router.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n        var args = router.args || {};\n        var route = routerFn.call(this, vertices, args, this // linkView\n        );\n        if (!route) return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point);\n        return route;\n    },\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n        var namespace = this.paper.options.connectorNamespace || _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n        var connectorFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connector) ? connector : namespace[connector.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n        var args = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n        var path = connectorFn.call(this, sourcePoint, targetPoint, route, args, this // linkView\n        );\n        if (typeof path === \"string\") {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_11__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizePathData(path));\n        }\n        return path;\n    },\n    // Public API.\n    // -----------\n    getConnection: function() {\n        var path = this.path;\n        if (!path) return null;\n        return path.clone();\n    },\n    getSerializedConnection: function() {\n        var path = this.path;\n        if (!path) return null;\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty(\"data\")) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n    getConnectionSubdivisions: function() {\n        var path = this.path;\n        if (!path) return null;\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty(\"segmentSubdivisions\")) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n    getConnectionLength: function() {\n        var path = this.path;\n        if (!path) return 0;\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty(\"length\")) return metrics.length;\n        var length = path.length({\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n        metrics.length = length;\n        return length;\n    },\n    getPointAtLength: function(length) {\n        var path = this.path;\n        if (!path) return null;\n        return path.pointAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getPointAtRatio: function(ratio) {\n        var path = this.path;\n        if (!path) return null;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getTangentAtLength: function(length) {\n        var path = this.path;\n        if (!path) return null;\n        return path.tangentAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getTangentAtRatio: function(ratio) {\n        var path = this.path;\n        if (!path) return null;\n        return path.tangentAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getClosestPoint: function(point) {\n        var path = this.path;\n        if (!path) return null;\n        return path.closestPoint(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getClosestPointLength: function(point) {\n        var path = this.path;\n        if (!path) return null;\n        return path.closestPointLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    getClosestPointRatio: function(point) {\n        var path = this.path;\n        if (!path) return null;\n        return path.closestPointNormalizedLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n    },\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n        var position = {};\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === \"number\") {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n        // find closest point t\n        var path = this.path;\n        var pathOpt = {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        };\n        var labelPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = {\n                x: labelOffsetDiff.x,\n                y: labelOffsetDiff.y\n            };\n        }\n        position.offset = labelOffset;\n        // ANGLE:\n        position.angle = localAngle;\n        return position;\n    },\n    _getLabelTransformationMatrix: function(labelPosition) {\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === \"number\") {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === \"number\") {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error(\"dia.LinkView: invalid label position distance.\");\n        }\n        var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n        var labelOffset = 0;\n        var labelOffsetCoordinates = {\n            x: 0,\n            y: 0\n        };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === \"number\") labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n        var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n        var path = this.path;\n        var pathOpt = {\n            segmentSubdivisions: this.getConnectionSubdivisions()\n        };\n        var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n            if (isKeepGradient) {\n                angle = tangent.angle() + labelAngle;\n                if (isEnsureLegibility) {\n                    angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_12__.normalizeAngle)((angle + 90) % 180 - 90);\n                }\n            }\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n    },\n    getLabelCoordinates: function(labelPosition) {\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(transformationMatrix.e, transformationMatrix.f);\n    },\n    getVertexIndex: function(x, y) {\n        var model = this.model;\n        var vertices = model.vertices();\n        var vertexLength = this.getClosestPointLength(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y));\n        var idx = 0;\n        for(var n = vertices.length; idx < n; idx++){\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n        return idx;\n    },\n    // Interaction. The controller part.\n    // ---------------------------------\n    notifyPointerdown (evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify(\"link:pointerdown\", evt, x, y);\n    },\n    notifyPointermove (evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify(\"link:pointermove\", evt, x, y);\n    },\n    notifyPointerup (evt, x, y) {\n        this.notify(\"link:pointerup\", evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n    pointerdblclick: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify(\"link:pointerdblclick\", evt, x, y);\n    },\n    pointerclick: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify(\"link:pointerclick\", evt, x, y);\n    },\n    contextmenu: function(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify(\"link:contextmenu\", evt, x, y);\n    },\n    pointerdown: function(evt, x, y) {\n        this.notifyPointerdown(evt, x, y);\n        // Backwards compatibility for the default markup\n        var className = evt.target.getAttribute(\"class\");\n        switch(className){\n            case \"marker-vertex\":\n                this.dragVertexStart(evt, x, y);\n                return;\n            case \"marker-vertex-remove\":\n            case \"marker-vertex-remove-area\":\n                this.dragVertexRemoveStart(evt, x, y);\n                return;\n            case \"marker-arrowhead\":\n                this.dragArrowheadStart(evt, x, y);\n                return;\n            case \"connection\":\n            case \"connection-wrap\":\n                this.dragConnectionStart(evt, x, y);\n                return;\n            case \"marker-source\":\n            case \"marker-target\":\n                return;\n        }\n        this.dragStart(evt, x, y);\n    },\n    pointermove: function(evt, x, y) {\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n        var data = this.eventData(evt);\n        switch(data.action){\n            case \"vertex-move\":\n                this.dragVertex(evt, x, y);\n                break;\n            case \"label-move\":\n                this.dragLabel(evt, x, y);\n                break;\n            case \"arrowhead-move\":\n                this.dragArrowhead(evt, x, y);\n                break;\n            case \"move\":\n                this.drag(evt, x, y);\n                break;\n        }\n        // Backwards compatibility\n        if (dragData) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)(dragData, this.eventData(evt));\n        this.notifyPointermove(evt, x, y);\n    },\n    pointerup: function(evt, x, y) {\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n        var data = this.eventData(evt);\n        switch(data.action){\n            case \"vertex-move\":\n                this.dragVertexEnd(evt, x, y);\n                break;\n            case \"label-move\":\n                this.dragLabelEnd(evt, x, y);\n                break;\n            case \"arrowhead-move\":\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n            case \"move\":\n                this.dragEnd(evt, x, y);\n        }\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n    mouseover: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify(\"link:mouseover\", evt);\n    },\n    mouseout: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify(\"link:mouseout\", evt);\n    },\n    mouseenter: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify(\"link:mouseenter\", evt);\n    },\n    mouseleave: function(evt) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify(\"link:mouseleave\", evt);\n    },\n    mousewheel: function(evt, x, y, delta) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify(\"link:mousewheel\", evt, x, y, delta);\n    },\n    onevent: function(evt, eventName, x, y) {\n        // Backwards compatibility\n        var linkTool = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(evt.target).findParentByClass(\"link-tool\", this.el);\n        if (linkTool) {\n            // No further action to be executed\n            evt.stopPropagation();\n            // Allow `interactive.useLinkTools=false`\n            if (this.can(\"useLinkTools\")) {\n                if (eventName === \"remove\") {\n                    // Built-in remove event\n                    this.model.remove({\n                        ui: true\n                    });\n                    // Do not trigger link pointerdown\n                    return;\n                } else {\n                    // link:options and other custom events inside the link tools\n                    this.notify(eventName, evt, x, y);\n                }\n            }\n            this.notifyPointerdown(evt, x, y);\n            this.paper.delegateDragEvents(this, evt.data);\n        } else {\n            _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.onevent.apply(this, arguments);\n        }\n    },\n    onlabel: function(evt, x, y) {\n        this.notifyPointerdown(evt, x, y);\n        this.dragLabelStart(evt, x, y);\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n    // Drag Start Handlers\n    dragConnectionStart: function(evt, x, y) {\n        if (!this.can(\"vertexAdd\")) return;\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        var vertexIdx = this.addVertex({\n            x: x,\n            y: y\n        }, {\n            ui: true\n        });\n        this.eventData(evt, {\n            action: \"vertex-move\",\n            vertexIdx: vertexIdx\n        });\n    },\n    dragLabelStart: function(evt, x, y) {\n        if (this.can(\"labelMove\")) {\n            if (this.isDefaultInteractionPrevented(evt)) return;\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute(\"label-idx\"), 10);\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n            this.eventData(evt, {\n                action: \"label-move\",\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n        } else {\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, {\n                stopPropagation: true\n            });\n        }\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n    dragVertexStart: function(evt, x, y) {\n        if (!this.can(\"vertexMove\")) return;\n        var vertexNode = evt.target;\n        var vertexIdx = parseInt(vertexNode.getAttribute(\"idx\"), 10);\n        this.eventData(evt, {\n            action: \"vertex-move\",\n            vertexIdx: vertexIdx\n        });\n    },\n    dragVertexRemoveStart: function(evt, x, y) {\n        if (!this.can(\"vertexRemove\")) return;\n        var removeNode = evt.target;\n        var vertexIdx = parseInt(removeNode.getAttribute(\"idx\"), 10);\n        this.model.removeVertex(vertexIdx);\n    },\n    dragArrowheadStart: function(evt, x, y) {\n        if (!this.can(\"arrowheadMove\")) return;\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute(\"end\");\n        var data = this.startArrowheadMove(arrowheadType, {\n            ignoreBackwardsCompatibility: true\n        });\n        this.eventData(evt, data);\n    },\n    dragStart: function(evt, x, y) {\n        if (this.isDefaultInteractionPrevented(evt)) return;\n        if (!this.can(\"linkMove\")) return;\n        this.eventData(evt, {\n            action: \"move\",\n            dx: x,\n            dy: y\n        });\n    },\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var label = {\n            position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n        };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = {\n            ui: true\n        };\n        if (this.paper.isAsync() && evt.type === \"touchmove\") {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n    dragVertex: function(evt, x, y) {\n        var data = this.eventData(evt);\n        this.model.vertex(data.vertexIdx, {\n            x: x,\n            y: y\n        }, {\n            ui: true\n        });\n    },\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n    drag: function(evt, x, y) {\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, {\n            ui: true\n        });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n    // Drag End Handlers\n    dragLabelEnd: function() {\n    // noop\n    },\n    dragVertexEnd: function() {\n    // noop\n    },\n    dragArrowheadEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var paper = this.paper;\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n        this._afterArrowheadMove(data);\n    },\n    dragEnd: function() {\n    // noop\n    },\n    _disallow: function(data) {\n        switch(data.whenNotAllowed){\n            case \"remove\":\n                this.model.remove({\n                    ui: true\n                });\n                break;\n            case \"revert\":\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, {\n                    ui: true\n                });\n                break;\n        }\n    },\n    _finishEmbedding: function(data) {\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n    _notifyConnectEvent: function(data, evt) {\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !_Link_mjs__WEBPACK_IMPORTED_MODULE_13__.Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify(\"link:disconnect\", evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify(\"link:connect\", evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n        for(let i = 0; i < points.length; i++){\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n        return {\n            x,\n            y\n        };\n    },\n    _snapArrowheadSelf: function(evt, x, y) {\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n        const anchor = this.getEndAnchor(data.arrowhead === \"source\" ? \"target\" : \"source\");\n        const vertices = model.vertices();\n        const points = [\n            anchor,\n            ...vertices\n        ];\n        const snapPoint = this._snapToPoints({\n            x: x,\n            y: y\n        }, points, radius);\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n    _snapArrowhead: function(evt, x, y) {\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findViewsInArea({\n            x: x - r,\n            y: y - r,\n            width: 2 * r,\n            height: 2 * r\n        });\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute(\"magnet\") !== \"false\") {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n            view.$(\"[magnet]\").toArray().forEach((magnet)=>{\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n            candidates.forEach((candidate)=>{\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n        }, this);\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, \"highlighter\");\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n            if (!newClosestMagnet) {\n                if (typeof connectionStrategy !== \"function\" || prevX === x && prevY === y) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isEqual)(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n            data.prevEnd = end;\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n        } else {\n            end = {\n                x: x,\n                y: y\n            };\n        }\n        this.model.set(endType, end || {\n            x: x,\n            y: y\n        }, {\n            ui: true\n        });\n        if (prevClosestView) {\n            this.notify(\"link:snap:disconnect\", evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify(\"link:snap:connect\", evt, closestView, closestMagnet, endType);\n        }\n        return isSnapped;\n    },\n    _snapArrowheadEnd: function(data) {\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n            closestView.unhighlight(data.magnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n        data.closestView = data.closestMagnet = null;\n    },\n    _connectArrowhead: function(target, x, y, data) {\n        // checking views right under the pointer\n        const { paper, model } = this;\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, \"highlighter\");\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n        data.eventTarget = target;\n        model.set(data.arrowhead, {\n            x: x,\n            y: y\n        }, {\n            ui: true\n        });\n    },\n    _connectArrowheadEnd: function(data = {}, x, y) {\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n        viewUnderPointer.unhighlight(magnetProxy, {\n            connecting: true\n        });\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, {\n            ui: true\n        });\n    },\n    _beforeArrowheadMove: function(data) {\n        data.z = this.model.get(\"z\");\n        this.model.toFront();\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = \"none\";\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n    _afterArrowheadMove: function(data) {\n        if (data.z !== null) {\n            this.model.set(\"z\", data.z, {\n                ui: true\n            });\n            data.z = null;\n        }\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n        args[4] = arrowhead;\n        args[5] = this;\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n        if (arrowhead === \"source\") {\n            i = 2;\n            oppositeArrowhead = \"target\";\n        } else {\n            j = 2;\n            oppositeArrowhead = \"source\";\n        }\n        var end = this.model.get(oppositeArrowhead);\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n        return validateConnectionArgs;\n    },\n    _markAvailableMagnets: function(data) {\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n        for(var i = 0, n = elements.length; i < n; i++){\n            var view = elements[i].findView(paper);\n            if (!view) {\n                continue;\n            }\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll(\"[magnet]\"));\n            if (view.el.getAttribute(\"magnet\") !== \"false\") {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for(var j = 0, m = availableMagnets.length; j < m; j++){\n                    view.highlight(availableMagnets[j], {\n                        magnetAvailability: true\n                    });\n                }\n                // highlight the entire view\n                view.highlight(null, {\n                    elementAvailability: true\n                });\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n    _unmarkAvailableMagnets: function(data) {\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n        for(var i = 0, n = markedKeys.length; i < n; i++){\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for(var j = 0, m = markedMagnets.length; j < m; j++){\n                    view.unhighlight(markedMagnets[j], {\n                        magnetAvailability: true\n                    });\n                }\n                view.unhighlight(null, {\n                    elementAvailability: true\n                });\n            }\n        }\n        data.marked = null;\n    },\n    startArrowheadMove: function(end, opt) {\n        opt || (opt = {});\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: \"arrowhead-move\",\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || \"revert\",\n            initialMagnet: this[end + \"Magnet\"] || (this[end + \"View\"] ? this[end + \"View\"].el : null),\n            initialEnd: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n        this._beforeArrowheadMove(data);\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n        return data;\n    },\n    // Lifecycle methods\n    onMount: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n    onDetach: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n    onRemove: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_1__.CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n}, {\n    Flags: Flags\n});\nObject.defineProperty(LinkView.prototype, \"sourceBBox\", {\n    enumerable: true,\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n});\nObject.defineProperty(LinkView.prototype, \"targetBBox\", {\n    enumerable: true,\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL0xpbmtWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDUjtBQUNIO0FBQzZJO0FBQ3pGO0FBQ25DO0FBQ007QUFDL0I7QUFFdkIsTUFBTXdCLFFBQVE7SUFDVkMsT0FBT3pCLG1EQUFRQSxDQUFDd0IsS0FBSyxDQUFDQyxLQUFLO0lBQzNCQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsY0FBYztJQUNkQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDZjtBQUVBLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFFcEMsTUFBTUMsV0FBV2xDLG1EQUFRQSxDQUFDbUMsTUFBTSxDQUFDO0lBRXBDQyxXQUFXO1FBRVAsSUFBSUMsYUFBYXJDLG1EQUFRQSxDQUFDc0MsU0FBUyxDQUFDRixTQUFTLENBQUNHLEtBQUssQ0FBQyxJQUFJLEVBQUVDLEtBQUssQ0FBQztRQUVoRUgsV0FBV0ksSUFBSSxDQUFDO1FBRWhCLE9BQU9KLFdBQVdLLElBQUksQ0FBQztJQUMzQjtJQUVBQyxTQUFTO1FBRUxDLGlCQUFpQjtRQUNqQkMsaUJBQWlCO1FBQ2pCQyxnQkFBZ0I7UUFDaEJDLGlCQUFpQjtRQUNqQkMsdUJBQXVCO1FBQ3ZCQyxnQkFBZ0I7SUFDcEI7SUFFQUMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLGNBQWM7SUFDZEMsSUFBSTtJQUNKQyxXQUFXO0lBRVhDLFNBQVM7SUFDVEMsa0JBQWtCO0lBRWxCQyxZQUFZO1FBRVJ6RCxtREFBUUEsQ0FBQ3NDLFNBQVMsQ0FBQ21CLFVBQVUsQ0FBQ2xCLEtBQUssQ0FBQyxJQUFJLEVBQUVtQjtRQUUxQyx3RkFBd0Y7UUFDeEYsdUZBQXVGO1FBQ3ZGLDJFQUEyRTtRQUMzRSxJQUFJLENBQUNSLFdBQVcsR0FBRyxDQUFDO1FBRXBCLDZCQUE2QjtRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFD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SSxDQUFDek4sS0FBSyxDQUFDakIsTUFBTTtZQUNqQyxPQUFPLElBQUl0RCw4Q0FBSUEsQ0FBQ2dTLFVBQVU0RCxDQUFDLEVBQUU1RCxVQUFVNkQsQ0FBQztRQUM1QztRQUNBLElBQUk5RyxlQUFlLElBQUksQ0FBQ0EsWUFBWTtRQUNwQyxJQUFJOUssV0FBV2lPLGdCQUFnQixDQUFDbkQsZUFBZTtZQUMzQyxPQUFPLElBQUkvTyw4Q0FBSUEsQ0FBQyxJQUFJLENBQUNvTixZQUFZO1FBQ3JDO1FBQ0EsT0FBT25KLFdBQVd3aEIsV0FBVyxDQUFDMVcsZ0JBQWdCOUssV0FBV3FELEVBQUU7SUFDL0Q7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2RpYS9MaW5rVmlldy5tanM/NTA0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsVmlldyB9IGZyb20gJy4vQ2VsbFZpZXcubWpzJztcbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL0xpbmsubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZVByZWZpeCwgcmVtb3ZlQ2xhc3NOYW1lUHJlZml4LCBtZXJnZSwgdGVtcGxhdGUsIGFzc2lnbiwgdG9BcnJheSwgaXNPYmplY3QsIGlzRnVuY3Rpb24sIGNsb25lLCBpc1BlcmNlbnRhZ2UsIHJlc3VsdCwgaXNFcXVhbCB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFBvaW50LCBMaW5lLCBQYXRoLCBub3JtYWxpemVBbmdsZSwgUmVjdCwgUG9seWxpbmUgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyByb3V0ZXJzIGZyb20gJy4uL3JvdXRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGNvbm5lY3RvcnMgZnJvbSAnLi4vY29ubmVjdG9ycy9pbmRleC5tanMnO1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6IENlbGxWaWV3LkZsYWdzLlRPT0xTLFxuICAgIFJFTkRFUjogJ1JFTkRFUicsXG4gICAgVVBEQVRFOiAnVVBEQVRFJyxcbiAgICBMRUdBQ1lfVE9PTFM6ICdMRUdBQ1lfVE9PTFMnLFxuICAgIExBQkVMUzogJ0xBQkVMUycsXG4gICAgVkVSVElDRVM6ICdWRVJUSUNFUycsXG4gICAgU09VUkNFOiAnU09VUkNFJyxcbiAgICBUQVJHRVQ6ICdUQVJHRVQnLFxuICAgIENPTk5FQ1RPUjogJ0NPTk5FQ1RPUidcbn07XG5cbi8vIExpbmsgYmFzZSB2aWV3IGFuZCBjb250cm9sbGVyLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgTGlua1ZpZXcgPSBDZWxsVmlldy5leHRlbmQoe1xuXG4gICAgY2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IENlbGxWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUuYXBwbHkodGhpcykuc3BsaXQoJyAnKTtcblxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2xpbmsnKTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcblxuICAgICAgICBzaG9ydExpbmtMZW5ndGg6IDEwNSxcbiAgICAgICAgZG91YmxlTGlua1Rvb2xzOiBmYWxzZSxcbiAgICAgICAgbG9uZ0xpbmtMZW5ndGg6IDE1NSxcbiAgICAgICAgbGlua1Rvb2xzT2Zmc2V0OiA0MCxcbiAgICAgICAgZG91YmxlTGlua1Rvb2xzT2Zmc2V0OiA2NSxcbiAgICAgICAgc2FtcGxlSW50ZXJ2YWw6IDUwXG4gICAgfSxcblxuICAgIF9sYWJlbENhY2hlOiBudWxsLFxuICAgIF9sYWJlbFNlbGVjdG9yczogbnVsbCxcbiAgICBfbWFya2VyQ2FjaGU6IG51bGwsXG4gICAgX1Y6IG51bGwsXG4gICAgX2RyYWdEYXRhOiBudWxsLCAvLyBkZXByZWNhdGVkXG5cbiAgICBtZXRyaWNzOiBudWxsLFxuICAgIGRlY2ltYWxzUm91bmRpbmc6IDIsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGBfLmxhYmVsQ2FjaGVgIGlzIGEgbWFwcGluZyBvZiBpbmRleGVzIG9mIGxhYmVscyBpbiB0aGUgYHRoaXMuZ2V0KCdsYWJlbHMnKWAgYXJyYXkgdG9cbiAgICAgICAgLy8gYDxnIGNsYXNzPVwibGFiZWxcIj5gIG5vZGVzIHdyYXBwZWQgYnkgVmVjdG9yaXplci4gVGhpcyBhbGxvd3MgZm9yIHF1aWNrIGFjY2VzcyB0byB0aGVcbiAgICAgICAgLy8gbm9kZXMgaW4gYHVwZGF0ZUxhYmVsUG9zaXRpb24oKWAgaW4gb3JkZXIgdG8gdXBkYXRlIHRoZSBsYWJlbCBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuX2xhYmVsQ2FjaGUgPSB7fTtcblxuICAgICAgICAvLyBhIGNhY2hlIG9mIGxhYmVsIHNlbGVjdG9yc1xuICAgICAgICB0aGlzLl9sYWJlbFNlbGVjdG9ycyA9IHt9O1xuXG4gICAgICAgIC8vIGtlZXBzIG1hcmtlcnMgYmJveGVzIGFuZCBwb3NpdGlvbnMgYWdhaW4gZm9yIHF1aWNrZXIgYWNjZXNzXG4gICAgICAgIHRoaXMuX21hcmtlckNhY2hlID0ge307XG5cbiAgICAgICAgLy8gY2FjaGUgb2YgZGVmYXVsdCBtYXJrdXAgbm9kZXNcbiAgICAgICAgdGhpcy5fViA9IHt9O1xuXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gcGF0aCBtZXRyaWNzXG4gICAgICAgIHRoaXMuY2xlYW5Ob2Rlc0NhY2hlKCk7XG4gICAgfSxcblxuICAgIHByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IHtcbiAgICAgICAgbWFya3VwOiBbRmxhZ3MuUkVOREVSXSxcbiAgICAgICAgYXR0cnM6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICByb3V0ZXI6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICBjb25uZWN0b3I6IFtGbGFncy5DT05ORUNUT1JdLFxuICAgICAgICBzbW9vdGg6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICBtYW5oYXR0YW46IFtGbGFncy5VUERBVEVdLFxuICAgICAgICB0b29sTWFya3VwOiBbRmxhZ3MuTEVHQUNZX1RPT0xTXSxcbiAgICAgICAgbGFiZWxzOiBbRmxhZ3MuTEFCRUxTXSxcbiAgICAgICAgbGFiZWxNYXJrdXA6IFtGbGFncy5MQUJFTFNdLFxuICAgICAgICB2ZXJ0aWNlczogW0ZsYWdzLlZFUlRJQ0VTLCBGbGFncy5VUERBVEVdLFxuICAgICAgICB2ZXJ0ZXhNYXJrdXA6IFtGbGFncy5WRVJUSUNFU10sXG4gICAgICAgIHNvdXJjZTogW0ZsYWdzLlNPVVJDRSwgRmxhZ3MuVVBEQVRFXSxcbiAgICAgICAgdGFyZ2V0OiBbRmxhZ3MuVEFSR0VULCBGbGFncy5VUERBVEVdXG4gICAgfSxcblxuICAgIGluaXRGbGFnOiBbRmxhZ3MuUkVOREVSLCBGbGFncy5TT1VSQ0UsIEZsYWdzLlRBUkdFVCwgRmxhZ3MuVE9PTFNdLFxuXG4gICAgVVBEQVRFX1BSSU9SSVRZOiAxLFxuXG4gICAgY29uZmlybVVwZGF0ZTogZnVuY3Rpb24oZmxhZ3MsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlNPVVJDRSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51cGRhdGVFbmRQcm9wZXJ0aWVzKCdzb3VyY2UnKSkgcmV0dXJuIGZsYWdzO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLlNPVVJDRSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5UQVJHRVQpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRW5kUHJvcGVydGllcygndGFyZ2V0JykpIHJldHVybiBmbGFncztcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBGbGFncy5UQVJHRVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBwYXBlciwgc291cmNlVmlldywgdGFyZ2V0VmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBhcGVyICYmICgoc291cmNlVmlldyAmJiAhcGFwZXIuaXNWaWV3TW91bnRlZChzb3VyY2VWaWV3KSkgfHwgKHRhcmdldFZpZXcgJiYgIXBhcGVyLmlzVmlld01vdW50ZWQodGFyZ2V0VmlldykpKSkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHNvdXJjZVZpZXcgYW5kIHRhcmdldFZpZXcgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICAgIHJldHVybiBmbGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlJFTkRFUikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHMob3B0KTtcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBbRmxhZ3MuUkVOREVSLCBGbGFncy5VUERBVEUsIEZsYWdzLlZFUlRJQ0VTLCBGbGFncy5MQUJFTFMsIEZsYWdzLlRPT0xTLCBGbGFncy5MRUdBQ1lfVE9PTFMsIEZsYWdzLkNPTk5FQ1RPUl0pO1xuICAgICAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVwZGF0ZUhpZ2hsaWdodGVycyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlZFUlRJQ0VTKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWZXJ0ZXhNYXJrZXJzKCk7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgRmxhZ3MuVkVSVElDRVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBtb2RlbDtcbiAgICAgICAgbGV0IHVwZGF0ZUxhYmVscyA9IHRoaXMuaGFzRmxhZyhmbGFncywgRmxhZ3MuTEFCRUxTKTtcbiAgICAgICAgbGV0IHVwZGF0ZUxlZ2FjeVRvb2xzID0gdGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5MRUdBQ1lfVE9PTFMpO1xuXG4gICAgICAgIGlmICh1cGRhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMub25MYWJlbHNDaGFuZ2UobW9kZWwsIGF0dHJpYnV0ZXMubGFiZWxzLCBvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLkxBQkVMUyk7XG4gICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZUxlZ2FjeVRvb2xzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRvb2xzKCk7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgRmxhZ3MuTEVHQUNZX1RPT0xTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZUFsbCA9IHRoaXMuaGFzRmxhZyhmbGFncywgRmxhZ3MuVVBEQVRFKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29ubmVjdG9yID0gdGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5DT05ORUNUT1IpO1xuICAgICAgICBpZiAodXBkYXRlQWxsIHx8IHVwZGF0ZUNvbm5lY3Rvcikge1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVBbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IHJvdXRlIGFuZCB1cGRhdGUgdGhlIGdlb21ldHJ5XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0LnRyYW5zbGF0ZUJ5ICYmIG1vZGVsLmlzUmVsYXRpb25zaGlwRW1iZWRkZWRJbihvcHQudHJhbnNsYXRlQnkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpbmsgaXMgYmVpbmcgdHJhbnNsYXRlZCBieSBhbiBhbmNlc3RvciB0aGF0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBzb3VyY2UgcG9pbnQsIHRhcmdldCBwb2ludCBhbmQgYWxsIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgLy8gYnkgYW4gZXF1YWwgZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUob3B0LnR4LCBvcHQudHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIFtGbGFncy5VUERBVEUsIEZsYWdzLlRPT0xTLCBGbGFncy5DT05ORUNUT1JdKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhYmVscyA9IGZhbHNlO1xuICAgICAgICAgICAgdXBkYXRlTGVnYWN5VG9vbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHVwZGF0ZUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlTGFiZWxzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlTGVnYWN5VG9vbHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHNQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZUhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlRPT0xTKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLlRPT0xTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9LFxuXG4gICAgcmVxdWVzdENvbm5lY3Rpb25VcGRhdGU6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUodGhpcy5nZXRGbGFnKEZsYWdzLlVQREFURSksIG9wdCk7XG4gICAgfSxcblxuICAgIGlzTGFiZWxzUmVuZGVyUmVxdWlyZWQ6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNMYWJlbHMgPSB0aGlzLm1vZGVsLnByZXZpb3VzKCdsYWJlbHMnKTtcbiAgICAgICAgaWYgKCFwcmV2aW91c0xhYmVscykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gSGVyZSBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIGNhc2VzIHdoZW4gd2Uga25vdywgdGhhdCBjaGFuZ2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVxdWlyZSByZS1yZW5kZXJpbmcgb2YgYWxsIGxhYmVscy5cbiAgICAgICAgaWYgKCgncHJvcGVydHlQYXRoQXJyYXknIGluIG9wdCkgJiYgKCdwcm9wZXJ0eVZhbHVlJyBpbiBvcHQpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFiZWwgaXMgc2V0dGluZyBieSBgcHJvcCgpYCBtZXRob2RcbiAgICAgICAgICAgIHZhciBwYXRoQXJyYXkgPSBvcHQucHJvcGVydHlQYXRoQXJyYXkgfHwgW107XG4gICAgICAgICAgICB2YXIgcGF0aExlbmd0aCA9IHBhdGhBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hhbmdpbmcgYSBzaW5nbGUgbGFiZWwgaGVyZSBlLmcuICdsYWJlbHMvMC9wb3NpdGlvbidcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxFeGlzdHMgPSAhIXByZXZpb3VzTGFiZWxzW3BhdGhBcnJheVsxXV07XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hhbmdpbmcgdGhlIGVudGlyZSBsYWJlbC4gTmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcmt1cCBpcyBhbHNvIGJlaW5nIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCdtYXJrdXAnIGluIE9iamVjdChvcHQucHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhBcnJheVsyXSAhPT0gJ21hcmt1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBjaGFuZ2luZyBhIGxhYmVsIHByb3BlcnR5IGJ1dCBub3QgdGhlIG1hcmt1cFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIG9uTGFiZWxzQ2hhbmdlOiBmdW5jdGlvbihfbGluaywgX2xhYmVscywgb3B0KSB7XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBvcHRpbWl6YXRpb24gd29ya3MgaW4gYXN5bmM9ZmFsc2UgbW9kZSBvbmx5XG4gICAgICAgIGlmICh0aGlzLmlzTGFiZWxzUmVuZGVyUmVxdWlyZWQob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyaW5nLlxuICAgIC8vIC0tLS0tLS0tLS1cblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy52ZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy51bm1vdW50TGFiZWxzKCk7XG4gICAgICAgIHRoaXMuX1YgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXJrdXAoKTtcbiAgICAgICAgLy8gcmVuZGVyaW5nIGxhYmVscyBoYXMgdG8gYmUgcnVuIGFmdGVyIHRoZSBsaW5rIGlzIGFwcGVuZGVkIHRvIERPTSB0cmVlLiAob3RoZXJ3aXNlIDxUZXh0PiBiYm94XG4gICAgICAgIC8vIHJldHVybnMgemVybyB2YWx1ZXMpXG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlck1hcmt1cDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbWFya3VwID0gbGluay5nZXQoJ21hcmt1cCcpIHx8IGxpbmsubWFya3VwO1xuICAgICAgICBpZiAoIW1hcmt1cCkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IG1hcmt1cCByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXJrdXApKSByZXR1cm4gdGhpcy5yZW5kZXJKU09OTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMucmVuZGVyU3RyaW5nTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBpbnZhbGlkIG1hcmt1cCcpO1xuICAgIH0sXG5cbiAgICByZW5kZXJKU09OTWFya3VwOiBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgICAgICB2YXIgZG9jID0gdGhpcy5wYXJzZURPTUpTT04obWFya3VwLCB0aGlzLmVsKTtcbiAgICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgLy8gRnJhZ21lbnRcbiAgICAgICAgdGhpcy52ZWwuYXBwZW5kKGRvYy5mcmFnbWVudCk7XG4gICAgfSxcblxuICAgIHJlbmRlclN0cmluZ01hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgLy8gQSBzcGVjaWFsIG1hcmt1cCBjYW4gYmUgZ2l2ZW4gaW4gdGhlIGBwcm9wZXJ0aWVzLm1hcmt1cGAgcHJvcGVydHkuIFRoaXMgbWlnaHQgYmUgaGFuZHlcbiAgICAgICAgLy8gaWYgZS5nLiBhcnJvd2hlYWQgbWFya2VycyBzaG91bGQgYmUgYDxpbWFnZT5gIGVsZW1lbnRzIG9yIGFueSBvdGhlciBlbGVtZW50IHRoYW4gYDxwYXRoPmBzLlxuICAgICAgICAvLyBgLmNvbm5lY3Rpb25gLCBgLmNvbm5lY3Rpb24td3JhcGAsIGAubWFya2VyLXNvdXJjZWAgYW5kIGAubWFya2VyLXRhcmdldGAgc2VsZWN0b3JzXG4gICAgICAgIC8vIG9mIGVsZW1lbnRzIHdpdGggc3BlY2lhbCBtZWFuaW5nIHRob3VnaC4gVGhlcmVmb3JlLCB0aG9zZSBjbGFzc2VzIHNob3VsZCBiZSBwcmVzZXJ2ZWQgaW4gYW55XG4gICAgICAgIC8vIHNwZWNpYWwgbWFya3VwIHBhc3NlZCBpbiBgcHJvcGVydGllcy5tYXJrdXBgLlxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBWKG1hcmt1cCk7XG4gICAgICAgIC8vIGN1c3RvbSBtYXJrdXAgbWF5IGNvbnRhaW4gb25seSBvbmUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICAvLyBDYWNoZSBhbGwgY2hpbGRyZW4gZWxlbWVudHMgZm9yIHF1aWNrZXIgYWNjZXNzLlxuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9WOyAvLyB2ZWN0b3JpemVkIG1hcmt1cDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNoaWxkLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgdGhlIGpvaW50IGNsYXNzIG5hbWUgcHJlZml4LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gcmVtb3ZlQ2xhc3NOYW1lUHJlZml4KGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgY2FjaGVbJC5jYW1lbENhc2UoY2xhc3NOYW1lKV0gPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0aWFsIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLnJlbmRlclRvb2xzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyVmVydGV4TWFya2VycygpO1xuICAgICAgICB0aGlzLnJlbmRlckFycm93aGVhZE1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy52ZWwuYXBwZW5kKGNoaWxkcmVuKTtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsTWFya3VwOiBmdW5jdGlvbihsYWJlbE1hcmt1cCkge1xuXG4gICAgICAgIGlmICghbGFiZWxNYXJrdXApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFiZWxNYXJrdXApKSByZXR1cm4gdGhpcy5wYXJzZURPTUpTT04obGFiZWxNYXJrdXAsIG51bGwpO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsTWFya3VwID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMuX2dldExhYmVsU3RyaW5nTWFya3VwKGxhYmVsTWFya3VwKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEubGlua1ZpZXc6IGludmFsaWQgbGFiZWwgbWFya3VwJyk7XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbFN0cmluZ01hcmt1cDogZnVuY3Rpb24obGFiZWxNYXJrdXApIHtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBWKGxhYmVsTWFya3VwKTtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkcmVuLm5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGQgPSBjaGlsZHJlbltpXS5ub2RlO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBmcmFnbWVudDogZnJhZ21lbnQsIHNlbGVjdG9yczoge319OyAvLyBubyBzZWxlY3RvcnNcbiAgICB9LFxuXG4gICAgLy8gTGFiZWwgbWFya3VwIGZyYWdtZW50IG1heSBjb21lIHdyYXBwZWQgaW4gPGcgY2xhc3M9XCJsYWJlbFwiIC8+LCBvciBub3QuXG4gICAgLy8gSWYgaXQgZG9lc24ndCwgYWRkIHRoZSA8ZyAvPiBjb250YWluZXIgaGVyZS5cbiAgICBfbm9ybWFsaXplTGFiZWxNYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIGlmICghbWFya3VwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBmcmFnbWVudCA9IG1hcmt1cC5mcmFnbWVudDtcbiAgICAgICAgaWYgKCEobWFya3VwLmZyYWdtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgfHwgIW1hcmt1cC5mcmFnbWVudC5oYXNDaGlsZE5vZGVzKCkpIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBpbnZhbGlkIGxhYmVsIG1hcmt1cC4nKTtcblxuICAgICAgICB2YXIgdk5vZGU7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gZnJhZ21lbnQuY2hpbGROb2RlcztcblxuICAgICAgICBpZiAoKGNoaWxkTm9kZXMubGVuZ3RoID4gMSkgfHwgY2hpbGROb2Rlc1swXS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnRycpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgbWFya3VwIGZyYWdtZW50IGlzIG5vdCB3cmFwcGVkIGluIDxnIC8+XG4gICAgICAgICAgICAvLyBhZGQgYSA8ZyAvPiBjb250YWluZXJcbiAgICAgICAgICAgIHZOb2RlID0gVignZycpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2Tm9kZSA9IFYoY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2Tm9kZS5hZGRDbGFzcygnbGFiZWwnKTtcblxuICAgICAgICByZXR1cm4geyBub2RlOiB2Tm9kZS5ub2RlLCBzZWxlY3RvcnM6IG1hcmt1cC5zZWxlY3RvcnMgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyTGFiZWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9WO1xuICAgICAgICB2YXIgdkxhYmVscyA9IGNhY2hlLmxhYmVscztcbiAgICAgICAgdmFyIGxhYmVsQ2FjaGUgPSB0aGlzLl9sYWJlbENhY2hlID0ge307XG4gICAgICAgIHZhciBsYWJlbFNlbGVjdG9ycyA9IHRoaXMuX2xhYmVsU2VsZWN0b3JzID0ge307XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBsYWJlbHMgPSBtb2RlbC5hdHRyaWJ1dGVzLmxhYmVscyB8fCBbXTtcbiAgICAgICAgdmFyIGxhYmVsc0NvdW50ID0gbGFiZWxzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGFiZWxzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh2TGFiZWxzKSB2TGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodkxhYmVscykge1xuICAgICAgICAgICAgdkxhYmVscy5lbXB0eSgpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGxhYmVsIGNvbnRhaW5lciBpbiB0aGUgbWFya3VwIGJ1dCBzb21lIGxhYmVscyBhcmUgZGVmaW5lZFxuICAgICAgICAgICAgLy8gYWRkIGEgPGcgY2xhc3M9XCJsYWJlbHNcIiAvPiBjb250YWluZXJcbiAgICAgICAgICAgIHZMYWJlbHMgPSBjYWNoZS5sYWJlbHMgPSBWKCdnJykuYWRkQ2xhc3MoJ2xhYmVscycpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbHNMYXllcikge1xuICAgICAgICAgICAgICAgIHZMYWJlbHMuYWRkQ2xhc3MoYWRkQ2xhc3NOYW1lUHJlZml4KHJlc3VsdCh0aGlzLCAnY2xhc3NOYW1lJykpKTtcbiAgICAgICAgICAgICAgICB2TGFiZWxzLmF0dHIoJ21vZGVsLWlkJywgbW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHNDb3VudDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1hcmt1cCA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsTWFya3VwKHRoaXMuX2dldExhYmVsTWFya3VwKGxhYmVsLm1hcmt1cCkpO1xuICAgICAgICAgICAgdmFyIGxhYmVsTm9kZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgICAgICBpZiAobGFiZWxNYXJrdXApIHtcblxuICAgICAgICAgICAgICAgIGxhYmVsTm9kZSA9IGxhYmVsTWFya3VwLm5vZGU7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gbGFiZWxNYXJrdXAuc2VsZWN0b3JzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJ1aWx0aW5EZWZhdWx0TGFiZWwgPSAgbW9kZWwuX2J1aWx0aW5zLmRlZmF1bHRMYWJlbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbE1hcmt1cCA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsTWFya3VwKHRoaXMuX2dldExhYmVsTWFya3VwKGJ1aWx0aW5EZWZhdWx0TGFiZWwubWFya3VwKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRMYWJlbCA9IG1vZGVsLl9nZXREZWZhdWx0TGFiZWwoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdExhYmVsTWFya3VwID0gdGhpcy5fbm9ybWFsaXplTGFiZWxNYXJrdXAodGhpcy5fZ2V0TGFiZWxNYXJrdXAoZGVmYXVsdExhYmVsLm1hcmt1cCkpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0TWFya3VwID0gZGVmYXVsdExhYmVsTWFya3VwIHx8IGJ1aWx0aW5EZWZhdWx0TGFiZWxNYXJrdXA7XG5cbiAgICAgICAgICAgICAgICBsYWJlbE5vZGUgPSBkZWZhdWx0TWFya3VwLm5vZGU7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gZGVmYXVsdE1hcmt1cC5zZWxlY3RvcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsTm9kZS5zZXRBdHRyaWJ1dGUoJ2xhYmVsLWlkeCcsIGkpOyAvLyBhc3NpZ24gbGFiZWwtaWR4XG4gICAgICAgICAgICB2TGFiZWxzLmFwcGVuZChsYWJlbE5vZGUpO1xuICAgICAgICAgICAgbGFiZWxDYWNoZVtpXSA9IGxhYmVsTm9kZTsgLy8gY2FjaGUgbm9kZSBmb3IgYHVwZGF0ZUxhYmVscygpYCBzbyBpdCBjYW4ganVzdCB1cGRhdGUgbGFiZWwgbm9kZSBwb3NpdGlvbnNcblxuICAgICAgICAgICAgdmFyIHJvb3RTZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzW3Jvb3RTZWxlY3Rvcl0pIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBhbWJpZ3VvdXMgbGFiZWwgcm9vdCBzZWxlY3Rvci4nKTtcbiAgICAgICAgICAgIHNlbGVjdG9yc1tyb290U2VsZWN0b3JdID0gbGFiZWxOb2RlO1xuXG4gICAgICAgICAgICBsYWJlbFNlbGVjdG9yc1tpXSA9IHNlbGVjdG9yczsgLy8gY2FjaGUgbGFiZWwgc2VsZWN0b3JzIGZvciBgdXBkYXRlTGFiZWxzKClgXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2TGFiZWxzLnBhcmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdW50TGFiZWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb3VudExhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgZWwsIHBhcGVyLCBtb2RlbCwgX1YsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzOiB2TGFiZWxzIH0gPSBfVjtcbiAgICAgICAgaWYgKCF2TGFiZWxzIHx8ICFtb2RlbC5oYXNMYWJlbHMoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IG5vZGUgfSA9IHZMYWJlbHM7XG4gICAgICAgIGlmIChvcHRpb25zLmxhYmVsc0xheWVyKSB7XG4gICAgICAgICAgICBwYXBlci5nZXRMYXllclZpZXcob3B0aW9ucy5sYWJlbHNMYXllcikuaW5zZXJ0U29ydGVkTm9kZShub2RlLCBtb2RlbC5nZXQoJ3onKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBlbCkge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVubW91bnRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIF9WIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIV9WKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzOiB2TGFiZWxzIH0gPSBfVjtcbiAgICAgICAgaWYgKHZMYWJlbHMgJiYgb3B0aW9ucy5sYWJlbHNMYXllcikge1xuICAgICAgICAgICAgdkxhYmVscy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5kTGFiZWxOb2RlOiBmdW5jdGlvbihsYWJlbEluZGV4LCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBsYWJlbFJvb3QgPSB0aGlzLl9sYWJlbENhY2hlW2xhYmVsSW5kZXhdO1xuICAgICAgICBpZiAoIWxhYmVsUm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGxhYmVsU2VsZWN0b3JzID0gdGhpcy5fbGFiZWxTZWxlY3RvcnNbbGFiZWxJbmRleF07XG4gICAgICAgIGNvbnN0IFtub2RlID0gbnVsbF0gPSB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCBsYWJlbFJvb3QsIGxhYmVsU2VsZWN0b3JzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBsYWJlbCBhdHRycyBpbnRvIGxhYmVsIGF0dHJzIChvciB1c2UgYnVpbHQtaW4gZGVmYXVsdCBsYWJlbCBhdHRycyBpZiBuZWl0aGVyIGlzIHByb3ZpZGVkKVxuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsQXR0cnM6IGZ1bmN0aW9uKGhhc0N1c3RvbU1hcmt1cCwgbGFiZWxBdHRycywgZGVmYXVsdExhYmVsQXR0cnMsIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycykge1xuXG4gICAgICAgIGlmIChsYWJlbEF0dHJzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGxhYmVsQXR0cnMgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsQXR0cnMgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbEF0dHJzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21NYXJrdXApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0N1c3RvbU1hcmt1cCkgcmV0dXJuIGRlZmF1bHRMYWJlbEF0dHJzO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMsIGRlZmF1bHRMYWJlbEF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDdXN0b21NYXJrdXApIHJldHVybiBtZXJnZSh7fSwgZGVmYXVsdExhYmVsQXR0cnMsIGxhYmVsQXR0cnMpO1xuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycywgZGVmYXVsdExhYmVsQXR0cnMsIGxhYmVsQXR0cnMpO1xuICAgIH0sXG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IGxhYmVsIHNpemUgaW50byBsYWJlbCBzaXplIChubyBidWlsdC1pbiBkZWZhdWx0KVxuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWxTaXplLCBkZWZhdWx0TGFiZWxTaXplKSB7XG5cbiAgICAgICAgaWYgKGxhYmVsU2l6ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChsYWJlbFNpemUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsU2l6ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsU2l6ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXJnZSh7fSwgZGVmYXVsdExhYmVsU2l6ZSwgbGFiZWxTaXplKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlTGFiZWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX1YubGFiZWxzKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gbW9kZWwuZ2V0KCdsYWJlbHMnKSB8fCBbXTtcbiAgICAgICAgdmFyIGNhbkxhYmVsTW92ZSA9IHRoaXMuY2FuKCdsYWJlbE1vdmUnKTtcblxuICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbCA9IG1vZGVsLl9idWlsdGlucy5kZWZhdWx0TGFiZWw7XG4gICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMgPSBidWlsdGluRGVmYXVsdExhYmVsLmF0dHJzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSBtb2RlbC5fZ2V0RGVmYXVsdExhYmVsKCk7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxNYXJrdXAgPSBkZWZhdWx0TGFiZWwubWFya3VwO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsQXR0cnMgPSBkZWZhdWx0TGFiZWwuYXR0cnM7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxTaXplID0gZGVmYXVsdExhYmVsLnNpemU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbE5vZGUgPSB0aGlzLl9sYWJlbENhY2hlW2ldO1xuICAgICAgICAgICAgbGFiZWxOb2RlLnNldEF0dHJpYnV0ZSgnY3Vyc29yJywgKGNhbkxhYmVsTW92ZSA/ICdtb3ZlJyA6ICdkZWZhdWx0JykpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gdGhpcy5fbGFiZWxTZWxlY3RvcnNbaV07XG5cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1hcmt1cCA9IGxhYmVsLm1hcmt1cDtcbiAgICAgICAgICAgIHZhciBsYWJlbEF0dHJzID0gbGFiZWwuYXR0cnM7XG4gICAgICAgICAgICB2YXIgbGFiZWxTaXplID0gbGFiZWwuc2l6ZTtcblxuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5fbWVyZ2VMYWJlbEF0dHJzKFxuICAgICAgICAgICAgICAgIChsYWJlbE1hcmt1cCB8fCBkZWZhdWx0TGFiZWxNYXJrdXApLFxuICAgICAgICAgICAgICAgIGxhYmVsQXR0cnMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdExhYmVsQXR0cnMsXG4gICAgICAgICAgICAgICAgYnVpbHRpbkRlZmF1bHRMYWJlbEF0dHJzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX21lcmdlTGFiZWxTaXplKFxuICAgICAgICAgICAgICAgIGxhYmVsU2l6ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFiZWxTaXplXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKGxhYmVsTm9kZSwgYXR0cnMsIHtcbiAgICAgICAgICAgICAgICByb290QkJveDogbmV3IFJlY3Qoc2l6ZSksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlclRvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBUb29scyBhcmUgYSBncm91cCBvZiBjbGlja2FibGUgZWxlbWVudHMgdGhhdCBtYW5pcHVsYXRlIHRoZSB3aG9sZSBsaW5rLlxuICAgICAgICAvLyBBIGdvb2QgZXhhbXBsZSBvZiB0aGlzIGlzIHRoZSByZW1vdmUgdG9vbCB0aGF0IHJlbW92ZXMgdGhlIHdob2xlIGxpbmsuXG4gICAgICAgIC8vIFRvb2xzIGFwcGVhciBhZnRlciBob3ZlcmluZyB0aGUgbGluayBjbG9zZSB0byB0aGUgYHNvdXJjZWAgZWxlbWVudC9wb2ludCBvZiB0aGUgbGlua1xuICAgICAgICAvLyBidXQgYXJlIG9mZnNldCBhIGJpdCBzbyB0aGF0IHRoZXkgZG9uJ3QgY292ZXIgdGhlIGBtYXJrZXItYXJyb3doZWFkYC5cblxuICAgICAgICB2YXIgJHRvb2xzID0gJCh0aGlzLl9WLmxpbmtUb29scy5ub2RlKS5lbXB0eSgpO1xuICAgICAgICB2YXIgdG9vbFRlbXBsYXRlID0gdGVtcGxhdGUodGhpcy5tb2RlbC5nZXQoJ3Rvb2xNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLnRvb2xNYXJrdXApO1xuICAgICAgICB2YXIgdG9vbCA9IFYodG9vbFRlbXBsYXRlKCkpO1xuXG4gICAgICAgICR0b29scy5hcHBlbmQodG9vbC5ub2RlKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgdG9vbCBub2RlIHNvIHRoYXQgdGhlIGB1cGRhdGVUb29sc1Bvc2l0aW9uKClgIGNhbiB1cGRhdGUgdGhlIHRvb2wgcG9zaXRpb24gcXVpY2tseS5cbiAgICAgICAgdGhpcy5fdG9vbENhY2hlID0gdG9vbDtcblxuICAgICAgICAvLyBJZiBgZG91YmxlTGlua1Rvb2xzYCBpcyBlbmFibGVkLCB3ZSByZW5kZXIgY29weSBvZiB0aGUgdG9vbHMgb24gdGhlIG90aGVyIHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGxpbmsgYXMgd2VsbCBidXQgb25seSBpZiB0aGUgbGluayBpcyBsb25nZXIgdGhhbiBgbG9uZ0xpbmtMZW5ndGhgLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvdWJsZUxpbmtUb29scykge1xuXG4gICAgICAgICAgICB2YXIgdG9vbDI7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2RvdWJsZVRvb2xNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLmRvdWJsZVRvb2xNYXJrdXApIHtcbiAgICAgICAgICAgICAgICB0b29sVGVtcGxhdGUgPSB0ZW1wbGF0ZSh0aGlzLm1vZGVsLmdldCgnZG91YmxlVG9vbE1hcmt1cCcpIHx8IHRoaXMubW9kZWwuZG91YmxlVG9vbE1hcmt1cCk7XG4gICAgICAgICAgICAgICAgdG9vbDIgPSBWKHRvb2xUZW1wbGF0ZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbDIgPSB0b29sLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR0b29scy5hcHBlbmQodG9vbDIubm9kZSk7XG4gICAgICAgICAgICB0aGlzLl90b29sMkNhY2hlID0gdG9vbDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyVmVydGV4TWFya2VyczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9WLm1hcmtlclZlcnRpY2VzKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgJG1hcmtlclZlcnRpY2VzID0gJCh0aGlzLl9WLm1hcmtlclZlcnRpY2VzLm5vZGUpLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gQSBzcGVjaWFsIG1hcmt1cCBjYW4gYmUgZ2l2ZW4gaW4gdGhlIGBwcm9wZXJ0aWVzLnZlcnRleE1hcmt1cGAgcHJvcGVydHkuIFRoaXMgbWlnaHQgYmUgaGFuZHlcbiAgICAgICAgLy8gaWYgZGVmYXVsdCBzdHlsaW5nIChlbGVtZW50cykgYXJlIG5vdCBkZXNpcmVkLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHVzZSBhbnlcbiAgICAgICAgLy8gU1ZHIGVsZW1lbnRzIGZvciAubWFya2VyLXZlcnRleCBhbmQgLm1hcmtlci12ZXJ0ZXgtcmVtb3ZlIHRvb2xzLlxuICAgICAgICB2YXIgbWFya3VwVGVtcGxhdGUgPSB0ZW1wbGF0ZSh0aGlzLm1vZGVsLmdldCgndmVydGV4TWFya3VwJykgfHwgdGhpcy5tb2RlbC52ZXJ0ZXhNYXJrdXApO1xuXG4gICAgICAgIHRoaXMubW9kZWwudmVydGljZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleCwgaWR4KSB7XG4gICAgICAgICAgICAkbWFya2VyVmVydGljZXMuYXBwZW5kKFYobWFya3VwVGVtcGxhdGUoYXNzaWduKHsgaWR4OiBpZHggfSwgdmVydGV4KSkpLm5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyQXJyb3doZWFkTWFya2VyczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gQ3VzdG9tIG1hcmt1cHMgbWlnaHQgbm90IGhhdmUgYXJyb3doZWFkIG1hcmtlcnMuIFRoZXJlZm9yZSwganVtcCBvZiB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICAgICAgaWYgKCF0aGlzLl9WLm1hcmtlckFycm93aGVhZHMpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciAkbWFya2VyQXJyb3doZWFkcyA9ICQodGhpcy5fVi5tYXJrZXJBcnJvd2hlYWRzLm5vZGUpO1xuXG4gICAgICAgICRtYXJrZXJBcnJvd2hlYWRzLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gQSBzcGVjaWFsIG1hcmt1cCBjYW4gYmUgZ2l2ZW4gaW4gdGhlIGBwcm9wZXJ0aWVzLnZlcnRleE1hcmt1cGAgcHJvcGVydHkuIFRoaXMgbWlnaHQgYmUgaGFuZHlcbiAgICAgICAgLy8gaWYgZGVmYXVsdCBzdHlsaW5nIChlbGVtZW50cykgYXJlIG5vdCBkZXNpcmVkLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHVzZSBhbnlcbiAgICAgICAgLy8gU1ZHIGVsZW1lbnRzIGZvciAubWFya2VyLXZlcnRleCBhbmQgLm1hcmtlci12ZXJ0ZXgtcmVtb3ZlIHRvb2xzLlxuICAgICAgICB2YXIgbWFya3VwVGVtcGxhdGUgPSB0ZW1wbGF0ZSh0aGlzLm1vZGVsLmdldCgnYXJyb3doZWFkTWFya3VwJykgfHwgdGhpcy5tb2RlbC5hcnJvd2hlYWRNYXJrdXApO1xuXG4gICAgICAgIHRoaXMuX1Yuc291cmNlQXJyb3doZWFkID0gVihtYXJrdXBUZW1wbGF0ZSh7IGVuZDogJ3NvdXJjZScgfSkpO1xuICAgICAgICB0aGlzLl9WLnRhcmdldEFycm93aGVhZCA9IFYobWFya3VwVGVtcGxhdGUoeyBlbmQ6ICd0YXJnZXQnIH0pKTtcblxuICAgICAgICAkbWFya2VyQXJyb3doZWFkcy5hcHBlbmQodGhpcy5fVi5zb3VyY2VBcnJvd2hlYWQubm9kZSwgdGhpcy5fVi50YXJnZXRBcnJvd2hlYWQubm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSB2ZXJ0aWNlcyB0aGF0IGxpZSBvbiAob3IgbmVhcmx5IG9uKSBzdHJhaWdodCBsaW5lcyB3aXRoaW4gdGhlIGxpbmtcbiAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiByZW1vdmVkIHBvaW50c1xuICAgIHJlbW92ZVJlZHVuZGFudExpbmVhclZlcnRpY2VzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBjb25zdCBTSU1QTElGWV9USFJFU0hPTEQgPSAwLjAwMTtcblxuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBsaW5rLnZlcnRpY2VzKCk7XG4gICAgICAgIGNvbnN0IHJvdXRlUG9pbnRzID0gW3RoaXMuc291cmNlQW5jaG9yLCAuLi52ZXJ0aWNlcywgdGhpcy50YXJnZXRBbmNob3JdO1xuICAgICAgICBjb25zdCBudW1Sb3V0ZVBvaW50cyA9IHJvdXRlUG9pbnRzLmxlbmd0aDtcblxuICAgICAgICAvLyBwdXQgcm91dGVQb2ludHMgaW50byBhIHBvbHlsaW5lIGFuZCB0cnkgdG8gc2ltcGxpZnlcbiAgICAgICAgY29uc3QgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUocm91dGVQb2ludHMpO1xuICAgICAgICBwb2x5bGluZS5zaW1wbGlmeSh7IHRocmVzaG9sZDogU0lNUExJRllfVEhSRVNIT0xEIH0pO1xuICAgICAgICBjb25zdCBwb2x5bGluZVBvaW50cyA9IHBvbHlsaW5lLnBvaW50cy5tYXAoKHBvaW50KSA9PiAocG9pbnQudG9KU09OKCkpKTsgLy8gSlNPTiBvZiBwb2ludHMgYWZ0ZXIgc2ltcGxpZmljYXRpb25cbiAgICAgICAgY29uc3QgbnVtUG9seWxpbmVQb2ludHMgPSBwb2x5bGluZVBvaW50cy5sZW5ndGg7IC8vIG51bWJlciBvZiBwb2ludHMgYWZ0ZXIgc2ltcGxpZmljYXRpb25cblxuICAgICAgICAvLyBzaG9ydGN1dCBpZiBzaW1wbGlmaWNhdGlvbiBkaWQgbm90IHJlbW92ZSBhbnkgcmVkdW5kYW50IHZlcnRpY2VzOlxuICAgICAgICBpZiAobnVtUm91dGVQb2ludHMgPT09IG51bVBvbHlsaW5lUG9pbnRzKSByZXR1cm4gMDtcblxuICAgICAgICAvLyBlbHNlOiBzZXQgc2ltcGxpZmllZCBwb2x5bGluZSBwb2ludHMgYXMgbGluayB2ZXJ0aWNlc1xuICAgICAgICAvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgcG9seWxpbmUgcG9pbnRzIGFnYWluICg9IHNvdXJjZS90YXJnZXQgYW5jaG9ycylcbiAgICAgICAgbGluay52ZXJ0aWNlcyhwb2x5bGluZVBvaW50cy5zbGljZSgxLCBudW1Qb2x5bGluZVBvaW50cyAtIDEpLCBvcHQpO1xuICAgICAgICByZXR1cm4gKG51bVJvdXRlUG9pbnRzIC0gbnVtUG9seWxpbmVQb2ludHMpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVEZWZhdWx0Q29ubmVjdGlvblBhdGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuX1Y7XG5cbiAgICAgICAgaWYgKGNhY2hlLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNhY2hlLmNvbm5lY3Rpb24uYXR0cignZCcsIHRoaXMuZ2V0U2VyaWFsaXplZENvbm5lY3Rpb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGUuY29ubmVjdGlvbldyYXApIHtcbiAgICAgICAgICAgIGNhY2hlLmNvbm5lY3Rpb25XcmFwLmF0dHIoJ2QnLCB0aGlzLmdldFNlcmlhbGl6ZWRDb25uZWN0aW9uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlLm1hcmtlclNvdXJjZSAmJiBjYWNoZS5tYXJrZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZUFuZEF1dG9PcmllbnRBcnJvd3MoY2FjaGUubWFya2VyU291cmNlLCBjYWNoZS5tYXJrZXJUYXJnZXQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEVuZFZpZXc6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVZpZXcgfHwgbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0VmlldyB8fCBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdHlwZSBwYXJhbWV0ZXIgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RW5kQW5jaG9yOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuc291cmNlQW5jaG9yKTtcbiAgICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFbmRDb25uZWN0aW9uUG9pbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5zb3VyY2VQb2ludCk7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy50YXJnZXRQb2ludCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFbmRNYWduZXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VWaWV3ID0gdGhpcy5zb3VyY2VWaWV3O1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlVmlldykgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFnbmV0IHx8IHNvdXJjZVZpZXcuZWw7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWaWV3ID0gdGhpcy50YXJnZXRWaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VmlldykgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0TWFnbmV0IHx8IHRhcmdldFZpZXcuZWw7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG5cbiAgICAvLyBVcGRhdGluZy5cbiAgICAvLyAtLS0tLS0tLS1cblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUm91dGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4ID0gMCwgdHkgPSAwKSB7XG4gICAgICAgIGNvbnN0IHsgcm91dGUsIHBhdGggfSA9IHRoaXM7XG4gICAgICAgIGlmICghcm91dGUgfHwgIXBhdGgpIHJldHVybjtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSByb3V0ZVxuICAgICAgICBjb25zdCBwb2x5bGluZSA9IG5ldyBQb2x5bGluZShyb3V0ZSk7XG4gICAgICAgIHBvbHlsaW5lLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLnJvdXRlID0gcG9seWxpbmUucG9pbnRzO1xuICAgICAgICAvLyB0cmFuc2xhdGUgc291cmNlIGFuZCB0YXJnZXQgY29ubmVjdGlvbiBhbmQgbWFya2VyIHBvaW50cy5cbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlQ29ubmVjdGlvblBvaW50cyh0eCwgdHkpO1xuICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIGdlb21ldHJ5IHBhdGhcbiAgICAgICAgcGF0aC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRE9NKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBtb2RlbCwgc2VsZWN0b3JzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFuTm9kZXNDYWNoZSgpO1xuICAgICAgICAvLyB1cGRhdGUgU1ZHIGF0dHJpYnV0ZXMgZGVmaW5lZCBieSAnYXR0cnMvJy5cbiAgICAgICAgdGhpcy51cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlcyhlbCwgbW9kZWwuYXR0cigpLCB7IHNlbGVjdG9ycyB9KTtcbiAgICAgICAgLy8gbGVnYWN5IGxpbmsgcGF0aCB1cGRhdGVcbiAgICAgICAgdGhpcy51cGRhdGVEZWZhdWx0Q29ubmVjdGlvblBhdGgoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBsYWJlbCBwb3NpdGlvbiBldGMuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sc1Bvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXJyb3doZWFkTWFya2VycygpO1xuICAgICAgICAvLyAqRGVwcmVjYXRlZCpcbiAgICAgICAgLy8gTG9jYWwgcGVycGVuZGljdWxhciBmbGFnIChhcyBvcHBvc2VkIHRvIG9uZSBkZWZpbmVkIG9uIHBhcGVyKS5cbiAgICAgICAgLy8gQ291bGQgYmUgZW5hYmxlZCBpbnNpZGUgYSBjb25uZWN0b3Ivcm91dGVyLiBJdCdzIHZhbGlkIG9ubHlcbiAgICAgICAgLy8gZHVyaW5nIHRoZSB1cGRhdGUgZXhlY3V0aW9uLlxuICAgICAgICB0aGlzLm9wdGlvbnMucGVycGVuZGljdWxhciA9IG51bGw7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJvdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBtb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICAvLyAxLiBGaW5kIEFuY2hvcnNcbiAgICAgICAgY29uc3QgYW5jaG9ycyA9IHRoaXMuZmluZEFuY2hvcnModmVydGljZXMpO1xuICAgICAgICBjb25zdCBzb3VyY2VBbmNob3IgPSB0aGlzLnNvdXJjZUFuY2hvciA9IGFuY2hvcnMuc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSB0aGlzLnRhcmdldEFuY2hvciA9IGFuY2hvcnMudGFyZ2V0O1xuICAgICAgICAvLyAyLiBGaW5kIFJvdXRlXG4gICAgICAgIGNvbnN0IHJvdXRlID0gdGhpcy5maW5kUm91dGUodmVydGljZXMpO1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIC8vIDMuIEZpbmQgQ29ubmVjdGlvbiBQb2ludHNcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Qb2ludHMgPSB0aGlzLmZpbmRDb25uZWN0aW9uUG9pbnRzKHJvdXRlLCBzb3VyY2VBbmNob3IsIHRhcmdldEFuY2hvcik7XG4gICAgICAgIHRoaXMuc291cmNlUG9pbnQgPSBjb25uZWN0aW9uUG9pbnRzLnNvdXJjZTtcbiAgICAgICAgdGhpcy50YXJnZXRQb2ludCA9IGNvbm5lY3Rpb25Qb2ludHMudGFyZ2V0O1xuICAgIH0sXG5cbiAgICB1cGRhdGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByb3V0ZSwgc291cmNlUG9pbnQsIHRhcmdldFBvaW50IH0gPSB0aGlzO1xuICAgICAgICAvLyAzYi4gRmluZCBNYXJrZXIgQ29ubmVjdGlvbiBQb2ludCAtIEJhY2t3YXJkcyBDb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IG1hcmtlclBvaW50cyA9IHRoaXMuZmluZE1hcmtlclBvaW50cyhyb3V0ZSwgc291cmNlUG9pbnQsIHRhcmdldFBvaW50KTtcbiAgICAgICAgLy8gNC4gRmluZCBDb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZpbmRQYXRoKHJvdXRlLCBtYXJrZXJQb2ludHMuc291cmNlIHx8IHNvdXJjZVBvaW50LCBtYXJrZXJQb2ludHMudGFyZ2V0IHx8IHRhcmdldFBvaW50KTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9LFxuXG4gICAgZmluZE1hcmtlclBvaW50czogZnVuY3Rpb24ocm91dGUsIHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCkge1xuXG4gICAgICAgIHZhciBmaXJzdFdheXBvaW50ID0gcm91dGVbMF07XG4gICAgICAgIHZhciBsYXN0V2F5cG9pbnQgPSByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBzb3VyY2UgcG9pbnQgYnkgdGhlIHdpZHRoIG9mIHRoZSBtYXJrZXIgdGFraW5nIGludG8gYWNjb3VudFxuICAgICAgICAvLyBpdHMgc2NhbGUgYXJvdW5kIHgtYXhpcy4gTm90ZSB0aGF0IHNjYWxlIGlzIHRoZSBvbmx5IHRyYW5zZm9ybSB0aGF0XG4gICAgICAgIC8vIG1ha2VzIHNlbnNlIHRvIGJlIHNldCBpbiBgLm1hcmtlci1zb3VyY2VgIGF0dHJpYnV0ZXMgb2JqZWN0XG4gICAgICAgIC8vIGFzIGFsbCBvdGhlciB0cmFuc2Zvcm1zICh0cmFuc2xhdGUvcm90YXRlKSB3aWxsIGJlIHJlcGxhY2VkXG4gICAgICAgIC8vIGJ5IHRoZSBgdHJhbnNsYXRlQW5kQXV0b09yaWVudCgpYCBmdW5jdGlvbi5cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fbWFya2VyQ2FjaGU7XG4gICAgICAgIC8vIGNhY2hlIHNvdXJjZSBhbmQgdGFyZ2V0IHBvaW50c1xuICAgICAgICB2YXIgc291cmNlTWFya2VyUG9pbnQsIHRhcmdldE1hcmtlclBvaW50O1xuXG4gICAgICAgIGlmICh0aGlzLl9WLm1hcmtlclNvdXJjZSkge1xuXG4gICAgICAgICAgICBjYWNoZS5zb3VyY2VCQm94ID0gY2FjaGUuc291cmNlQkJveCB8fCB0aGlzLl9WLm1hcmtlclNvdXJjZS5nZXRCQm94KCk7XG4gICAgICAgICAgICBzb3VyY2VNYXJrZXJQb2ludCA9IFBvaW50KHNvdXJjZVBvaW50KS5tb3ZlKFxuICAgICAgICAgICAgICAgIGZpcnN0V2F5cG9pbnQgfHwgdGFyZ2V0UG9pbnQsXG4gICAgICAgICAgICAgICAgY2FjaGUuc291cmNlQkJveC53aWR0aCAqIHRoaXMuX1YubWFya2VyU291cmNlLnNjYWxlKCkuc3ggKiAtMVxuICAgICAgICAgICAgKS5yb3VuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX1YubWFya2VyVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGNhY2hlLnRhcmdldEJCb3ggPSBjYWNoZS50YXJnZXRCQm94IHx8IHRoaXMuX1YubWFya2VyVGFyZ2V0LmdldEJCb3goKTtcbiAgICAgICAgICAgIHRhcmdldE1hcmtlclBvaW50ID0gUG9pbnQodGFyZ2V0UG9pbnQpLm1vdmUoXG4gICAgICAgICAgICAgICAgbGFzdFdheXBvaW50IHx8IHNvdXJjZVBvaW50LFxuICAgICAgICAgICAgICAgIGNhY2hlLnRhcmdldEJCb3gud2lkdGggKiB0aGlzLl9WLm1hcmtlclRhcmdldC5zY2FsZSgpLnN4ICogLTFcbiAgICAgICAgICAgICkucm91bmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBtYXJrdXAgZm9yIHRoZSBtYXJrZXIsIHVzZSB0aGUgY29ubmVjdGlvbiBwb2ludC5cbiAgICAgICAgY2FjaGUuc291cmNlUG9pbnQgPSBzb3VyY2VNYXJrZXJQb2ludCB8fCBzb3VyY2VQb2ludC5jbG9uZSgpO1xuICAgICAgICBjYWNoZS50YXJnZXRQb2ludCA9IHRhcmdldE1hcmtlclBvaW50IHx8IHRhcmdldFBvaW50LmNsb25lKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlTWFya2VyUG9pbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldE1hcmtlclBvaW50XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGZpbmRBbmNob3JzT3JkZXJlZDogZnVuY3Rpb24oZmlyc3RFbmRUeXBlLCBmaXJzdFJlZiwgc2Vjb25kRW5kVHlwZSwgc2Vjb25kUmVmKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0QW5jaG9yLCBzZWNvbmRBbmNob3I7XG4gICAgICAgIHZhciBmaXJzdEFuY2hvclJlZiwgc2Vjb25kQW5jaG9yUmVmO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZmlyc3REZWYgPSBtb2RlbC5nZXQoZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgdmFyIHNlY29uZERlZiA9IG1vZGVsLmdldChzZWNvbmRFbmRUeXBlKTtcbiAgICAgICAgdmFyIGZpcnN0VmlldyA9IHRoaXMuZ2V0RW5kVmlldyhmaXJzdEVuZFR5cGUpO1xuICAgICAgICB2YXIgc2Vjb25kVmlldyA9IHRoaXMuZ2V0RW5kVmlldyhzZWNvbmRFbmRUeXBlKTtcbiAgICAgICAgdmFyIGZpcnN0TWFnbmV0ID0gdGhpcy5nZXRFbmRNYWduZXQoZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgdmFyIHNlY29uZE1hZ25ldCA9IHRoaXMuZ2V0RW5kTWFnbmV0KHNlY29uZEVuZFR5cGUpO1xuXG4gICAgICAgIC8vIEFuY2hvciBmaXJzdFxuICAgICAgICBpZiAoZmlyc3RWaWV3KSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RSZWYpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEFuY2hvclJlZiA9IG5ldyBQb2ludChmaXJzdFJlZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZFZpZXcpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEFuY2hvclJlZiA9IHNlY29uZE1hZ25ldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RBbmNob3JSZWYgPSBuZXcgUG9pbnQoc2Vjb25kRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0QW5jaG9yID0gdGhpcy5nZXRBbmNob3IoZmlyc3REZWYuYW5jaG9yLCBmaXJzdFZpZXcsIGZpcnN0TWFnbmV0LCBmaXJzdEFuY2hvclJlZiwgZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0QW5jaG9yID0gbmV3IFBvaW50KGZpcnN0RGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuY2hvciBzZWNvbmRcbiAgICAgICAgaWYgKHNlY29uZFZpZXcpIHtcbiAgICAgICAgICAgIHNlY29uZEFuY2hvclJlZiA9IG5ldyBQb2ludChzZWNvbmRSZWYgfHwgZmlyc3RBbmNob3IpO1xuICAgICAgICAgICAgc2Vjb25kQW5jaG9yID0gdGhpcy5nZXRBbmNob3Ioc2Vjb25kRGVmLmFuY2hvciwgc2Vjb25kVmlldywgc2Vjb25kTWFnbmV0LCBzZWNvbmRBbmNob3JSZWYsIHNlY29uZEVuZFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Vjb25kQW5jaG9yID0gbmV3IFBvaW50KHNlY29uZERlZik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlc1tmaXJzdEVuZFR5cGVdID0gZmlyc3RBbmNob3I7XG4gICAgICAgIHJlc1tzZWNvbmRFbmRUeXBlXSA9IHNlY29uZEFuY2hvcjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgZmluZEFuY2hvcnM6IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF07XG4gICAgICAgIHZhciBsYXN0VmVydGV4ID0gdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKG1vZGVsLnRhcmdldCgpLnByaW9yaXR5ICYmICFtb2RlbC5zb3VyY2UoKS5wcmlvcml0eSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJzZWQgb3JkZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRBbmNob3JzT3JkZXJlZCgndGFyZ2V0JywgbGFzdFZlcnRleCwgJ3NvdXJjZScsIGZpcnN0VmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzdWFsIG9yZGVyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRBbmNob3JzT3JkZXJlZCgnc291cmNlJywgZmlyc3RWZXJ0ZXgsICd0YXJnZXQnLCBsYXN0VmVydGV4KTtcbiAgICB9LFxuXG4gICAgZmluZENvbm5lY3Rpb25Qb2ludHM6IGZ1bmN0aW9uKHJvdXRlLCBzb3VyY2VBbmNob3IsIHRhcmdldEFuY2hvcikge1xuXG4gICAgICAgIHZhciBmaXJzdFdheXBvaW50ID0gcm91dGVbMF07XG4gICAgICAgIHZhciBsYXN0V2F5cG9pbnQgPSByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHNvdXJjZURlZiA9IG1vZGVsLmdldCgnc291cmNlJyk7XG4gICAgICAgIHZhciB0YXJnZXREZWYgPSBtb2RlbC5nZXQoJ3RhcmdldCcpO1xuICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuc291cmNlVmlldztcbiAgICAgICAgdmFyIHRhcmdldFZpZXcgPSB0aGlzLnRhcmdldFZpZXc7XG4gICAgICAgIHZhciBwYXBlck9wdGlvbnMgPSB0aGlzLnBhcGVyLm9wdGlvbnM7XG4gICAgICAgIHZhciBzb3VyY2VNYWduZXQsIHRhcmdldE1hZ25ldDtcblxuICAgICAgICAvLyBDb25uZWN0aW9uIFBvaW50IFNvdXJjZVxuICAgICAgICB2YXIgc291cmNlUG9pbnQ7XG4gICAgICAgIGlmIChzb3VyY2VWaWV3ICYmICFzb3VyY2VWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGhpcy5zb3VyY2VNYWduZXQpKSB7XG4gICAgICAgICAgICBzb3VyY2VNYWduZXQgPSAodGhpcy5zb3VyY2VNYWduZXQgfHwgc291cmNlVmlldy5lbCk7XG4gICAgICAgICAgICB2YXIgc291cmNlQ29ubmVjdGlvblBvaW50RGVmID0gc291cmNlRGVmLmNvbm5lY3Rpb25Qb2ludCB8fCBwYXBlck9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludDtcbiAgICAgICAgICAgIHZhciBzb3VyY2VQb2ludFJlZiA9IGZpcnN0V2F5cG9pbnQgfHwgdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUxpbmUgPSBuZXcgTGluZShzb3VyY2VQb2ludFJlZiwgc291cmNlQW5jaG9yKTtcbiAgICAgICAgICAgIHNvdXJjZVBvaW50ID0gdGhpcy5nZXRDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgc291cmNlQ29ubmVjdGlvblBvaW50RGVmLFxuICAgICAgICAgICAgICAgIHNvdXJjZVZpZXcsXG4gICAgICAgICAgICAgICAgc291cmNlTWFnbmV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZUxpbmUsXG4gICAgICAgICAgICAgICAgJ3NvdXJjZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VQb2ludCA9IHNvdXJjZUFuY2hvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25uZWN0aW9uIFBvaW50IFRhcmdldFxuICAgICAgICB2YXIgdGFyZ2V0UG9pbnQ7XG4gICAgICAgIGlmICh0YXJnZXRWaWV3ICYmICF0YXJnZXRWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGhpcy50YXJnZXRNYWduZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXRNYWduZXQgPSAodGhpcy50YXJnZXRNYWduZXQgfHwgdGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q29ubmVjdGlvblBvaW50RGVmID0gdGFyZ2V0RGVmLmNvbm5lY3Rpb25Qb2ludCB8fCBwYXBlck9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRQb2ludFJlZiA9IGxhc3RXYXlwb2ludCB8fCBzb3VyY2VBbmNob3I7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TGluZSA9IG5ldyBMaW5lKHRhcmdldFBvaW50UmVmLCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0aGlzLmdldENvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICB0YXJnZXRDb25uZWN0aW9uUG9pbnREZWYsXG4gICAgICAgICAgICAgICAgdGFyZ2V0VmlldyxcbiAgICAgICAgICAgICAgICB0YXJnZXRNYWduZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGluZSxcbiAgICAgICAgICAgICAgICAndGFyZ2V0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFBvaW50ID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlUG9pbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFBvaW50XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEFuY2hvcjogZnVuY3Rpb24oYW5jaG9yRGVmLCBjZWxsVmlldywgbWFnbmV0LCByZWYsIGVuZFR5cGUpIHtcblxuICAgICAgICB2YXIgaXNDb25uZWN0aW9uID0gY2VsbFZpZXcuaXNOb2RlQ29ubmVjdGlvbihtYWduZXQpO1xuICAgICAgICB2YXIgcGFwZXJPcHRpb25zID0gdGhpcy5wYXBlci5vcHRpb25zO1xuICAgICAgICBpZiAoIWFuY2hvckRlZikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFuY2hvckRlZiA9IHBhcGVyT3B0aW9ucy5kZWZhdWx0TGlua0FuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcGVyT3B0aW9ucy5wZXJwZW5kaWN1bGFyTGlua3MgfHwgdGhpcy5vcHRpb25zLnBlcnBlbmRpY3VsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYHBlcnBlbmRpY3VsYXJMaW5rc2AgZmxhZyBpcyBzZXQgb24gdGhlIHBhcGVyIGFuZCB0aGVyZSBhcmUgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIGxpbmssIHRoZW4gdHJ5IHRvIGZpbmQgYSBjb25uZWN0aW9uIHBvaW50IHRoYXQgbWFrZXMgdGhlIGxpbmsgcGVycGVuZGljdWxhclxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGUgbGluayB3b24ndCBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSB0YXJnZXRlZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckRlZiA9IHsgbmFtZTogJ3BlcnBlbmRpY3VsYXInIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yRGVmID0gcGFwZXJPcHRpb25zLmRlZmF1bHRBbmNob3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmNob3JEZWYpIHRocm93IG5ldyBFcnJvcignQW5jaG9yIHJlcXVpcmVkLicpO1xuICAgICAgICB2YXIgYW5jaG9yRm47XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhbmNob3JGbiA9IGFuY2hvckRlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmNob3JOYW1lID0gYW5jaG9yRGVmLm5hbWU7XG4gICAgICAgICAgICB2YXIgYW5jaG9yTmFtZXNwYWNlID0gaXNDb25uZWN0aW9uID8gJ2xpbmtBbmNob3JOYW1lc3BhY2UnIDogJ2FuY2hvck5hbWVzcGFjZSc7XG4gICAgICAgICAgICBhbmNob3JGbiA9IHBhcGVyT3B0aW9uc1thbmNob3JOYW1lc3BhY2VdW2FuY2hvck5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFuY2hvcjogJyArIGFuY2hvck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JGbi5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGNlbGxWaWV3LFxuICAgICAgICAgICAgbWFnbmV0LFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgYW5jaG9yRGVmLmFyZ3MgfHwge30sXG4gICAgICAgICAgICBlbmRUeXBlLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWFuY2hvcikgcmV0dXJuIG5ldyBQb2ludCgpO1xuICAgICAgICByZXR1cm4gYW5jaG9yLnJvdW5kKHRoaXMuZGVjaW1hbHNSb3VuZGluZyk7XG4gICAgfSxcblxuXG4gICAgZ2V0Q29ubmVjdGlvblBvaW50OiBmdW5jdGlvbihjb25uZWN0aW9uUG9pbnREZWYsIHZpZXcsIG1hZ25ldCwgbGluZSwgZW5kVHlwZSkge1xuXG4gICAgICAgIHZhciBjb25uZWN0aW9uUG9pbnQ7XG4gICAgICAgIHZhciBhbmNob3IgPSBsaW5lLmVuZDtcbiAgICAgICAgdmFyIHBhcGVyT3B0aW9ucyA9IHRoaXMucGFwZXIub3B0aW9ucztcblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAodHlwZW9mIHBhcGVyT3B0aW9ucy5saW5rQ29ubmVjdGlvblBvaW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgbGlua0Nvbm5lY3Rpb25NYWduZXQgPSAobWFnbmV0ID09PSB2aWV3LmVsKSA/IHVuZGVmaW5lZCA6IG1hZ25ldDtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludCA9IHBhcGVyT3B0aW9ucy5saW5rQ29ubmVjdGlvblBvaW50KHRoaXMsIHZpZXcsIGxpbmtDb25uZWN0aW9uTWFnbmV0LCBsaW5lLnN0YXJ0LCBlbmRUeXBlKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uUG9pbnQpIHJldHVybiBjb25uZWN0aW9uUG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25Qb2ludERlZikgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Qb2ludEZuO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25Qb2ludERlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Rm4gPSBjb25uZWN0aW9uUG9pbnREZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvblBvaW50TmFtZSA9IGNvbm5lY3Rpb25Qb2ludERlZi5uYW1lO1xuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Rm4gPSBwYXBlck9wdGlvbnMuY29ubmVjdGlvblBvaW50TmFtZXNwYWNlW2Nvbm5lY3Rpb25Qb2ludE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uUG9pbnRGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbm5lY3Rpb24gcG9pbnQ6ICcgKyBjb25uZWN0aW9uUG9pbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uUG9pbnQgPSBjb25uZWN0aW9uUG9pbnRGbi5jYWxsKHRoaXMsIGxpbmUsIHZpZXcsIG1hZ25ldCwgY29ubmVjdGlvblBvaW50RGVmLmFyZ3MgfHwge30sIGVuZFR5cGUsIHRoaXMpO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25Qb2ludCkgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qb2ludC5yb3VuZCh0aGlzLmRlY2ltYWxzUm91bmRpbmcpO1xuICAgIH0sXG5cbiAgICBfdHJhbnNsYXRlQ29ubmVjdGlvblBvaW50czogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fbWFya2VyQ2FjaGU7XG5cbiAgICAgICAgY2FjaGUuc291cmNlUG9pbnQub2Zmc2V0KHR4LCB0eSk7XG4gICAgICAgIGNhY2hlLnRhcmdldFBvaW50Lm9mZnNldCh0eCwgdHkpO1xuICAgICAgICB0aGlzLnNvdXJjZVBvaW50Lm9mZnNldCh0eCwgdHkpO1xuICAgICAgICB0aGlzLnRhcmdldFBvaW50Lm9mZnNldCh0eCwgdHkpO1xuICAgICAgICB0aGlzLnNvdXJjZUFuY2hvci5vZmZzZXQodHgsIHR5KTtcbiAgICAgICAgdGhpcy50YXJnZXRBbmNob3Iub2Zmc2V0KHR4LCB0eSk7XG4gICAgfSxcblxuICAgIC8vIGNvbWJpbmUgZGVmYXVsdCBsYWJlbCBwb3NpdGlvbiB3aXRoIGJ1aWx0LWluIGRlZmF1bHQgbGFiZWwgcG9zaXRpb25cbiAgICBfZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25Qcm9wZXJ0eTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbCA9IG1vZGVsLl9idWlsdGlucy5kZWZhdWx0TGFiZWw7XG4gICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsUG9zaXRpb24gPSBidWlsdGluRGVmYXVsdExhYmVsLnBvc2l0aW9uO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSBtb2RlbC5fZ2V0RGVmYXVsdExhYmVsKCk7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbiA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsUG9zaXRpb24oZGVmYXVsdExhYmVsLnBvc2l0aW9uKTtcblxuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIGJ1aWx0aW5EZWZhdWx0TGFiZWxQb3NpdGlvbiwgZGVmYXVsdExhYmVsUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvLyBpZiBsYWJlbCBwb3NpdGlvbiBpcyBhIG51bWJlciwgbm9ybWFsaXplIGl0IHRvIGEgcG9zaXRpb24gb2JqZWN0XG4gICAgLy8gdGhpcyBtYWtlcyBzdXJlIHRoYXQgbGFiZWwgcG9zaXRpb25zIGNhbiBiZSBtZXJnZWQgcHJvcGVybHlcbiAgICBfbm9ybWFsaXplTGFiZWxQb3NpdGlvbjogZnVuY3Rpb24obGFiZWxQb3NpdGlvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxQb3NpdGlvbiA9PT0gJ251bWJlcicpIHJldHVybiB7IGRpc3RhbmNlOiBsYWJlbFBvc2l0aW9uLCBvZmZzZXQ6IG51bGwsIGFuZ2xlOiAwLCBhcmdzOiBudWxsIH07XG4gICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvLyBleHBlY3RzIG5vcm1hbGl6ZWQgcG9zaXRpb24gcHJvcGVydGllc1xuICAgIC8vIGUuZy4gYHRoaXMuX25vcm1hbGl6ZUxhYmVsUG9zaXRpb24obGFiZWxQb3NpdGlvbilgIGFuZCBgdGhpcy5fZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25Qcm9wZXJ0eSgpYFxuICAgIF9tZXJnZUxhYmVsUG9zaXRpb25Qcm9wZXJ0eTogZnVuY3Rpb24obm9ybWFsaXplZExhYmVsUG9zaXRpb24sIG5vcm1hbGl6ZWREZWZhdWx0TGFiZWxQb3NpdGlvbikge1xuXG4gICAgICAgIGlmIChub3JtYWxpemVkTGFiZWxQb3NpdGlvbiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGFiZWxQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkRGVmYXVsdExhYmVsUG9zaXRpb24gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWREZWZhdWx0TGFiZWxQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXJnZSh7fSwgbm9ybWFsaXplZERlZmF1bHRMYWJlbFBvc2l0aW9uLCBub3JtYWxpemVkTGFiZWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIHVwZGF0ZUxhYmVsUG9zaXRpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX1YubGFiZWxzKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBhc3N1bWVzIGFsbCB0aGUgbGFiZWwgbm9kZXMgYXJlIHN0b3JlZCBpbiB0aGUgYHRoaXMuX2xhYmVsQ2FjaGVgIGhhc2ggdGFibGVcbiAgICAgICAgLy8gYnkgdGhlaXIgaW5kaWNlcyBpbiB0aGUgYHRoaXMuZ2V0KCdsYWJlbHMnKWAgYXJyYXkuIFRoaXMgaXMgZG9uZSBpbiB0aGUgYHJlbmRlckxhYmVscygpYCBtZXRob2QuXG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVscyA9IG1vZGVsLmdldCgnbGFiZWxzJykgfHwgW107XG4gICAgICAgIGlmICghbGFiZWxzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uID0gdGhpcy5fZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25Qcm9wZXJ0eSgpO1xuXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDAsIG4gPSBsYWJlbHMubGVuZ3RoOyBpZHggPCBuOyBpZHgrKykge1xuICAgICAgICAgICAgdmFyIGxhYmVsTm9kZSA9IHRoaXMuX2xhYmVsQ2FjaGVbaWR4XTtcbiAgICAgICAgICAgIGlmICghbGFiZWxOb2RlKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpZHhdO1xuICAgICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLl9ub3JtYWxpemVMYWJlbFBvc2l0aW9uKGxhYmVsLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX21lcmdlTGFiZWxQb3NpdGlvblByb3BlcnR5KGxhYmVsUG9zaXRpb24sIGRlZmF1bHRMYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IHRoaXMuX2dldExhYmVsVHJhbnNmb3JtYXRpb25NYXRyaXgocG9zaXRpb24pO1xuICAgICAgICAgICAgbGFiZWxOb2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1hdGlvbk1hdHJpeCkpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5MYWJlbE1hdHJpY2VzKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2NsZWFuTGFiZWxNYXRyaWNlczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgLy8gQ2xlYW4gbWFnbmV0TWF0cml4IGZvciBhbGwgbm9kZXMgb2YgdGhlIGxhYmVsLlxuICAgICAgICAvLyBDYWNoZWQgQm91bmRpbmdSZWN0IGRvZXMgbm90IG5lZWQgdG8gdXBkYXRlZCB3aGVuIHRoZSBwb3NpdGlvbiBjaGFuZ2VzXG4gICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCB3b3JrIGZvciBsYWJlbHMgd2l0aCBYTUwgU3RyaW5nIG1hcmt1cHMuXG4gICAgICAgIGNvbnN0IHsgbWV0cmljcywgX2xhYmVsU2VsZWN0b3JzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBfbGFiZWxTZWxlY3RvcnNbaW5kZXhdO1xuICAgICAgICBpZiAoIXNlbGVjdG9ycykgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBzZWxlY3RvciBpbiBzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IHNlbGVjdG9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICBpZiAoaWQgJiYgKGlkIGluIG1ldHJpY3MpKSBkZWxldGUgbWV0cmljc1tpZF0ubWFnbmV0TWF0cml4O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVRvb2xzUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fVi5saW5rVG9vbHMpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIHRvb2xzIGEgYml0IHRvIHRoZSB0YXJnZXQgcG9zaXRpb24gYnV0IGRvbid0IGNvdmVyIHRoZSBgc291cmNlQXJyb3doZWFkYCBtYXJrZXIuXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgb2Zmc2V0IGlzIGhhcmRjb2RlZCBoZXJlLiBUaGUgb2Zmc2V0IHNob3VsZCBiZSBhbHdheXNcbiAgICAgICAgLy8gbW9yZSB0aGFuIHRoZSBgdGhpcy4kKCcubWFya2VyLWFycm93aGVhZFtlbmQ9XCJzb3VyY2VcIl0nKVswXS5iYm94KCkud2lkdGhgIGJ1dCBsb29raW5nXG4gICAgICAgIC8vIHRoaXMgdXAgYWxsIHRoZSB0aW1lIHdvdWxkIGJlIHNsb3cuXG5cbiAgICAgICAgdmFyIHNjYWxlID0gJyc7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9wdGlvbnMubGlua1Rvb2xzT2Zmc2V0O1xuICAgICAgICB2YXIgY29ubmVjdGlvbkxlbmd0aCA9IHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpO1xuXG4gICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyBjb25uZWN0aW9uTGVuZ3RoPU5hTiBpbiBvZGQgY2FzZXMgKGZvciBiZXppZXIgY3VydmVzKS5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIHdvbid0IHVwZGF0ZSB0b29scyBwb3NpdGlvbiBhdCBhbGwuXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGNvbm5lY3Rpb25MZW5ndGgpKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBsaW5rIGlzIHRvbyBzaG9ydCwgbWFrZSB0aGUgdG9vbHMgaGFsZiB0aGUgc2l6ZSBhbmQgdGhlIG9mZnNldCB0d2ljZSBhcyBsb3cuXG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbkxlbmd0aCA8IHRoaXMub3B0aW9ucy5zaG9ydExpbmtMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICdzY2FsZSguNSknO1xuICAgICAgICAgICAgICAgIG9mZnNldCAvPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9vbFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEF0TGVuZ3RoKG9mZnNldCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Rvb2xDYWNoZS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB0b29sUG9zaXRpb24ueCArICcsICcgKyB0b29sUG9zaXRpb24ueSArICcpICcgKyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG91YmxlTGlua1Rvb2xzICYmIGNvbm5lY3Rpb25MZW5ndGggPj0gdGhpcy5vcHRpb25zLmxvbmdMaW5rTGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlTGlua1Rvb2xzT2Zmc2V0ID0gdGhpcy5vcHRpb25zLmRvdWJsZUxpbmtUb29sc09mZnNldCB8fCBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB0b29sUG9zaXRpb24gPSB0aGlzLmdldFBvaW50QXRMZW5ndGgoY29ubmVjdGlvbkxlbmd0aCAtIGRvdWJsZUxpbmtUb29sc09mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbDJDYWNoZS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB0b29sUG9zaXRpb24ueCArICcsICcgKyB0b29sUG9zaXRpb24ueSArICcpICcgKyBzY2FsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbDJDYWNoZS5hdHRyKCdkaXNwbGF5JywgJ2lubGluZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kb3VibGVMaW5rVG9vbHMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2wyQ2FjaGUuYXR0cignZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdXBkYXRlQXJyb3doZWFkTWFya2VyczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9WLm1hcmtlckFycm93aGVhZHMpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIGdldHRpbmcgYmJveCBvZiBhbiBlbGVtZW50IHdpdGggYGRpc3BsYXk9XCJub25lXCJgIGluIElFOSBlbmRzIHVwIHdpdGggYWNjZXNzIHZpb2xhdGlvblxuICAgICAgICBpZiAoJC5jc3ModGhpcy5fVi5tYXJrZXJBcnJvd2hlYWRzLm5vZGUsICdkaXNwbGF5JykgPT09ICdub25lJykgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIHN4ID0gdGhpcy5nZXRDb25uZWN0aW9uTGVuZ3RoKCkgPCB0aGlzLm9wdGlvbnMuc2hvcnRMaW5rTGVuZ3RoID8gLjUgOiAxO1xuICAgICAgICB0aGlzLl9WLnNvdXJjZUFycm93aGVhZC5zY2FsZShzeCk7XG4gICAgICAgIHRoaXMuX1YudGFyZ2V0QXJyb3doZWFkLnNjYWxlKHN4KTtcblxuICAgICAgICB0aGlzLl90cmFuc2xhdGVBbmRBdXRvT3JpZW50QXJyb3dzKHRoaXMuX1Yuc291cmNlQXJyb3doZWFkLCB0aGlzLl9WLnRhcmdldEFycm93aGVhZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZUVuZFByb3BlcnRpZXM6IGZ1bmN0aW9uKGVuZFR5cGUpIHtcblxuICAgICAgICBjb25zdCB7IG1vZGVsLCBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5kVmlld1Byb3BlcnR5ID0gYCR7ZW5kVHlwZX1WaWV3YDtcbiAgICAgICAgY29uc3QgZW5kRGVmID0gbW9kZWwuZ2V0KGVuZFR5cGUpO1xuICAgICAgICBjb25zdCBlbmRJZCA9IGVuZERlZiAmJiBlbmREZWYuaWQ7XG5cbiAgICAgICAgaWYgKCFlbmRJZCkge1xuICAgICAgICAgICAgLy8gdGhlIGxpbmsgZW5kIGlzIGEgcG9pbnQgfiByZWN0IDB4MFxuICAgICAgICAgICAgdGhpc1tlbmRWaWV3UHJvcGVydHldID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWFnbmV0KGVuZFR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRNb2RlbCA9IHBhcGVyLmdldE1vZGVsQnlJZChlbmRJZCk7XG4gICAgICAgIGlmICghZW5kTW9kZWwpIHRocm93IG5ldyBFcnJvcignTGlua1ZpZXc6IGludmFsaWQgJyArIGVuZFR5cGUgKyAnIGNlbGwuJyk7XG5cbiAgICAgICAgY29uc3QgZW5kVmlldyA9IGVuZE1vZGVsLmZpbmRWaWV3KHBhcGVyKTtcbiAgICAgICAgaWYgKCFlbmRWaWV3KSB7XG4gICAgICAgICAgICAvLyBBIHZpZXcgZm9yIGEgbW9kZWwgc2hvdWxkIGFsd2F5cyBleGlzdFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tlbmRWaWV3UHJvcGVydHldID0gZW5kVmlldztcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNYWduZXQoZW5kVHlwZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICB1cGRhdGVFbmRNYWduZXQ6IGZ1bmN0aW9uKGVuZFR5cGUpIHtcblxuICAgICAgICBjb25zdCBlbmRNYWduZXRQcm9wZXJ0eSA9IGAke2VuZFR5cGV9TWFnbmV0YDtcbiAgICAgICAgY29uc3QgZW5kVmlldyA9IHRoaXMuZ2V0RW5kVmlldyhlbmRUeXBlKTtcbiAgICAgICAgaWYgKGVuZFZpZXcpIHtcbiAgICAgICAgICAgIGxldCBjb25uZWN0ZWRNYWduZXQgPSBlbmRWaWV3LmdldE1hZ25ldEZyb21MaW5rRW5kKHRoaXMubW9kZWwuZ2V0KGVuZFR5cGUpKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWRNYWduZXQgPT09IGVuZFZpZXcuZWwpIGNvbm5lY3RlZE1hZ25ldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzW2VuZE1hZ25ldFByb3BlcnR5XSA9IGNvbm5lY3RlZE1hZ25ldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbZW5kTWFnbmV0UHJvcGVydHldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdHJhbnNsYXRlQW5kQXV0b09yaWVudEFycm93czogZnVuY3Rpb24oc291cmNlQXJyb3csIHRhcmdldEFycm93KSB7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgbWFya2VycyBcInBvaW50XCIgdG8gdGhlaXIgc3RpY2t5IHBvaW50cyBiZWluZyBhdXRvLW9yaWVudGVkIHRvd2FyZHNcbiAgICAgICAgLy8gYHRhcmdldFBvc2l0aW9uYC9gc291cmNlUG9zaXRpb25gLiBBbmQgZG8gc28gb25seSBpZiB0aGVyZSBpcyBhIG1hcmt1cCBmb3IgdGhlbS5cbiAgICAgICAgdmFyIHJvdXRlID0gdG9BcnJheSh0aGlzLnJvdXRlKTtcbiAgICAgICAgaWYgKHNvdXJjZUFycm93KSB7XG4gICAgICAgICAgICBzb3VyY2VBcnJvdy50cmFuc2xhdGVBbmRBdXRvT3JpZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlUG9pbnQsXG4gICAgICAgICAgICAgICAgcm91dGVbMF0gfHwgdGhpcy50YXJnZXRQb2ludCxcbiAgICAgICAgICAgICAgICB0aGlzLnBhcGVyLmNlbGxzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldEFycm93KSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJvdy50cmFuc2xhdGVBbmRBdXRvT3JpZW50KFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0UG9pbnQsXG4gICAgICAgICAgICAgICAgcm91dGVbcm91dGUubGVuZ3RoIC0gMV0gfHwgdGhpcy5zb3VyY2VQb2ludCxcbiAgICAgICAgICAgICAgICB0aGlzLnBhcGVyLmNlbGxzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHk6IGZ1bmN0aW9uKGlkeCkge1xuXG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlbC5sYWJlbChpZHgpLnBvc2l0aW9uIHx8IHt9KTtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsUG9zaXRpb25BbmdsZTogZnVuY3Rpb24oaWR4KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHkoaWR4KTtcbiAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uLmFuZ2xlIHx8IDApO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxQb3NpdGlvbkFyZ3M6IGZ1bmN0aW9uKGlkeCkge1xuXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gdGhpcy5fZ2V0TGFiZWxQb3NpdGlvblByb3BlcnR5KGlkeCk7XG4gICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9uLmFyZ3M7XG4gICAgfSxcblxuICAgIF9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSB0aGlzLm1vZGVsLl9nZXREZWZhdWx0TGFiZWwoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uID0gZGVmYXVsdExhYmVsLnBvc2l0aW9uIHx8IHt9O1xuICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsUG9zaXRpb24uYXJncztcbiAgICB9LFxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBsYWJlbCBwb3NpdGlvbiBhcmdzIGludG8gbGFiZWwgcG9zaXRpb24gYXJnc1xuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsUG9zaXRpb25BcmdzOiBmdW5jdGlvbihsYWJlbFBvc2l0aW9uQXJncywgZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzKSB7XG5cbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb25BcmdzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb25BcmdzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MsIGxhYmVsUG9zaXRpb25BcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGRlZmF1bHQgbGFiZWwgYXQgZ2l2ZW4gcG9zaXRpb24gYXQgZW5kIG9mIGBsYWJlbHNgIGFycmF5LlxuICAgIC8vIEZvdXIgc2lnbmF0dXJlczpcbiAgICAvLyAtIG9iaiwgb2JqID0gcG9pbnQsIG9wdFxuICAgIC8vIC0gb2JqLCBudW0sIG9iaiA9IHBvaW50LCBhbmdsZSwgb3B0XG4gICAgLy8gLSBudW0sIG51bSwgb2JqID0geCwgeSwgb3B0XG4gICAgLy8gLSBudW0sIG51bSwgbnVtLCBvYmogPSB4LCB5LCBhbmdsZSwgb3B0XG4gICAgLy8gQXNzaWducyByZWxhdGl2ZSBjb29yZGluYXRlcyBieSBkZWZhdWx0OlxuICAgIC8vIGBvcHQuYWJzb2x1dGVEaXN0YW5jZWAgZm9yY2VzIGFic29sdXRlIGNvb3JkaW5hdGVzLlxuICAgIC8vIGBvcHQucmV2ZXJzZURpc3RhbmNlYCBmb3JjZXMgcmV2ZXJzZSBhYnNvbHV0ZSBjb29yZGluYXRlcyAoaWYgYWJzb2x1dGVEaXN0YW5jZSA9IHRydWUpLlxuICAgIC8vIGBvcHQuYWJzb2x1dGVPZmZzZXRgIGZvcmNlcyBhYnNvbHV0ZSBjb29yZGluYXRlcyBmb3Igb2Zmc2V0LlxuICAgIC8vIEFkZGl0aW9uYWwgYXJnczpcbiAgICAvLyBgb3B0LmtlZXBHcmFkaWVudGAgYXV0by1hZGp1c3RzIHRoZSBhbmdsZSBvZiB0aGUgbGFiZWwgdG8gbWF0Y2ggcGF0aCBncmFkaWVudCBhdCBwb3NpdGlvbi5cbiAgICAvLyBgb3B0LmVuc3VyZUxlZ2liaWxpdHlgIHJvdGF0ZXMgbGFiZWxzIHNvIHRoZXkgYXJlIG5ldmVyIHVwc2lkZS1kb3duLlxuICAgIGFkZExhYmVsOiBmdW5jdGlvbihwMSwgcDIsIHAzLCBwNCkge1xuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBkYXRhIGZyb20gdGhlIGZvdXIgcG9zc2libGUgc2lnbmF0dXJlc1xuICAgICAgICB2YXIgbG9jYWxYO1xuICAgICAgICB2YXIgbG9jYWxZO1xuICAgICAgICB2YXIgbG9jYWxBbmdsZSA9IDA7XG4gICAgICAgIHZhciBsb2NhbE9wdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwMSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIHt4LCB5fSBvYmplY3QgcHJvdmlkZWQgYXMgZmlyc3QgcGFyYW1ldGVyXG4gICAgICAgICAgICBsb2NhbFggPSBwMS54O1xuICAgICAgICAgICAgbG9jYWxZID0gcDEueTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcDIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgYW5kIG9wdCBwcm92aWRlZCBhcyBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBsb2NhbEFuZ2xlID0gcDI7XG4gICAgICAgICAgICAgICAgbG9jYWxPcHQgPSBwMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0IHByb3ZpZGVkIGFzIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBsb2NhbE9wdCA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8geCBhbmQgeSBwcm92aWRlZCBhcyBmaXJzdCBhbmQgc2Vjb25kIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGxvY2FsWCA9IHAxO1xuICAgICAgICAgICAgbG9jYWxZID0gcDI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGFuZ2xlIGFuZCBvcHQgcHJvdmlkZWQgYXMgdGhpcmQgYW5kIGZvdXJ0aCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgbG9jYWxBbmdsZSA9IHAzO1xuICAgICAgICAgICAgICAgIGxvY2FsT3B0ID0gcDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9wdCBwcm92aWRlZCBhcyB0aGlyZCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBsb2NhbE9wdCA9IHAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVyZ2UgbGFiZWwgcG9zaXRpb24gYXJndW1lbnRzXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MgPSB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MoKTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25BcmdzID0gbG9jYWxPcHQ7XG4gICAgICAgIHZhciBwb3NpdGlvbkFyZ3MgPSB0aGlzLl9tZXJnZUxhYmVsUG9zaXRpb25BcmdzKGxhYmVsUG9zaXRpb25BcmdzLCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MpO1xuXG4gICAgICAgIC8vIGFwcGVuZCBsYWJlbCB0byBsYWJlbHMgYXJyYXlcbiAgICAgICAgdmFyIGxhYmVsID0geyBwb3NpdGlvbjogdGhpcy5nZXRMYWJlbFBvc2l0aW9uKGxvY2FsWCwgbG9jYWxZLCBsb2NhbEFuZ2xlLCBwb3NpdGlvbkFyZ3MpIH07XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdGhpcy5tb2RlbC5pbnNlcnRMYWJlbChpZHgsIGxhYmVsLCBsb2NhbE9wdCk7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG5ldyB2ZXJ0ZXggYXQgY2FsY3VsYXRlZCBpbmRleCB0byB0aGUgYHZlcnRpY2VzYCBhcnJheS5cbiAgICBhZGRWZXJ0ZXg6IGZ1bmN0aW9uKHgsIHksIG9wdCkge1xuXG4gICAgICAgIC8vIGFjY2VwdCBpbnB1dCBpbiBmb3JtIGB7IHgsIHkgfSwgb3B0YCBvciBgeCwgeSwgb3B0YFxuICAgICAgICB2YXIgaXNQb2ludFByb3ZpZGVkID0gKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyk7XG4gICAgICAgIHZhciBsb2NhbFggPSBpc1BvaW50UHJvdmlkZWQgPyB4LnggOiB4O1xuICAgICAgICB2YXIgbG9jYWxZID0gaXNQb2ludFByb3ZpZGVkID8geC55IDogeTtcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0gaXNQb2ludFByb3ZpZGVkID8geSA6IG9wdDtcblxuICAgICAgICB2YXIgdmVydGV4ID0geyB4OiBsb2NhbFgsIHk6IGxvY2FsWSB9O1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRWZXJ0ZXhJbmRleChsb2NhbFgsIGxvY2FsWSk7XG4gICAgICAgIHRoaXMubW9kZWwuaW5zZXJ0VmVydGV4KGlkeCwgdmVydGV4LCBsb2NhbE9wdCk7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIFNlbmQgYSB0b2tlbiAoYW4gU1ZHIGVsZW1lbnQsIHVzdWFsbHkgYSBjaXJjbGUpIGFsb25nIHRoZSBjb25uZWN0aW9uIHBhdGguXG4gICAgLy8gRXhhbXBsZTogYGxpbmsuZmluZFZpZXcocGFwZXIpLnNlbmRUb2tlbihWKCdjaXJjbGUnLCB7IHI6IDcsIGZpbGw6ICdncmVlbicgfSkubm9kZSlgXG4gICAgLy8gYG9wdC5kdXJhdGlvbmAgaXMgb3B0aW9uYWwgYW5kIGlzIGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdG9rZW4gdHJhdmVscyBmcm9tIHRoZSBzb3VyY2UgdG8gdGhlIHRhcmdldCBvZiB0aGUgbGluay4gRGVmYXVsdCBpcyBgMTAwMGAuXG4gICAgLy8gYG9wdC5kaXJlY3RvbmAgaXMgb3B0aW9uYWwgYW5kIGl0IGRldGVybWluZXMgd2hldGhlciB0aGUgdG9rZW4gZ29lcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgb3Igb3RoZXIgd2F5IHJvdW5kIChgcmV2ZXJzZWApXG4gICAgLy8gYG9wdC5jb25uZWN0aW9uYCBpcyBhbiBvcHRpb25hbCBzZWxlY3RvciB0byB0aGUgY29ubmVjdGlvbiBwYXRoLlxuICAgIC8vIGBjYWxsYmFja2AgaXMgb3B0aW9uYWwgYW5kIGlzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIHRva2VuIHJlYWNoZXMgdGhlIHRhcmdldC5cbiAgICBzZW5kVG9rZW46IGZ1bmN0aW9uKHRva2VuLCBvcHQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gb25BbmltYXRpb25FbmQodlRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZUb2tlbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiwgaXNSZXZlcnNlZCwgc2VsZWN0b3I7XG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG9wdC5kdXJhdGlvbjtcbiAgICAgICAgICAgIGlzUmV2ZXJzZWQgPSAob3B0LmRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gb3B0LmNvbm5lY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHQ7XG4gICAgICAgICAgICBpc1JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDEwMDA7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBkdXI6IGR1cmF0aW9uICsgJ21zJyxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiAxLFxuICAgICAgICAgICAgY2FsY01vZGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgZmlsbDogJ2ZyZWV6ZSdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uQXR0cmlidXRlcy5rZXlQb2ludHMgPSAnMTswJztcbiAgICAgICAgICAgIGFuaW1hdGlvbkF0dHJpYnV0ZXMua2V5VGltZXMgPSAnMDsxJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2VG9rZW4gPSBWKHRva2VuKTtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGNvbm5lY3Rpb24gcGF0aC5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCB0aGlzLmVsLCB0aGlzLnNlbGVjdG9ycylbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgY29ubmVjdGlvbiBwYXRoIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9WO1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IChjYWNoZS5jb25uZWN0aW9uKSA/IGNhY2hlLmNvbm5lY3Rpb24ubm9kZSA6IHRoaXMuZWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoY29ubmVjdGlvbiBpbnN0YW5jZW9mIFNWR1BhdGhFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHRva2VuIGFuaW1hdGlvbiByZXF1aXJlcyBhIHZhbGlkIGNvbm5lY3Rpb24gcGF0aC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZUb2tlblxuICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMucGFwZXIuY2VsbHMpXG4gICAgICAgICAgICAuYW5pbWF0ZUFsb25nUGF0aChhbmltYXRpb25BdHRyaWJ1dGVzLCBjb25uZWN0aW9uKTtcblxuICAgICAgICBzZXRUaW1lb3V0KG9uQW5pbWF0aW9uRW5kKHZUb2tlbiwgY2FsbGJhY2spLCBkdXJhdGlvbik7XG4gICAgfSxcblxuICAgIGZpbmRSb3V0ZTogZnVuY3Rpb24odmVydGljZXMpIHtcblxuICAgICAgICB2ZXJ0aWNlcyB8fCAodmVydGljZXMgPSBbXSk7XG5cbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMucGFwZXIub3B0aW9ucy5yb3V0ZXJOYW1lc3BhY2UgfHwgcm91dGVycztcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMubW9kZWwucm91dGVyKCk7XG4gICAgICAgIHZhciBkZWZhdWx0Um91dGVyID0gdGhpcy5wYXBlci5vcHRpb25zLmRlZmF1bHRSb3V0ZXI7XG5cbiAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0Um91dGVyKSByb3V0ZXIgPSBkZWZhdWx0Um91dGVyO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdmVydGljZXMubWFwKFBvaW50KTsgLy8gbm8gcm91dGVyIHNwZWNpZmllZFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdXRlckZuID0gaXNGdW5jdGlvbihyb3V0ZXIpID8gcm91dGVyIDogbmFtZXNwYWNlW3JvdXRlci5uYW1lXTtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJvdXRlckZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHVua25vd24gcm91dGVyOiBcIicgKyByb3V0ZXIubmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLmFyZ3MgfHwge307XG5cbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVyRm4uY2FsbChcbiAgICAgICAgICAgIHRoaXMsIC8vIGNvbnRleHRcbiAgICAgICAgICAgIHZlcnRpY2VzLCAvLyB2ZXJ0aWNlc1xuICAgICAgICAgICAgYXJncywgLy8gb3B0aW9uc1xuICAgICAgICAgICAgdGhpcyAvLyBsaW5rVmlld1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcm91dGUpIHJldHVybiB2ZXJ0aWNlcy5tYXAoUG9pbnQpO1xuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgYGRgIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgYDxwYXRoPmAgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGxpbmtcbiAgICAvLyBiZXR3ZWVuIGBzb3VyY2VgIGFuZCBgdGFyZ2V0YC5cbiAgICBmaW5kUGF0aDogZnVuY3Rpb24ocm91dGUsIHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCkge1xuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLnBhcGVyLm9wdGlvbnMuY29ubmVjdG9yTmFtZXNwYWNlIHx8IGNvbm5lY3RvcnM7XG4gICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLm1vZGVsLmNvbm5lY3RvcigpO1xuICAgICAgICB2YXIgZGVmYXVsdENvbm5lY3RvciA9IHRoaXMucGFwZXIub3B0aW9ucy5kZWZhdWx0Q29ubmVjdG9yO1xuXG4gICAgICAgIGlmICghY29ubmVjdG9yKSB7XG4gICAgICAgICAgICBjb25uZWN0b3IgPSBkZWZhdWx0Q29ubmVjdG9yIHx8IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbm5lY3RvckZuID0gaXNGdW5jdGlvbihjb25uZWN0b3IpID8gY29ubmVjdG9yIDogbmFtZXNwYWNlW2Nvbm5lY3Rvci5uYW1lXTtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbm5lY3RvckZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHVua25vd24gY29ubmVjdG9yOiBcIicgKyBjb25uZWN0b3IubmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gY2xvbmUoY29ubmVjdG9yLmFyZ3MgfHwge30pO1xuICAgICAgICBhcmdzLnJhdyA9IHRydWU7IC8vIFJlcXVlc3QgcmF3IGcuUGF0aCBhcyB0aGUgcmVzdWx0LlxuXG4gICAgICAgIHZhciBwYXRoID0gY29ubmVjdG9yRm4uY2FsbChcbiAgICAgICAgICAgIHRoaXMsIC8vIGNvbnRleHRcbiAgICAgICAgICAgIHNvdXJjZVBvaW50LCAvLyBzdGFydCBwb2ludFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQsIC8vIGVuZCBwb2ludFxuICAgICAgICAgICAgcm91dGUsIC8vIHZlcnRpY2VzXG4gICAgICAgICAgICBhcmdzLCAvLyBvcHRpb25zXG4gICAgICAgICAgICB0aGlzIC8vIGxpbmtWaWV3XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGNvbm5lY3RvcnMgbm90IHN1cHBvcnRpbmcgYHJhd2Agb3B0aW9uLlxuICAgICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKFYubm9ybWFsaXplUGF0aERhdGEocGF0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8vIFB1YmxpYyBBUEkuXG4gICAgLy8gLS0tLS0tLS0tLS1cblxuICAgIGdldENvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBwYXRoLmNsb25lKCk7XG4gICAgfSxcblxuICAgIGdldFNlcmlhbGl6ZWRDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgaWYgKG1ldHJpY3MuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSkgcmV0dXJuIG1ldHJpY3MuZGF0YTtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLnNlcmlhbGl6ZSgpO1xuICAgICAgICBtZXRyaWNzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm1ldHJpY3M7XG4gICAgICAgIGlmIChtZXRyaWNzLmhhc093blByb3BlcnR5KCdzZWdtZW50U3ViZGl2aXNpb25zJykpIHJldHVybiBtZXRyaWNzLnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBwYXRoLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoKTtcbiAgICAgICAgbWV0cmljcy5zZWdtZW50U3ViZGl2aXNpb25zID0gc3ViZGl2aXNpb25zO1xuICAgICAgICByZXR1cm4gc3ViZGl2aXNpb25zO1xuICAgIH0sXG5cbiAgICBnZXRDb25uZWN0aW9uTGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgaWYgKG1ldHJpY3MuaGFzT3duUHJvcGVydHkoJ2xlbmd0aCcpKSByZXR1cm4gbWV0cmljcy5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aCh7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgICAgICBtZXRyaWNzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucG9pbnRBdExlbmd0aChsZW5ndGgsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldFBvaW50QXRSYXRpbzogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZShyYXRpbykpIHJhdGlvID0gcGFyc2VGbG9hdChyYXRpbykgLyAxMDA7XG4gICAgICAgIHJldHVybiBwYXRoLnBvaW50QXQocmF0aW8sIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldFRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgudGFuZ2VudEF0TGVuZ3RoKGxlbmd0aCwgeyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VGFuZ2VudEF0UmF0aW86IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgudGFuZ2VudEF0KHJhdGlvLCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguY2xvc2VzdFBvaW50KHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguY2xvc2VzdFBvaW50TGVuZ3RoKHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnRSYXRpbzogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgbGFiZWwgcG9zaXRpb24gb2JqZWN0IGJhc2VkIG9uIHR3byBwcm92aWRlZCBjb29yZGluYXRlcywgeCBhbmQgeS5cbiAgICAvLyAoVXNlZCBiZWhpbmQgdGhlIHNjZW5lcyB3aGVuIHVzZXIgbW92ZXMgbGFiZWxzIGFyb3VuZC4pXG4gICAgLy8gVHdvIHNpZ25hdHVyZXM6XG4gICAgLy8gLSBudW0sIG51bSwgb2JqID0geCwgeSwgb3B0aW9uc1xuICAgIC8vIC0gbnVtLCBudW0sIG51bSwgb2JqID0geCwgeSwgYW5nbGUsIG9wdGlvbnNcbiAgICAvLyBBY2NlcHRzIGRpc3RhbmNlL29mZnNldCBvcHRpb25zID0gYGFic29sdXRlRGlzdGFuY2U6IGJvb2xlYW5gLCBgcmV2ZXJzZURpc3RhbmNlOiBib29sZWFuYCwgYGFic29sdXRlT2Zmc2V0OiBib29sZWFuYFxuICAgIC8vIC0gYGFic29sdXRlT2Zmc2V0YCBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gbW92ZSBiZXlvbmQgY29ubmVjdGlvbiBlbmRwb2ludHNcbiAgICAvLyBBZGRpdGlvbmFsIG9wdGlvbnMgPSBga2VlcEdyYWRpZW50OiBib29sZWFuYCwgYGVuc3VyZUxlZ2liaWxpdHk6IGJvb2xlYW5gXG4gICAgZ2V0TGFiZWxQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSwgcDMsIHA0KSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0ge307XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGRhdGEgZnJvbSB0aGUgdHdvIHBvc3NpYmxlIHNpZ25hdHVyZXNcbiAgICAgICAgdmFyIGxvY2FsQW5nbGUgPSAwO1xuICAgICAgICB2YXIgbG9jYWxPcHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcDMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBhbmdsZSBhbmQgb3B0IHByb3ZpZGVkIGFzIHRoaXJkIGFuZCBmb3VydGggYXJndW1lbnRcbiAgICAgICAgICAgIGxvY2FsQW5nbGUgPSBwMztcbiAgICAgICAgICAgIGxvY2FsT3B0ID0gcDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvcHQgcHJvdmlkZWQgYXMgdGhpcmQgYXJndW1lbnRcbiAgICAgICAgICAgIGxvY2FsT3B0ID0gcDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIGxvY2FsT3B0IGFzIGBhcmdzYCBvZiB0aGUgcG9zaXRpb24gb2JqZWN0IHRoYXQgaXMgcGFzc2VkIGFsb25nXG4gICAgICAgIGlmIChsb2NhbE9wdCkgcG9zaXRpb24uYXJncyA9IGxvY2FsT3B0O1xuXG4gICAgICAgIC8vIGlkZW50aWZ5IGRpc3RhbmNlL29mZnNldCBzZXR0aW5nc1xuICAgICAgICB2YXIgaXNEaXN0YW5jZVJlbGF0aXZlID0gIShsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZURpc3RhbmNlKTsgLy8gcmVsYXRpdmUgYnkgZGVmYXVsdFxuICAgICAgICB2YXIgaXNEaXN0YW5jZUFic29sdXRlUmV2ZXJzZSA9IChsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZURpc3RhbmNlICYmIGxvY2FsT3B0LnJldmVyc2VEaXN0YW5jZSk7IC8vIG5vbi1yZXZlcnNlIGJ5IGRlZmF1bHRcbiAgICAgICAgdmFyIGlzT2Zmc2V0QWJzb2x1dGUgPSBsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZU9mZnNldDsgLy8gb2Zmc2V0IGlzIG5vbi1hYnNvbHV0ZSBieSBkZWZhdWx0XG5cbiAgICAgICAgLy8gZmluZCBjbG9zZXN0IHBvaW50IHRcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIHZhciBwYXRoT3B0ID0geyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9O1xuICAgICAgICB2YXIgbGFiZWxQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIHQgPSBwYXRoLmNsb3Nlc3RQb2ludFQobGFiZWxQb2ludCwgcGF0aE9wdCk7XG5cbiAgICAgICAgLy8gRElTVEFOQ0U6XG4gICAgICAgIHZhciBsYWJlbERpc3RhbmNlID0gcGF0aC5sZW5ndGhBdFQodCwgcGF0aE9wdCk7XG4gICAgICAgIGlmIChpc0Rpc3RhbmNlUmVsYXRpdmUpIGxhYmVsRGlzdGFuY2UgPSAobGFiZWxEaXN0YW5jZSAvIHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpKSB8fCAwOyAvLyBmaXggdG8gcHJldmVudCBOYU4gZm9yIDAgbGVuZ3RoXG4gICAgICAgIGlmIChpc0Rpc3RhbmNlQWJzb2x1dGVSZXZlcnNlKSBsYWJlbERpc3RhbmNlID0gKC0xICogKHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpIC0gbGFiZWxEaXN0YW5jZSkpIHx8IDE7IC8vIGZpeCBmb3IgZW5kIHBvaW50ICgtMCA9PiAxKVxuICAgICAgICBwb3NpdGlvbi5kaXN0YW5jZSA9IGxhYmVsRGlzdGFuY2U7XG5cbiAgICAgICAgLy8gT0ZGU0VUOlxuICAgICAgICAvLyB1c2UgYWJzb2x1dGUgb2Zmc2V0IGlmOlxuICAgICAgICAvLyAtIG9wdC5hYnNvbHV0ZU9mZnNldCBpcyB0cnVlLFxuICAgICAgICAvLyAtIG9wdC5hYnNvbHV0ZU9mZnNldCBpcyBub3QgdHJ1ZSBidXQgdGhlcmUgaXMgbm8gdGFuZ2VudFxuICAgICAgICB2YXIgdGFuZ2VudDtcbiAgICAgICAgaWYgKCFpc09mZnNldEFic29sdXRlKSB0YW5nZW50ID0gcGF0aC50YW5nZW50QXRUKHQpO1xuICAgICAgICB2YXIgbGFiZWxPZmZzZXQ7XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBsYWJlbE9mZnNldCA9IHRhbmdlbnQucG9pbnRPZmZzZXQobGFiZWxQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFBvaW50ID0gcGF0aC5wb2ludEF0VCh0KTtcbiAgICAgICAgICAgIHZhciBsYWJlbE9mZnNldERpZmYgPSBsYWJlbFBvaW50LmRpZmZlcmVuY2UoY2xvc2VzdFBvaW50KTtcbiAgICAgICAgICAgIGxhYmVsT2Zmc2V0ID0geyB4OiBsYWJlbE9mZnNldERpZmYueCwgeTogbGFiZWxPZmZzZXREaWZmLnkgfTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbi5vZmZzZXQgPSBsYWJlbE9mZnNldDtcblxuICAgICAgICAvLyBBTkdMRTpcbiAgICAgICAgcG9zaXRpb24uYW5nbGUgPSBsb2NhbEFuZ2xlO1xuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsVHJhbnNmb3JtYXRpb25NYXRyaXg6IGZ1bmN0aW9uKGxhYmVsUG9zaXRpb24pIHtcblxuICAgICAgICB2YXIgbGFiZWxEaXN0YW5jZTtcbiAgICAgICAgdmFyIGxhYmVsQW5nbGUgPSAwO1xuICAgICAgICB2YXIgYXJncyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsUG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBsYWJlbERpc3RhbmNlID0gbGFiZWxQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxQb3NpdGlvbi5kaXN0YW5jZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBsYWJlbFBvc2l0aW9uLmFyZ3MgfHwge307XG4gICAgICAgICAgICBsYWJlbERpc3RhbmNlID0gbGFiZWxQb3NpdGlvbi5kaXN0YW5jZTtcbiAgICAgICAgICAgIGxhYmVsQW5nbGUgPSBsYWJlbFBvc2l0aW9uLmFuZ2xlIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogaW52YWxpZCBsYWJlbCBwb3NpdGlvbiBkaXN0YW5jZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0Rpc3RhbmNlUmVsYXRpdmUgPSAoKGxhYmVsRGlzdGFuY2UgPiAwKSAmJiAobGFiZWxEaXN0YW5jZSA8PSAxKSk7XG5cbiAgICAgICAgdmFyIGxhYmVsT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24ub2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25PZmZzZXQgPSBsYWJlbFBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25PZmZzZXQgPT09ICdudW1iZXInKSBsYWJlbE9mZnNldCA9IHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uT2Zmc2V0LngpIGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMueCA9IHBvc2l0aW9uT2Zmc2V0Lng7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25PZmZzZXQueSkgbGFiZWxPZmZzZXRDb29yZGluYXRlcy55ID0gcG9zaXRpb25PZmZzZXQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc09mZnNldEFic29sdXRlID0gKChsYWJlbE9mZnNldENvb3JkaW5hdGVzLnggIT09IDApIHx8IChsYWJlbE9mZnNldENvb3JkaW5hdGVzLnkgIT09IDApIHx8IGxhYmVsT2Zmc2V0ID09PSAwKTtcblxuICAgICAgICB2YXIgaXNLZWVwR3JhZGllbnQgPSBhcmdzLmtlZXBHcmFkaWVudDtcbiAgICAgICAgdmFyIGlzRW5zdXJlTGVnaWJpbGl0eSA9IGFyZ3MuZW5zdXJlTGVnaWJpbGl0eTtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgdmFyIHBhdGhPcHQgPSB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH07XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaXNEaXN0YW5jZVJlbGF0aXZlID8gKGxhYmVsRGlzdGFuY2UgKiB0aGlzLmdldENvbm5lY3Rpb25MZW5ndGgoKSkgOiBsYWJlbERpc3RhbmNlO1xuICAgICAgICB2YXIgdGFuZ2VudCA9IHBhdGgudGFuZ2VudEF0TGVuZ3RoKGRpc3RhbmNlLCBwYXRoT3B0KTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRpb247XG4gICAgICAgIHZhciBhbmdsZSA9IGxhYmVsQW5nbGU7XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXRBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gdGFuZ2VudC5zdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uLm9mZnNldChsYWJlbE9mZnNldENvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHRhbmdlbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub3JtYWwucm90YXRlKHRhbmdlbnQuc3RhcnQsIC05MCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsLnNldExlbmd0aChsYWJlbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBub3JtYWwuZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNLZWVwR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBhbmdsZSA9ICh0YW5nZW50LmFuZ2xlKCkgKyBsYWJlbEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbnN1cmVMZWdpYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gbm9ybWFsaXplQW5nbGUoKChhbmdsZSArIDkwKSAlIDE4MCkgLSA5MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayAtIHRoZSBjb25uZWN0aW9uIGhhcyB6ZXJvIGxlbmd0aFxuICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBwYXRoLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXRBYnNvbHV0ZSkgdHJhbnNsYXRpb24ub2Zmc2V0KGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgICAgIC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSlcbiAgICAgICAgICAgIC5yb3RhdGUoYW5nbGUpO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbENvb3JkaW5hdGVzOiBmdW5jdGlvbihsYWJlbFBvc2l0aW9uKSB7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdGhpcy5fZ2V0TGFiZWxUcmFuc2Zvcm1hdGlvbk1hdHJpeChsYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0cmFuc2Zvcm1hdGlvbk1hdHJpeC5lLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeC5mKTtcbiAgICB9LFxuXG4gICAgZ2V0VmVydGV4SW5kZXg6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBtb2RlbC52ZXJ0aWNlcygpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhMZW5ndGggPSB0aGlzLmdldENsb3Nlc3RQb2ludExlbmd0aChuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICBmb3IgKHZhciBuID0gdmVydGljZXMubGVuZ3RoOyBpZHggPCBuOyBpZHgrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpZHhdO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWZXJ0ZXhMZW5ndGggPSB0aGlzLmdldENsb3Nlc3RQb2ludExlbmd0aChjdXJyZW50VmVydGV4KTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBjdXJyZW50VmVydGV4TGVuZ3RoKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIEludGVyYWN0aW9uLiBUaGUgY29udHJvbGxlciBwYXJ0LlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyZG93bi5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJkb3duJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbm90aWZ5UG9pbnRlcm1vdmUoZXZ0LCB4LCB5KSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVybW92ZS5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJtb3ZlJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbm90aWZ5UG9pbnRlcnVwKGV2dCwgeCwgeSkge1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpwb2ludGVydXAnLCBldnQsIHgsIHkpO1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcnVwLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmRibGNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmRibGNsaWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJkYmxjbGljaycsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJjbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpwb2ludGVyY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLmNvbnRleHRtZW51LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOmNvbnRleHRtZW51JywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIGRlZmF1bHQgbWFya3VwXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBldnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcblxuICAgICAgICAgICAgY2FzZSAnbWFya2VyLXZlcnRleCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnVmVydGV4U3RhcnQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNhc2UgJ21hcmtlci12ZXJ0ZXgtcmVtb3ZlJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcmtlci12ZXJ0ZXgtcmVtb3ZlLWFyZWEnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ZlcnRleFJlbW92ZVN0YXJ0KGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjYXNlICdtYXJrZXItYXJyb3doZWFkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcnJvd2hlYWRTdGFydChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGlvbic6XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW9uLXdyYXAnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0Nvbm5lY3Rpb25TdGFydChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY2FzZSAnbWFya2VyLXNvdXJjZSc6XG4gICAgICAgICAgICBjYXNlICdtYXJrZXItdGFyZ2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdTdGFydChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdmFyIGRyYWdEYXRhID0gdGhpcy5fZHJhZ0RhdGE7XG4gICAgICAgIGlmIChkcmFnRGF0YSkgdGhpcy5ldmVudERhdGEoZXZ0LCBkcmFnRGF0YSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBzd2l0Y2ggKGRhdGEuYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3ZlcnRleC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdWZXJ0ZXgoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbGFiZWwtbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnTGFiZWwoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYXJyb3doZWFkLW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0Fycm93aGVhZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWcoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGlmIChkcmFnRGF0YSkgYXNzaWduKGRyYWdEYXRhLCB0aGlzLmV2ZW50RGF0YShldnQpKTtcblxuICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJtb3ZlKGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdmFyIGRyYWdEYXRhID0gdGhpcy5fZHJhZ0RhdGE7XG4gICAgICAgIGlmIChkcmFnRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCBkcmFnRGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnRGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5hY3Rpb24pIHtcblxuICAgICAgICAgICAgY2FzZSAndmVydGV4LW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ZlcnRleEVuZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdsYWJlbC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdMYWJlbEVuZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhcnJvd2hlYWQtbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQXJyb3doZWFkRW5kKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZChldnQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVydXAoZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5jaGVja01vdXNlbGVhdmUoZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOm1vdXNlb3ZlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6bW91c2VvdXQnLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWVudGVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZWVudGVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm1vdXNlbGVhdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6bW91c2VsZWF2ZScsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSwgZGVsdGEpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2V3aGVlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZXdoZWVsJywgZXZ0LCB4LCB5LCBkZWx0YSk7XG4gICAgfSxcblxuICAgIG9uZXZlbnQ6IGZ1bmN0aW9uKGV2dCwgZXZlbnROYW1lLCB4LCB5KSB7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdmFyIGxpbmtUb29sID0gVihldnQudGFyZ2V0KS5maW5kUGFyZW50QnlDbGFzcygnbGluay10b29sJywgdGhpcy5lbCk7XG4gICAgICAgIGlmIChsaW5rVG9vbCkge1xuICAgICAgICAgICAgLy8gTm8gZnVydGhlciBhY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgYGludGVyYWN0aXZlLnVzZUxpbmtUb29scz1mYWxzZWBcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbigndXNlTGlua1Rvb2xzJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsdC1pbiByZW1vdmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmUoeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgbGluayBwb2ludGVyZG93blxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaW5rOm9wdGlvbnMgYW5kIG90aGVyIGN1c3RvbSBldmVudHMgaW5zaWRlIHRoZSBsaW5rIHRvb2xzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50TmFtZSwgZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMucGFwZXIuZGVsZWdhdGVEcmFnRXZlbnRzKHRoaXMsIGV2dC5kYXRhKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm9uZXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbmxhYmVsOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG5cbiAgICAgICAgdGhpcy5kcmFnTGFiZWxTdGFydChldnQsIHgsIHkpO1xuXG4gICAgICAgIHZhciBzdG9wUHJvcGFnYXRpb24gPSB0aGlzLmV2ZW50RGF0YShldnQpLnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbikgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICAvLyBEcmFnIFN0YXJ0IEhhbmRsZXJzXG5cbiAgICBkcmFnQ29ubmVjdGlvblN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuKCd2ZXJ0ZXhBZGQnKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbmV3IHZlcnRleCBoYXMganVzdCBiZWVuIHBsYWNlZC5cbiAgICAgICAgLy8gV2UnbGwgYmUgdXBkYXRlIHRoZSB2ZXJ5IHNhbWUgdmVydGV4IHBvc2l0aW9uIGluIGBwb2ludGVybW92ZSgpYC5cbiAgICAgICAgdmFyIHZlcnRleElkeCA9IHRoaXMuYWRkVmVydGV4KHsgeDogeCwgeTogeSB9LCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3ZlcnRleC1tb3ZlJyxcbiAgICAgICAgICAgIHZlcnRleElkeDogdmVydGV4SWR4XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBkcmFnTGFiZWxTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuKCdsYWJlbE1vdmUnKSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZChldnQpKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBsYWJlbE5vZGUgPSBldnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIHZhciBsYWJlbElkeCA9IHBhcnNlSW50KGxhYmVsTm9kZS5nZXRBdHRyaWJ1dGUoJ2xhYmVsLWlkeCcpLCAxMCk7XG5cbiAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbiA9IHRoaXMuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uUHJvcGVydHkoKTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsTGFiZWxQb3NpdGlvbiA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsUG9zaXRpb24odGhpcy5fZ2V0TGFiZWxQb3NpdGlvblByb3BlcnR5KGxhYmVsSWR4KSk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9tZXJnZUxhYmVsUG9zaXRpb25Qcm9wZXJ0eShpbml0aWFsTGFiZWxQb3NpdGlvbiwgZGVmYXVsdExhYmVsUG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRMYWJlbENvb3JkaW5hdGVzKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBkeCA9IGNvb3Jkcy54IC0geDsgLy8gaG93IG11Y2ggbmVlZHMgdG8gYmUgYWRkZWQgdG8gY3Vyc29yIHggdG8gZ2V0IHRvIGxhYmVsIHhcbiAgICAgICAgICAgIHZhciBkeSA9IGNvb3Jkcy55IC0geTsgLy8gaG93IG11Y2ggbmVlZHMgdG8gYmUgYWRkZWQgdG8gY3Vyc29yIHkgdG8gZ2V0IHRvIGxhYmVsIHlcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQW5nbGUgPSB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uQW5nbGUobGFiZWxJZHgpO1xuICAgICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25BcmdzID0gdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkFyZ3MobGFiZWxJZHgpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyA9IHRoaXMuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uQXJncygpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQXJncyA9IHRoaXMuX21lcmdlTGFiZWxQb3NpdGlvbkFyZ3MobGFiZWxQb3NpdGlvbkFyZ3MsIGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xhYmVsLW1vdmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsSWR4OiBsYWJlbElkeCxcbiAgICAgICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICAgICAgZHk6IGR5LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQW5nbGU6IHBvc2l0aW9uQW5nbGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BcmdzOiBwb3NpdGlvbkFyZ3MsXG4gICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbiAgICAgICAgICAgIC8vIElmIGxhYmVscyBjYW4ndCBiZSBkcmFnZ2VkIG5vIGRlZmF1bHQgYWN0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBzdG9wUHJvcGFnYXRpb246IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcGVyLmRlbGVnYXRlRHJhZ0V2ZW50cyh0aGlzLCBldnQuZGF0YSk7XG4gICAgfSxcblxuICAgIGRyYWdWZXJ0ZXhTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbigndmVydGV4TW92ZScpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHZlcnRleE5vZGUgPSBldnQudGFyZ2V0O1xuICAgICAgICB2YXIgdmVydGV4SWR4ID0gcGFyc2VJbnQodmVydGV4Tm9kZS5nZXRBdHRyaWJ1dGUoJ2lkeCcpLCAxMCk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgYWN0aW9uOiAndmVydGV4LW1vdmUnLFxuICAgICAgICAgICAgdmVydGV4SWR4OiB2ZXJ0ZXhJZHhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRyYWdWZXJ0ZXhSZW1vdmVTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbigndmVydGV4UmVtb3ZlJykpIHJldHVybjtcblxuICAgICAgICB2YXIgcmVtb3ZlTm9kZSA9IGV2dC50YXJnZXQ7XG4gICAgICAgIHZhciB2ZXJ0ZXhJZHggPSBwYXJzZUludChyZW1vdmVOb2RlLmdldEF0dHJpYnV0ZSgnaWR4JyksIDEwKTtcbiAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmVWZXJ0ZXgodmVydGV4SWR4KTtcbiAgICB9LFxuXG4gICAgZHJhZ0Fycm93aGVhZFN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuKCdhcnJvd2hlYWRNb3ZlJykpIHJldHVybjtcblxuICAgICAgICB2YXIgYXJyb3doZWFkTm9kZSA9IGV2dC50YXJnZXQ7XG4gICAgICAgIHZhciBhcnJvd2hlYWRUeXBlID0gYXJyb3doZWFkTm9kZS5nZXRBdHRyaWJ1dGUoJ2VuZCcpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc3RhcnRBcnJvd2hlYWRNb3ZlKGFycm93aGVhZFR5cGUsIHsgaWdub3JlQmFja3dhcmRzQ29tcGF0aWJpbGl0eTogdHJ1ZSB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuKCdsaW5rTW92ZScpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBhY3Rpb246ICdtb3ZlJyxcbiAgICAgICAgICAgIGR4OiB4LFxuICAgICAgICAgICAgZHk6IHlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgSGFuZGxlcnNcbiAgICBkcmFnTGFiZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIGxhYmVsID0geyBwb3NpdGlvbjogdGhpcy5nZXRMYWJlbFBvc2l0aW9uKCh4ICsgZGF0YS5keCksICh5ICsgZGF0YS5keSksIGRhdGEucG9zaXRpb25BbmdsZSwgZGF0YS5wb3NpdGlvbkFyZ3MpIH07XG4gICAgICAgIGlmICh0aGlzLnBhcGVyLm9wdGlvbnMuc25hcExhYmVscykgZGVsZXRlIGxhYmVsLnBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgLy8gVGhlIGB0b3VjaG1vdmUnIGV2ZW50cyBhcmUgbm90IGZpcmVkXG4gICAgICAgIC8vIHdoZW4gdGhlIG9yaWdpbmFsIGV2ZW50IHRhcmdldCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgY3VycmVudGx5IHJlLXJlbmRlcmVkIGNvbXBsZXRlbHkgd2hlbiBvbmx5XG4gICAgICAgIC8vIHRoZSBwb3NpdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBsYWJlbCBpcyB1cGRhdGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgIC8vIFRPRE86IHJlcGxhY2UgYHRvdWNobW92ZWAgd2l0aCBgcG9pbnRlcm1vdmVgIChicmVha2luZyBjaGFuZ2UpLlxuICAgICAgICBjb25zdCBzZXRPcHRpb25zID0geyB1aTogdHJ1ZSB9O1xuICAgICAgICBpZiAodGhpcy5wYXBlci5pc0FzeW5jKCkgJiYgZXZ0LnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgICBzZXRPcHRpb25zLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5sYWJlbChkYXRhLmxhYmVsSWR4LCBsYWJlbCwgc2V0T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGRyYWdWZXJ0ZXg6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdGhpcy5tb2RlbC52ZXJ0ZXgoZGF0YS52ZXJ0ZXhJZHgsIHsgeDogeCwgeTogeSB9LCB7IHVpOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICBkcmFnQXJyb3doZWFkOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5zbmFwTGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU25hcHBlZCA9IHRoaXMuX3NuYXBBcnJvd2hlYWQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIGlmICghaXNTbmFwcGVkICYmIHRoaXMucGFwZXIub3B0aW9ucy5zbmFwTGlua3NTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc25hcEFycm93aGVhZFNlbGYoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcGVyLm9wdGlvbnMuc25hcExpbmtzU2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NuYXBBcnJvd2hlYWRTZWxmKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RBcnJvd2hlYWQodGhpcy5nZXRFdmVudFRhcmdldChldnQpLCB4LCB5LCB0aGlzLmV2ZW50RGF0YShldnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkcmFnOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHRoaXMubW9kZWwudHJhbnNsYXRlKHggLSBkYXRhLmR4LCB5IC0gZGF0YS5keSwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBkeDogeCxcbiAgICAgICAgICAgIGR5OiB5XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEcmFnIEVuZCBIYW5kbGVyc1xuXG4gICAgZHJhZ0xhYmVsRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBkcmFnVmVydGV4RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBkcmFnQXJyb3doZWFkRW5kOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG5cbiAgICAgICAgaWYgKHBhcGVyLm9wdGlvbnMuc25hcExpbmtzKSB7XG4gICAgICAgICAgICB0aGlzLl9zbmFwQXJyb3doZWFkRW5kKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdEFycm93aGVhZEVuZChkYXRhLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFwZXIubGlua0FsbG93ZWQodGhpcykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFuZ2VkIGxpbmsgaXMgbm90IGFsbG93ZWQsIHJldmVydCB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAgICB0aGlzLl9kaXNhbGxvdyhkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaEVtYmVkZGluZyhkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeUNvbm5lY3RFdmVudChkYXRhLCBldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWZ0ZXJBcnJvd2hlYWRNb3ZlKGRhdGEpO1xuICAgIH0sXG5cbiAgICBkcmFnRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBfZGlzYWxsb3c6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEud2hlbk5vdEFsbG93ZWQpIHtcblxuICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlbW92ZSh7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyZXZlcnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChkYXRhLmFycm93aGVhZCwgZGF0YS5pbml0aWFsRW5kLCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maW5pc2hFbWJlZGRpbmc6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBSZXBhcmVudCB0aGUgbGluayBpZiBlbWJlZGRpbmcgaXMgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5wYXBlci5vcHRpb25zLmVtYmVkZGluZ01vZGUgJiYgdGhpcy5tb2RlbC5yZXBhcmVudCgpKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmV2ZXJzZSB0byB0aGUgb3JpZ2luYWwgJ3onIGluZGV4IChzZWUgYWZ0ZXJBcnJvd2hlYWRNb3ZlKCkpLlxuICAgICAgICAgICAgZGF0YS56ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbm90aWZ5Q29ubmVjdEV2ZW50OiBmdW5jdGlvbihkYXRhLCBldnQpIHtcblxuICAgICAgICB2YXIgYXJyb3doZWFkID0gZGF0YS5hcnJvd2hlYWQ7XG4gICAgICAgIHZhciBpbml0aWFsRW5kID0gZGF0YS5pbml0aWFsRW5kO1xuICAgICAgICB2YXIgY3VycmVudEVuZCA9IHRoaXMubW9kZWwucHJvcChhcnJvd2hlYWQpO1xuICAgICAgICB2YXIgZW5kQ2hhbmdlZCA9IGN1cnJlbnRFbmQgJiYgIUxpbmsuZW5kc0VxdWFsKGluaXRpYWxFbmQsIGN1cnJlbnRFbmQpO1xuICAgICAgICBpZiAoZW5kQ2hhbmdlZCkge1xuICAgICAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgICAgIGlmIChpbml0aWFsRW5kLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6ZGlzY29ubmVjdCcsIGV2dCwgcGFwZXIuZmluZFZpZXdCeU1vZGVsKGluaXRpYWxFbmQuaWQpLCBkYXRhLmluaXRpYWxNYWduZXQsIGFycm93aGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVuZC5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOmNvbm5lY3QnLCBldnQsIHBhcGVyLmZpbmRWaWV3QnlNb2RlbChjdXJyZW50RW5kLmlkKSwgZGF0YS5tYWduZXRVbmRlclBvaW50ZXIsIGFycm93aGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NuYXBUb1BvaW50czogZnVuY3Rpb24oc25hcFBvaW50LCBwb2ludHMsIHJhZGl1cykge1xuICAgICAgICBsZXQgY2xvc2VzdFBvaW50WCA9IG51bGw7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2VYID0gSW5maW5pdHk7XG5cbiAgICAgICAgbGV0IGNsb3Nlc3RQb2ludFkgPSBudWxsO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlWSA9IEluZmluaXR5O1xuXG4gICAgICAgIGxldCB4ID0gc25hcFBvaW50Lng7XG4gICAgICAgIGxldCB5ID0gc25hcFBvaW50Lnk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RYID0gTWF0aC5hYnMocG9pbnRzW2ldLnggLSBzbmFwUG9pbnQueCk7XG4gICAgICAgICAgICBpZiAoZGlzdFggPCBjbG9zZXN0RGlzdGFuY2VYKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlWCA9IGRpc3RYO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludFggPSBwb2ludHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRpc3RZID0gTWF0aC5hYnMocG9pbnRzW2ldLnkgLSBzbmFwUG9pbnQueSk7XG4gICAgICAgICAgICBpZiAoZGlzdFkgPCBjbG9zZXN0RGlzdGFuY2VZKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlWSA9IGRpc3RZO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludFkgPSBwb2ludHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2VzdERpc3RhbmNlWCA8IHJhZGl1cykge1xuICAgICAgICAgICAgeCA9IGNsb3Nlc3RQb2ludFgueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2VzdERpc3RhbmNlWSA8IHJhZGl1cykge1xuICAgICAgICAgICAgeSA9IGNsb3Nlc3RQb2ludFkueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9LFxuXG4gICAgX3NuYXBBcnJvd2hlYWRTZWxmOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IHBhcGVyLCBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzbmFwTGlua3NTZWxmIH0gPSBwYXBlci5vcHRpb25zO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gc25hcExpbmtzU2VsZi5yYWRpdXMgfHwgMjA7XG5cbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5nZXRFbmRBbmNob3IoZGF0YS5hcnJvd2hlYWQgPT09ICdzb3VyY2UnID8gJ3RhcmdldCcgOiAnc291cmNlJyk7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbW9kZWwudmVydGljZXMoKTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW2FuY2hvciwgLi4udmVydGljZXNdO1xuXG4gICAgICAgIGNvbnN0IHNuYXBQb2ludCA9IHRoaXMuX3NuYXBUb1BvaW50cyh7IHg6IHgsIHk6IHkgfSwgcG9pbnRzLCByYWRpdXMpO1xuXG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGFwZXIubG9jYWxUb0NsaWVudFBvaW50KHNuYXBQb2ludCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RBcnJvd2hlYWQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb2ludC54LCBwb2ludC55KSwgc25hcFBvaW50LngsIHNuYXBQb2ludC55LCB0aGlzLmV2ZW50RGF0YShldnQpKTtcbiAgICB9LFxuXG4gICAgX3NuYXBBcnJvd2hlYWQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc25hcExpbmtzLCBjb25uZWN0aW9uU3RyYXRlZ3kgfSA9IHBhcGVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBsZXQgaXNTbmFwcGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGNoZWNraW5nIHZpZXcgaW4gY2xvc2UgYXJlYSBvZiB0aGUgcG9pbnRlclxuXG4gICAgICAgIHZhciByID0gc25hcExpbmtzLnJhZGl1cyB8fCA1MDtcbiAgICAgICAgdmFyIHZpZXdzSW5BcmVhID0gcGFwZXIuZmluZFZpZXdzSW5BcmVhKHsgeDogeCAtIHIsIHk6IHkgLSByLCB3aWR0aDogMiAqIHIsIGhlaWdodDogMiAqIHIgfSk7XG5cbiAgICAgICAgdmFyIHByZXZDbG9zZXN0VmlldyA9IGRhdGEuY2xvc2VzdFZpZXcgfHwgbnVsbDtcbiAgICAgICAgdmFyIHByZXZDbG9zZXN0TWFnbmV0ID0gZGF0YS5jbG9zZXN0TWFnbmV0IHx8IG51bGw7XG4gICAgICAgIHZhciBwcmV2TWFnbmV0UHJveHkgPSBkYXRhLm1hZ25ldFByb3h5IHx8IG51bGw7XG5cbiAgICAgICAgZGF0YS5jbG9zZXN0VmlldyA9IGRhdGEuY2xvc2VzdE1hZ25ldCA9IGRhdGEubWFnbmV0UHJveHkgPSBudWxsO1xuXG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBwb2ludGVyID0gbmV3IFBvaW50KHgsIHkpO1xuXG4gICAgICAgIHZpZXdzSW5BcmVhLmZvckVhY2goZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgLy8gc2tpcCBjb25uZWN0aW5nIHRvIHRoZSBlbGVtZW50IGluIGNhc2UgJy4nOiB7IG1hZ25ldDogZmFsc2UgfSBhdHRyaWJ1dGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHZpZXcuZWwuZ2V0QXR0cmlidXRlKCdtYWduZXQnKSAhPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGJib3g6IHZpZXcubW9kZWwuZ2V0QkJveCgpLFxuICAgICAgICAgICAgICAgICAgICBtYWduZXQ6IHZpZXcuZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy4kKCdbbWFnbmV0XScpLnRvQXJyYXkoKS5mb3JFYWNoKG1hZ25ldCA9PiB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYmJveDogdmlldy5nZXROb2RlQkJveChtYWduZXQpLFxuICAgICAgICAgICAgICAgICAgICBtYWduZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1hZ25ldCwgYmJveCB9ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBtb2RlbCB0byBwb2ludGVyIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBiYm94LmNlbnRlcigpLnNxdWFyZWREaXN0YW5jZShwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBpcyBsb29rZWQgdXAgaW4gYSBjaXJjbGUgYXJlYSBieSBgZGlzdGFuY2UgPCByYFxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQWxyZWFkeVZhbGlkYXRlZCA9IHByZXZDbG9zZXN0TWFnbmV0ID09PSBtYWduZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FscmVhZHlWYWxpZGF0ZWQgfHwgcGFwZXIub3B0aW9ucy52YWxpZGF0ZUNvbm5lY3Rpb24uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlciwgZGF0YS52YWxpZGF0ZUNvbm5lY3Rpb25BcmdzKHZpZXcsICh2aWV3LmVsID09PSBtYWduZXQpID8gbnVsbCA6IG1hZ25ldClcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2xvc2VzdFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jbG9zZXN0TWFnbmV0ID0gbWFnbmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgdmFyIG1hZ25ldFByb3h5ID0gbnVsbDtcbiAgICAgICAgdmFyIGNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0VmlldztcbiAgICAgICAgdmFyIGNsb3Nlc3RNYWduZXQgPSBkYXRhLmNsb3Nlc3RNYWduZXQ7XG4gICAgICAgIGlmIChjbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICBtYWduZXRQcm94eSA9IGRhdGEubWFnbmV0UHJveHkgPSBjbG9zZXN0Vmlldy5maW5kUHJveHlOb2RlKGNsb3Nlc3RNYWduZXQsICdoaWdobGlnaHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRUeXBlID0gZGF0YS5hcnJvd2hlYWQ7XG4gICAgICAgIHZhciBuZXdDbG9zZXN0TWFnbmV0ID0gKHByZXZDbG9zZXN0TWFnbmV0ICE9PSBjbG9zZXN0TWFnbmV0KTtcbiAgICAgICAgaWYgKHByZXZDbG9zZXN0VmlldyAmJiBuZXdDbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICBwcmV2Q2xvc2VzdFZpZXcudW5oaWdobGlnaHQocHJldk1hZ25ldFByb3h5LCB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzbmFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2VzdFZpZXcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkVuZCwgcHJldlgsIHByZXZZIH0gPSBkYXRhO1xuICAgICAgICAgICAgZGF0YS5wcmV2WCA9IHg7XG4gICAgICAgICAgICBkYXRhLnByZXZZID0geTtcbiAgICAgICAgICAgIGlzU25hcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghbmV3Q2xvc2VzdE1hZ25ldCkgIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25TdHJhdGVneSAhPT0gJ2Z1bmN0aW9uJyB8fCAocHJldlggPT09IHggJiYgcHJldlkgPT09IHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYWduZXQgaGFzIG5vdCBjaGFuZ2VkIGFuZCB0aGUgbGluaydzIGVuZCBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIHggYW5kIHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU25hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuZCA9IGNsb3Nlc3RWaWV3LmdldExpbmtFbmQoY2xvc2VzdE1hZ25ldCwgeCwgeSwgdGhpcy5tb2RlbCwgZW5kVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW5ld0Nsb3Nlc3RNYWduZXQgJiYgaXNFcXVhbChwcmV2RW5kLCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNvdXJjZS90YXJnZXQganNvbiBoYXMgbm90IGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTbmFwcGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLnByZXZFbmQgPSBlbmQ7XG5cbiAgICAgICAgICAgIGlmIChuZXdDbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFZpZXcuaGlnaGxpZ2h0KG1hZ25ldFByb3h5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZW5kID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnNldChlbmRUeXBlLCBlbmQgfHwgeyB4OiB4LCB5OiB5IH0sIHsgdWk6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKHByZXZDbG9zZXN0Vmlldykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6c25hcDpkaXNjb25uZWN0JywgZXZ0LCBwcmV2Q2xvc2VzdFZpZXcsIHByZXZDbG9zZXN0TWFnbmV0LCBlbmRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2VzdFZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnNuYXA6Y29ubmVjdCcsIGV2dCwgY2xvc2VzdFZpZXcsIGNsb3Nlc3RNYWduZXQsIGVuZFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzU25hcHBlZDtcbiAgICB9LFxuXG4gICAgX3NuYXBBcnJvd2hlYWRFbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBGaW5pc2ggb2ZmIGxpbmsgc25hcHBpbmcuXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZXhjZXB0IHZpZXcgdW5oaWdobGlnaHRpbmcgd2FzIGFscmVhZHkgZG9uZSBvbiBwb2ludGVybW92ZS5cbiAgICAgICAgdmFyIGNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0VmlldztcbiAgICAgICAgdmFyIGNsb3Nlc3RNYWduZXQgPSBkYXRhLmNsb3Nlc3RNYWduZXQ7XG4gICAgICAgIGlmIChjbG9zZXN0VmlldyAmJiBjbG9zZXN0TWFnbmV0KSB7XG5cbiAgICAgICAgICAgIGNsb3Nlc3RWaWV3LnVuaGlnaGxpZ2h0KGRhdGEubWFnbmV0UHJveHksIHsgY29ubmVjdGluZzogdHJ1ZSwgc25hcHBpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICBkYXRhLm1hZ25ldFVuZGVyUG9pbnRlciA9IGNsb3Nlc3RWaWV3LmZpbmRNYWduZXQoY2xvc2VzdE1hZ25ldCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0TWFnbmV0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Nvbm5lY3RBcnJvd2hlYWQ6IGZ1bmN0aW9uKHRhcmdldCwgeCwgeSwgZGF0YSkge1xuXG4gICAgICAgIC8vIGNoZWNraW5nIHZpZXdzIHJpZ2h0IHVuZGVyIHRoZSBwb2ludGVyXG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmV2ZW50VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyB2aWV3IHVuZGVyIHBvaW50ZXIgaWYgdGhlcmUgd2FzIG9uZS5cbiAgICAgICAgICAgIGlmIChkYXRhLm1hZ25ldFByb3h5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS52aWV3VW5kZXJQb2ludGVyLnVuaGlnaGxpZ2h0KGRhdGEubWFnbmV0UHJveHksIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2aWV3VW5kZXJQb2ludGVyID0gZGF0YS52aWV3VW5kZXJQb2ludGVyID0gcGFwZXIuZmluZFZpZXcodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh2aWV3VW5kZXJQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSB2aWV3IHRoYXQgaXMgdW5kZXIgdGhlIHBvaW50ZXIsIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdFxuICAgICAgICAgICAgICAgIC8vIG1hZ25ldCBiYXNlZCBvbiB0aGUgcmVhbCB0YXJnZXQgZWxlbWVudCBvZiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgbWFnbmV0VW5kZXJQb2ludGVyID0gZGF0YS5tYWduZXRVbmRlclBvaW50ZXIgPSB2aWV3VW5kZXJQb2ludGVyLmZpbmRNYWduZXQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWduZXRQcm94eSA9IGRhdGEubWFnbmV0UHJveHkgPSB2aWV3VW5kZXJQb2ludGVyLmZpbmRQcm94eU5vZGUobWFnbmV0VW5kZXJQb2ludGVyLCAnaGlnaGxpZ2h0ZXInKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYWduZXRVbmRlclBvaW50ZXIgJiYgdGhpcy5wYXBlci5vcHRpb25zLnZhbGlkYXRlQ29ubmVjdGlvbi5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgcGFwZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudmFsaWRhdGVDb25uZWN0aW9uQXJncyh2aWV3VW5kZXJQb2ludGVyLCBtYWduZXRVbmRlclBvaW50ZXIpXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbWFnbmV0IGZvdW5kLCBkbyBub3QgaGlnaGxpZ2h0IGFueXRoaW5nIGFuZCBhc3N1bWUgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gdmlldyB1bmRlciBwb2ludGVyIHdlJ3JlIGludGVyZXN0ZWQgaW4gcmVjb25uZWN0aW5nIHRvLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgb3ZlcmFsbCBlbGVtZW50IGhhcyB0aGUgYXR0cmlidXRlIGAnLic6IHsgbWFnbmV0OiBmYWxzZSB9YC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hZ25ldFByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VW5kZXJQb2ludGVyLmhpZ2hsaWdodChtYWduZXRQcm94eSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlIG9mIGNvbm5lY3Rpb24gaXMgbm90IHZhbGlkLiBEaXNyZWdhcmQgdGhpcyBtYWduZXQuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYWduZXRQcm94eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UnbGwgdW5zZXQgcHJldmlvdXMgbWFnbmV0LlxuICAgICAgICAgICAgICAgIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkYXRhLm1hZ25ldFByb3h5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZXZlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgbW9kZWwuc2V0KGRhdGEuYXJyb3doZWFkLCB7IHg6IHgsIHk6IHkgfSwgeyB1aTogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgX2Nvbm5lY3RBcnJvd2hlYWRFbmQ6IGZ1bmN0aW9uKGRhdGEgPSB7fSwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlld1VuZGVyUG9pbnRlciwgbWFnbmV0VW5kZXJQb2ludGVyLCBtYWduZXRQcm94eSwgYXJyb3doZWFkIH0gPSBkYXRhO1xuXG4gICAgICAgIGlmICghbWFnbmV0VW5kZXJQb2ludGVyIHx8ICFtYWduZXRQcm94eSB8fCAhdmlld1VuZGVyUG9pbnRlcikgcmV0dXJuO1xuXG4gICAgICAgIHZpZXdVbmRlclBvaW50ZXIudW5oaWdobGlnaHQobWFnbmV0UHJveHksIHsgY29ubmVjdGluZzogdHJ1ZSB9KTtcblxuICAgICAgICAvLyBUaGUgbGluayBlbmQgaXMgdGFrZW4gZnJvbSB0aGUgbWFnbmV0IHVuZGVyIHRoZSBwb2ludGVyLCBub3QgdGhlIHByb3h5LlxuICAgICAgICBjb25zdCBlbmQgPSB2aWV3VW5kZXJQb2ludGVyLmdldExpbmtFbmQobWFnbmV0VW5kZXJQb2ludGVyLCB4LCB5LCBtb2RlbCwgYXJyb3doZWFkKTtcbiAgICAgICAgbW9kZWwuc2V0KGFycm93aGVhZCwgZW5kLCB7IHVpOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICBfYmVmb3JlQXJyb3doZWFkTW92ZTogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIGRhdGEueiA9IHRoaXMubW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgIHRoaXMubW9kZWwudG9Gcm9udCgpO1xuXG4gICAgICAgIC8vIExldCB0aGUgcG9pbnRlciBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgbGluayB2aWV3IGVsZW1lbnRzIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIGBldnQudGFyZ2V0YCBpcyBhbm90aGVyIGVsZW1lbnQgdW5kZXIgdGhlIHBvaW50ZXIsIG5vdCB0aGUgbGluayBpdHNlbGYuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgICAgIGRhdGEucG9pbnRlckV2ZW50cyA9IHN0eWxlLnBvaW50ZXJFdmVudHM7XG4gICAgICAgIHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5tYXJrQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrQXZhaWxhYmxlTWFnbmV0cyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWZ0ZXJBcnJvd2hlYWRNb3ZlOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgaWYgKGRhdGEueiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3onLCBkYXRhLnosIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICBkYXRhLnogPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGBwb2ludGVyLWV2ZW50c2AgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUuIFNlZSBgX2JlZm9yZUFycm93aGVhZE1vdmUoKWAgZm9yIGV4cGxhbmF0aW9uLlxuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkYXRhLnBvaW50ZXJFdmVudHM7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5tYXJrQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hcmtBdmFpbGFibGVNYWduZXRzKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVWYWxpZGF0ZUNvbm5lY3Rpb25BcmdzOiBmdW5jdGlvbihhcnJvd2hlYWQpIHtcbiAgICAgICAgLy8gSXQgbWFrZXMgc3VyZSB0aGUgYXJndW1lbnRzIGZvciB2YWxpZGF0ZUNvbm5lY3Rpb24gaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICAgIC8vIChzb3VyY2Ugdmlldywgc291cmNlIG1hZ25ldCwgdGFyZ2V0IHZpZXcsIHRhcmdldCBtYWduZXQgYW5kIGxpbmsgdmlldylcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBhcmdzWzRdID0gYXJyb3doZWFkO1xuICAgICAgICBhcmdzWzVdID0gdGhpcztcblxuICAgICAgICB2YXIgb3Bwb3NpdGVBcnJvd2hlYWQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgIGlmIChhcnJvd2hlYWQgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgIG9wcG9zaXRlQXJyb3doZWFkID0gJ3RhcmdldCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgIG9wcG9zaXRlQXJyb3doZWFkID0gJ3NvdXJjZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tb2RlbC5nZXQob3Bwb3NpdGVBcnJvd2hlYWQpO1xuXG4gICAgICAgIGlmIChlbmQuaWQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gYXJnc1tpXSA9IHRoaXMucGFwZXIuZmluZFZpZXdCeU1vZGVsKGVuZC5pZCk7XG4gICAgICAgICAgICB2YXIgbWFnbmV0ID0gdmlldy5nZXRNYWduZXRGcm9tTGlua0VuZChlbmQpO1xuICAgICAgICAgICAgaWYgKG1hZ25ldCA9PT0gdmlldy5lbCkgbWFnbmV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXJnc1tpICsgMV0gPSBtYWduZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbm5lY3Rpb25BcmdzKGNlbGxWaWV3LCBtYWduZXQpIHtcbiAgICAgICAgICAgIGFyZ3Nbal0gPSBjZWxsVmlldztcbiAgICAgICAgICAgIGFyZ3NbaiArIDFdID0gY2VsbFZpZXcuZWwgPT09IG1hZ25ldCA/IHVuZGVmaW5lZCA6IG1hZ25ldDtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQ29ubmVjdGlvbkFyZ3M7XG4gICAgfSxcblxuICAgIF9tYXJrQXZhaWxhYmxlTWFnbmV0czogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzTWFnbmV0QXZhaWxhYmxlKHZpZXcsIG1hZ25ldCkge1xuICAgICAgICAgICAgdmFyIHBhcGVyID0gdmlldy5wYXBlcjtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZSA9IHBhcGVyLm9wdGlvbnMudmFsaWRhdGVDb25uZWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlLmFwcGx5KHBhcGVyLCB0aGlzLnZhbGlkYXRlQ29ubmVjdGlvbkFyZ3ModmlldywgbWFnbmV0KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBwYXBlci5tb2RlbC5nZXRDZWxscygpO1xuICAgICAgICBkYXRhLm1hcmtlZCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IGVsZW1lbnRzW2ldLmZpbmRWaWV3KHBhcGVyKTtcblxuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWduZXRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmlldy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbbWFnbmV0XScpKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmVsLmdldEF0dHJpYnV0ZSgnbWFnbmV0JykgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IHdyYXBwaW5nIGdyb3VwIGlzIGFsc28gYSBtYWduZXRcbiAgICAgICAgICAgICAgICBtYWduZXRzLnB1c2godmlldy5lbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVNYWduZXRzID0gbWFnbmV0cy5maWx0ZXIoaXNNYWduZXRBdmFpbGFibGUuYmluZChkYXRhLCB2aWV3KSk7XG5cbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVNYWduZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgYWxsIGF2YWlsYWJsZSBtYWduZXRzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBhdmFpbGFibGVNYWduZXRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChhdmFpbGFibGVNYWduZXRzW2pdLCB7IG1hZ25ldEF2YWlsYWJpbGl0eTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSBlbnRpcmUgdmlld1xuICAgICAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KG51bGwsIHsgZWxlbWVudEF2YWlsYWJpbGl0eTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGRhdGEubWFya2VkW3ZpZXcubW9kZWwuaWRdID0gYXZhaWxhYmxlTWFnbmV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdW5tYXJrQXZhaWxhYmxlTWFnbmV0czogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIHZhciBtYXJrZWRLZXlzID0gT2JqZWN0LmtleXMoZGF0YS5tYXJrZWQpO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHZhciBtYXJrZWRNYWduZXRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbWFya2VkS2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gbWFya2VkS2V5c1tpXTtcbiAgICAgICAgICAgIG1hcmtlZE1hZ25ldHMgPSBkYXRhLm1hcmtlZFtpZF07XG5cbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5wYXBlci5maW5kVmlld0J5TW9kZWwoaWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IG1hcmtlZE1hZ25ldHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQobWFya2VkTWFnbmV0c1tqXSwgeyBtYWduZXRBdmFpbGFiaWxpdHk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQobnVsbCwgeyBlbGVtZW50QXZhaWxhYmlsaXR5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5tYXJrZWQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBzdGFydEFycm93aGVhZE1vdmU6IGZ1bmN0aW9uKGVuZCwgb3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgLy8gQWxsb3cgdG8gZGVsZWdhdGUgZXZlbnRzIGZyb20gYW4gYW5vdGhlciB2aWV3IHRvIHRoaXMgbGlua1ZpZXcgaW4gb3JkZXIgdG8gdHJpZ2dlciBhcnJvd2hlYWRcbiAgICAgICAgLy8gbW92ZSB3aXRob3V0IG5lZWQgdG8gY2xpY2sgb24gdGhlIGFjdHVhbCBhcnJvd2hlYWQgZG9tIGVsZW1lbnQuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYWN0aW9uOiAnYXJyb3doZWFkLW1vdmUnLFxuICAgICAgICAgICAgYXJyb3doZWFkOiBlbmQsXG4gICAgICAgICAgICB3aGVuTm90QWxsb3dlZDogb3B0LndoZW5Ob3RBbGxvd2VkIHx8ICdyZXZlcnQnLFxuICAgICAgICAgICAgaW5pdGlhbE1hZ25ldDogdGhpc1tlbmQgKyAnTWFnbmV0J10gfHwgKHRoaXNbZW5kICsgJ1ZpZXcnXSA/IHRoaXNbZW5kICsgJ1ZpZXcnXS5lbCA6IG51bGwpLFxuICAgICAgICAgICAgaW5pdGlhbEVuZDogY2xvbmUodGhpcy5tb2RlbC5nZXQoZW5kKSksXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbm5lY3Rpb25BcmdzOiB0aGlzLl9jcmVhdGVWYWxpZGF0ZUNvbm5lY3Rpb25BcmdzKGVuZClcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9iZWZvcmVBcnJvd2hlYWRNb3ZlKGRhdGEpO1xuXG4gICAgICAgIGlmIChvcHQuaWdub3JlQmFja3dhcmRzQ29tcGF0aWJpbGl0eSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0RhdGEgPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8vIExpZmVjeWNsZSBtZXRob2RzXG5cbiAgICBvbk1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm9uTW91bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb3VudExhYmVscygpO1xuICAgIH0sXG5cbiAgICBvbkRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5vbkRldGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVubW91bnRMYWJlbHMoKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51bm1vdW50TGFiZWxzKCk7XG4gICAgfVxuXG59LCB7XG5cbiAgICBGbGFnczogRmxhZ3MsXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtWaWV3LnByb3RvdHlwZSwgJ3NvdXJjZUJCb3gnLCB7XG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVZpZXcgPSB0aGlzLnNvdXJjZVZpZXc7XG4gICAgICAgIGlmICghc291cmNlVmlldykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZURlZiA9IHRoaXMubW9kZWwuc291cmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3Qoc291cmNlRGVmLngsIHNvdXJjZURlZi55KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlTWFnbmV0ID0gdGhpcy5zb3VyY2VNYWduZXQ7XG4gICAgICAgIGlmIChzb3VyY2VWaWV3LmlzTm9kZUNvbm5lY3Rpb24oc291cmNlTWFnbmV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMuc291cmNlQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlVmlldy5nZXROb2RlQkJveChzb3VyY2VNYWduZXQgfHwgc291cmNlVmlldy5lbCk7XG4gICAgfVxuXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtWaWV3LnByb3RvdHlwZSwgJ3RhcmdldEJCb3gnLCB7XG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhcmdldFZpZXcgPSB0aGlzLnRhcmdldFZpZXc7XG4gICAgICAgIGlmICghdGFyZ2V0Vmlldykge1xuICAgICAgICAgICAgdmFyIHRhcmdldERlZiA9IHRoaXMubW9kZWwudGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QodGFyZ2V0RGVmLngsIHRhcmdldERlZi55KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0TWFnbmV0ID0gdGhpcy50YXJnZXRNYWduZXQ7XG4gICAgICAgIGlmICh0YXJnZXRWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGFyZ2V0TWFnbmV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0Vmlldy5nZXROb2RlQkJveCh0YXJnZXRNYWduZXQgfHwgdGFyZ2V0Vmlldy5lbCk7XG4gICAgfVxufSk7XG5cbiJdLCJuYW1lcyI6WyJDZWxsVmlldyIsIkxpbmsiLCJWIiwiYWRkQ2xhc3NOYW1lUHJlZml4IiwicmVtb3ZlQ2xhc3NOYW1lUHJlZml4IiwibWVyZ2UiLCJ0ZW1wbGF0ZSIsImFzc2lnbiIsInRvQXJyYXkiLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJjbG9uZSIsImlzUGVyY2VudGFnZSIsInJlc3VsdCIsImlzRXF1YWwiLCJQb2ludCIsIkxpbmUiLCJQYXRoIiwibm9ybWFsaXplQW5nbGUiLCJSZWN0IiwiUG9seWxpbmUiLCJyb3V0ZXJzIiwiY29ubmVjdG9ycyIsIiQiLCJGbGFncyIsIlRPT0xTIiwiUkVOREVSIiwiVVBEQVRFIiwiTEVHQUNZX1RPT0xTIiwiTEFCRUxTIiwiVkVSVElDRVMiLCJTT1VSQ0UiLCJUQVJHRVQiLCJDT05ORUNUT1IiLCJMaW5rVmlldyIsImV4dGVuZCIsImNsYXNzTmFtZSIsImNsYXNzTmFtZXMiLCJwcm90b3R5cGUiLCJhcHBseSIsInNwbGl0IiwicHVzaCIsImpvaW4iLCJvcHRpb25zIiwic2hvcnRMaW5rTGVuZ3RoIiwiZG91YmxlTGlua1Rvb2xzIiwibG9uZ0xpbmtMZW5ndGgiLCJsaW5rVG9vbHNPZmZzZXQiLCJkb3VibGVMaW5rVG9vbHNPZmZzZXQiLCJzYW1wbGVJbnRlcnZhbCIsIl9sYWJlbENhY2hlIiwiX2xhYmVsU2VsZWN0b3JzIiwiX21hcmtlckNhY2hlIiwiX1YiLCJfZHJhZ0RhdGEiLCJtZXRyaWNzIiwiZGVjaW1hbHNSb3VuZGluZyIsImluaXRpYWxpemUiLCJhcmd1bWVudHMiLCJjbGVhbk5vZGVzQ2FjaGUiLCJwcmVzZW50YXRpb25BdHRyaWJ1dGVzIiwibWFya3VwIiwiYXR0cnMiLCJyb3V0ZXIiLCJjb25uZWN0b3IiLCJzbW9vdGgiLCJtYW5oYXR0YW4iLCJ0b29sTWFya3VwIiwibGFiZWxzIiwibGFiZWxNYXJrdXAiLCJ2ZXJ0aWNlcyIsInZlcnRleE1hcmt1cCIsInNvdXJjZSIsInRhcmdldCIsImluaXRGbGFnIiwiVVBEQVRFX1BSSU9SSVRZIiwiY29uZmlybVVwZGF0ZSIsImZsYWdzIiwib3B0IiwiaGFzRmxhZyIsInVwZGF0ZUVuZFByb3BlcnRpZXMiLCJyZW1vdmVGbGFnIiwicGFwZXIiLCJzb3VyY2VWaWV3IiwidGFyZ2V0VmlldyIsImlzVmlld01vdW50ZWQiLCJyZW5kZXIiLCJ1cGRhdGVIaWdobGlnaHRlcnMiLCJ1cGRhdGVUb29scyIsInJlbmRlclZlcnRleE1hcmtlcnMiLCJtb2RlbCIsImF0dHJpYnV0ZXMiLCJ1cGRhdGVMYWJlbHMiLCJ1cGRhdGVMZWdhY3lUb29scyIsIm9uTGFiZWxzQ2hhbmdlIiwicmVuZGVyVG9vbHMiLCJ1cGRhdGVBbGwiLCJ1cGRhdGVDb25uZWN0b3IiLCJ1cGRhdGVQYXRoIiwidXBkYXRlRE9NIiwidHJhbnNsYXRlQnkiLCJpc1JlbGF0aW9uc2hpcEVtYmVkZGVkSW4iLCJ0cmFuc2xhdGUiLCJ0eCIsInR5IiwidXBkYXRlIiwidXBkYXRlTGFiZWxQb3NpdGlvbnMiLCJ1cGRhdGVUb29sc1Bvc2l0aW9uIiwicmVxdWVzdENvbm5lY3Rpb25VcGRhdGUiLCJyZXF1ZXN0VXBkYXRlIiwiZ2V0RmxhZyIsImlzTGFiZWxzUmVuZGVyUmVxdWlyZWQiLCJwcmV2aW91c0xhYmVscyIsInByZXZpb3VzIiwicGF0aEFycmF5IiwicHJvcGVydHlQYXRoQXJyYXkiLCJwYXRoTGVuZ3RoIiwibGVuZ3RoIiwibGFiZWxFeGlzdHMiLCJPYmplY3QiLCJwcm9wZXJ0eVZhbHVlIiwiX2xpbmsiLCJfbGFiZWxzIiwicmVuZGVyTGFiZWxzIiwidmVsIiwiZW1wdHkiLCJ1bm1vdW50TGFiZWxzIiwicmVuZGVyTWFya3VwIiwibGluayIsImdldCIsIkVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwicmVuZGVySlNPTk1hcmt1cCIsInJlbmRlclN0cmluZ01hcmt1cCIsImRvYyIsInBhcnNlRE9NSlNPTiIsImVsIiwic2VsZWN0b3JzIiwiYXBwZW5kIiwiZnJhZ21lbnQiLCJjaGlsZHJlbiIsImNhY2hlIiwiaSIsIm4iLCJjaGlsZCIsImF0dHIiLCJjYW1lbENhc2UiLCJyZW5kZXJBcnJvd2hlYWRNYXJrZXJzIiwiX2dldExhYmVsTWFya3VwIiwidW5kZWZpbmVkIiwiX2dldExhYmVsU3RyaW5nTWFya3VwIiwiZG9jdW1lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiYXBwZW5kQ2hpbGQiLCJub2RlIiwiY3VycmVudENoaWxkIiwiX25vcm1hbGl6ZUxhYmVsTWFya3VwIiwiRG9jdW1lbnRGcmFnbWVudCIsImhhc0NoaWxkTm9kZXMiLCJ2Tm9kZSIsImNoaWxkTm9kZXMiLCJub2RlTmFtZSIsInRvVXBwZXJDYXNlIiwiYWRkQ2xhc3MiLCJ2TGFiZWxzIiwibGFiZWxDYWNoZSIsImxhYmVsU2VsZWN0b3JzIiwibGFiZWxzQ291bnQiLCJyZW1vdmUiLCJsYWJlbHNMYXllciIsImlkIiwibGFiZWwiLCJsYWJlbE5vZGUiLCJidWlsdGluRGVmYXVsdExhYmVsIiwiX2J1aWx0aW5zIiwiZGVmYXVsdExhYmVsIiwiYnVpbHRpbkRlZmF1bHRMYWJlbE1hcmt1cCIsIl9nZXREZWZhdWx0TGFiZWwiLCJkZWZhdWx0TGFiZWxNYXJrdXAiLCJkZWZhdWx0TWFya3VwIiwic2V0QXR0cmlidXRlIiwicm9vdFNlbGVjdG9yIiwic2VsZWN0b3IiLCJwYXJlbnQiLCJtb3VudExhYmVscyIsImhhc0xhYmVscyIsImdldExheWVyVmlldyIsImluc2VydFNvcnRlZE5vZGUiLCJwYXJlbnROb2RlIiwiZmluZExhYmVsTm9kZSIsImxhYmVsSW5kZXgiLCJsYWJlbFJvb3QiLCJmaW5kQnlTZWxlY3RvciIsIl9tZXJnZUxhYmVsQXR0cnMiLCJoYXNDdXN0b21NYXJrdXAiLCJsYWJlbEF0dHJzIiwiZGVmYXVsdExhYmVsQXR0cnMiLCJidWlsdGluRGVmYXVsdExhYmVsQXR0cnMiLCJfbWVyZ2VMYWJlbFNpemUiLCJsYWJlbFNpemUiLCJkZWZhdWx0TGFiZWxTaXplIiwiY2FuTGFiZWxNb3ZlIiwiY2FuIiwic2l6ZSIsInVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzIiwicm9vdEJCb3giLCJsaW5rVG9vbHMiLCIkdG9vbHMiLCJ0b29sVGVtcGxhdGUiLCJ0b29sIiwiX3Rvb2xDYWNoZSIsInRvb2wyIiwiZG91YmxlVG9vbE1hcmt1cCIsIl90b29sMkNhY2hlIiwibWFya2VyVmVydGljZXMiLCIkbWFya2VyVmVydGljZXMiLCJtYXJrdXBUZW1wbGF0ZSIsImZvckVhY2giLCJ2ZXJ0ZXgiLCJpZHgiLCJtYXJrZXJBcnJvd2hlYWRzIiwiJG1hcmtlckFycm93aGVhZHMiLCJhcnJvd2hlYWRNYXJrdXAiLCJzb3VyY2VBcnJvd2hlYWQiLCJlbmQiLCJ0YXJnZXRBcnJvd2hlYWQiLCJyZW1vdmVSZWR1bmRhbnRMaW5lYXJWZXJ0aWNlcyIsIlNJTVBMSUZZX1RIUkVTSE9MRCIsInJvdXRlUG9pbnRzIiwic291cmNlQW5jaG9yIiwidGFyZ2V0QW5jaG9yIiwibnVtUm91dGVQb2ludHMiLCJwb2x5bGluZSIsInNpbXBsaWZ5IiwidGhyZXNob2xkIiwicG9seWxpbmVQb2ludHMiLCJwb2ludHMiLCJtYXAiLCJwb2ludCIsInRvSlNPTiIsIm51bVBvbHlsaW5lUG9pbnRzIiwic2xpY2UiLCJ1cGRhdGVEZWZhdWx0Q29ubmVjdGlvblBhdGgiLCJjb25uZWN0aW9uIiwiZ2V0U2VyaWFsaXplZENvbm5lY3Rpb24iLCJjb25uZWN0aW9uV3JhcCIsIm1hcmtlclNvdXJjZSIsIm1hcmtlclRhcmdldCIsIl90cmFuc2xhdGVBbmRBdXRvT3JpZW50QXJyb3dzIiwiZ2V0RW5kVmlldyIsInR5cGUiLCJnZXRFbmRBbmNob3IiLCJnZXRFbmRDb25uZWN0aW9uUG9pbnQiLCJzb3VyY2VQb2ludCIsInRhcmdldFBvaW50IiwiZ2V0RW5kTWFnbmV0Iiwic291cmNlTWFnbmV0IiwidGFyZ2V0TWFnbmV0IiwidXBkYXRlUm91dGUiLCJyb3V0ZSIsInBhdGgiLCJfdHJhbnNsYXRlQ29ubmVjdGlvblBvaW50cyIsInVwZGF0ZUFycm93aGVhZE1hcmtlcnMiLCJwZXJwZW5kaWN1bGFyIiwiYW5jaG9ycyIsImZpbmRBbmNob3JzIiwiZmluZFJvdXRlIiwiY29ubmVjdGlvblBvaW50cyIsImZpbmRDb25uZWN0aW9uUG9pbnRzIiwibWFya2VyUG9pbnRzIiwiZmluZE1hcmtlclBvaW50cyIsImZpbmRQYXRoIiwiZmlyc3RXYXlwb2ludCIsImxhc3RXYXlwb2ludCIsInNvdXJjZU1hcmtlclBvaW50IiwidGFyZ2V0TWFya2VyUG9pbnQiLCJzb3VyY2VCQm94IiwiZ2V0QkJveCIsIm1vdmUiLCJ3aWR0aCIsInNjYWxlIiwic3giLCJyb3VuZCIsInRhcmdldEJCb3giLCJmaW5kQW5jaG9yc09yZGVyZWQiLCJmaXJzdEVuZFR5cGUiLCJmaXJzdFJlZiIsInNlY29uZEVuZFR5cGUiLCJzZWNvbmRSZWYiLCJmaXJzdEFuY2hvciIsInNlY29uZEFuY2hvciIsImZpcnN0QW5jaG9yUmVmIiwic2Vjb25kQW5jaG9yUmVmIiwiZmlyc3REZWYiLCJzZWNvbmREZWYiLCJmaXJzdFZpZXciLCJzZWNvbmRWaWV3IiwiZmlyc3RNYWduZXQiLCJzZWNvbmRNYWduZXQiLCJnZXRBbmNob3IiLCJhbmNob3IiLCJyZXMiLCJmaXJzdFZlcnRleCIsImxhc3RWZXJ0ZXgiLCJwcmlvcml0eSIsInNvdXJjZURlZiIsInRhcmdldERlZiIsInBhcGVyT3B0aW9ucyIsImlzTm9kZUNvbm5lY3Rpb24iLCJzb3VyY2VDb25uZWN0aW9uUG9pbnREZWYiLCJjb25uZWN0aW9uUG9pbnQiLCJkZWZhdWx0Q29ubmVjdGlvblBvaW50Iiwic291cmNlUG9pbnRSZWYiLCJzb3VyY2VMaW5lIiwiZ2V0Q29ubmVjdGlvblBvaW50IiwidGFyZ2V0Q29ubmVjdGlvblBvaW50RGVmIiwidGFyZ2V0UG9pbnRSZWYiLCJ0YXJnZXRMaW5lIiwiYW5jaG9yRGVmIiwiY2VsbFZpZXciLCJtYWduZXQiLCJyZWYiLCJlbmRUeXBlIiwiaXNDb25uZWN0aW9uIiwiZGVmYXVsdExpbmtBbmNob3IiLCJwZXJwZW5kaWN1bGFyTGlua3MiLCJuYW1lIiwiZGVmYXVsdEFuY2hvciIsImFuY2hvckZuIiwiYW5jaG9yTmFtZSIsImFuY2hvck5hbWVzcGFjZSIsImNhbGwiLCJhcmdzIiwiY29ubmVjdGlvblBvaW50RGVmIiwidmlldyIsImxpbmUiLCJsaW5rQ29ubmVjdGlvblBvaW50IiwibGlua0Nvbm5lY3Rpb25NYWduZXQiLCJzdGFydCIsImNvbm5lY3Rpb25Qb2ludEZuIiwiY29ubmVjdGlvblBvaW50TmFtZSIsImNvbm5lY3Rpb25Qb2ludE5hbWVzcGFjZSIsIm9mZnNldCIsIl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvblByb3BlcnR5IiwiYnVpbHRpbkRlZmF1bHRMYWJlbFBvc2l0aW9uIiwicG9zaXRpb24iLCJkZWZhdWx0TGFiZWxQb3NpdGlvbiIsIl9ub3JtYWxpemVMYWJlbFBvc2l0aW9uIiwibGFiZWxQb3NpdGlvbiIsImRpc3RhbmNlIiwiYW5nbGUiLCJfbWVyZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkiLCJub3JtYWxpemVkTGFiZWxQb3NpdGlvbiIsIm5vcm1hbGl6ZWREZWZhdWx0TGFiZWxQb3NpdGlvbiIsInRyYW5zZm9ybWF0aW9uTWF0cml4IiwiX2dldExhYmVsVHJhbnNmb3JtYXRpb25NYXRyaXgiLCJtYXRyaXhUb1RyYW5zZm9ybVN0cmluZyIsIl9jbGVhbkxhYmVsTWF0cmljZXMiLCJpbmRleCIsIm1hZ25ldE1hdHJpeCIsImNvbm5lY3Rpb25MZW5ndGgiLCJnZXRDb25uZWN0aW9uTGVuZ3RoIiwiTnVtYmVyIiwiaXNOYU4iLCJ0b29sUG9zaXRpb24iLCJnZXRQb2ludEF0TGVuZ3RoIiwieCIsInkiLCJjc3MiLCJlbmRWaWV3UHJvcGVydHkiLCJlbmREZWYiLCJlbmRJZCIsInVwZGF0ZUVuZE1hZ25ldCIsImVuZE1vZGVsIiwiZ2V0TW9kZWxCeUlkIiwiZW5kVmlldyIsImZpbmRWaWV3IiwiZW5kTWFnbmV0UHJvcGVydHkiLCJjb25uZWN0ZWRNYWduZXQiLCJnZXRNYWduZXRGcm9tTGlua0VuZCIsInNvdXJjZUFycm93IiwidGFyZ2V0QXJyb3ciLCJ0cmFuc2xhdGVBbmRBdXRvT3JpZW50IiwiY2VsbHMiLCJfZ2V0TGFiZWxQb3NpdGlvblByb3BlcnR5IiwiX2dldExhYmVsUG9zaXRpb25BbmdsZSIsIl9nZXRMYWJlbFBvc2l0aW9uQXJncyIsIl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MiLCJfbWVyZ2VMYWJlbFBvc2l0aW9uQXJncyIsImxhYmVsUG9zaXRpb25BcmdzIiwiZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzIiwiYWRkTGFiZWwiLCJwMSIsInAyIiwicDMiLCJwNCIsImxvY2FsWCIsImxvY2FsWSIsImxvY2FsQW5nbGUiLCJsb2NhbE9wdCIsInBvc2l0aW9uQXJncyIsImdldExhYmVsUG9zaXRpb24iLCJpbnNlcnRMYWJlbCIsImFkZFZlcnRleCIsImlzUG9pbnRQcm92aWRlZCIsImdldFZlcnRleEluZGV4IiwiaW5zZXJ0VmVydGV4Iiwic2VuZFRva2VuIiwidG9rZW4iLCJjYWxsYmFjayIsIm9uQW5pbWF0aW9uRW5kIiwidlRva2VuIiwiZHVyYXRpb24iLCJpc1JldmVyc2VkIiwiZGlyZWN0aW9uIiwiYW5pbWF0aW9uQXR0cmlidXRlcyIsImR1ciIsInJlcGVhdENvdW50IiwiY2FsY01vZGUiLCJmaWxsIiwia2V5UG9pbnRzIiwia2V5VGltZXMiLCJxdWVyeVNlbGVjdG9yIiwiU1ZHUGF0aEVsZW1lbnQiLCJhcHBlbmRUbyIsImFuaW1hdGVBbG9uZ1BhdGgiLCJzZXRUaW1lb3V0IiwibmFtZXNwYWNlIiwicm91dGVyTmFtZXNwYWNlIiwiZGVmYXVsdFJvdXRlciIsInJvdXRlckZuIiwiY29ubmVjdG9yTmFtZXNwYWNlIiwiZGVmYXVsdENvbm5lY3RvciIsImNvbm5lY3RvckZuIiwicmF3Iiwibm9ybWFsaXplUGF0aERhdGEiLCJnZXRDb25uZWN0aW9uIiwiaGFzT3duUHJvcGVydHkiLCJkYXRhIiwic2VyaWFsaXplIiwiZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucyIsInNlZ21lbnRTdWJkaXZpc2lvbnMiLCJzdWJkaXZpc2lvbnMiLCJnZXRTZWdtZW50U3ViZGl2aXNpb25zIiwicG9pbnRBdExlbmd0aCIsImdldFBvaW50QXRSYXRpbyIsInJhdGlvIiwicGFyc2VGbG9hdCIsInBvaW50QXQiLCJnZXRUYW5nZW50QXRMZW5ndGgiLCJ0YW5nZW50QXRMZW5ndGgiLCJnZXRUYW5nZW50QXRSYXRpbyIsInRhbmdlbnRBdCIsImdldENsb3Nlc3RQb2ludCIsImNsb3Nlc3RQb2ludCIsImdldENsb3Nlc3RQb2ludExlbmd0aCIsImNsb3Nlc3RQb2ludExlbmd0aCIsImdldENsb3Nlc3RQb2ludFJhdGlvIiwiY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aCIsImlzRGlzdGFuY2VSZWxhdGl2ZSIsImFic29sdXRlRGlzdGFuY2UiLCJpc0Rpc3RhbmNlQWJzb2x1dGVSZXZlcnNlIiwicmV2ZXJzZURpc3RhbmNlIiwiaXNPZmZzZXRBYnNvbHV0ZSIsImFic29sdXRlT2Zmc2V0IiwicGF0aE9wdCIsImxhYmVsUG9pbnQiLCJ0IiwiY2xvc2VzdFBvaW50VCIsImxhYmVsRGlzdGFuY2UiLCJsZW5ndGhBdFQiLCJ0YW5nZW50IiwidGFuZ2VudEF0VCIsImxhYmVsT2Zmc2V0IiwicG9pbnRPZmZzZXQiLCJwb2ludEF0VCIsImxhYmVsT2Zmc2V0RGlmZiIsImRpZmZlcmVuY2UiLCJsYWJlbEFuZ2xlIiwibGFiZWxPZmZzZXRDb29yZGluYXRlcyIsInBvc2l0aW9uT2Zmc2V0IiwiaXNLZWVwR3JhZGllbnQiLCJrZWVwR3JhZGllbnQiLCJpc0Vuc3VyZUxlZ2liaWxpdHkiLCJlbnN1cmVMZWdpYmlsaXR5IiwidHJhbnNsYXRpb24iLCJub3JtYWwiLCJyb3RhdGUiLCJzZXRMZW5ndGgiLCJjcmVhdGVTVkdNYXRyaXgiLCJnZXRMYWJlbENvb3JkaW5hdGVzIiwiZSIsImYiLCJ2ZXJ0ZXhMZW5ndGgiLCJjdXJyZW50VmVydGV4IiwiY3VycmVudFZlcnRleExlbmd0aCIsIm5vdGlmeVBvaW50ZXJkb3duIiwiZXZ0IiwicG9pbnRlcmRvd24iLCJub3RpZnkiLCJub3RpZnlQb2ludGVybW92ZSIsInBvaW50ZXJtb3ZlIiwibm90aWZ5UG9pbnRlcnVwIiwicG9pbnRlcnVwIiwicG9pbnRlcmRibGNsaWNrIiwicG9pbnRlcmNsaWNrIiwiY29udGV4dG1lbnUiLCJnZXRBdHRyaWJ1dGUiLCJkcmFnVmVydGV4U3RhcnQiLCJkcmFnVmVydGV4UmVtb3ZlU3RhcnQiLCJkcmFnQXJyb3doZWFkU3RhcnQiLCJkcmFnQ29ubmVjdGlvblN0YXJ0IiwiZHJhZ1N0YXJ0IiwiZHJhZ0RhdGEiLCJldmVudERhdGEiLCJhY3Rpb24iLCJkcmFnVmVydGV4IiwiZHJhZ0xhYmVsIiwiZHJhZ0Fycm93aGVhZCIsImRyYWciLCJkcmFnVmVydGV4RW5kIiwiZHJhZ0xhYmVsRW5kIiwiZHJhZ0Fycm93aGVhZEVuZCIsImRyYWdFbmQiLCJjaGVja01vdXNlbGVhdmUiLCJtb3VzZW92ZXIiLCJtb3VzZW91dCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwibW91c2V3aGVlbCIsImRlbHRhIiwib25ldmVudCIsImV2ZW50TmFtZSIsImxpbmtUb29sIiwiZmluZFBhcmVudEJ5Q2xhc3MiLCJzdG9wUHJvcGFnYXRpb24iLCJ1aSIsImRlbGVnYXRlRHJhZ0V2ZW50cyIsIm9ubGFiZWwiLCJkcmFnTGFiZWxTdGFydCIsInZlcnRleElkeCIsImlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkIiwiY3VycmVudFRhcmdldCIsImxhYmVsSWR4IiwicGFyc2VJbnQiLCJpbml0aWFsTGFiZWxQb3NpdGlvbiIsImNvb3JkcyIsImR4IiwiZHkiLCJwb3NpdGlvbkFuZ2xlIiwidmVydGV4Tm9kZSIsInJlbW92ZU5vZGUiLCJyZW1vdmVWZXJ0ZXgiLCJhcnJvd2hlYWROb2RlIiwiYXJyb3doZWFkVHlwZSIsInN0YXJ0QXJyb3doZWFkTW92ZSIsImlnbm9yZUJhY2t3YXJkc0NvbXBhdGliaWxpdHkiLCJzbmFwTGFiZWxzIiwic2V0T3B0aW9ucyIsImlzQXN5bmMiLCJhc3luYyIsInNuYXBMaW5rcyIsImlzU25hcHBlZCIsIl9zbmFwQXJyb3doZWFkIiwic25hcExpbmtzU2VsZiIsIl9zbmFwQXJyb3doZWFkU2VsZiIsIl9jb25uZWN0QXJyb3doZWFkIiwiZ2V0RXZlbnRUYXJnZXQiLCJfc25hcEFycm93aGVhZEVuZCIsIl9jb25uZWN0QXJyb3doZWFkRW5kIiwibGlua0FsbG93ZWQiLCJfZGlzYWxsb3ciLCJfZmluaXNoRW1iZWRkaW5nIiwiX25vdGlmeUNvbm5lY3RFdmVudCIsIl9hZnRlckFycm93aGVhZE1vdmUiLCJ3aGVuTm90QWxsb3dlZCIsInNldCIsImFycm93aGVhZCIsImluaXRpYWxFbmQiLCJlbWJlZGRpbmdNb2RlIiwicmVwYXJlbnQiLCJ6IiwiY3VycmVudEVuZCIsInByb3AiLCJlbmRDaGFuZ2VkIiwiZW5kc0VxdWFsIiwiZmluZFZpZXdCeU1vZGVsIiwiaW5pdGlhbE1hZ25ldCIsIm1hZ25ldFVuZGVyUG9pbnRlciIsIl9zbmFwVG9Qb2ludHMiLCJzbmFwUG9pbnQiLCJyYWRpdXMiLCJjbG9zZXN0UG9pbnRYIiwiY2xvc2VzdERpc3RhbmNlWCIsIkluZmluaXR5IiwiY2xvc2VzdFBvaW50WSIsImNsb3Nlc3REaXN0YW5jZVkiLCJkaXN0WCIsIk1hdGgiLCJhYnMiLCJkaXN0WSIsImxvY2FsVG9DbGllbnRQb2ludCIsImVsZW1lbnRGcm9tUG9pbnQiLCJjb25uZWN0aW9uU3RyYXRlZ3kiLCJyIiwidmlld3NJbkFyZWEiLCJmaW5kVmlld3NJbkFyZWEiLCJoZWlnaHQiLCJwcmV2Q2xvc2VzdFZpZXciLCJjbG9zZXN0VmlldyIsInByZXZDbG9zZXN0TWFnbmV0IiwiY2xvc2VzdE1hZ25ldCIsInByZXZNYWduZXRQcm94eSIsIm1hZ25ldFByb3h5IiwibWluRGlzdGFuY2UiLCJNQVhfVkFMVUUiLCJwb2ludGVyIiwiY2FuZGlkYXRlcyIsImJib3giLCJnZXROb2RlQkJveCIsImNhbmRpZGF0ZSIsImNlbnRlciIsInNxdWFyZWREaXN0YW5jZSIsImlzQWxyZWFkeVZhbGlkYXRlZCIsInZhbGlkYXRlQ29ubmVjdGlvbiIsInZhbGlkYXRlQ29ubmVjdGlvbkFyZ3MiLCJmaW5kUHJveHlOb2RlIiwibmV3Q2xvc2VzdE1hZ25ldCIsInVuaGlnaGxpZ2h0IiwiY29ubmVjdGluZyIsInNuYXBwaW5nIiwicHJldkVuZCIsInByZXZYIiwicHJldlkiLCJnZXRMaW5rRW5kIiwiaGlnaGxpZ2h0IiwiZmluZE1hZ25ldCIsImV2ZW50VGFyZ2V0Iiwidmlld1VuZGVyUG9pbnRlciIsIl9iZWZvcmVBcnJvd2hlYWRNb3ZlIiwidG9Gcm9udCIsInN0eWxlIiwicG9pbnRlckV2ZW50cyIsIm1hcmtBdmFpbGFibGUiLCJfbWFya0F2YWlsYWJsZU1hZ25ldHMiLCJfdW5tYXJrQXZhaWxhYmxlTWFnbmV0cyIsIl9jcmVhdGVWYWxpZGF0ZUNvbm5lY3Rpb25BcmdzIiwib3Bwb3NpdGVBcnJvd2hlYWQiLCJqIiwiaXNNYWduZXRBdmFpbGFibGUiLCJ2YWxpZGF0ZSIsImVsZW1lbnRzIiwiZ2V0Q2VsbHMiLCJtYXJrZWQiLCJtYWduZXRzIiwicXVlcnlTZWxlY3RvckFsbCIsImF2YWlsYWJsZU1hZ25ldHMiLCJmaWx0ZXIiLCJiaW5kIiwibSIsIm1hZ25ldEF2YWlsYWJpbGl0eSIsImVsZW1lbnRBdmFpbGFiaWxpdHkiLCJtYXJrZWRLZXlzIiwia2V5cyIsIm1hcmtlZE1hZ25ldHMiLCJvbk1vdW50Iiwib25EZXRhY2giLCJvblJlbW92ZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/LinkView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/Paper.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/dia/Paper.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paper: () => (/* binding */ Paper)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/jointjs/src/mvc/View.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/CellView.mjs\");\n/* harmony import */ var _ElementView_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ElementView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/ElementView.mjs\");\n/* harmony import */ var _LinkView_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LinkView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/LinkView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Link.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Link.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\");\n/* harmony import */ var _Graph_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Graph.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Graph.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../highlighters/index.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/index.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(ssr)/./node_modules/jointjs/src/linkAnchors/index.mjs\");\n/* harmony import */ var _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../connectionPoints/index.mjs */ \"(ssr)/./node_modules/jointjs/src/connectionPoints/index.mjs\");\n/* harmony import */ var _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../anchors/index.mjs */ \"(ssr)/./node_modules/jointjs/src/anchors/index.mjs\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! backbone */ \"(ssr)/./node_modules/backbone/backbone.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst sortingTypes = {\n    NONE: \"sorting-none\",\n    APPROX: \"sorting-approximate\",\n    EXACT: \"sorting-exact\"\n};\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\nconst HighlightingTypes = _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView.Highlighting;\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: \"stroke\",\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: \"addClass\",\n        options: {\n            className: \"available-magnet\"\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: \"addClass\",\n        options: {\n            className: \"available-cell\"\n        }\n    }\n};\nconst defaultLayers = [\n    {\n        name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.BACK\n    },\n    {\n        name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.CELLS\n    },\n    {\n        name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.LABELS\n    },\n    {\n        name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.FRONT\n    },\n    {\n        name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.TOOLS\n    }\n];\nconst Paper = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.View.extend({\n    className: \"paper\",\n    options: {\n        width: 800,\n        height: 600,\n        origin: {\n            x: 0,\n            y: 0\n        },\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n        perpendicularLinks: false,\n        elementView: _ElementView_mjs__WEBPACK_IMPORTED_MODULE_5__.ElementView,\n        linkView: _LinkView_mjs__WEBPACK_IMPORTED_MODULE_6__.LinkView,\n        snapLabels: false,\n        snapLinks: false,\n        snapLinksSelf: false,\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n        highlighting: defaultHighlighting,\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the Backbone.model or a function returning the Backbone.model\n        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n        defaultLink: new _Link_mjs__WEBPACK_IMPORTED_MODULE_7__.Link,\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: {\n            name: \"normal\"\n        },\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: {\n            name: \"normal\"\n        },\n        defaultAnchor: {\n            name: \"center\"\n        },\n        defaultLinkAnchor: {\n            name: \"connectionRatio\"\n        },\n        defaultConnectionPoint: {\n            name: \"bbox\"\n        },\n        /* CONNECTING */ connectionStrategy: null,\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute(\"magnet\") !== \"passive\";\n        },\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === \"target\" ? cellViewT : cellViewS) instanceof _ElementView_mjs__WEBPACK_IMPORTED_MODULE_5__.ElementView;\n        },\n        /* EMBEDDING */ // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: \"bbox\",\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n        // Rendering Options\n        sorting: sortingTypes.EXACT,\n        frozen: false,\n        autoFreeze: false,\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n        beforeRender: null,\n        afterRender: null,\n        viewport: null,\n        // Default namespaces\n        cellViewNamespace: null,\n        routerNamespace: null,\n        connectorNamespace: null,\n        highlighterNamespace: _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_8__,\n        anchorNamespace: _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_9__,\n        linkAnchorNamespace: _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_10__,\n        connectionPointNamespace: _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_11__,\n        overflow: false\n    },\n    events: {\n        \"dblclick\": \"pointerdblclick\",\n        \"dbltap\": \"pointerdblclick\",\n        \"contextmenu\": \"contextmenu\",\n        \"mousedown\": \"pointerdown\",\n        \"touchstart\": \"pointerdown\",\n        \"mouseover\": \"mouseover\",\n        \"mouseout\": \"mouseout\",\n        \"mouseenter\": \"mouseenter\",\n        \"mouseleave\": \"mouseleave\",\n        \"wheel\": \"mousewheel\",\n        \"mouseenter .joint-cell\": \"mouseenter\",\n        \"mouseleave .joint-cell\": \"mouseleave\",\n        \"mouseenter .joint-tools\": \"mouseenter\",\n        \"mouseleave .joint-tools\": \"mouseleave\",\n        \"dblclick .joint-cell [magnet]\": \"magnetpointerdblclick\",\n        \"contextmenu .joint-cell [magnet]\": \"magnetcontextmenu\",\n        \"mousedown .joint-link .label\": \"onlabel\",\n        \"touchstart .joint-link .label\": \"onlabel\",\n        \"dragstart .joint-cell image\": \"onImageDragStart\" // firefox fix\n    },\n    documentEvents: {\n        \"mousemove\": \"pointermove\",\n        \"touchmove\": \"pointermove\",\n        \"mouseup\": \"pointerup\",\n        \"touchend\": \"pointerup\",\n        \"touchcancel\": \"pointerup\"\n    },\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    $background: null,\n    layers: null,\n    $grid: null,\n    $document: null,\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n    SORT_DELAYING_BATCHES: [\n        \"add\",\n        \"to-front\",\n        \"to-back\"\n    ],\n    UPDATE_DELAYING_BATCHES: [\n        \"translate\"\n    ],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: [\n        \"TEXTAREA\",\n        \"INPUT\",\n        \"BUTTON\",\n        \"SELECT\",\n        \"OPTION\"\n    ],\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        \"SELECT\"\n    ],\n    MIN_SCALE: 1e-6,\n    init: function() {\n        const { options, el } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */ options.cellViewNamespace = typeof joint !== \"undefined\" && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.has)(joint, \"shapes\") ? joint.shapes : null;\n        /* eslint-enable no-undef */ }\n        const model = this.model = options.model || new _Graph_mjs__WEBPACK_IMPORTED_MODULE_13__.Graph;\n        // Layers (SVGGroups)\n        this._layers = {};\n        this.setGrid(options.drawGrid);\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n        // Hash of all cell views.\n        this._views = {};\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: []\n        };\n        // Reference to the paper owner document\n        this.$document = jquery__WEBPACK_IMPORTED_MODULE_0__(el.ownerDocument);\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n    _resetUpdates: function() {\n        return this._updates = {\n            id: null,\n            priorities: [\n                {},\n                {},\n                {}\n            ],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, \"add\", this.onCellAdded).listenTo(model, \"remove\", this.onCellRemoved).listenTo(model, \"change\", this.onCellChange).listenTo(model, \"reset\", this.onGraphReset).listenTo(model, \"sort\", this.onGraphSort).listenTo(model, \"batch:stop\", this.onGraphBatchStop);\n        this.on(\"cell:highlight\", this.onCellHighlight).on(\"cell:unhighlight\", this.onCellUnhighlight).on(\"scale translate\", this.update);\n    },\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({\n                key: \"addCells\"\n            });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({\n                key: \"addCells\"\n            });\n        }\n    },\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged(\"z\") && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n    cloneOptions: function() {\n        const { options } = this;\n        const { defaultConnector, defaultRouter, defaultConnectionPoint, defaultAnchor, defaultLinkAnchor, origin, highlighting, cellViewNamespace, interactive } = options;\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */ if (!cellViewNamespace && typeof joint !== \"undefined\" && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.has)(joint, \"shapes\")) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */ // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(defaultConnector)) {\n            options.defaultConnector = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(defaultConnector);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(defaultRouter)) {\n            options.defaultRouter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(defaultRouter);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(defaultConnectionPoint);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(defaultAnchor)) {\n            options.defaultAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(defaultAnchor);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(defaultLinkAnchor);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isPlainObject)(interactive)) {\n            options.interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({}, interactive);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isPlainObject)(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaultsDeep)({}, highlighting, defaultHighlighting);\n        }\n        options.origin = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({}, origin);\n    },\n    children: function() {\n        var ns = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].namespace;\n        return [\n            {\n                namespaceURI: ns.xhtml,\n                tagName: \"div\",\n                className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.addClassNamePrefix)(\"paper-background\"),\n                selector: \"background\"\n            },\n            {\n                namespaceURI: ns.xhtml,\n                tagName: \"div\",\n                className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.addClassNamePrefix)(\"paper-grid\"),\n                selector: \"grid\"\n            },\n            {\n                namespaceURI: ns.svg,\n                tagName: \"svg\",\n                attributes: {\n                    \"width\": \"100%\",\n                    \"height\": \"100%\",\n                    \"xmlns:xlink\": ns.xlink\n                },\n                selector: \"svg\",\n                children: [\n                    {\n                        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                        tagName: \"defs\",\n                        selector: \"defs\"\n                    },\n                    {\n                        tagName: \"g\",\n                        className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.addClassNamePrefix)(\"layers\"),\n                        selector: \"layers\"\n                    }\n                ]\n            }\n        ];\n    },\n    hasLayerView (layerName) {\n        return layerName in this._layers;\n    },\n    getLayerView (layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n    getLayerNode (layerName) {\n        return this.getLayerView(layerName).el;\n    },\n    render: function() {\n        this.renderChildren();\n        const { childNodes, options } = this;\n        const { svg, defs, layers, background, grid } = childNodes;\n        svg.style.overflow = options.overflow ? \"visible\" : \"hidden\";\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n        this.$background = jquery__WEBPACK_IMPORTED_MODULE_0__(background);\n        this.$grid = jquery__WEBPACK_IMPORTED_MODULE_0__(grid);\n        this.renderLayers();\n        _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].ensureId(svg);\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n        if (options.drawGrid) {\n            this.drawGrid();\n        }\n        return this;\n    },\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted })=>{\n            const layerView = new _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.PaperLayer({\n                name\n            });\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.addClassNamePrefix)(\"viewport\"));\n        labelsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.addClassNamePrefix)(\"viewport\"));\n    },\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach((name)=>{\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach((name)=>{\n            _layers[name].removePivots();\n        });\n    },\n    update: function() {\n        if (this.options.drawGrid) {\n            this.drawGrid();\n        }\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n        return this;\n    },\n    matrix: function(ctm) {\n        var viewport = this.layers;\n        // Getter:\n        if (ctm === undefined) {\n            var transformString = viewport.getAttribute(\"transform\");\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].createSVGMatrix(ctm);\n        }\n        // Setter:\n        ctm = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].createSVGMatrix(ctm);\n        var ctmString = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].matrixToTransformString(ctm);\n        viewport.setAttribute(\"transform\", ctmString);\n        this._viewportMatrix = ctm;\n        this._viewportTransformString = viewport.getAttribute(\"transform\");\n        return this;\n    },\n    clientMatrix: function() {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].createSVGMatrix(this.cells.getScreenCTM());\n    },\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for(var j = 0, n = links.length; j < n; j++){\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = [\n                    \"UPDATE\"\n                ];\n                if (link.getTargetCell() === model) flagLabels.push(\"TARGET\");\n                if (link.getSourceCell() === model) flagLabels.push(\"SOURCE\");\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag([\n            \"SOURCE\",\n            \"TARGET\"\n        ])) === 0) {\n            var dumpOptions = {\n                silent: true\n            };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet(\"source\");\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet(\"target\");\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || isAsync && opt.async !== false) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for(let i = priority - 1; i >= UPDATE_PRIORITY; i--){\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === \"function\") viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = {\n                updated: 1,\n                priority: view.UPDATE_PRIORITY\n            };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return cid in updates.mounted;\n    },\n    dumpViews: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)({}, opt, {\n            viewport: null\n        });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        }while (!batchStats.empty);\n        const stats = {\n            updated: updateCount,\n            batches: batchCount,\n            priority\n        };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while(i > 0 && i--){\n            // a faster way how to check if an object is empty\n            for(let _key in priorities[priorityIndexes[i]])return true;\n        }\n        return false;\n    },\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = {\n            processed: 0,\n            priority: MIN_PRIORITY\n        });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.cancelFrame)(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger(\"render:idle\", opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === \"function\") {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error(\"dia.Paper: can not unfreeze the paper after it was removed\");\n        }\n        updates.id = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.nextFrame)(this.updateViewsAsync, this, opt, data);\n    },\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== \"function\") {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== \"function\") return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== \"function\") {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === \"function\") {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger(\"render:done\", stats, opt);\n    },\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = \"viewport\" in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== \"function\") viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== \"function\") postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for(var i = 0, n = priorityIndexes.length; i < n; i++){\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for(var cid in priorityUpdates){\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for(var i = 0; i < n; i++){\n            unmountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for(var i = 0; i < n; i++){\n            mountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== \"function\") viewportFn = null;\n        var batchSize = \"mountBatchSize\" in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for(var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++){\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n                mounting: true\n            });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== \"function\") return unmountCount;\n        var batchSize = \"unmountBatchSize\" in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for(var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++){\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_4__.views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = \"viewport\" in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== \"function\") viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n        let isUnmounted = false;\n        let isMounted = false;\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n                mounting: true\n            });\n            isMounted = true;\n        }\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n    checkViewport: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = \"viewport\" in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey) {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.cancelFrame)(id);\n    },\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n    isAsync: function() {\n        return !!this.options.async;\n    },\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n    onRemove: function() {\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n    getComputedSize: function() {\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(w)) w = this.el.clientWidth;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(h)) h = this.el.clientHeight;\n        return {\n            width: w,\n            height: h\n        };\n    },\n    setDimensions: function(width, height) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = width === undefined ? currentWidth : width;\n        let h = height === undefined ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger(\"resize\", computedSize.width, computedSize.height);\n    },\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(w)) w = Math.round(w);\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(h)) h = Math.round(h);\n        this.$el.css({\n            width: w === null ? \"\" : w,\n            height: h === null ? \"\" : h\n        });\n    },\n    setOrigin: function(ox, oy) {\n        return this.translate(ox || 0, oy || 0);\n    },\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({\n                gridWidth,\n                gridHeight,\n                padding\n            }, opt);\n        }\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n        this.setOrigin(-x * sx, -y * sy);\n        this.setDimensions(width * sx, height * sy);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n    },\n    getFitToContentArea: function(opt = {}) {\n        // Calculate the paper size to accommodate all the graph's elements.\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeSides)(opt.padding || 0);\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n        const area = \"contentArea\" in opt ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n        let tx = 0;\n        if (newOrigin === \"negative\" && area.x < 0 || newOrigin === \"positive\" && area.x >= 0 || newOrigin === \"any\") {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n        let ty = 0;\n        if (newOrigin === \"negative\" && area.y < 0 || newOrigin === \"positive\" && area.y >= 0 || newOrigin === \"any\") {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n        let contentBBox, contentLocalOrigin;\n        if (\"contentArea\" in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n        if (!contentBBox.width || !contentBBox.height) return;\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: \"top\",\n            horizontalAlign: \"left\"\n        });\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeSides)(opt.padding);\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n        fittingBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n        const currentScale = this.scale();\n        let newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n        let newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n            const gridSize = opt.scaleGrid;\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n        const scaleDiff = {\n            x: newSx / currentScale.sx,\n            y: newSy / currentScale.sy\n        };\n        const origin = this.options.origin;\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n        switch(opt.verticalAlign){\n            case \"middle\":\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case \"bottom\":\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case \"top\":\n            default:\n                break;\n        }\n        switch(opt.horizontalAlign){\n            case \"middle\":\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case \"right\":\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case \"left\":\n            default:\n                break;\n        }\n        this.scale(newSx, newSy);\n        this.translate(newOx, newOy);\n    },\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect();\n        }\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(this.cells).getBBox();\n    },\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n    getRestrictedArea: function(...args) {\n        const { restrictTranslate } = this.options;\n        let restrictedArea;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(restrictTranslate);\n        }\n        return restrictedArea;\n    },\n    createViewForModel: function(cell) {\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get(\"type\") + \"View\";\n        var namespaceViewClass = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.getByPath)(namespace, type, \".\");\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = _LinkView_mjs__WEBPACK_IMPORTED_MODULE_6__.LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = _ElementView_mjs__WEBPACK_IMPORTED_MODULE_5__.ElementView;\n        }\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = optionalViewClass.prototype instanceof backbone__WEBPACK_IMPORTED_MODULE_1__.View ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.LABELS : options.labelsLayer\n        });\n    },\n    removeView: function(cell) {\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n    renderView: function(cell, opt) {\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.result)(view, \"initFlag\"));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n        return false;\n    },\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : \"reset\";\n        this.freeze({\n            key\n        });\n        for(var i = 0, n = cells.length; i < n; i++){\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({\n            key\n        });\n        this.sortViews();\n    },\n    removeViews: function() {\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.invoke)(this._views, \"remove\");\n        this._views = {};\n    },\n    sortViews: function() {\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n    sortViewsExact: function() {\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n        var $cells = jquery__WEBPACK_IMPORTED_MODULE_0__(this.cells).children(\"[model-id]\");\n        var cells = this.model.get(\"cells\");\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.sortElements)($cells, function(a, b) {\n            var cellA = cells.get(a.getAttribute(\"model-id\"));\n            var cellB = cells.get(b.getAttribute(\"model-id\"));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return zA === zB ? 0 : zA < zB ? -1 : 1;\n        });\n    },\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames.CELLS);\n        const { el, model } = view;\n        switch(this.options.sorting){\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get(\"z\"));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n    detachView (view) {\n        view.unmount();\n        view.onDetach();\n    },\n    scale: function(sx, sy, ox, oy) {\n        // getter\n        if (sx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].matrixToScale(this.matrix());\n        }\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        if (ox === undefined) {\n            ox = 0;\n            oy = 0;\n        }\n        var translate = this.translate();\n        if (ox || oy || translate.tx || translate.ty) {\n            var newTx = translate.tx - ox * (sx - 1);\n            var newTy = translate.ty - oy * (sy - 1);\n            this.translate(newTx, newTy);\n        }\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n        var ctm = this.matrix();\n        ctm.a = sx;\n        ctm.d = sy;\n        this.matrix(ctm);\n        this.trigger(\"scale\", sx, sy, ox, oy);\n        return this;\n    },\n    // Experimental - do not use in production.\n    rotate: function(angle, cx, cy) {\n        // getter\n        if (angle === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].matrixToRotate(this.matrix());\n        }\n        // setter\n        // If the origin is not set explicitely, rotate around the center. Note that\n        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n        // the real bounding box (`bbox()`) including transformations).\n        if (cx === undefined) {\n            var bbox = this.cells.getBBox();\n            cx = bbox.width / 2;\n            cy = bbox.height / 2;\n        }\n        var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        this.matrix(ctm);\n        return this;\n    },\n    translate: function(tx, ty) {\n        // getter\n        if (tx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].matrixToTranslate(this.matrix());\n        }\n        const { options } = this;\n        const { origin, drawGrid } = options;\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n        const ctm = this.matrix();\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n        this.matrix(ctm);\n        const { tx: ox, ty: oy } = this.translate();\n        origin.x = ox;\n        origin.y = oy;\n        this.trigger(\"translate\", ox, oy);\n        if (drawGrid) {\n            this.drawGrid();\n        }\n        return this;\n    },\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n        var el = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isString)($el) ? this.cells.querySelector($el) : $el instanceof jquery__WEBPACK_IMPORTED_MODULE_0__ ? $el[0] : $el;\n        var id = this.findAttribute(\"model-id\", el);\n        if (id) return this._views[id];\n        return undefined;\n    },\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n        var id = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(cell) ? cell : cell && cell.id;\n        return this._views[id];\n    },\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n        p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(p);\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({\n                target: this.cells\n            }).containsPoint(p);\n        }, this);\n    },\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n        opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)(opt || {}, {\n            strict: false\n        });\n        rect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(rect);\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? \"containsRect\" : \"intersect\";\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({\n                target: this.cells\n            }));\n        }, this);\n    },\n    removeTools: function() {\n        this.dispatchToolsEvent(\"remove\");\n        return this;\n    },\n    hideTools: function() {\n        this.dispatchToolsEvent(\"hide\");\n        return this;\n    },\n    showTools: function() {\n        this.dispatchToolsEvent(\"show\");\n        return this;\n    },\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== \"string\") return;\n        this.trigger(\"tools:event\", event, ...args);\n    },\n    getModelById: function(id) {\n        return this.model.getCell(id);\n    },\n    snapToGrid: function(x, y) {\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(x, y);\n        var paperPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n        var paperRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(x, y);\n        var clientPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n        var clientRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"].transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n    localToPagePoint: function(x, y) {\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n    localToPageRect: function(x, y, width, height) {\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n    pageToLocalPoint: function(x, y) {\n        var pagePoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n    pageToLocalRect: function(x, y, width, height) {\n        var pageOffset = this.pageOffset();\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n    clientOffset: function() {\n        var clientRect = this.svg.getBoundingClientRect();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_17__.Point(clientRect.left, clientRect.top);\n    },\n    pageOffset: function() {\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n    linkAllowed: function(linkView) {\n        if (!(linkView instanceof _LinkView_mjs__WEBPACK_IMPORTED_MODULE_6__.LinkView)) {\n            throw new Error(\"Must provide a linkView.\");\n        }\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n        if (typeof paperOptions.allowLink === \"function\") {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n        return true;\n    },\n    getDefaultLink: function(cellView, magnet) {\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone();\n    },\n    // Cell highlighting.\n    // ------------------\n    resolveHighlighter: function(opt = {}) {\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting, highlighterNamespace } = this.options;\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */ if (highlighterDef === undefined) {\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting[\"default\"];\n            }\n        }\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n        // Allow specifying a highlighter by name.\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isString)(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== \"function\") {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== \"function\") {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n    // Interaction.\n    // ------------\n    pointerdblclick: function(evt) {\n        evt.preventDefault();\n        // magnetpointerdblclick can stop propagation\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger(\"blank:pointerdblclick\", evt, localPoint.x, localPoint.y);\n        }\n    },\n    pointerclick: function(evt) {\n        // magnetpointerclick can stop propagation\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n            evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n            } else {\n                this.trigger(\"blank:pointerclick\", evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n    contextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        this.contextMenuTrigger(evt);\n    },\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger(\"blank:contextmenu\", evt, localPoint.x, localPoint.y);\n        }\n    },\n    pointerdown: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = button === 2;\n        if (view) {\n            if (!isContextMenu && this.guard(evt, view)) return;\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n            // Custom event\n            const eventEvt = this.customEventTrigger(evt, view);\n            if (eventEvt) {\n                // `onevent` could have stopped propagation\n                if (eventEvt.isPropagationStopped()) return;\n                evt.data = eventEvt.data;\n            }\n            // Element magnet\n            const magnetNode = target.closest(\"[magnet]\");\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(jquery__WEBPACK_IMPORTED_MODULE_0__.Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = jquery__WEBPACK_IMPORTED_MODULE_0__.Event(evt.originalEvent, {\n                type: \"contextmenu\",\n                data: evt.data\n            });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger(\"blank:pointerdown\", evt, localPoint.x, localPoint.y);\n            }\n            this.delegateDragEvents(view, evt.data);\n        }\n    },\n    pointermove: function(evt) {\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n        // Note: the events are undelegated after the first `pointermove` event.\n        // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n        var mousemoved = ++data.mousemoved;\n        if (mousemoved <= this.options.moveThreshold) return;\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger(\"blank:pointermove\", evt, localPoint.x, localPoint.y);\n        }\n        this.eventData(evt, data);\n    },\n    pointerup: function(evt) {\n        this.undelegateDocumentEvents();\n        var normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger(\"blank:pointerup\", normalizedEvt, localPoint.x, localPoint.y);\n        }\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick(jquery__WEBPACK_IMPORTED_MODULE_0__.Event(evt.originalEvent, {\n                type: \"click\",\n                data: evt.data\n            }));\n        }\n        this.delegateEvents();\n    },\n    mouseover: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n        if (view) {\n            view.mouseover(evt);\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger(\"blank:mouseover\", evt);\n        }\n    },\n    mouseout: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n        if (view) {\n            view.mouseout(evt);\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger(\"blank:mouseout\", evt);\n        }\n    },\n    mouseenter: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered\n         } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger(\"paper:mouseenter\", evt);\n        }\n    },\n    mouseleave: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered\n         } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger(\"paper:mouseleave\", evt);\n        }\n    },\n    _processMouseWheelEvtBuf: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.debounce)(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY)=>acc + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.cap)(deltaY, WHEEL_CAP), 0);\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger(\"paper:pinch\", event, x, y, scale);\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: []\n        };\n    }, WHEEL_WAIT_MS, {\n        maxWait: WHEEL_WAIT_MS\n    }),\n    mousewheel: function(evt) {\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeWheel)(originalEvent);\n        const pinchHandlers = this._events[\"paper:pinch\"];\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = originalEvent;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n            } else {\n                this.trigger(\"blank:mousewheel\", evt, localPoint.x, localPoint.y, delta);\n            }\n            this.trigger(\"paper:pan\", evt, deltaX, deltaY);\n        }\n    },\n    onevent: function(evt) {\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute(\"event\");\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n    magnetEvent: function(evt, handler) {\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute(\"magnet\");\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n    onmagnet: function(evt) {\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = jquery__WEBPACK_IMPORTED_MODULE_0__.Event(evt.originalEvent, {\n                type: \"contextmenu\",\n                data: evt.data,\n                currentTarget: evt.currentTarget\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n    magnetpointerdblclick: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n        this.magnetContextMenuTrigger(evt);\n    },\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n    onlabel: function(evt) {\n        var labelNode = evt.currentTarget;\n        var view = this.findView(labelNode);\n        if (!view) return;\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        if (this.guard(evt, view)) return;\n        // Custom event\n        const eventEvt = this.customEventTrigger(evt, view, labelNode);\n        if (eventEvt) {\n            // `onevent` could have stopped propagation\n            if (eventEvt.isPropagationStopped()) return;\n            evt.data = eventEvt.data;\n        }\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onlabel(evt, localPoint.x, localPoint.y);\n    },\n    getPointerArgs (evt) {\n        const normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [\n            normalizedEvt,\n            x,\n            y\n        ];\n    },\n    delegateDragEvents: function(view, data) {\n        data || (data = {});\n        this.eventData({\n            data: data\n        }, {\n            sourceView: view || null,\n            mousemoved: 0\n        });\n        this.delegateDocumentEvents(null, data);\n    },\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n        if (evt.type === \"mousedown\" && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n        const { target } = evt;\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n        if (view && view.model && view.model instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__.Cell) {\n            return false;\n        }\n        if (this.svg === target || this.el === target || jquery__WEBPACK_IMPORTED_MODULE_0__.contains(this.svg, target)) {\n            return false;\n        }\n        return true; // Event guarded. Paper should not react on it in any way.\n    },\n    setGridSize: function(gridSize) {\n        const { options } = this;\n        options.gridSize = gridSize;\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.drawGrid();\n        }\n        return this;\n    },\n    clearGrid: function() {\n        if (this.$grid) {\n            this.$grid.css(\"backgroundImage\", \"none\");\n        }\n        return this;\n    },\n    _getGridRefs: function() {\n        if (!this._gridCache) {\n            this._gridCache = {\n                root: (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"svg\", {\n                    width: \"100%\",\n                    height: \"100%\"\n                }, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"defs\")),\n                patterns: {},\n                add: function(id, vel) {\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(this.root.node.childNodes[0]).append(vel);\n                    this.patterns[id] = vel;\n                    this.root.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"rect\", {\n                        width: \"100%\",\n                        height: \"100%\",\n                        fill: \"url(#\" + id + \")\"\n                    }));\n                },\n                get: function(id) {\n                    return this.patterns[id];\n                },\n                exist: function(id) {\n                    return this.patterns[id] !== undefined;\n                }\n            };\n        }\n        return this._gridCache;\n    },\n    setGrid: function(drawGrid) {\n        this.clearGrid();\n        this._gridCache = null;\n        this._gridSettings = [];\n        var optionsList = Array.isArray(drawGrid) ? drawGrid : [\n            drawGrid || {}\n        ];\n        optionsList.forEach(function(item) {\n            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n        }, this);\n        return this;\n    },\n    _resolveDrawGridOption: function(opt) {\n        var namespace = this.constructor.gridPatterns;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isString)(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({}, item);\n            });\n        }\n        var options = opt || {\n            args: [\n                {}\n            ]\n        };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n        if (!isArray && !name && !options.markup) {\n            name = \"dot\";\n        }\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({}, item);\n            });\n            var args = Array.isArray(options.args) ? options.args : [\n                options.args || {}\n            ];\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.defaults)(args[0], (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.omit)(opt, \"args\"));\n            for(var i = 0; i < args.length; i++){\n                if (pattern[i]) {\n                    (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n        return isArray ? options : [\n            options\n        ];\n    },\n    drawGrid: function(opt) {\n        const gridSize = this.options.drawGridSize || this.options.gridSize;\n        if (gridSize <= 1) {\n            return this.clearGrid();\n        }\n        var localOptions = Array.isArray(opt) ? opt : [\n            opt\n        ];\n        var ctm = this.matrix();\n        var refs = this._getGridRefs();\n        this._gridSettings.forEach(function(gridLayerSetting, index) {\n            var id = \"pattern_\" + index;\n            var options = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.merge)(gridLayerSetting, localOptions[index], {\n                sx: ctm.a || 1,\n                sy: ctm.d || 1,\n                ox: ctm.e || 0,\n                oy: ctm.f || 0\n            });\n            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n            if (!refs.exist(id)) {\n                refs.add(id, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"pattern\", {\n                    id: id,\n                    patternUnits: \"userSpaceOnUse\"\n                }, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(options.markup)));\n            }\n            var patternDefVel = refs.get(id);\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(options.update)) {\n                options.update(patternDefVel.node.childNodes[0], options);\n            }\n            var x = options.ox % options.width;\n            if (x < 0) x += options.width;\n            var y = options.oy % options.height;\n            if (y < 0) y += options.height;\n            patternDefVel.attr({\n                x: x,\n                y: y,\n                width: options.width,\n                height: options.height\n            });\n        });\n        var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n        patternUri = \"url(data:image/svg+xml;base64,\" + btoa(patternUri) + \")\";\n        this.$grid.css(\"backgroundImage\", patternUri);\n        return this;\n    },\n    updateBackgroundImage: function(opt) {\n        opt = opt || {};\n        var backgroundPosition = opt.position || \"center\";\n        var backgroundSize = opt.size || \"auto auto\";\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n        // backgroundPosition\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(backgroundPosition)) {\n            var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n            var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n            backgroundPosition = x + \"px \" + y + \"px\";\n        }\n        // backgroundSize\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(backgroundSize)) {\n            backgroundSize = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_16__.Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + \"px \" + backgroundSize.height + \"px\";\n        }\n        this.$background.css({\n            backgroundSize: backgroundSize,\n            backgroundPosition: backgroundPosition\n        });\n    },\n    drawBackgroundImage: function(img, opt) {\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.$background.css(\"backgroundImage\", \"\");\n            return;\n        }\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n        opt = opt || {};\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || \"no-repeat\";\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.camelCase)(backgroundRepeat)];\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isFunction)(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error(\"dia.Paper: background pattern must return an HTML Canvas instance\");\n            }\n            backgroundImage = canvas.toDataURL(\"image/png\");\n            backgroundRepeat = \"repeat\";\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n        this.$background.css({\n            opacity: backgroundOpacity,\n            backgroundRepeat: backgroundRepeat,\n            backgroundImage: \"url(\" + backgroundImage + \")\"\n        });\n        this.updateBackgroundImage(opt);\n    },\n    updateBackgroundColor: function(color) {\n        this.$el.css(\"backgroundColor\", color || \"\");\n    },\n    drawBackground: function(opt) {\n        opt = opt || {};\n        this.updateBackgroundColor(opt.color);\n        if (opt.image) {\n            opt = this._background = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.cloneDeep)(opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.guid)(opt);\n            var img = document.createElement(\"img\");\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n        return this;\n    },\n    setInteractivity: function(value) {\n        this.options.interactive = value;\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.invoke)(this._views, \"setInteractivity\", value);\n    },\n    // Paper definitions.\n    // ------------------\n    isDefined: function(defId) {\n        return !!this.svg.getElementById(defId);\n    },\n    defineFilter: function(filter) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(filter)) {\n            throw new TypeError(\"dia.Paper: defineFilter() requires 1. argument to be an object.\");\n        }\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.hashCode)(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n            var namespace = _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error(\"Non-existing filter \" + name);\n            }\n            // Set the filter area to be 3x the bounding box of the cell\n            // and center the filter around the cell.\n            var filterAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.assign)({\n                filterUnits: \"objectBoundingBox\",\n                x: -1,\n                y: -1,\n                width: 3,\n                height: 3\n            }, filter.attrs, {\n                id: filterId\n            });\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n        return filterId;\n    },\n    defineGradient: function(gradient) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(gradient)) {\n            throw new TypeError(\"dia.Paper: defineGradient() requires 1. argument to be an object.\");\n        }\n        const { svg, defs } = this;\n        const { type, // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        id = type + svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.hashCode)(JSON.stringify(gradient)), stops, attrs = {} } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.toArray)(stops).map(({ offset, color, opacity })=>{\n            return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"stop\").attr({\n                \"offset\": offset,\n                \"stop-color\": color,\n                \"stop-opacity\": Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n    definePattern: function(pattern) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(pattern)) {\n            throw new TypeError(\"dia.Paper: definePattern() requires 1. argument to be an object.\");\n        }\n        const { svg, defs } = this;\n        const { // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.hashCode)(JSON.stringify(pattern)), markup, attrs = {} } = pattern;\n        if (!markup) {\n            throw new TypeError(\"dia.Paper: definePattern() requires markup.\");\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"pattern\", {\n            patternUnits: \"userSpaceOnUse\"\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === \"string\") {\n            patternVEl.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(markup));\n        } else {\n            const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.parseDOMJSON)(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n    defineMarker: function(marker) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isObject)(marker)) {\n            throw new TypeError(\"dia.Paper: defineMarker() requires the first argument to be an object.\");\n        }\n        const { svg, defs } = this;\n        const { // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.hashCode)(JSON.stringify(marker)), // user-provided markup\n        // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n        markup, // user-provided attributes\n        // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n        // note: `transform` attrs are ignored by browsers\n        attrs = {}, // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n        markerUnits = \"userSpaceOnUse\" } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"marker\", {\n            orient: \"auto\",\n            overflow: \"visible\",\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === \"string\") {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = Array.isArray(markupVEl) ? markupVEl : [\n                    markupVEl\n                ];\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.parseDOMJSON)(markup);\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\"g\").append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = \"path\" } = marker;\n            markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.omit)(marker, \"type\", \"id\", \"markup\", \"attrs\", \"markerUnits\");\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key)=>{\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key){\n                    case \"transform\":\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, value + \" \" + markupValue);\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    },\n    customEventTrigger: function(evt, view, rootNode = view.el) {\n        const eventNode = evt.target.closest(\"[event]\");\n        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n            const eventEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_15__.normalizeEvent)(jquery__WEBPACK_IMPORTED_MODULE_0__.Event(evt.originalEvent, {\n                data: evt.data,\n                // Originally the event listener was attached to the event element.\n                currentTarget: eventNode\n            }));\n            this.onevent(eventEvt);\n            if (eventEvt.isDefaultPrevented()) {\n                evt.preventDefault();\n            }\n            return eventEvt;\n        }\n        return null;\n    }\n}, {\n    sorting: sortingTypes,\n    Layers: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_3__.LayersNames,\n    backgroundPatterns: {\n        flipXy: function(img) {\n            // d b\n            // q p\n            var canvas = document.createElement(\"canvas\");\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n            var ctx = canvas.getContext(\"2d\");\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            return canvas;\n        },\n        flipX: function(img) {\n            // d b\n            // d b\n            var canvas = document.createElement(\"canvas\");\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n            var ctx = canvas.getContext(\"2d\");\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            return canvas;\n        },\n        flipY: function(img) {\n            // d d\n            // q q\n            var canvas = document.createElement(\"canvas\");\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n            var ctx = canvas.getContext(\"2d\");\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            return canvas;\n        },\n        watermark: function(img, opt) {\n            //   d\n            // d\n            opt = opt || {};\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n            var canvas = document.createElement(\"canvas\");\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n            var ctx = canvas.getContext(\"2d\");\n            var angle = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_12__.isNumber)(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_19__.toRad)(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n            for(var i = 0; i < 4; i++){\n                for(var j = 0; j < 4; j++){\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n            return canvas;\n        }\n    },\n    gridPatterns: {\n        dot: [\n            {\n                color: \"#AAAAAA\",\n                thickness: 1,\n                markup: \"rect\",\n                update: function(el, opt) {\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(el).attr({\n                        width: opt.thickness * opt.sx,\n                        height: opt.thickness * opt.sy,\n                        fill: opt.color\n                    });\n                }\n            }\n        ],\n        fixedDot: [\n            {\n                color: \"#AAAAAA\",\n                thickness: 1,\n                markup: \"rect\",\n                update: function(el, opt) {\n                    var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(el).attr({\n                        width: size,\n                        height: size,\n                        fill: opt.color\n                    });\n                }\n            }\n        ],\n        mesh: [\n            {\n                color: \"#AAAAAA\",\n                thickness: 1,\n                markup: \"path\",\n                update: function(el, opt) {\n                    var d;\n                    var width = opt.width;\n                    var height = opt.height;\n                    var thickness = opt.thickness;\n                    if (width - thickness >= 0 && height - thickness >= 0) {\n                        d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                    } else {\n                        d = \"M 0 0 0 0\";\n                    }\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(el).attr({\n                        \"d\": d,\n                        stroke: opt.color,\n                        \"stroke-width\": opt.thickness\n                    });\n                }\n            }\n        ],\n        doubleMesh: [\n            {\n                color: \"#AAAAAA\",\n                thickness: 1,\n                markup: \"path\",\n                update: function(el, opt) {\n                    var d;\n                    var width = opt.width;\n                    var height = opt.height;\n                    var thickness = opt.thickness;\n                    if (width - thickness >= 0 && height - thickness >= 0) {\n                        d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                    } else {\n                        d = \"M 0 0 0 0\";\n                    }\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(el).attr({\n                        \"d\": d,\n                        stroke: opt.color,\n                        \"stroke-width\": opt.thickness\n                    });\n                }\n            },\n            {\n                color: \"#000000\",\n                thickness: 3,\n                scaleFactor: 4,\n                markup: \"path\",\n                update: function(el, opt) {\n                    var d;\n                    var width = opt.width;\n                    var height = opt.height;\n                    var thickness = opt.thickness;\n                    if (width - thickness >= 0 && height - thickness >= 0) {\n                        d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                    } else {\n                        d = \"M 0 0 0 0\";\n                    }\n                    (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(el).attr({\n                        \"d\": d,\n                        stroke: opt.color,\n                        \"stroke-width\": opt.thickness\n                    });\n                }\n            }\n        ]\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL1BhcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFnQ0o7QUFDeUI7QUFDTDtBQUNMO0FBQ007QUFDTjtBQUNSO0FBQ0E7QUFDRTtBQUN1QjtBQUNEO0FBQ0Y7QUFDVTtBQUNsQjtBQUV6QjtBQUNTO0FBRWhDLE1BQU1tRCxlQUFlO0lBQ2pCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztBQUNYO0FBRUEsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsbUJBQW1CO0FBQ3pCLE1BQU1DLG9CQUFvQkM7QUFDMUIsTUFBTUMsZUFBZSxrQkFBa0IsMEJBQTBCO0FBRWpFLE1BQU1DLG9CQUFvQnhCLG1EQUFRQSxDQUFDeUIsWUFBWTtBQUUvQyxNQUFNQyxzQkFBc0I7SUFDeEIsQ0FBQ0Ysa0JBQWtCRyxPQUFPLENBQUMsRUFBRTtRQUN6QkMsTUFBTTtRQUNOQyxTQUFTO1lBQ0xDLFNBQVM7UUFDYjtJQUNKO0lBQ0EsQ0FBQ04sa0JBQWtCTyxtQkFBbUIsQ0FBQyxFQUFFO1FBQ3JDSCxNQUFNO1FBQ05DLFNBQVM7WUFDTEcsV0FBVztRQUNmO0lBQ0o7SUFDQSxDQUFDUixrQkFBa0JTLG9CQUFvQixDQUFDLEVBQUU7UUFDdENMLE1BQU07UUFDTkMsU0FBUztZQUNMRyxXQUFXO1FBQ2Y7SUFDSjtBQUNKO0FBRUEsTUFBTUUsZ0JBQWdCO0lBQUM7UUFDbkJOLE1BQU10Qix3REFBV0EsQ0FBQzZCLElBQUk7SUFDMUI7SUFBRztRQUNDUCxNQUFNdEIsd0RBQVdBLENBQUM4QixLQUFLO0lBQzNCO0lBQUc7UUFDQ1IsTUFBTXRCLHdEQUFXQSxDQUFDK0IsTUFBTTtJQUM1QjtJQUFHO1FBQ0NULE1BQU10Qix3REFBV0EsQ0FBQ2dDLEtBQUs7SUFDM0I7SUFBRztRQUNDVixNQUFNdEIsd0RBQVdBLENBQUNpQyxLQUFLO0lBQzNCO0NBQUU7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RHpQLElBQUk7NEJBQUM7NEJBQUtoYjs0QkFBTzs0QkFBRzs0QkFBY0M7eUJBQU8sQ0FBQzJxQixJQUFJLENBQUM7b0JBQ25ELE9BQU87d0JBQ0g1UCxJQUFJO29CQUNSO29CQUVBL2YseURBQUNBLENBQUN1TCxJQUFJOGUsSUFBSSxDQUFDO3dCQUFFLEtBQUt0Szt3QkFBRzZQLFFBQVE1bUIsSUFBSStpQixLQUFLO3dCQUFFLGdCQUFnQi9pQixJQUFJd21CLFNBQVM7b0JBQUM7Z0JBQzFFO1lBQ0o7WUFBRztnQkFDQ3pELE9BQU87Z0JBQ1B5RCxXQUFXO2dCQUNYdEYsYUFBYTtnQkFDYk4sUUFBUTtnQkFDUnpiLFFBQVEsU0FBUzVDLEVBQUUsRUFBRXZDLEdBQUc7b0JBRXBCLElBQUkrVztvQkFDSixJQUFJaGIsUUFBUWlFLElBQUlqRSxLQUFLO29CQUNyQixJQUFJQyxTQUFTZ0UsSUFBSWhFLE1BQU07b0JBQ3ZCLElBQUl3cUIsWUFBWXhtQixJQUFJd21CLFNBQVM7b0JBRTdCLElBQUl6cUIsUUFBUXlxQixhQUFhLEtBQUt4cUIsU0FBU3dxQixhQUFhLEdBQUc7d0JBQ25EelAsSUFBSTs0QkFBQzs0QkFBS2hiOzRCQUFPOzRCQUFHOzRCQUFjQzt5QkFBTyxDQUFDMnFCLElBQUksQ0FBQztvQkFDbkQsT0FBTzt3QkFDSDVQLElBQUk7b0JBQ1I7b0JBRUEvZix5REFBQ0EsQ0FBQ3VMLElBQUk4ZSxJQUFJLENBQUM7d0JBQUUsS0FBS3RLO3dCQUFHNlAsUUFBUTVtQixJQUFJK2lCLEtBQUs7d0JBQUUsZ0JBQWdCL2lCLElBQUl3bUIsU0FBUztvQkFBQztnQkFDMUU7WUFDSjtTQUFFO0lBQ047QUFDSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL1BhcGVyLm1qcz9jYzljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7XG4gICAgaXNOdW1iZXIsXG4gICAgYXNzaWduLFxuICAgIG5leHRGcmFtZSxcbiAgICBpc09iamVjdCxcbiAgICBjYW5jZWxGcmFtZSxcbiAgICBkZWZhdWx0cyxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgYWRkQ2xhc3NOYW1lUHJlZml4LFxuICAgIG5vcm1hbGl6ZVNpZGVzLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQbGFpbk9iamVjdCxcbiAgICBnZXRCeVBhdGgsXG4gICAgc29ydEVsZW1lbnRzLFxuICAgIGlzU3RyaW5nLFxuICAgIGd1aWQsXG4gICAgbm9ybWFsaXplRXZlbnQsXG4gICAgbm9ybWFsaXplV2hlZWwsXG4gICAgY2FwLFxuICAgIGRlYm91bmNlLFxuICAgIG9taXQsXG4gICAgcmVzdWx0LFxuICAgIG1lcmdlLFxuICAgIGNhbWVsQ2FzZSxcbiAgICBjbG9uZURlZXAsXG4gICAgaW52b2tlLFxuICAgIGhhc2hDb2RlLFxuICAgIGZpbHRlciBhcyBfZmlsdGVyLFxuICAgIHBhcnNlRE9NSlNPTixcbiAgICB0b0FycmF5LFxuICAgIGhhc1xufSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0LCBQb2ludCwgdG9SYWQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBWaWV3LCB2aWV3cyB9IGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ2VsbFZpZXcgfSBmcm9tICcuL0NlbGxWaWV3Lm1qcyc7XG5pbXBvcnQgeyBFbGVtZW50VmlldyB9IGZyb20gJy4vRWxlbWVudFZpZXcubWpzJztcbmltcG9ydCB7IExpbmtWaWV3IH0gZnJvbSAnLi9MaW5rVmlldy5tanMnO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJy4vTGluay5tanMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL0dyYXBoLm1qcyc7XG5pbXBvcnQgeyBMYXllcnNOYW1lcywgUGFwZXJMYXllciB9IGZyb20gJy4vUGFwZXJMYXllci5tanMnO1xuaW1wb3J0ICogYXMgaGlnaGxpZ2h0ZXJzIGZyb20gJy4uL2hpZ2hsaWdodGVycy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgbGlua0FuY2hvcnMgZnJvbSAnLi4vbGlua0FuY2hvcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGNvbm5lY3Rpb25Qb2ludHMgZnJvbSAnLi4vY29ubmVjdGlvblBvaW50cy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgYW5jaG9ycyBmcm9tICcuLi9hbmNob3JzL2luZGV4Lm1qcyc7XG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnO1xuXG5jb25zdCBzb3J0aW5nVHlwZXMgPSB7XG4gICAgTk9ORTogJ3NvcnRpbmctbm9uZScsXG4gICAgQVBQUk9YOiAnc29ydGluZy1hcHByb3hpbWF0ZScsXG4gICAgRVhBQ1Q6ICdzb3J0aW5nLWV4YWN0J1xufTtcblxuY29uc3QgV0hFRUxfQ0FQID0gNTA7XG5jb25zdCBXSEVFTF9XQUlUX01TID0gMjA7XG5jb25zdCBNT1VOVF9CQVRDSF9TSVpFID0gMTAwMDtcbmNvbnN0IFVQREFURV9CQVRDSF9TSVpFID0gSW5maW5pdHk7XG5jb25zdCBNSU5fUFJJT1JJVFkgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuXG5jb25zdCBIaWdobGlnaHRpbmdUeXBlcyA9IENlbGxWaWV3LkhpZ2hsaWdodGluZztcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodGluZyA9IHtcbiAgICBbSGlnaGxpZ2h0aW5nVHlwZXMuREVGQVVMVF06IHtcbiAgICAgICAgbmFtZTogJ3N0cm9rZScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgW0hpZ2hsaWdodGluZ1R5cGVzLk1BR05FVF9BVkFJTEFCSUxJVFldOiB7XG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2F2YWlsYWJsZS1tYWduZXQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFtIaWdobGlnaHRpbmdUeXBlcy5FTEVNRU5UX0FWQUlMQUJJTElUWV06IHtcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYXZhaWxhYmxlLWNlbGwnXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBkZWZhdWx0TGF5ZXJzID0gW3tcbiAgICBuYW1lOiBMYXllcnNOYW1lcy5CQUNLLFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkNFTExTLFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkxBQkVMUyxcbn0sIHtcbiAgICBuYW1lOiBMYXllcnNOYW1lcy5GUk9OVFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLlRPT0xTXG59XTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyID0gVmlldy5leHRlbmQoe1xuXG4gICAgY2xhc3NOYW1lOiAncGFwZXInLFxuXG4gICAgb3B0aW9uczoge1xuXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBvcmlnaW46IHsgeDogMCwgeTogMCB9LCAvLyB4LHkgY29vcmRpbmF0ZXMgaW4gdG9wLWxlZnQgY29ybmVyXG4gICAgICAgIGdyaWRTaXplOiAxLFxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBncmlkIGxpbmVzIG9uIHRoZSBwYXBlcidzIERPTSBlbGVtZW50LlxuICAgICAgICAvLyBlLmcgZHJhd0dyaWQ6IHRydWUsIGRyYXdHcmlkOiB7IGNvbG9yOiAncmVkJywgdGhpY2tuZXNzOiAyIH1cbiAgICAgICAgZHJhd0dyaWQ6IGZhbHNlLFxuICAgICAgICAvLyBJZiBub3Qgc2V0LCB0aGUgc2l6ZSBvZiB0aGUgdmlzdWFsIGdyaWQgaXMgdGhlIHNhbWUgYXMgdGhlIGBncmlkU2l6ZWAuXG4gICAgICAgIGRyYXdHcmlkU2l6ZTogbnVsbCxcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBiYWNrZ3JvdW5kIG9uIHRoZSBwYXBlcidzIERPTSBlbGVtZW50LlxuICAgICAgICAvLyBlLmcuIGJhY2tncm91bmQ6IHsgY29sb3I6ICdsaWdodGJsdWUnLCBpbWFnZTogJy9wYXBlci1iYWNrZ3JvdW5kLnBuZycsIHJlcGVhdDogJ2ZsaXAteHknIH1cbiAgICAgICAgYmFja2dyb3VuZDogZmFsc2UsXG5cbiAgICAgICAgcGVycGVuZGljdWxhckxpbmtzOiBmYWxzZSxcbiAgICAgICAgZWxlbWVudFZpZXc6IEVsZW1lbnRWaWV3LFxuICAgICAgICBsaW5rVmlldzogTGlua1ZpZXcsXG4gICAgICAgIHNuYXBMYWJlbHM6IGZhbHNlLCAvLyBmYWxzZSwgdHJ1ZVxuICAgICAgICBzbmFwTGlua3M6IGZhbHNlLCAvLyBmYWxzZSwgdHJ1ZSwgeyByYWRpdXM6IHZhbHVlIH1cbiAgICAgICAgc25hcExpbmtzU2VsZjogZmFsc2UsIC8vIGZhbHNlLCB0cnVlLCB7IHJhZGl1czogdmFsdWUgfVxuXG4gICAgICAgIC8vIFNob3VsZCB0aGUgbGluayBsYWJlbHMgYmUgcmVuZGVyZWQgaW50byBpdHMgb3duIGxheWVyP1xuICAgICAgICAvLyBgZmFsc2VgIC0gdGhlIGxhYmVscyBhcmUgcGFydCBvZiB0aGUgbGlua3NcbiAgICAgICAgLy8gYHRydWVgIC0gdGhlIGxhYmVscyBhcmUgYXBwZW5kZWQgdG8gTGF5ZXJzTmFtZS5MQUJFTFNcbiAgICAgICAgLy8gW0xheWVyc05hbWVdIC0gdGhlIGxhYmVscyBhcmUgYXBwZW5kZWQgdG8gdGhlIGxheWVyIHNwZWNpZmllZFxuICAgICAgICBsYWJlbHNMYXllcjogZmFsc2UsXG5cbiAgICAgICAgLy8gV2hlbiBzZXQgdG8gRkFMU0UsIGFuIGVsZW1lbnQgbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiAxIGxpbmsgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50LlxuICAgICAgICBtdWx0aUxpbmtzOiB0cnVlLFxuXG4gICAgICAgIC8vIEZvciBhZGRpbmcgY3VzdG9tIGd1YXJkIGxvZ2ljLlxuICAgICAgICBndWFyZDogZnVuY3Rpb24oZXZ0LCB2aWV3KSB7XG5cbiAgICAgICAgICAgIC8vIEZBTFNFIG1lYW5zIHRoZSBldmVudCBpc24ndCBndWFyZGVkLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGluZzogZGVmYXVsdEhpZ2hsaWdodGluZyxcblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGNvbnRleHQgbWVudSBmcm9tIGJlaW5nIGRpc3BsYXllZC5cbiAgICAgICAgcHJldmVudENvbnRleHRNZW51OiB0cnVlLFxuXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBibGFuazpwb2ludGVyPGFjdGlvbj4uXG4gICAgICAgIHByZXZlbnREZWZhdWx0QmxhbmtBY3Rpb246IHRydWUsXG5cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIGNlbGw6cG9pbnRlcjxhY3Rpb24+LlxuICAgICAgICBwcmV2ZW50RGVmYXVsdFZpZXdBY3Rpb246IHRydWUsXG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIHRyYW5zbGF0aW9uIG9mIGVsZW1lbnRzIGJ5IGdpdmVuIGJvdW5kaW5nIGJveC5cbiAgICAgICAgLy8gT3B0aW9uIGFjY2VwdHMgYSBib29sZWFuOlxuICAgICAgICAvLyAgdHJ1ZSAtIHRoZSB0cmFuc2xhdGlvbiBpcyByZXN0cmljdGVkIHRvIHRoZSBwYXBlciBhcmVhXG4gICAgICAgIC8vICBmYWxzZSAtIG5vIHJlc3RyaWN0aW9uc1xuICAgICAgICAvLyBBIG1ldGhvZDpcbiAgICAgICAgLy8gcmVzdHJpY3RUcmFuc2xhdGU6IGZ1bmN0aW9uKGVsZW1lbnRWaWV3KSB7XG4gICAgICAgIC8vICAgICB2YXIgcGFyZW50SWQgPSBlbGVtZW50Vmlldy5tb2RlbC5nZXQoJ3BhcmVudCcpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHBhcmVudElkICYmIHRoaXMubW9kZWwuZ2V0Q2VsbChwYXJlbnRJZCkuZ2V0QkJveCgpO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvLyBPciBhIGJvdW5kaW5nIGJveDpcbiAgICAgICAgLy8gcmVzdHJpY3RUcmFuc2xhdGU6IHsgeDogMTAsIHk6IDEwLCB3aWR0aDogNzkwLCBoZWlnaHQ6IDU5MCB9XG4gICAgICAgIHJlc3RyaWN0VHJhbnNsYXRlOiBmYWxzZSxcblxuICAgICAgICAvLyBNYXJrcyBhbGwgYXZhaWxhYmxlIG1hZ25ldHMgd2l0aCAnYXZhaWxhYmxlLW1hZ25ldCcgY2xhc3MgbmFtZSBhbmQgYWxsIGF2YWlsYWJsZSBjZWxscyB3aXRoXG4gICAgICAgIC8vICdhdmFpbGFibGUtY2VsbCcgY2xhc3MgbmFtZS4gTWFya3MgdGhlbSB3aGVuIGRyYWdnaW5nIGEgbGluayBpcyBzdGFydGVkIGFuZCB1bm1hcmtcbiAgICAgICAgLy8gd2hlbiB0aGUgZHJhZ2dpbmcgaXMgc3RvcHBlZC5cbiAgICAgICAgbWFya0F2YWlsYWJsZTogZmFsc2UsXG5cbiAgICAgICAgLy8gRGVmaW5lcyB3aGF0IGxpbmsgbW9kZWwgaXMgYWRkZWQgdG8gdGhlIGdyYXBoIGFmdGVyIGFuIHVzZXIgY2xpY2tzIG9uIGFuIGFjdGl2ZSBtYWduZXQuXG4gICAgICAgIC8vIFZhbHVlIGNvdWxkIGJlIHRoZSBCYWNrYm9uZS5tb2RlbCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgQmFja2JvbmUubW9kZWxcbiAgICAgICAgLy8gZGVmYXVsdExpbms6IGZ1bmN0aW9uKGVsZW1lbnRWaWV3LCBtYWduZXQpIHsgcmV0dXJuIGNvbmRpdGlvbiA/IG5ldyBjdXN0b21MaW5rMSgpIDogbmV3IGN1c3RvbUxpbmsyKCkgfVxuICAgICAgICBkZWZhdWx0TGluazogbmV3IExpbmssXG5cbiAgICAgICAgLy8gQSBjb25uZWN0b3IgdGhhdCBpcyB1c2VkIGJ5IGxpbmtzIHdpdGggbm8gY29ubmVjdG9yIGRlZmluZWQgb24gdGhlIG1vZGVsLlxuICAgICAgICAvLyBlLmcuIHsgbmFtZTogJ3JvdW5kZWQnLCBhcmdzOiB7IHJhZGl1czogNSB9fSBvciBhIGZ1bmN0aW9uXG4gICAgICAgIGRlZmF1bHRDb25uZWN0b3I6IHsgbmFtZTogJ25vcm1hbCcgfSxcblxuICAgICAgICAvLyBBIHJvdXRlciB0aGF0IGlzIHVzZWQgYnkgbGlua3Mgd2l0aCBubyByb3V0ZXIgZGVmaW5lZCBvbiB0aGUgbW9kZWwuXG4gICAgICAgIC8vIGUuZy4geyBuYW1lOiAnb25lU2lkZScsIGFyZ3M6IHsgcGFkZGluZzogMTAgfX0gb3IgYSBmdW5jdGlvblxuICAgICAgICBkZWZhdWx0Um91dGVyOiB7IG5hbWU6ICdub3JtYWwnIH0sXG5cbiAgICAgICAgZGVmYXVsdEFuY2hvcjogeyBuYW1lOiAnY2VudGVyJyB9LFxuXG4gICAgICAgIGRlZmF1bHRMaW5rQW5jaG9yOiB7IG5hbWU6ICdjb25uZWN0aW9uUmF0aW8nIH0sXG5cbiAgICAgICAgZGVmYXVsdENvbm5lY3Rpb25Qb2ludDogeyBuYW1lOiAnYmJveCcgfSxcblxuICAgICAgICAvKiBDT05ORUNUSU5HICovXG5cbiAgICAgICAgY29ubmVjdGlvblN0cmF0ZWd5OiBudWxsLFxuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdG8gYWRkIGEgbmV3IGxpbmsgdG8gdGhlIGdyYXBoIHdoZW4gdXNlciBjbGlja3Mgb24gYW4gYSBtYWduZXQuXG4gICAgICAgIHZhbGlkYXRlTWFnbmV0OiBmdW5jdGlvbihfY2VsbFZpZXcsIG1hZ25ldCwgX2V2dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hZ25ldC5nZXRBdHRyaWJ1dGUoJ21hZ25ldCcpICE9PSAncGFzc2l2ZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhbGxvdyBvciBkaXNhbGxvdyB0aGUgbGluayBjb25uZWN0aW9uIHdoaWxlIGFuIGFycm93aGVhZCBlbmQgKHNvdXJjZS90YXJnZXQpXG4gICAgICAgIC8vIGJlaW5nIGNoYW5nZWQuXG4gICAgICAgIHZhbGlkYXRlQ29ubmVjdGlvbjogZnVuY3Rpb24oY2VsbFZpZXdTLCBfbWFnbmV0UywgY2VsbFZpZXdULCBfbWFnbmV0VCwgZW5kLCBfbGlua1ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAoZW5kID09PSAndGFyZ2V0JyA/IGNlbGxWaWV3VCA6IGNlbGxWaWV3UykgaW5zdGFuY2VvZiBFbGVtZW50VmlldztcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBFTUJFRERJTkcgKi9cblxuICAgICAgICAvLyBFbmFibGVzIGVtYmVkZGluZy4gUmUtcGFyZW50IHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aCBlbGVtZW50cyB1bmRlciBpdCBhbmQgbWFrZXMgc3VyZSB0aGF0XG4gICAgICAgIC8vIGFsbCBsaW5rcyBhbmQgZWxlbWVudHMgYXJlIHZpc2libGUgdGFrZW4gdGhlIGxldmVsIG9mIGVtYmVkZGluZyBpbnRvIGFjY291bnQuXG4gICAgICAgIGVtYmVkZGluZ01vZGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3cgdGhlIGVsZW1lbnQgZW1iZWRkaW5nIHdoaWxlIGFuIGVsZW1lbnQgYmVpbmcgdHJhbnNsYXRlZC5cbiAgICAgICAgdmFsaWRhdGVFbWJlZGRpbmc6IGZ1bmN0aW9uKGNoaWxkVmlldywgcGFyZW50Vmlldykge1xuICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbGwgZWxlbWVudHMgY2FuIGJlIGluIHJlbGF0aW9uIGNoaWxkLXBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhbGxvdyBvciBkaXNhbGxvdyBhbiBlbWJlZGRlZCBlbGVtZW50IHRvIGJlIHVuZW1iZWRkZWQgLyB0byBiZWNvbWUgYSByb290LlxuICAgICAgICB2YWxpZGF0ZVVuZW1iZWRkaW5nOiBmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWxsIGVsZW1lbnRzIGNhbiBiZWNvbWUgcm9vdHNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZXMgdGhlIHdheSBob3cgYSBjZWxsIGZpbmRzIGEgc3VpdGFibGUgcGFyZW50IHdoZW4gaXQncyBkcmFnZ2VkIG92ZXIgdGhlIHBhcGVyLlxuICAgICAgICAvLyBUaGUgY2VsbCB3aXRoIHRoZSBoaWdoZXN0IHotaW5kZXggKHZpc3VhbGx5IG9uIHRoZSB0b3ApIHdpbGwgYmUgY2hvc2VuLlxuICAgICAgICBmaW5kUGFyZW50Qnk6ICdiYm94JywgLy8gJ2Jib3gnfCdjZW50ZXInfCdvcmlnaW4nfCdjb3JuZXInfCd0b3BSaWdodCd8J2JvdHRvbUxlZnQnXG5cbiAgICAgICAgLy8gSWYgZW5hYmxlZCBvbmx5IHRoZSBlbGVtZW50IG9uIHRoZSB2ZXJ5IGZyb250IGlzIHRha2VuIGludG8gYWNjb3VudCBmb3IgdGhlIGVtYmVkZGluZy5cbiAgICAgICAgLy8gSWYgZGlzYWJsZWQgdGhlIGVsZW1lbnRzIHVuZGVyIHRoZSBkcmFnZ2VkIHZpZXcgYXJlIHRlc3RlZCBvbmUgYnkgb25lXG4gICAgICAgIC8vIChmcm9tIGZyb250IHRvIGJhY2spIHVudGlsIGEgdmFsaWQgcGFyZW50IGZvdW5kLlxuICAgICAgICBmcm9udFBhcmVudE9ubHk6IHRydWUsXG5cbiAgICAgICAgLy8gSW50ZXJhY3RpdmUgZmxhZ3MuIFNlZSBvbmxpbmUgZG9jcyBmb3IgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgaW50ZXJhY3RpdmUgZmxhZ3MuXG4gICAgICAgIGludGVyYWN0aXZlOiB7XG4gICAgICAgICAgICBsYWJlbE1vdmU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2hlbiBzZXQgdG8gdHJ1ZSB0aGUgbGlua3MgY2FuIGJlIHBpbm5lZCB0byB0aGUgcGFwZXIuXG4gICAgICAgIC8vIGkuZS4gbGluayBzb3VyY2UvdGFyZ2V0IGNhbiBiZSBhIHBvaW50IGUuZy4gbGluay5nZXQoJ3NvdXJjZScpID09PiB7IHg6IDEwMCwgeTogMTAwIH07XG4gICAgICAgIGxpbmtQaW5uaW5nOiB0cnVlLFxuXG4gICAgICAgIC8vIEN1c3RvbSB2YWxpZGF0aW9uIGFmdGVyIGFuIGludGVyYWN0aW9uIHdpdGggYSBsaW5rIGVuZHMuXG4gICAgICAgIC8vIFJlY29nbml6ZXMgYSBmdW5jdGlvbi4gSWYgYGZhbHNlYCBpcyByZXR1cm5lZCwgdGhlIGxpbmsgaXMgZGlzYWxsb3dlZCAocmVtb3ZlZCBvciByZXZlcnRlZClcbiAgICAgICAgLy8gKGxpbmtWaWV3LCBwYXBlcikgPT4gYm9vbGVhblxuICAgICAgICBhbGxvd0xpbms6IG51bGwsXG5cbiAgICAgICAgLy8gQWxsb3dlZCBudW1iZXIgb2YgbW91c2Vtb3ZlIGV2ZW50cyBhZnRlciB3aGljaCB0aGUgcG9pbnRlcmNsaWNrIGV2ZW50IHdpbGwgYmUgc3RpbGwgdHJpZ2dlcmVkLlxuICAgICAgICBjbGlja1RocmVzaG9sZDogMCxcblxuICAgICAgICAvLyBOdW1iZXIgb2YgcmVxdWlyZWQgbW91c2Vtb3ZlIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IHBvaW50ZXJtb3ZlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgICAgICBtb3ZlVGhyZXNob2xkOiAwLFxuXG4gICAgICAgIC8vIE51bWJlciBvZiByZXF1aXJlZCBtb3VzZW1vdmUgZXZlbnRzIGJlZm9yZSBhIGxpbmsgaXMgY3JlYXRlZCBvdXQgb2YgdGhlIG1hZ25ldC5cbiAgICAgICAgLy8gT3Igc3RyaW5nIGBvbmxlYXZlYCBzbyB0aGUgbGluayBpcyBjcmVhdGVkIHdoZW4gdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBtYWduZXRcbiAgICAgICAgbWFnbmV0VGhyZXNob2xkOiAwLFxuXG4gICAgICAgIC8vIFJlbmRlcmluZyBPcHRpb25zXG5cbiAgICAgICAgc29ydGluZzogc29ydGluZ1R5cGVzLkVYQUNULFxuXG4gICAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgICAgYXV0b0ZyZWV6ZTogZmFsc2UsXG5cbiAgICAgICAgLy8gbm8gZG9jcyB5ZXRcbiAgICAgICAgb25WaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0LCBwYXBlcikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHVwZGF0ZSBjb25uZWN0ZWQgbGlua3Mgd2hlbjpcbiAgICAgICAgICAgIC8vIDEuIHRoZSB2aWV3IHdhcyBqdXN0IGluc2VydGVkIChhZGRlZCB0byB0aGUgZ3JhcGggYW5kIHJlbmRlcmVkKVxuICAgICAgICAgICAgLy8gMi4gdGhlIHZpZXcgd2FzIGp1c3QgbW91bnRlZCAoYWRkZWQgYmFjayB0byB0aGUgcGFwZXIgYnkgdmlld3BvcnQgZnVuY3Rpb24pXG4gICAgICAgICAgICAvLyAzLiB0aGUgY2hhbmdlIHdhcyBtYXJrZWQgYXMgYGlzb2xhdGVgLlxuICAgICAgICAgICAgLy8gNC4gdGhlIHZpZXcgbW9kZWwgd2FzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBncmFwaFxuICAgICAgICAgICAgaWYgKChmbGFnICYgKHZpZXcuRkxBR19JTlNFUlQgfCB2aWV3LkZMQUdfUkVNT1ZFKSkgfHwgb3B0Lm1vdW50aW5nIHx8IG9wdC5pc29sYXRlKSByZXR1cm47XG4gICAgICAgICAgICBwYXBlci5yZXF1ZXN0Q29ubmVjdGVkTGlua3NVcGRhdGUodmlldywgcHJpb3JpdHksIG9wdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbm8gZG9jcyB5ZXRcbiAgICAgICAgb25WaWV3UG9zdHBvbmVkOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwYXBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcGVyLmZvcmNlUG9zdHBvbmVkVmlld1VwZGF0ZSh2aWV3LCBmbGFnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVSZW5kZXI6IG51bGwsIC8vIGZ1bmN0aW9uKG9wdCwgcGFwZXIpIHsgfSxcblxuICAgICAgICBhZnRlclJlbmRlcjogbnVsbCwgLy8gZnVuY3Rpb24oc3RhdHMsIG9wdCwgcGFwZXIpIHtcblxuICAgICAgICB2aWV3cG9ydDogbnVsbCxcblxuICAgICAgICAvLyBEZWZhdWx0IG5hbWVzcGFjZXNcblxuICAgICAgICBjZWxsVmlld05hbWVzcGFjZTogbnVsbCxcblxuICAgICAgICByb3V0ZXJOYW1lc3BhY2U6IG51bGwsXG5cbiAgICAgICAgY29ubmVjdG9yTmFtZXNwYWNlOiBudWxsLFxuXG4gICAgICAgIGhpZ2hsaWdodGVyTmFtZXNwYWNlOiBoaWdobGlnaHRlcnMsXG5cbiAgICAgICAgYW5jaG9yTmFtZXNwYWNlOiBhbmNob3JzLFxuXG4gICAgICAgIGxpbmtBbmNob3JOYW1lc3BhY2U6IGxpbmtBbmNob3JzLFxuXG4gICAgICAgIGNvbm5lY3Rpb25Qb2ludE5hbWVzcGFjZTogY29ubmVjdGlvblBvaW50cyxcblxuICAgICAgICBvdmVyZmxvdzogZmFsc2VcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdkYmxjbGljayc6ICdwb2ludGVyZGJsY2xpY2snLFxuICAgICAgICAnZGJsdGFwJzogJ3BvaW50ZXJkYmxjbGljaycsXG4gICAgICAgICdjb250ZXh0bWVudSc6ICdjb250ZXh0bWVudScsXG4gICAgICAgICdtb3VzZWRvd24nOiAncG9pbnRlcmRvd24nLFxuICAgICAgICAndG91Y2hzdGFydCc6ICdwb2ludGVyZG93bicsXG4gICAgICAgICdtb3VzZW92ZXInOiAnbW91c2VvdmVyJyxcbiAgICAgICAgJ21vdXNlb3V0JzogJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNlZW50ZXInOiAnbW91c2VlbnRlcicsXG4gICAgICAgICdtb3VzZWxlYXZlJzogJ21vdXNlbGVhdmUnLFxuICAgICAgICAnd2hlZWwnOiAnbW91c2V3aGVlbCcsXG4gICAgICAgICdtb3VzZWVudGVyIC5qb2ludC1jZWxsJzogJ21vdXNlZW50ZXInLFxuICAgICAgICAnbW91c2VsZWF2ZSAuam9pbnQtY2VsbCc6ICdtb3VzZWxlYXZlJyxcbiAgICAgICAgJ21vdXNlZW50ZXIgLmpvaW50LXRvb2xzJzogJ21vdXNlZW50ZXInLFxuICAgICAgICAnbW91c2VsZWF2ZSAuam9pbnQtdG9vbHMnOiAnbW91c2VsZWF2ZScsXG4gICAgICAgICdkYmxjbGljayAuam9pbnQtY2VsbCBbbWFnbmV0XSc6ICdtYWduZXRwb2ludGVyZGJsY2xpY2snLFxuICAgICAgICAnY29udGV4dG1lbnUgLmpvaW50LWNlbGwgW21hZ25ldF0nOiAnbWFnbmV0Y29udGV4dG1lbnUnLFxuICAgICAgICAnbW91c2Vkb3duIC5qb2ludC1saW5rIC5sYWJlbCc6ICdvbmxhYmVsJywgLy8gaW50ZXJhY3Rpb24gd2l0aCBsaW5rIGxhYmVsXG4gICAgICAgICd0b3VjaHN0YXJ0IC5qb2ludC1saW5rIC5sYWJlbCc6ICdvbmxhYmVsJyxcbiAgICAgICAgJ2RyYWdzdGFydCAuam9pbnQtY2VsbCBpbWFnZSc6ICdvbkltYWdlRHJhZ1N0YXJ0JyAvLyBmaXJlZm94IGZpeFxuICAgIH0sXG5cbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICAnbW91c2Vtb3ZlJzogJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgJ3RvdWNobW92ZSc6ICdwb2ludGVybW92ZScsXG4gICAgICAgICdtb3VzZXVwJzogJ3BvaW50ZXJ1cCcsXG4gICAgICAgICd0b3VjaGVuZCc6ICdwb2ludGVydXAnLFxuICAgICAgICAndG91Y2hjYW5jZWwnOiAncG9pbnRlcnVwJ1xuICAgIH0sXG5cbiAgICBzdmc6IG51bGwsXG4gICAgdmlld3BvcnQ6IG51bGwsXG4gICAgZGVmczogbnVsbCxcbiAgICB0b29sczogbnVsbCxcbiAgICAkYmFja2dyb3VuZDogbnVsbCxcbiAgICBsYXllcnM6IG51bGwsXG4gICAgJGdyaWQ6IG51bGwsXG4gICAgJGRvY3VtZW50OiBudWxsLFxuXG4gICAgLy8gRm9yIHN0b3JpbmcgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IChDVE0pIG9mIHRoZSBwYXBlcidzIHZpZXdwb3J0LlxuICAgIF92aWV3cG9ydE1hdHJpeDogbnVsbCxcbiAgICAvLyBGb3IgdmVyaWZ5aW5nIHdoZXRoZXIgdGhlIENUTSBpcyB1cC10by1kYXRlLiBUaGUgdmlld3BvcnQgdHJhbnNmb3JtIGF0dHJpYnV0ZVxuICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBtYW5pcHVsYXRlZCBkaXJlY3RseS5cbiAgICBfdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmc6IG51bGwsXG4gICAgLy8gVXBkYXRlcyBkYXRhIChwcmlvcml0aWVzLCB1bm1vdW50ZWQgdmlld3MgZXRjLilcbiAgICBfdXBkYXRlczogbnVsbCxcbiAgICAvLyBQYXBlciBMYXllcnNcbiAgICBfbGF5ZXJzOiBudWxsLFxuXG4gICAgU09SVF9ERUxBWUlOR19CQVRDSEVTOiBbJ2FkZCcsICd0by1mcm9udCcsICd0by1iYWNrJ10sXG4gICAgVVBEQVRFX0RFTEFZSU5HX0JBVENIRVM6IFsndHJhbnNsYXRlJ10sXG4gICAgLy8gSWYgeW91IGludGVyYWN0IHdpdGggdGhlc2UgZWxlbWVudHMsXG4gICAgLy8gdGhlIGRlZmF1bHQgaW50ZXJhY3Rpb24gc3VjaCBhcyBgZWxlbWVudCBtb3ZlYCBpcyBwcmV2ZW50ZWQuXG4gICAgRk9STV9DT05UUk9MX1RBR19OQU1FUzogWydURVhUQVJFQScsICdJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ09QVElPTiddICxcbiAgICAvLyBJZiB5b3UgaW50ZXJhY3Qgd2l0aCB0aGVzZSBlbGVtZW50cywgdGhlIGV2ZW50cyBhcmUgbm90IHByb3BhZ2F0ZWQgdG8gdGhlIHBhcGVyXG4gICAgLy8gaS5lLiBwYXBlciBldmVudHMgc3VjaCBhcyBgZWxlbWVudDpwb2ludGVyZG93bmAgYXJlIG5vdCB0cmlnZ2VyZWQuXG4gICAgR1VBUkRFRF9UQUdfTkFNRVM6IFtcbiAgICAgICAgLy8gR3VhcmQgPHNlbGVjdD4gZm9yIGNvbnNpc3RlbmN5LiBXaGVuIHlvdSBjbGljayBvbiBpdDpcbiAgICAgICAgLy8gQ2hyb21lOiB0cmlnZ2VycyBgcG9pbnRlcmRvd25gLCBgcG9pbnRlcnVwYCwgYHBvaW50ZXJjbGlja2AgdG8gb3BlblxuICAgICAgICAvLyBGaXJlZm94OiB0cmlnZ2VycyBgcG9pbnRlcmRvd25gIG9uIG9wZW4sIGBwb2ludGVydXBgIChhbmQgYHBvaW50ZXJjbGlja2Agb25seSBpZiB5b3UgaGF2ZW4ndCBtb3ZlZCkuXG4gICAgICAgIC8vICAgICAgICAgIG9uIGNsb3NlLiBIb3dldmVyLCBpZiB5b3Ugb3BlbiBhbmQgdGhlbiBjbG9zZSBieSBjbGlja2luZyBlbHNld2hlcmUgb24gdGhlIHBhZ2UsXG4gICAgICAgIC8vICAgICAgICAgICBubyBvdGhlciBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIFNhZmFyaTogd2hlbiB5b3Ugb3BlbiBpdCwgaXQgdHJpZ2dlcnMgYHBvaW50ZXJkb3duYC4gVGhhdCdzIGl0LlxuICAgICAgICAnU0VMRUNUJyxcbiAgICBdLFxuICAgIE1JTl9TQ0FMRTogMWUtNixcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgICAgIG9wdGlvbnMuY2VsbFZpZXdOYW1lc3BhY2UgPSB0eXBlb2Ygam9pbnQgIT09ICd1bmRlZmluZWQnICYmIGhhcyhqb2ludCwgJ3NoYXBlcycpID8gam9pbnQuc2hhcGVzIDogbnVsbDtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWwgfHwgbmV3IEdyYXBoO1xuXG4gICAgICAgIC8vIExheWVycyAoU1ZHR3JvdXBzKVxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICB0aGlzLnNldEdyaWQob3B0aW9ucy5kcmF3R3JpZCk7XG4gICAgICAgIHRoaXMuY2xvbmVPcHRpb25zKCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMuX3NldERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydExpc3RlbmluZygpO1xuXG4gICAgICAgIC8vIEhhc2ggb2YgYWxsIGNlbGwgdmlld3MuXG4gICAgICAgIHRoaXMuX3ZpZXdzID0ge307XG5cbiAgICAgICAgLy8gTW91c2Ugd2hlZWwgZXZlbnRzIGJ1ZmZlclxuICAgICAgICB0aGlzLl9td19ldnRfYnVmZmVyID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG51bGwsXG4gICAgICAgICAgICBkZWx0YXM6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSB0byB0aGUgcGFwZXIgb3duZXIgZG9jdW1lbnRcbiAgICAgICAgdGhpcy4kZG9jdW1lbnQgPSAkKGVsLm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAvLyBSZW5kZXIgZXhpc3RpbmcgY2VsbHMgaW4gdGhlIGdyYXBoXG4gICAgICAgIHRoaXMucmVzZXRWaWV3cyhtb2RlbC5hdHRyaWJ1dGVzLmNlbGxzLm1vZGVscyk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSZW5kZXJpbmcgTG9vcFxuICAgICAgICBpZiAoIXRoaXMuaXNGcm96ZW4oKSAmJiB0aGlzLmlzQXN5bmMoKSkgdGhpcy51cGRhdGVWaWV3c0FzeW5jKCk7XG4gICAgfSxcblxuICAgIF9yZXNldFVwZGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgICAgcHJpb3JpdGllczogW3t9LCB7fSwge31dLFxuICAgICAgICAgICAgdW5tb3VudGVkQ2lkczogW10sXG4gICAgICAgICAgICBtb3VudGVkQ2lkczogW10sXG4gICAgICAgICAgICB1bm1vdW50ZWQ6IHt9LFxuICAgICAgICAgICAgbW91bnRlZDoge30sXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIGtleUZyb3plbjogZmFsc2UsXG4gICAgICAgICAgICBmcmVlemVLZXk6IG51bGwsXG4gICAgICAgICAgICBzb3J0OiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlkbGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHN0YXJ0TGlzdGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyhtb2RlbCwgJ2FkZCcsIHRoaXMub25DZWxsQWRkZWQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdyZW1vdmUnLCB0aGlzLm9uQ2VsbFJlbW92ZWQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdjaGFuZ2UnLCB0aGlzLm9uQ2VsbENoYW5nZSlcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ3Jlc2V0JywgdGhpcy5vbkdyYXBoUmVzZXQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdzb3J0JywgdGhpcy5vbkdyYXBoU29ydClcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ2JhdGNoOnN0b3AnLCB0aGlzLm9uR3JhcGhCYXRjaFN0b3ApO1xuICAgICAgICB0aGlzLm9uKCdjZWxsOmhpZ2hsaWdodCcsIHRoaXMub25DZWxsSGlnaGxpZ2h0KVxuICAgICAgICAgICAgLm9uKCdjZWxsOnVuaGlnaGxpZ2h0JywgdGhpcy5vbkNlbGxVbmhpZ2hsaWdodClcbiAgICAgICAgICAgIC5vbignc2NhbGUgdHJhbnNsYXRlJywgdGhpcy51cGRhdGUpO1xuICAgIH0sXG5cbiAgICBvbkNlbGxBZGRlZDogZnVuY3Rpb24oY2VsbCwgXywgb3B0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9wdC5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpIHx8ICFpc051bWJlcihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhjZWxsLCBvcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdC5tYXhQb3NpdGlvbiA9PT0gcG9zaXRpb24pIHRoaXMuZnJlZXplKHsga2V5OiAnYWRkQ2VsbHMnIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KGNlbGwsIG9wdCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDApIHRoaXMudW5mcmVlemUoeyBrZXk6ICdhZGRDZWxscycgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25DZWxsUmVtb3ZlZDogZnVuY3Rpb24oY2VsbCwgXywgb3B0KSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChjZWxsKTtcbiAgICAgICAgaWYgKHZpZXcpIHRoaXMucmVxdWVzdFZpZXdVcGRhdGUodmlldywgdmlldy5GTEFHX1JFTU9WRSwgdmlldy5VUERBVEVfUFJJT1JJVFksIG9wdCk7XG4gICAgfSxcblxuICAgIG9uQ2VsbENoYW5nZTogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG4gICAgICAgIGlmIChjZWxsID09PSB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuY2VsbHMpIHJldHVybjtcbiAgICAgICAgaWYgKGNlbGwuaGFzQ2hhbmdlZCgneicpICYmIHRoaXMub3B0aW9ucy5zb3J0aW5nID09PSBzb3J0aW5nVHlwZXMuQVBQUk9YKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwoY2VsbCk7XG4gICAgICAgICAgICBpZiAodmlldykgdGhpcy5yZXF1ZXN0Vmlld1VwZGF0ZSh2aWV3LCB2aWV3LkZMQUdfSU5TRVJULCB2aWV3LlVQREFURV9QUklPUklUWSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkdyYXBoUmVzZXQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG9wdCkge1xuICAgICAgICB0aGlzLnJlc2V0TGF5ZXJzKCk7XG4gICAgICAgIHRoaXMucmVzZXRWaWV3cyhjb2xsZWN0aW9uLm1vZGVscywgb3B0KTtcbiAgICB9LFxuXG4gICAgb25HcmFwaFNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNBY3RpdmVCYXRjaCh0aGlzLlNPUlRfREVMQVlJTkdfQkFUQ0hFUykpIHJldHVybjtcbiAgICAgICAgdGhpcy5zb3J0Vmlld3MoKTtcbiAgICB9LFxuXG4gICAgb25HcmFwaEJhdGNoU3RvcDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Zyb3plbigpKSByZXR1cm47XG4gICAgICAgIHZhciBuYW1lID0gZGF0YSAmJiBkYXRhLmJhdGNoTmFtZTtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5tb2RlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXN5bmMoKSkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZURlbGF5aW5nQmF0Y2hlcyA9IHRoaXMuVVBEQVRFX0RFTEFZSU5HX0JBVENIRVM7XG4gICAgICAgICAgICBpZiAodXBkYXRlRGVsYXlpbmdCYXRjaGVzLmluY2x1ZGVzKG5hbWUpICYmICFncmFwaC5oYXNBY3RpdmVCYXRjaCh1cGRhdGVEZWxheWluZ0JhdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydERlbGF5aW5nQmF0Y2hlcyA9IHRoaXMuU09SVF9ERUxBWUlOR19CQVRDSEVTO1xuICAgICAgICBpZiAoc29ydERlbGF5aW5nQmF0Y2hlcy5pbmNsdWRlcyhuYW1lKSAmJiAhZ3JhcGguaGFzQWN0aXZlQmF0Y2goc29ydERlbGF5aW5nQmF0Y2hlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFZpZXdzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmVPcHRpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRlZmF1bHRDb25uZWN0b3IsXG4gICAgICAgICAgICBkZWZhdWx0Um91dGVyLFxuICAgICAgICAgICAgZGVmYXVsdENvbm5lY3Rpb25Qb2ludCxcbiAgICAgICAgICAgIGRlZmF1bHRBbmNob3IsXG4gICAgICAgICAgICBkZWZhdWx0TGlua0FuY2hvcixcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGhpZ2hsaWdodGluZyxcbiAgICAgICAgICAgIGNlbGxWaWV3TmFtZXNwYWNlLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmVcbiAgICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBjZWxsVmlldyBuYW1lc3BhY2UgZm9yIEVTNVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICBpZiAoIWNlbGxWaWV3TmFtZXNwYWNlICYmIHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKGpvaW50LCAnc2hhcGVzJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2VsbFZpZXdOYW1lc3BhY2UgPSBqb2ludC5zaGFwZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgICAgIC8vIEhlcmUgaWYgYSBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIHdlIGNhbiBub3QgY2xvbmUgaXQsIGFzIHRoaXMgd291bGQgcmVzdWx0IGluIGxvb3NpbmcgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBpcyB1c2VkLCB0aGUgY2xvbmluZyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gcHJldmVudCBtb2RpZnlpbmcgdGhlIG9wdGlvbnMgb24gcHJvdG90eXBlLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdENvbm5lY3RvcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdENvbm5lY3RvciA9IGNsb25lRGVlcChkZWZhdWx0Q29ubmVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdFJvdXRlcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFJvdXRlciA9IGNsb25lRGVlcChkZWZhdWx0Um91dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdENvbm5lY3Rpb25Qb2ludCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludCA9IGNsb25lRGVlcChkZWZhdWx0Q29ubmVjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdEFuY2hvcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFuY2hvciA9IGNsb25lRGVlcChkZWZhdWx0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdExpbmtBbmNob3IpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRMaW5rQW5jaG9yID0gY2xvbmVEZWVwKGRlZmF1bHRMaW5rQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChpbnRlcmFjdGl2ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaW50ZXJhY3RpdmUgPSBhc3NpZ24oe30sIGludGVyYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChoaWdobGlnaHRpbmcpKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgaGlnaGxpZ2h0aW5nIG9wdGlvbnMgaW50byB0aGUgdXNlciBzcGVjaWZpZWQgb3B0aW9ucy5cbiAgICAgICAgICAgIG9wdGlvbnMuaGlnaGxpZ2h0aW5nID0gZGVmYXVsdHNEZWVwKHt9LCBoaWdobGlnaHRpbmcsIGRlZmF1bHRIaWdobGlnaHRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMub3JpZ2luID0gYXNzaWduKHt9LCBvcmlnaW4pO1xuICAgIH0sXG5cbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBucyA9IFYubmFtZXNwYWNlO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogbnMueGh0bWwsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYWRkQ2xhc3NOYW1lUHJlZml4KCdwYXBlci1iYWNrZ3JvdW5kJyksXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2JhY2tncm91bmQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogbnMueGh0bWwsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYWRkQ2xhc3NOYW1lUHJlZml4KCdwYXBlci1ncmlkJyksXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dyaWQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogbnMuc3ZnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3N2ZycsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ3htbG5zOnhsaW5rJzogbnMueGxpbmtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RvcjogJ3N2ZycsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYDxkZWZzPmAgZWxlbWVudCB0byB0aGUgU1ZHIGRvY3VtZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZmlsdGVycyBhbmQgZ3JhZGllbnRzLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgZGVzaXJlZCB0byBoYXZlIHRoZSBkZWZzIGRlZmluZWQgYmVmb3JlIHRoZSB2aWV3cG9ydCAoZS5nLiB0byBtYWtlIGEgUERGIGRvY3VtZW50IHBpY2sgdXAgZGVmcyBwcm9wZXJseSkuXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2RlZnMnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZGVmcydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBhZGRDbGFzc05hbWVQcmVmaXgoJ2xheWVycycpLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbGF5ZXJzJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfV07XG4gICAgfSxcblxuICAgIGhhc0xheWVyVmlldyhsYXllck5hbWUpIHtcbiAgICAgICAgcmV0dXJuICAobGF5ZXJOYW1lIGluIHRoaXMuX2xheWVycyk7XG4gICAgfSxcblxuICAgIGdldExheWVyVmlldyhsYXllck5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBfbGF5ZXJzIH0gPSB0aGlzO1xuICAgICAgICBpZiAobGF5ZXJOYW1lIGluIF9sYXllcnMpIHJldHVybiBfbGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlhLlBhcGVyOiBVbmtub3duIGxheWVyIFwiJHtsYXllck5hbWV9XCJgKTtcbiAgICB9LFxuXG4gICAgZ2V0TGF5ZXJOb2RlKGxheWVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllclZpZXcobGF5ZXJOYW1lKS5lbDtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHsgY2hpbGROb2Rlcywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdmcsIGRlZnMsIGxheWVycywgYmFja2dyb3VuZCwgZ3JpZCB9ID0gY2hpbGROb2RlcztcblxuICAgICAgICBzdmcuc3R5bGUub3ZlcmZsb3cgPSBvcHRpb25zLm92ZXJmbG93ID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG5cbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZGVmcyA9IGRlZnM7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB0aGlzLiRiYWNrZ3JvdW5kID0gJChiYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy4kZ3JpZCA9ICQoZ3JpZCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJMYXllcnMoKTtcblxuICAgICAgICBWLmVuc3VyZUlkKHN2Zyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChvcHRpb25zLmJhY2tncm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZHJhd0dyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJMYXllcnM6IGZ1bmN0aW9uKGxheWVycyA9IGRlZmF1bHRMYXllcnMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXllcnMoKTtcbiAgICAgICAgLy8gVE9ETzogTGF5ZXJzIHRvIGJlIHJlYWQgZnJvbSB0aGUgZ3JhcGggYGxheWVyc2AgYXR0cmlidXRlXG4gICAgICAgIGxheWVycy5mb3JFYWNoKCh7IG5hbWUsIHNvcnRlZCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXllclZpZXcgPSBuZXcgUGFwZXJMYXllcih7IG5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmxheWVycy5hcHBlbmRDaGlsZChsYXllclZpZXcuZWwpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdID0gbGF5ZXJWaWV3O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGNvbnN0IGNlbGxzTGF5ZXJWaWV3ID0gdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuQ0VMTFMpO1xuICAgICAgICBjb25zdCB0b29sc0xheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLlRPT0xTKTtcbiAgICAgICAgY29uc3QgbGFiZWxzTGF5ZXJWaWV3ID0gdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuTEFCRUxTKTtcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdGhpcy50b29scyA9IHRvb2xzTGF5ZXJWaWV3LmVsO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy52aWV3cG9ydCA9IGNlbGxzTGF5ZXJWaWV3LmVsO1xuICAgICAgICAvLyB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY2VsbHNMYXllclZpZXcudmVsLmFkZENsYXNzKGFkZENsYXNzTmFtZVByZWZpeCgndmlld3BvcnQnKSk7XG4gICAgICAgIGxhYmVsc0xheWVyVmlldy52ZWwuYWRkQ2xhc3MoYWRkQ2xhc3NOYW1lUHJlZml4KCd2aWV3cG9ydCcpKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBfbGF5ZXJzIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhfbGF5ZXJzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgX2xheWVyc1tuYW1lXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfbGF5ZXJzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IF9sYXllcnMgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKF9sYXllcnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBfbGF5ZXJzW25hbWVdLnJlbW92ZVBpdm90cygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYXdHcmlkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2UodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF0cml4OiBmdW5jdGlvbihjdG0pIHtcblxuICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLmxheWVycztcblxuICAgICAgICAvLyBHZXR0ZXI6XG4gICAgICAgIGlmIChjdG0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtU3RyaW5nID0gdmlld3BvcnQuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLl92aWV3cG9ydFRyYW5zZm9ybVN0cmluZyB8fCBudWxsKSA9PT0gdHJhbnNmb3JtU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBvayB0byByZXR1cm4gdGhlIGNhY2hlZCBtYXRyaXguIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGhhcyBub3QgY2hhbmdlZCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBtYXRyaXggd2FzIHN0b3JlZC5cbiAgICAgICAgICAgICAgICBjdG0gPSB0aGlzLl92aWV3cG9ydE1hdHJpeDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZpZXdwb3J0IHRyYW5zZm9ybSBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuIE1lYXN1cmUgdGhlIG1hdHJpeCBhbmQgY2FjaGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgY3RtID0gdmlld3BvcnQuZ2V0Q1RNKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRNYXRyaXggPSBjdG07XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBjYWNoZWQgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAgICAgICAgICAvLyBJZiBubyBtYXRyaXggcHJldmlvdXNseSBzdG9yZWQgdGhlIGlkZW50aXR5IG1hdHJpeCBpcyByZXR1cm5lZC5cbiAgICAgICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeChjdG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dGVyOlxuICAgICAgICBjdG0gPSBWLmNyZWF0ZVNWR01hdHJpeChjdG0pO1xuICAgICAgICB2YXIgY3RtU3RyaW5nID0gVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyhjdG0pO1xuICAgICAgICB2aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN0bVN0cmluZyk7XG5cbiAgICAgICAgdGhpcy5fdmlld3BvcnRNYXRyaXggPSBjdG07XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0VHJhbnNmb3JtU3RyaW5nID0gdmlld3BvcnQuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xpZW50TWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgodGhpcy5jZWxscy5nZXRTY3JlZW5DVE0oKSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RDb25uZWN0ZWRMaW5rc1VwZGF0ZTogZnVuY3Rpb24odmlldywgcHJpb3JpdHksIG9wdCkge1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIENlbGxWaWV3KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5tb2RlbC5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gbGlua3Nbal07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwobGluayk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rVmlldykgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGZsYWdMYWJlbHMgPSBbJ1VQREFURSddO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rLmdldFRhcmdldENlbGwoKSA9PT0gbW9kZWwpIGZsYWdMYWJlbHMucHVzaCgnVEFSR0VUJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsuZ2V0U291cmNlQ2VsbCgpID09PSBtb2RlbCkgZmxhZ0xhYmVscy5wdXNoKCdTT1VSQ0UnKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHkgKyAxLCBsaW5rVmlldy5VUERBVEVfUFJJT1JJVFkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVWaWV3VXBkYXRlKGxpbmtWaWV3LCBsaW5rVmlldy5nZXRGbGFnKGZsYWdMYWJlbHMpLCBuZXh0UHJpb3JpdHksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9yY2VQb3N0cG9uZWRWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnKSB7XG4gICAgICAgIGlmICghdmlldyB8fCAhKHZpZXcgaW5zdGFuY2VvZiBDZWxsVmlldykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgaWYgKG1vZGVsLmlzRWxlbWVudCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgoZmxhZyAmIHZpZXcuZ2V0RmxhZyhbJ1NPVVJDRScsICdUQVJHRVQnXSkpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZHVtcE9wdGlvbnMgPSB7IHNpbGVudDogdHJ1ZSB9O1xuICAgICAgICAgICAgLy8gTGlua1ZpZXcgaXMgd2FpdGluZyBmb3IgdGhlIHRhcmdldCBvciB0aGUgc291cmNlIGNlbGxWaWV3IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgY2VsbHMgYXJlIG5vdCBpbiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICB2YXIgc291cmNlRmxhZyA9IDA7XG4gICAgICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuZmluZFZpZXdCeU1vZGVsKG1vZGVsLmdldFNvdXJjZUNlbGwoKSk7XG4gICAgICAgICAgICBpZiAoc291cmNlVmlldyAmJiAhdGhpcy5pc1ZpZXdNb3VudGVkKHNvdXJjZVZpZXcpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRmxhZyA9IHRoaXMuZHVtcFZpZXcoc291cmNlVmlldywgZHVtcE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlRW5kTWFnbmV0KCdzb3VyY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRGbGFnID0gMDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRWaWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwobW9kZWwuZ2V0VGFyZ2V0Q2VsbCgpKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRWaWV3ICYmICF0aGlzLmlzVmlld01vdW50ZWQodGFyZ2V0VmlldykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRGbGFnID0gdGhpcy5kdW1wVmlldyh0YXJnZXRWaWV3LCBkdW1wT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVFbmRNYWduZXQoJ3RhcmdldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZUZsYWcgPT09IDAgJiYgdGFyZ2V0RmxhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGxlZnRvdmVyIGZsYWcgaXMgMCwgYWxsIHZpZXcgdXBkYXRlcyB3ZXJlIGRvbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmR1bXBWaWV3KHZpZXcsIGR1bXBPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlcXVlc3RWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVmlld1VwZGF0ZSh2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0KTtcbiAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLmlzQXN5bmMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNGcm96ZW4oKSB8fCAoaXNBc3luYyAmJiBvcHQuYXN5bmMgIT09IGZhbHNlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNBY3RpdmVCYXRjaCh0aGlzLlVQREFURV9ERUxBWUlOR19CQVRDSEVTKSkgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLnVwZGF0ZVZpZXdzKG9wdCk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB0aGlzLm5vdGlmeUFmdGVyUmVuZGVyKHN0YXRzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBzY2hlZHVsZVZpZXdVcGRhdGU6IGZ1bmN0aW9uKHZpZXcsIHR5cGUsIHByaW9yaXR5LCBvcHQpIHtcbiAgICAgICAgY29uc3QgeyBfdXBkYXRlczogdXBkYXRlcywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHVwZGF0ZXMuaWRsZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0ZyZWV6ZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuaWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5mcmVlemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IEZMQUdfUkVNT1ZFLCBGTEFHX0lOU0VSVCwgVVBEQVRFX1BSSU9SSVRZLCBjaWQgfSA9IHZpZXc7XG4gICAgICAgIGxldCBwcmlvcml0eVVwZGF0ZXMgPSB1cGRhdGVzLnByaW9yaXRpZXNbcHJpb3JpdHldO1xuICAgICAgICBpZiAoIXByaW9yaXR5VXBkYXRlcykgcHJpb3JpdHlVcGRhdGVzID0gdXBkYXRlcy5wcmlvcml0aWVzW3ByaW9yaXR5XSA9IHt9O1xuICAgICAgICAvLyBNb3ZlIGhpZ2hlciBwcmlvcml0eSB1cGRhdGVzIHRvIHRoaXMgcHJpb3JpdHlcbiAgICAgICAgaWYgKHByaW9yaXR5ID4gVVBEQVRFX1BSSU9SSVRZKSB7XG4gICAgICAgICAgICAvLyBOb3QgdGhlIGRlZmF1bHQgcHJpb3JpdHkgZm9yIHRoaXMgdmlldy4gSXQncyBtb3N0IGxpa2VseSBhIGxpbmsgdmlld1xuICAgICAgICAgICAgLy8gY29ubmVjdGVkIHRvIGFub3RoZXIgbGluayB2aWV3LCB3aGljaCB0cmlnZ2VyZWQgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIHVwZGF0ZSBzY2hlZHVsZWQgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGFscmVhZHksIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSByZXF1ZXN0ZWQgcHJpb3JpdHkgdG8gdGhlIGxvd2VzdCBvbmUuIERvZXMgbm90IHNlZW0gdG8gYmUgY3JpdGljYWxcbiAgICAgICAgICAgIC8vIHJpZ2h0IG5vdywgYXMgaXQgXCJvbmx5XCIgcmVzdWx0cyBpbiBtdWx0aXBsZSB1cGRhdGVzIG9uIHRoZSBzYW1lIHZpZXcuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJpb3JpdHkgLSAxOyBpID49IFVQREFURV9QUklPUklUWTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlByaW9yaXR5VXBkYXRlcyA9IHVwZGF0ZXMucHJpb3JpdGllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZQcmlvcml0eVVwZGF0ZXMgfHwgIShjaWQgaW4gcHJldlByaW9yaXR5VXBkYXRlcykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5VXBkYXRlc1tjaWRdIHw9IHByZXZQcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJldlByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VHlwZSA9IHByaW9yaXR5VXBkYXRlc1tjaWRdIHx8IDA7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGluZ1xuICAgICAgICBpZiAoKGN1cnJlbnRUeXBlICYgdHlwZSkgPT09IHR5cGUpIHJldHVybjtcbiAgICAgICAgaWYgKCFjdXJyZW50VHlwZSkgdXBkYXRlcy5jb3VudCsrO1xuICAgICAgICBpZiAodHlwZSAmIEZMQUdfUkVNT1ZFICYmIGN1cnJlbnRUeXBlICYgRkxBR19JTlNFUlQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB2aWV3IGlzIHJlbW92ZWQgd2UgbmVlZCB0byByZW1vdmUgdGhlIGluc2VydCBmbGFnIGFzIHRoaXMgaXMgYSByZWluc2VydFxuICAgICAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gXj0gRkxBR19JTlNFUlQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAmIEZMQUdfSU5TRVJUICYmIGN1cnJlbnRUeXBlICYgRkxBR19SRU1PVkUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB2aWV3IGlzIGFkZGVkIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZW1vdmUgZmxhZyBhcyB0aGlzIGlzIHZpZXcgd2FzIHByZXZpb3VzbHkgcmVtb3ZlZFxuICAgICAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gXj0gRkxBR19SRU1PVkU7XG4gICAgICAgIH1cbiAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gfD0gdHlwZTtcbiAgICAgICAgY29uc3Qgdmlld1VwZGF0ZUZuID0gb3B0aW9ucy5vblZpZXdVcGRhdGU7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld1VwZGF0ZUZuID09PSAnZnVuY3Rpb24nKSB2aWV3VXBkYXRlRm4uY2FsbCh0aGlzLCB2aWV3LCB0eXBlLCBwcmlvcml0eSwgb3B0IHx8IHt9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZHVtcFZpZXdVcGRhdGU6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gMDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciBwcmlvcml0eVVwZGF0ZXMgPSB1cGRhdGVzLnByaW9yaXRpZXNbdmlldy5VUERBVEVfUFJJT1JJVFldO1xuICAgICAgICB2YXIgZmxhZyA9IHRoaXMucmVnaXN0ZXJNb3VudGVkVmlldyh2aWV3KSB8IHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBkdW1wVmlldzogZnVuY3Rpb24odmlldywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuZHVtcFZpZXdVcGRhdGUodmlldyk7XG4gICAgICAgIGlmICghZmxhZykgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHNob3VsZE5vdGlmeSA9ICFvcHQuc2lsZW50O1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB0aGlzLm5vdGlmeUJlZm9yZVJlbmRlcihvcHQpO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlciA9IHRoaXMudXBkYXRlVmlldyh2aWV3LCBmbGFnLCBvcHQpO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHsgdXBkYXRlZDogMSwgcHJpb3JpdHk6IHZpZXcuVVBEQVRFX1BSSU9SSVRZIH07XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFmdGVyUmVuZGVyKHN0YXRzLCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0b3ZlcjtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlldzogZnVuY3Rpb24odmlldywgZmxhZywgb3B0KSB7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHsgRkxBR19SRU1PVkUsIEZMQUdfSU5TRVJULCBGTEFHX0lOSVQsIG1vZGVsIH0gPSB2aWV3O1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIENlbGxWaWV3KSB7XG4gICAgICAgICAgICBpZiAoZmxhZyAmIEZMQUdfUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVWaWV3KG1vZGVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFnICYgRkxBR19JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luaXRpYWxJbnNlcnQgPSAhIShmbGFnICYgRkxBR19JTklUKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgXj0gRkxBR19JTklUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydFZpZXcodmlldywgaXNJbml0aWFsSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICBmbGFnIF49IEZMQUdfSU5TRVJUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhZykgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB2aWV3LmNvbmZpcm1VcGRhdGUoZmxhZywgb3B0IHx8IHt9KTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZVZpZXc6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChtb2RlbCk7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuZHVtcFZpZXcodmlldywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyVW5tb3VudGVkVmlldzogZnVuY3Rpb24odmlldykge1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgaWYgKGNpZCBpbiB1cGRhdGVzLnVubW91bnRlZCkgcmV0dXJuIDA7XG4gICAgICAgIHZhciBmbGFnID0gdXBkYXRlcy51bm1vdW50ZWRbY2lkXSB8PSB2aWV3LkZMQUdfSU5TRVJUO1xuICAgICAgICB1cGRhdGVzLnVubW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICBkZWxldGUgdXBkYXRlcy5tb3VudGVkW2NpZF07XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICByZWdpc3Rlck1vdW50ZWRWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIHZhciBjaWQgPSB2aWV3LmNpZDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICBpZiAoY2lkIGluIHVwZGF0ZXMubW91bnRlZCkgcmV0dXJuIDA7XG4gICAgICAgIHVwZGF0ZXMubW91bnRlZFtjaWRdID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlcy5tb3VudGVkQ2lkcy5wdXNoKGNpZCk7XG4gICAgICAgIHZhciBmbGFnID0gdXBkYXRlcy51bm1vdW50ZWRbY2lkXSB8fCAwO1xuICAgICAgICBkZWxldGUgdXBkYXRlcy51bm1vdW50ZWRbY2lkXTtcbiAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgfSxcblxuICAgIGlzVmlld01vdW50ZWQ6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaWQgPSB2aWV3LmNpZDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICByZXR1cm4gKGNpZCBpbiB1cGRhdGVzLm1vdW50ZWQpO1xuICAgIH0sXG5cbiAgICBkdW1wVmlld3M6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgcGFzc2luZ09wdCA9IGRlZmF1bHRzKHt9LCBvcHQsIHsgdmlld3BvcnQ6IG51bGwgfSk7XG4gICAgICAgIHRoaXMuY2hlY2tWaWV3cG9ydChwYXNzaW5nT3B0KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cyhwYXNzaW5nT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gU3luY2hyb25vdXMgdmlld3MgdXBkYXRlXG4gICAgdXBkYXRlVmlld3M6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB0aGlzLm5vdGlmeUJlZm9yZVJlbmRlcihvcHQpO1xuICAgICAgICBsZXQgYmF0Y2hTdGF0cztcbiAgICAgICAgbGV0IHVwZGF0ZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGJhdGNoQ291bnQgPSAwO1xuICAgICAgICBsZXQgcHJpb3JpdHkgPSBNSU5fUFJJT1JJVFk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGJhdGNoQ291bnQrKztcbiAgICAgICAgICAgIGJhdGNoU3RhdHMgPSB0aGlzLnVwZGF0ZVZpZXdzQmF0Y2gob3B0KTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50ICs9IGJhdGNoU3RhdHMudXBkYXRlZDtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gTWF0aC5taW4oYmF0Y2hTdGF0cy5wcmlvcml0eSwgcHJpb3JpdHkpO1xuICAgICAgICB9IHdoaWxlICghYmF0Y2hTdGF0cy5lbXB0eSk7XG4gICAgICAgIGNvbnN0IHN0YXRzID0geyB1cGRhdGVkOiB1cGRhdGVDb3VudCwgYmF0Y2hlczogYmF0Y2hDb3VudCwgcHJpb3JpdHkgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlBZnRlclJlbmRlcihzdGF0cywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH0sXG5cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMuX3VwZGF0ZXMucHJpb3JpdGllcztcbiAgICAgICAgY29uc3QgcHJpb3JpdHlJbmRleGVzID0gT2JqZWN0LmtleXMocHJpb3JpdGllcyk7IC8vIGNvbnZlcnQgcHJpb3JpdGllcyB0byBhIGRlbnNlIGFycmF5XG4gICAgICAgIGxldCBpID0gcHJpb3JpdHlJbmRleGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIGktLSkge1xuICAgICAgICAgICAgLy8gYSBmYXN0ZXIgd2F5IGhvdyB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgICAgICAgIGZvciAobGV0IF9rZXkgaW4gcHJpb3JpdGllc1twcmlvcml0eUluZGV4ZXNbaV1dKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpZXdzQXN5bmM6IGZ1bmN0aW9uKG9wdCwgZGF0YSkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHsgcHJvY2Vzc2VkOiAwLCBwcmlvcml0eTogTUlOX1BSSU9SSVRZIH0pO1xuICAgICAgICBjb25zdCB7IF91cGRhdGVzOiB1cGRhdGVzLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpZCA9IHVwZGF0ZXMuaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUoaWQpO1xuICAgICAgICAgICAgaWYgKGRhdGEucHJvY2Vzc2VkID09PSAwICYmIHRoaXMuaGFzU2NoZWR1bGVkVXBkYXRlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlCZWZvcmVSZW5kZXIob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy51cGRhdGVWaWV3c0JhdGNoKG9wdCk7XG4gICAgICAgICAgICBjb25zdCBwYXNzaW5nT3B0ID0gZGVmYXVsdHMoe30sIG9wdCwge1xuICAgICAgICAgICAgICAgIG1vdW50QmF0Y2hTaXplOiBNT1VOVF9CQVRDSF9TSVpFIC0gc3RhdHMubW91bnRlZCxcbiAgICAgICAgICAgICAgICB1bm1vdW50QmF0Y2hTaXplOiBNT1VOVF9CQVRDSF9TSVpFIC0gc3RhdHMudW5tb3VudGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrU3RhdHMgPSB0aGlzLmNoZWNrVmlld3BvcnQocGFzc2luZ09wdCk7XG4gICAgICAgICAgICBjb25zdCB1bm1vdW50Q291bnQgPSBjaGVja1N0YXRzLnVubW91bnRlZDtcbiAgICAgICAgICAgIGNvbnN0IG1vdW50Q291bnQgPSBjaGVja1N0YXRzLm1vdW50ZWQ7XG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZGF0YS5wcm9jZXNzZWQ7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IHVwZGF0ZXMuY291bnQ7XG4gICAgICAgICAgICBpZiAoc3RhdHMudXBkYXRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHVwZGF0ZXMgaGF2ZSBiZWVuIGp1c3QgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkICs9IHN0YXRzLnVwZGF0ZWQgKyBzdGF0cy51bm1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgc3RhdHMucHJvY2Vzc2VkID0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgIGRhdGEucHJpb3JpdHkgPSBNYXRoLm1pbihzdGF0cy5wcmlvcml0eSwgZGF0YS5wcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmVtcHR5ICYmIG1vdW50Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudW5tb3VudGVkICs9IHVubW91bnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMubW91bnRlZCArPSBtb3VudENvdW50O1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5wcmlvcml0eSA9IGRhdGEucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5QWZ0ZXJSZW5kZXIoc3RhdHMsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcmlvcml0eSA9IE1JTl9QUklPUklUWTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZXMuaWRsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvRnJlZXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5pZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyOmlkbGUnLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzRm4gPSBvcHQucHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAodG90YWwgJiYgdHlwZW9mIHByb2dyZXNzRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuLmNhbGwodGhpcywgc3RhdHMuZW1wdHksIHByb2Nlc3NlZCwgdG90YWwsIHN0YXRzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGZyYW1lIGNvdWxkIGhhdmUgYmVlbiBjYW5jZWxlZCBpbiBhIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodXBkYXRlcy5pZCAhPT0gaWQpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuUGFwZXI6IGNhbiBub3QgdW5mcmVlemUgdGhlIHBhcGVyIGFmdGVyIGl0IHdhcyByZW1vdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlcy5pZCA9IG5leHRGcmFtZSh0aGlzLnVwZGF0ZVZpZXdzQXN5bmMsIHRoaXMsIG9wdCwgZGF0YSk7XG4gICAgfSxcblxuICAgIG5vdGlmeUJlZm9yZVJlbmRlcjogZnVuY3Rpb24ob3B0ID0ge30pIHtcbiAgICAgICAgbGV0IGJlZm9yZUZuID0gb3B0LmJlZm9yZVJlbmRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmVmb3JlRm4gPSB0aGlzLm9wdGlvbnMuYmVmb3JlUmVuZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVGbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUZuLmNhbGwodGhpcywgb3B0LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgbm90aWZ5QWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKHN0YXRzLCBvcHQgPSB7fSkge1xuICAgICAgICBsZXQgYWZ0ZXJGbiA9IG9wdC5hZnRlclJlbmRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBhZnRlckZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhZnRlckZuID0gdGhpcy5vcHRpb25zLmFmdGVyUmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYWZ0ZXJGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWZ0ZXJGbi5jYWxsKHRoaXMsIHN0YXRzLCBvcHQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyOmRvbmUnLCBzdGF0cywgb3B0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlld3NCYXRjaDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gb3B0LmJhdGNoU2l6ZSB8fCBVUERBVEVfQkFUQ0hfU0laRTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgdXBkYXRlQ291bnQgPSAwO1xuICAgICAgICB2YXIgcG9zdHBvbmVDb3VudCA9IDA7XG4gICAgICAgIHZhciB1bm1vdW50Q291bnQgPSAwO1xuICAgICAgICB2YXIgbW91bnRDb3VudCA9IDA7XG4gICAgICAgIHZhciBtYXhQcmlvcml0eSA9IE1JTl9QUklPUklUWTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBwcmlvcml0aWVzID0gdXBkYXRlcy5wcmlvcml0aWVzO1xuICAgICAgICB2YXIgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gb3B0ID8gb3B0LnZpZXdwb3J0IDogb3B0aW9ucy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSB2aWV3cG9ydEZuID0gbnVsbDtcbiAgICAgICAgdmFyIHBvc3Rwb25lVmlld0ZuID0gb3B0aW9ucy5vblZpZXdQb3N0cG9uZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zdHBvbmVWaWV3Rm4gIT09ICdmdW5jdGlvbicpIHBvc3Rwb25lVmlld0ZuID0gbnVsbDtcbiAgICAgICAgdmFyIHByaW9yaXR5SW5kZXhlcyA9IE9iamVjdC5rZXlzKHByaW9yaXRpZXMpOyAvLyBjb252ZXJ0IHByaW9yaXRpZXMgdG8gYSBkZW5zZSBhcnJheVxuICAgICAgICBtYWluOiBmb3IgKHZhciBpID0gMCwgbiA9IHByaW9yaXR5SW5kZXhlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0eSA9ICtwcmlvcml0eUluZGV4ZXNbaV07XG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlVcGRhdGVzID0gcHJpb3JpdGllc1twcmlvcml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBjaWQgaW4gcHJpb3JpdHlVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUNvdW50ID49IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBtYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBvY2N1clxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZsYWcgPSBwcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRGbGFnICYgdmlldy5GTEFHX1JFTU9WRSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGNoZWNrIGEgdmlldyBmb3Igdmlld3BvcnQgaWYgd2UgYXJlIGFib3V0IHRvIHJlbW92ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEZXRhY2hlZCA9IGNpZCBpbiB1cGRhdGVzLnVubW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcuREVUQUNIQUJMRSAmJiB2aWV3cG9ydEZuICYmICF2aWV3cG9ydEZuLmNhbGwodGhpcywgdmlldywgIWlzRGV0YWNoZWQsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbm1vdW50IFZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMudW5tb3VudGVkW2NpZF0gfD0gY3VycmVudEZsYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdW50IFZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGbGFnIHw9IHZpZXcuRkxBR19JTlNFUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZsYWcgfD0gdGhpcy5yZWdpc3Rlck1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVmdG92ZXJGbGFnID0gdGhpcy51cGRhdGVWaWV3KHZpZXcsIGN1cnJlbnRGbGFnLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0b3ZlckZsYWcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZpZXcgdXBkYXRlIGhhcyBub3QgZmluaXNoZWQgY29tcGxldGVseVxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eVVwZGF0ZXNbY2lkXSA9IGxlZnRvdmVyRmxhZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3N0cG9uZVZpZXdGbiB8fCAhcG9zdHBvbmVWaWV3Rm4uY2FsbCh0aGlzLCB2aWV3LCBsZWZ0b3ZlckZsYWcsIHRoaXMpIHx8IHByaW9yaXR5VXBkYXRlc1tjaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heFByaW9yaXR5ID4gcHJpb3JpdHkpIG1heFByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnQrKztcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaW9yaXR5OiBtYXhQcmlvcml0eSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IHVwZGF0ZUNvdW50LFxuICAgICAgICAgICAgcG9zdHBvbmVkOiBwb3N0cG9uZUNvdW50LFxuICAgICAgICAgICAgdW5tb3VudGVkOiB1bm1vdW50Q291bnQsXG4gICAgICAgICAgICBtb3VudGVkOiBtb3VudENvdW50LFxuICAgICAgICAgICAgZW1wdHk6IGVtcHR5XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFVubW91bnRlZFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGNvbnN0IHVubW91bnRlZENpZHMgPSBPYmplY3Qua2V5cyh1cGRhdGVzLnVubW91bnRlZCk7XG4gICAgICAgIGNvbnN0IG4gPSB1bm1vdW50ZWRDaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdW5tb3VudGVkVmlld3MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB1bm1vdW50ZWRWaWV3c1tpXSA9IHZpZXdzW3VubW91bnRlZENpZHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bm1vdW50ZWRWaWV3cztcbiAgICB9LFxuXG4gICAgZ2V0TW91bnRlZFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGNvbnN0IG1vdW50ZWRDaWRzID0gT2JqZWN0LmtleXModXBkYXRlcy5tb3VudGVkKTtcbiAgICAgICAgY29uc3QgbiA9IG1vdW50ZWRDaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbW91bnRlZFZpZXdzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbW91bnRlZFZpZXdzW2ldID0gdmlld3NbbW91bnRlZENpZHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3VudGVkVmlld3M7XG4gICAgfSxcblxuICAgIGNoZWNrVW5tb3VudGVkVmlld3M6IGZ1bmN0aW9uKHZpZXdwb3J0Rm4sIG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCAgPSB7fSk7XG4gICAgICAgIHZhciBtb3VudENvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSB2aWV3cG9ydEZuID0gbnVsbDtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9ICdtb3VudEJhdGNoU2l6ZScgaW4gb3B0ID8gb3B0Lm1vdW50QmF0Y2hTaXplIDogSW5maW5pdHk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIHVubW91bnRlZENpZHMgPSB1cGRhdGVzLnVubW91bnRlZENpZHM7XG4gICAgICAgIHZhciB1bm1vdW50ZWQgPSB1cGRhdGVzLnVubW91bnRlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBNYXRoLm1pbih1bm1vdW50ZWRDaWRzLmxlbmd0aCwgYmF0Y2hTaXplKTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNpZCA9IHVubW91bnRlZENpZHNbaV07XG4gICAgICAgICAgICBpZiAoIShjaWQgaW4gdW5tb3VudGVkKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICBpZiAoIXZpZXcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHZpZXcuREVUQUNIQUJMRSAmJiB2aWV3cG9ydEZuICYmICF2aWV3cG9ydEZuLmNhbGwodGhpcywgdmlldywgZmFsc2UsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhdCB0aGUgZW5kIG9mIGFsbCB1bm1vdW50ZWQgaWRzLCBzbyB0aGlzIGNhbiBiZSBjaGVjayBsYXRlciBhZ2FpblxuICAgICAgICAgICAgICAgIHVubW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91bnRDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLnJlZ2lzdGVyTW91bnRlZFZpZXcodmlldyk7XG4gICAgICAgICAgICBpZiAoZmxhZykgdGhpcy5zY2hlZHVsZVZpZXdVcGRhdGUodmlldywgZmxhZywgdmlldy5VUERBVEVfUFJJT1JJVFksIHsgbW91bnRpbmc6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiB2aWV3cywgdGhhdCBoYXZlIGJlZW4gbW91bnRlZFxuICAgICAgICB1bm1vdW50ZWRDaWRzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q291bnQ7XG4gICAgfSxcblxuICAgIGNoZWNrTW91bnRlZFZpZXdzOiBmdW5jdGlvbih2aWV3cG9ydEZuLCBvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciB1bm1vdW50Q291bnQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0Rm4gIT09ICdmdW5jdGlvbicpIHJldHVybiB1bm1vdW50Q291bnQ7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSAndW5tb3VudEJhdGNoU2l6ZScgaW4gb3B0ID8gb3B0LnVubW91bnRCYXRjaFNpemUgOiBJbmZpbml0eTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgbW91bnRlZENpZHMgPSB1cGRhdGVzLm1vdW50ZWRDaWRzO1xuICAgICAgICB2YXIgbW91bnRlZCA9IHVwZGF0ZXMubW91bnRlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBNYXRoLm1pbihtb3VudGVkQ2lkcy5sZW5ndGgsIGJhdGNoU2l6ZSk7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaWQgPSBtb3VudGVkQ2lkc1tpXTtcbiAgICAgICAgICAgIGlmICghKGNpZCBpbiBtb3VudGVkKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICBpZiAoIXZpZXcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCF2aWV3LkRFVEFDSEFCTEUgfHwgdmlld3BvcnRGbi5jYWxsKHRoaXMsIHZpZXcsIHRydWUsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhdCB0aGUgZW5kIG9mIGFsbCBtb3VudGVkIGlkcywgc28gdGhpcyBjYW4gYmUgY2hlY2sgbGF0ZXIgYWdhaW5cbiAgICAgICAgICAgICAgICBtb3VudGVkQ2lkcy5wdXNoKGNpZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bm1vdW50Q291bnQrKztcbiAgICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5yZWdpc3RlclVubW91bnRlZFZpZXcodmlldyk7XG4gICAgICAgICAgICBpZiAoZmxhZykgdGhpcy5kZXRhY2hWaWV3KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByaWQgb2Ygdmlld3MsIHRoYXQgaGF2ZSBiZWVuIHVubW91bnRlZFxuICAgICAgICBtb3VudGVkQ2lkcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybiB1bm1vdW50Q291bnQ7XG4gICAgfSxcblxuICAgIGNoZWNrVmlld1Zpc2liaWxpdHk6IGZ1bmN0aW9uKGNlbGxWaWV3LCBvcHQgPSB7fSkge1xuICAgICAgICBsZXQgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gb3B0ID8gb3B0LnZpZXdwb3J0IDogdGhpcy5vcHRpb25zLnZpZXdwb3J0O1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0Rm4gIT09ICdmdW5jdGlvbicpIHZpZXdwb3J0Rm4gPSBudWxsO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgY29uc3QgeyBtb3VudGVkLCB1bm1vdW50ZWQgfSA9IHVwZGF0ZXM7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSAhY2VsbFZpZXcuREVUQUNIQUJMRSB8fCAhdmlld3BvcnRGbiB8fCB2aWV3cG9ydEZuLmNhbGwodGhpcywgY2VsbFZpZXcsIGZhbHNlLCB0aGlzKTtcblxuICAgICAgICBsZXQgaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjZWxsVmlldy5jaWQgaW4gbW91bnRlZCAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KGNlbGxWaWV3KTtcbiAgICAgICAgICAgIGlmIChmbGFnKSB0aGlzLmRldGFjaFZpZXcoY2VsbFZpZXcpO1xuICAgICAgICAgICAgY29uc3QgaSA9IHVwZGF0ZXMubW91bnRlZENpZHMuaW5kZXhPZihjZWxsVmlldy5jaWQpO1xuICAgICAgICAgICAgdXBkYXRlcy5tb3VudGVkQ2lkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVW5tb3VudGVkICYmIGNlbGxWaWV3LmNpZCBpbiB1bm1vdW50ZWQgJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHVwZGF0ZXMudW5tb3VudGVkQ2lkcy5pbmRleE9mKGNlbGxWaWV3LmNpZCk7XG4gICAgICAgICAgICB1cGRhdGVzLnVubW91bnRlZENpZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLnJlZ2lzdGVyTW91bnRlZFZpZXcoY2VsbFZpZXcpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHRoaXMuc2NoZWR1bGVWaWV3VXBkYXRlKGNlbGxWaWV3LCBmbGFnLCBjZWxsVmlldy5VUERBVEVfUFJJT1JJVFksIHsgbW91bnRpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdW50ZWQ6IGlzTW91bnRlZCA/IDEgOiAwLFxuICAgICAgICAgICAgdW5tb3VudGVkOiBpc1VubW91bnRlZCA/IDEgOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNoZWNrVmlld3BvcnQ6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgcGFzc2luZ09wdCA9IGRlZmF1bHRzKHt9LCBvcHQsIHtcbiAgICAgICAgICAgIG1vdW50QmF0Y2hTaXplOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHVubW91bnRCYXRjaFNpemU6IEluZmluaXR5XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gcGFzc2luZ09wdCA/IHBhc3NpbmdPcHQudmlld3BvcnQgOiB0aGlzLm9wdGlvbnMudmlld3BvcnQ7XG4gICAgICAgIHZhciB1bm1vdW50ZWRDb3VudCA9IHRoaXMuY2hlY2tNb3VudGVkVmlld3Modmlld3BvcnRGbiwgcGFzc2luZ09wdCk7XG4gICAgICAgIGlmICh1bm1vdW50ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayB2aWV3cywgdGhhdCBoYXZlIGJlZW4ganVzdCB1bm1vdW50ZWQgYW5kIHB1c2hlZCBhdCB0aGUgZW5kIG9mIHRoZSBjaWRzIGFycmF5XG4gICAgICAgICAgICB2YXIgdW5tb3VudGVkQ2lkcyA9IHRoaXMuX3VwZGF0ZXMudW5tb3VudGVkQ2lkcztcbiAgICAgICAgICAgIHBhc3NpbmdPcHQubW91bnRCYXRjaFNpemUgPSBNYXRoLm1pbih1bm1vdW50ZWRDaWRzLmxlbmd0aCAtIHVubW91bnRlZENvdW50LCBwYXNzaW5nT3B0Lm1vdW50QmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW91bnRlZENvdW50ID0gdGhpcy5jaGVja1VubW91bnRlZFZpZXdzKHZpZXdwb3J0Rm4sIHBhc3NpbmdPcHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW91bnRlZDogbW91bnRlZENvdW50LFxuICAgICAgICAgICAgdW5tb3VudGVkOiB1bm1vdW50ZWRDb3VudFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBmcmVlemU6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIga2V5ID0gb3B0LmtleTtcbiAgICAgICAgdmFyIGlzRnJvemVuID0gdGhpcy5vcHRpb25zLmZyb3plbjtcbiAgICAgICAgdmFyIGZyZWV6ZUtleSA9IHVwZGF0ZXMuZnJlZXplS2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGtleSAhPT0gZnJlZXplS2V5KSAge1xuICAgICAgICAgICAgLy8ga2V5IHBhc3NlZCwgYnV0IHRoZSBwYXBlciBpcyBhbHJlYWR5IGZyZWV6ZWQgd2l0aCBhbm90aGVyIGtleVxuICAgICAgICAgICAgaWYgKGlzRnJvemVuICYmIGZyZWV6ZUtleSkgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlcy5mcmVlemVLZXkgPSBrZXk7XG4gICAgICAgICAgICB1cGRhdGVzLmtleUZyb3plbiA9IGlzRnJvemVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB1cGRhdGVzLmlkO1xuICAgICAgICB1cGRhdGVzLmlkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpICYmIGlkKSBjYW5jZWxGcmFtZShpZCk7XG4gICAgfSxcblxuICAgIHVuZnJlZXplOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIGtleSA9IG9wdC5rZXk7XG4gICAgICAgIHZhciBmcmVlemVLZXkgPSB1cGRhdGVzLmZyZWV6ZUtleTtcbiAgICAgICAgLy8ga2V5IHBhc3NlZCwgYnV0IHRoZSBwYXBlciBpcyBhbHJlYWR5IGZyZWV6ZWQgd2l0aCBhbm90aGVyIGtleVxuICAgICAgICBpZiAoa2V5ICYmIGZyZWV6ZUtleSAmJiBrZXkgIT09IGZyZWV6ZUtleSkgcmV0dXJuO1xuICAgICAgICB1cGRhdGVzLmZyZWV6ZUtleSA9IG51bGw7XG4gICAgICAgIC8vIGtleSBwYXNzZWQsIGJ1dCB0aGUgcGFwZXIgaXMgYWxyZWFkeSBmcmVlemVkXG4gICAgICAgIGlmIChrZXkgJiYga2V5ID09PSBmcmVlemVLZXkgJiYgdXBkYXRlcy5rZXlGcm96ZW4pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3c0FzeW5jKG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdzKG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmZyb3plbiA9IHVwZGF0ZXMua2V5RnJvemVuID0gZmFsc2U7XG4gICAgICAgIGlmICh1cGRhdGVzLnNvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFZpZXdzKCk7XG4gICAgICAgICAgICB1cGRhdGVzLnNvcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0FzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRpb25zLmFzeW5jO1xuICAgIH0sXG5cbiAgICBpc0Zyb3plbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9ucy5mcm96ZW47XG4gICAgfSxcblxuICAgIGlzRXhhY3RTb3J0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0aW5nID09PSBzb3J0aW5nVHlwZXMuRVhBQ1Q7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgLy9jbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzL3ZpZXdzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgIHRoaXMucmVtb3ZlTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld3MoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29tcHV0ZWRTaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHcgPSBvcHRpb25zLndpZHRoO1xuICAgICAgICB2YXIgaCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICBpZiAoIWlzTnVtYmVyKHcpKSB3ID0gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKCFpc051bWJlcihoKSkgaCA9IHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICByZXR1cm4geyB3aWR0aDogdywgaGVpZ2h0OiBoIH07XG4gICAgfSxcblxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBjdXJyZW50V2lkdGgsIGhlaWdodDogY3VycmVudEhlaWdodCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHcgPSAod2lkdGggPT09IHVuZGVmaW5lZCkgPyBjdXJyZW50V2lkdGggOiB3aWR0aDtcbiAgICAgICAgbGV0IGggPSAoaGVpZ2h0ID09PSB1bmRlZmluZWQpID8gY3VycmVudEhlaWdodCA6IGhlaWdodDtcbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gdyAmJiBjdXJyZW50SGVpZ2h0ID09PSBoKSByZXR1cm47XG4gICAgICAgIG9wdGlvbnMud2lkdGggPSB3O1xuICAgICAgICBvcHRpb25zLmhlaWdodCA9IGg7XG4gICAgICAgIHRoaXMuX3NldERpbWVuc2lvbnMoKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWRTaXplID0gdGhpcy5nZXRDb21wdXRlZFNpemUoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXNpemUnLCBjb21wdXRlZFNpemUud2lkdGgsIGNvbXB1dGVkU2l6ZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBfc2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHcgPSBvcHRpb25zLndpZHRoO1xuICAgICAgICBsZXQgaCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICBpZiAoaXNOdW1iZXIodykpIHcgPSBNYXRoLnJvdW5kKHcpO1xuICAgICAgICBpZiAoaXNOdW1iZXIoaCkpIGggPSBNYXRoLnJvdW5kKGgpO1xuICAgICAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6ICh3ID09PSBudWxsKSA/ICcnIDogdyxcbiAgICAgICAgICAgIGhlaWdodDogKGggPT09IG51bGwpID8gJycgOiBoXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXRPcmlnaW46IGZ1bmN0aW9uKG94LCBveSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUob3ggfHwgMCwgb3kgfHwgMCk7XG4gICAgfSxcblxuICAgIC8vIEV4cGFuZC9zaHJpbmsgdGhlIHBhcGVyIHRvIGZpdCB0aGUgY29udGVudC5cbiAgICAvLyBBbHRlcm5hdGl2ZWx5IHNpZ25hdHVyZSBmdW5jdGlvbihvcHQpXG4gICAgZml0VG9Db250ZW50OiBmdW5jdGlvbihncmlkV2lkdGgsIGdyaWRIZWlnaHQsIHBhZGRpbmcsIG9wdCkge1xuXG4gICAgICAgIGlmIChpc09iamVjdChncmlkV2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgb3B0ID0gZ3JpZFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgYSBkZXByZWNhdGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgb3B0ID0gYXNzaWduKHsgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0LCBwYWRkaW5nIH0sIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuZ2V0Rml0VG9Db250ZW50QXJlYShvcHQpO1xuICAgICAgICBjb25zdCB7IHN4LCBzeSB9ID0gdGhpcy5zY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKC14ICogc3gsIC15ICogc3kpO1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMod2lkdGggKiBzeCwgaGVpZ2h0ICogc3kpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0Rml0VG9Db250ZW50QXJlYTogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBhcGVyIHNpemUgdG8gYWNjb21tb2RhdGUgYWxsIHRoZSBncmFwaCdzIGVsZW1lbnRzLlxuXG4gICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IG9wdC5ncmlkV2lkdGggfHwgMTtcbiAgICAgICAgY29uc3QgZ3JpZEhlaWdodCA9IG9wdC5ncmlkSGVpZ2h0IHx8IDE7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyB8fCAwKTtcblxuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IE1hdGgubWF4KG9wdC5taW5XaWR0aCB8fCAwLCBncmlkV2lkdGgpO1xuICAgICAgICBjb25zdCBtaW5IZWlnaHQgPSBNYXRoLm1heChvcHQubWluSGVpZ2h0IHx8IDAsIGdyaWRIZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IG9wdC5tYXhXaWR0aCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBvcHQubWF4SGVpZ2h0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IG9wdC5hbGxvd05ld09yaWdpbjtcblxuICAgICAgICBjb25zdCBhcmVhID0gKCdjb250ZW50QXJlYScgaW4gb3B0KSA/IG5ldyBSZWN0KG9wdC5jb250ZW50QXJlYSkgOiB0aGlzLmdldENvbnRlbnRBcmVhKG9wdCk7XG4gICAgICAgIGNvbnN0IHsgc3gsIHN5IH0gPSB0aGlzLnNjYWxlKCk7XG4gICAgICAgIGFyZWEueCAqPSBzeDtcbiAgICAgICAgYXJlYS55ICo9IHN5O1xuICAgICAgICBhcmVhLndpZHRoICo9IHN4O1xuICAgICAgICBhcmVhLmhlaWdodCAqPSBzeTtcblxuICAgICAgICBsZXQgY2FsY1dpZHRoID0gTWF0aC5jZWlsKChhcmVhLndpZHRoICsgYXJlYS54KSAvIGdyaWRXaWR0aCk7XG4gICAgICAgIGxldCBjYWxjSGVpZ2h0ID0gTWF0aC5jZWlsKChhcmVhLmhlaWdodCArIGFyZWEueSkgLyBncmlkSGVpZ2h0KTtcbiAgICAgICAgaWYgKCFvcHQuYWxsb3dOZWdhdGl2ZUJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICBjYWxjV2lkdGggPSBNYXRoLm1heChjYWxjV2lkdGgsIDEpO1xuICAgICAgICAgICAgY2FsY0hlaWdodCA9IE1hdGgubWF4KGNhbGNIZWlnaHQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGNXaWR0aCAqPSBncmlkV2lkdGg7XG4gICAgICAgIGNhbGNIZWlnaHQgKj0gZ3JpZEhlaWdodDtcblxuICAgICAgICBsZXQgdHggPSAwO1xuICAgICAgICBpZiAoKG5ld09yaWdpbiA9PT0gJ25lZ2F0aXZlJyAmJiBhcmVhLnggPCAwKSB8fCAobmV3T3JpZ2luID09PSAncG9zaXRpdmUnICYmIGFyZWEueCA+PSAwKSB8fCBuZXdPcmlnaW4gPT09ICdhbnknKSB7XG4gICAgICAgICAgICB0eCA9IE1hdGguY2VpbCgtYXJlYS54IC8gZ3JpZFdpZHRoKSAqIGdyaWRXaWR0aDtcbiAgICAgICAgICAgIHR4ICs9IHBhZGRpbmcubGVmdDtcbiAgICAgICAgICAgIGNhbGNXaWR0aCArPSB0eDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGlmICgobmV3T3JpZ2luID09PSAnbmVnYXRpdmUnICYmIGFyZWEueSA8IDApIHx8IChuZXdPcmlnaW4gPT09ICdwb3NpdGl2ZScgJiYgYXJlYS55ID49IDApIHx8IG5ld09yaWdpbiA9PT0gJ2FueScpIHtcbiAgICAgICAgICAgIHR5ID0gTWF0aC5jZWlsKC1hcmVhLnkgLyBncmlkSGVpZ2h0KSAqIGdyaWRIZWlnaHQ7XG4gICAgICAgICAgICB0eSArPSBwYWRkaW5nLnRvcDtcbiAgICAgICAgICAgIGNhbGNIZWlnaHQgKz0gdHk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjV2lkdGggKz0gcGFkZGluZy5yaWdodDtcbiAgICAgICAgY2FsY0hlaWdodCArPSBwYWRkaW5nLmJvdHRvbTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlc3VsdGluZyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gbWluaW11bS5cbiAgICAgICAgY2FsY1dpZHRoID0gTWF0aC5tYXgoY2FsY1dpZHRoLCBtaW5XaWR0aCk7XG4gICAgICAgIGNhbGNIZWlnaHQgPSBNYXRoLm1heChjYWxjSGVpZ2h0LCBtaW5IZWlnaHQpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmVzdWx0aW5nIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGxlc3NlciB0aGFuIG1heGltdW0uXG4gICAgICAgIGNhbGNXaWR0aCA9IE1hdGgubWluKGNhbGNXaWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICBjYWxjSGVpZ2h0ID0gTWF0aC5taW4oY2FsY0hlaWdodCwgbWF4SGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoLXR4IC8gc3gsIC10eSAvIHN5LCBjYWxjV2lkdGggLyBzeCwgY2FsY0hlaWdodCAvIHN5KTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtVG9GaXRDb250ZW50OiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnRCQm94LCBjb250ZW50TG9jYWxPcmlnaW47XG4gICAgICAgIGlmICgnY29udGVudEFyZWEnIGluIG9wdCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEFyZWEgPSBvcHQuY29udGVudEFyZWE7XG4gICAgICAgICAgICBjb250ZW50QkJveCA9IHRoaXMubG9jYWxUb1BhcGVyUmVjdChjb250ZW50QXJlYSk7XG4gICAgICAgICAgICBjb250ZW50TG9jYWxPcmlnaW4gPSBuZXcgUG9pbnQoY29udGVudEFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudEJCb3ggPSB0aGlzLmdldENvbnRlbnRCQm94KG9wdCk7XG4gICAgICAgICAgICBjb250ZW50TG9jYWxPcmlnaW4gPSB0aGlzLnBhcGVyVG9Mb2NhbFBvaW50KGNvbnRlbnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGVudEJCb3gud2lkdGggfHwgIWNvbnRlbnRCQm94LmhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIGRlZmF1bHRzKG9wdCwge1xuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IHRydWUsXG4gICAgICAgICAgICBzY2FsZUdyaWQ6IG51bGwsXG4gICAgICAgICAgICBtaW5TY2FsZTogMCxcbiAgICAgICAgICAgIG1heFNjYWxlOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgIC8vbWluU2NhbGVYXG4gICAgICAgICAgICAvL21pblNjYWxlWVxuICAgICAgICAgICAgLy9tYXhTY2FsZVhcbiAgICAgICAgICAgIC8vbWF4U2NhbGVZXG4gICAgICAgICAgICAvL2ZpdHRpbmdCQm94XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyk7XG5cbiAgICAgICAgY29uc3QgbWluU2NhbGVYID0gb3B0Lm1pblNjYWxlWCB8fCBvcHQubWluU2NhbGU7XG4gICAgICAgIGNvbnN0IG1heFNjYWxlWCA9IG9wdC5tYXhTY2FsZVggfHwgb3B0Lm1heFNjYWxlO1xuICAgICAgICBjb25zdCBtaW5TY2FsZVkgPSBvcHQubWluU2NhbGVZIHx8IG9wdC5taW5TY2FsZTtcbiAgICAgICAgY29uc3QgbWF4U2NhbGVZID0gb3B0Lm1heFNjYWxlWSB8fCBvcHQubWF4U2NhbGU7XG5cbiAgICAgICAgbGV0IGZpdHRpbmdCQm94O1xuICAgICAgICBpZiAob3B0LmZpdHRpbmdCQm94KSB7XG4gICAgICAgICAgICBmaXR0aW5nQkJveCA9IG9wdC5maXR0aW5nQkJveDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRTaXplID0gdGhpcy5nZXRDb21wdXRlZFNpemUoKTtcbiAgICAgICAgICAgIGZpdHRpbmdCQm94ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRUcmFuc2xhdGUudHgsXG4gICAgICAgICAgICAgICAgeTogY3VycmVudFRyYW5zbGF0ZS50eSxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29tcHV0ZWRTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY29tcHV0ZWRTaXplLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpdHRpbmdCQm94ID0gbmV3IFJlY3QoZml0dGluZ0JCb3gpLm1vdmVBbmRFeHBhbmQoe1xuICAgICAgICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgeTogcGFkZGluZy50b3AsXG4gICAgICAgICAgICB3aWR0aDogLXBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IC1wYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHRoaXMuc2NhbGUoKTtcblxuICAgICAgICBsZXQgbmV3U3ggPSBmaXR0aW5nQkJveC53aWR0aCAvIGNvbnRlbnRCQm94LndpZHRoICogY3VycmVudFNjYWxlLnN4O1xuICAgICAgICBsZXQgbmV3U3kgPSBmaXR0aW5nQkJveC5oZWlnaHQgLyBjb250ZW50QkJveC5oZWlnaHQgKiBjdXJyZW50U2NhbGUuc3k7XG5cbiAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBuZXdTeCA9IG5ld1N5ID0gTWF0aC5taW4obmV3U3gsIG5ld1N5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXAgc2NhbGUgdG8gYSBncmlkXG4gICAgICAgIGlmIChvcHQuc2NhbGVHcmlkKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGdyaWRTaXplID0gb3B0LnNjYWxlR3JpZDtcblxuICAgICAgICAgICAgbmV3U3ggPSBncmlkU2l6ZSAqIE1hdGguZmxvb3IobmV3U3ggLyBncmlkU2l6ZSk7XG4gICAgICAgICAgICBuZXdTeSA9IGdyaWRTaXplICogTWF0aC5mbG9vcihuZXdTeSAvIGdyaWRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlIG1pbi9tYXggYm91bmRhcmllc1xuICAgICAgICBuZXdTeCA9IE1hdGgubWluKG1heFNjYWxlWCwgTWF0aC5tYXgobWluU2NhbGVYLCBuZXdTeCkpO1xuICAgICAgICBuZXdTeSA9IE1hdGgubWluKG1heFNjYWxlWSwgTWF0aC5tYXgobWluU2NhbGVZLCBuZXdTeSkpO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlRGlmZiA9IHtcbiAgICAgICAgICAgIHg6IG5ld1N4IC8gY3VycmVudFNjYWxlLnN4LFxuICAgICAgICAgICAgeTogbmV3U3kgLyBjdXJyZW50U2NhbGUuc3lcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLm9wdGlvbnMub3JpZ2luO1xuICAgICAgICBsZXQgbmV3T3ggPSBmaXR0aW5nQkJveC54IC0gY29udGVudExvY2FsT3JpZ2luLnggKiBuZXdTeCAtIG9yaWdpbi54O1xuICAgICAgICBsZXQgbmV3T3kgPSBmaXR0aW5nQkJveC55IC0gY29udGVudExvY2FsT3JpZ2luLnkgKiBuZXdTeSAtIG9yaWdpbi55O1xuXG4gICAgICAgIHN3aXRjaCAob3B0LnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgbmV3T3kgPSBuZXdPeSArIChmaXR0aW5nQkJveC5oZWlnaHQgLSBjb250ZW50QkJveC5oZWlnaHQgKiBzY2FsZURpZmYueSkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBuZXdPeSA9IG5ld095ICsgKGZpdHRpbmdCQm94LmhlaWdodCAtIGNvbnRlbnRCQm94LmhlaWdodCAqIHNjYWxlRGlmZi55KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcHQuaG9yaXpvbnRhbEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIG5ld094ID0gbmV3T3ggKyAoZml0dGluZ0JCb3gud2lkdGggLSBjb250ZW50QkJveC53aWR0aCAqIHNjYWxlRGlmZi54KSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbmV3T3ggPSBuZXdPeCArIChmaXR0aW5nQkJveC53aWR0aCAtIGNvbnRlbnRCQm94LndpZHRoICogc2NhbGVEaWZmLngpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FsZShuZXdTeCwgbmV3U3kpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZShuZXdPeCwgbmV3T3kpO1xuICAgIH0sXG5cbiAgICBzY2FsZUNvbnRlbnRUb0ZpdDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtVG9GaXRDb250ZW50KG9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29udGVudCBhcmVhIGluIGxvY2FsIHVuaXRzICh3aXRob3V0IHRyYW5zZm9ybWF0aW9ucykuXG4gICAgZ2V0Q29udGVudEFyZWE6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIGlmIChvcHQgJiYgb3B0LnVzZU1vZGVsR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmdldEJCb3goKSB8fCBuZXcgUmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFYodGhpcy5jZWxscykuZ2V0QkJveCgpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvbnRlbnQgYmJveCBpbiB0aGUgcGFwZXIgdW5pdHMgKGFzIGl0IGFwcGVhcnMgb24gc2NyZWVuKS5cbiAgICBnZXRDb250ZW50QkJveDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUb1BhcGVyUmVjdCh0aGlzLmdldENvbnRlbnRBcmVhKG9wdCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgZ2VvbWV0cnkgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGUgZW50aXJlXG4gICAgLy8gcGFwZXIgYXJlYSAoY29vcmRpbmF0ZXMgZnJvbSB0aGUgbGVmdCBwYXBlciBib3JkZXIgdG8gdGhlIHJpZ2h0IG9uZVxuICAgIC8vIGFuZCB0aGUgdG9wIGJvcmRlciB0byB0aGUgYm90dG9tIG9uZSkuXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFwZXJUb0xvY2FsUmVjdCh0aGlzLmdldENvbXB1dGVkU2l6ZSgpKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVzdHJpY3RlZEFyZWE6IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICBjb25zdCB7IHJlc3RyaWN0VHJhbnNsYXRlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgbGV0IHJlc3RyaWN0ZWRBcmVhO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXN0cmljdFRyYW5zbGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIEEgbWV0aG9kIHJldHVybmluZyBhIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWEgPSByZXN0cmljdFRyYW5zbGF0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN0cmljdFRyYW5zbGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHBhcGVyIGFyZWFcbiAgICAgICAgICAgIHJlc3RyaWN0ZWRBcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3RyaWN0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgICAvLyBmYWxzeSB2YWx1ZVxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWEgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYW55IG90aGVyIHZhbHVlXG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYSA9IG5ldyBSZWN0KHJlc3RyaWN0VHJhbnNsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN0cmljdGVkQXJlYTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVmlld0Zvck1vZGVsOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICAvLyBBIGNsYXNzIHRha2VuIGZyb20gdGhlIHBhcGVyIG9wdGlvbnMuXG4gICAgICAgIHZhciBvcHRpb25hbFZpZXdDbGFzcztcblxuICAgICAgICAvLyBBIGRlZmF1bHQgYmFzaWMgY2xhc3MgKGVpdGhlciBkaWEuRWxlbWVudFZpZXcgb3IgZGlhLkxpbmtWaWV3KVxuICAgICAgICB2YXIgZGVmYXVsdFZpZXdDbGFzcztcblxuICAgICAgICAvLyBBIHNwZWNpYWwgY2xhc3MgZGVmaW5lZCBmb3IgdGhpcyBtb2RlbCBpbiB0aGUgY29ycmVzcG9uZGluZyBuYW1lc3BhY2UuXG4gICAgICAgIC8vIGUuZy4gam9pbnQuc2hhcGVzLmJhc2ljLlJlY3Qgc2VhcmNoZXMgZm9yIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0Vmlld1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjZWxsLmdldCgndHlwZScpICsgJ1ZpZXcnO1xuICAgICAgICB2YXIgbmFtZXNwYWNlVmlld0NsYXNzID0gZ2V0QnlQYXRoKG5hbWVzcGFjZSwgdHlwZSwgJy4nKTtcblxuICAgICAgICBpZiAoY2VsbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgb3B0aW9uYWxWaWV3Q2xhc3MgPSBvcHRpb25zLmxpbmtWaWV3O1xuICAgICAgICAgICAgZGVmYXVsdFZpZXdDbGFzcyA9IExpbmtWaWV3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uYWxWaWV3Q2xhc3MgPSBvcHRpb25zLmVsZW1lbnRWaWV3O1xuICAgICAgICAgICAgZGVmYXVsdFZpZXdDbGFzcyA9IEVsZW1lbnRWaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYSkgdGhlIHBhcGVyIG9wdGlvbnMgdmlldyBpcyBhIGNsYXNzIChkZXByZWNhdGVkKVxuICAgICAgICAvLyAgMS4gc2VhcmNoIHRoZSBuYW1lc3BhY2UgZm9yIGEgdmlld1xuICAgICAgICAvLyAgMi4gaWYgbm8gdmlldyB3YXMgZm91bmQsIHVzZSB2aWV3IGZyb20gdGhlIHBhcGVyIG9wdGlvbnNcbiAgICAgICAgLy8gYikgdGhlIHBhcGVyIG9wdGlvbnMgdmlldyBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIC8vICAxLiBjYWxsIHRoZSBmdW5jdGlvbiBmcm9tIHRoZSBwYXBlciBvcHRpb25zXG4gICAgICAgIC8vICAyLiBpZiBubyB2aWV3IHdhcyByZXR1cm4sIHNlYXJjaCB0aGUgbmFtZXNwYWNlIGZvciBhIHZpZXdcbiAgICAgICAgLy8gIDMuIGlmIG5vIHZpZXcgd2FzIGZvdW5kLCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgdmFyIFZpZXdDbGFzcyA9IChvcHRpb25hbFZpZXdDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBCYWNrYm9uZS5WaWV3KVxuICAgICAgICAgICAgPyBuYW1lc3BhY2VWaWV3Q2xhc3MgfHwgb3B0aW9uYWxWaWV3Q2xhc3NcbiAgICAgICAgICAgIDogb3B0aW9uYWxWaWV3Q2xhc3MuY2FsbCh0aGlzLCBjZWxsKSB8fCBuYW1lc3BhY2VWaWV3Q2xhc3MgfHwgZGVmYXVsdFZpZXdDbGFzcztcblxuICAgICAgICByZXR1cm4gbmV3IFZpZXdDbGFzcyh7XG4gICAgICAgICAgICBtb2RlbDogY2VsbCxcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiBvcHRpb25zLmludGVyYWN0aXZlLFxuICAgICAgICAgICAgbGFiZWxzTGF5ZXI6IG9wdGlvbnMubGFiZWxzTGF5ZXIgPT09IHRydWUgPyBMYXllcnNOYW1lcy5MQUJFTFMgOiBvcHRpb25zLmxhYmVsc0xheWVyXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVWaWV3OiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgY29uc3QgeyBpZCB9ID0gY2VsbDtcbiAgICAgICAgY29uc3QgeyBfdmlld3MsIF91cGRhdGVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB2aWV3ID0gX3ZpZXdzW2lkXTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZhciB7IGNpZCB9ID0gdmlldztcbiAgICAgICAgICAgIGNvbnN0IHsgbW91bnRlZCwgdW5tb3VudGVkIH0gPSBfdXBkYXRlcztcbiAgICAgICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICBkZWxldGUgX3ZpZXdzW2lkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBtb3VudGVkW2NpZF07XG4gICAgICAgICAgICBkZWxldGUgdW5tb3VudGVkW2NpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcblxuICAgIHJlbmRlclZpZXc6IGZ1bmN0aW9uKGNlbGwsIG9wdCkge1xuXG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy5fdmlld3M7XG4gICAgICAgIGxldCB2aWV3LCBmbGFnO1xuICAgICAgICBsZXQgY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlkIGluIHZpZXdzKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmlld3NbaWRdO1xuICAgICAgICAgICAgaWYgKHZpZXcubW9kZWwgPT09IGNlbGwpIHtcbiAgICAgICAgICAgICAgICBmbGFnID0gdmlldy5GTEFHX0lOU0VSVDtcbiAgICAgICAgICAgICAgICBjcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZpZXcgZm9yIHRoaXMgYGlkYCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjZWxsIGlzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBtb2RlbCB3aXRoIGlkZW50aWNhbCBpZFxuICAgICAgICAgICAgICAgIC8vIFdlIHNpbXBseSByZW1vdmUgdGhlIGV4aXN0aW5nIHZpZXcgYW5kIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVZpZXcoY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdzW2lkXSA9IHRoaXMuY3JlYXRlVmlld0Zvck1vZGVsKGNlbGwpO1xuICAgICAgICAgICAgdmlldy5wYXBlciA9IHRoaXM7XG4gICAgICAgICAgICBmbGFnID0gdGhpcy5yZWdpc3RlclVubW91bnRlZFZpZXcodmlldykgfCB0aGlzLkZMQUdfSU5JVCB8IHZpZXcuZ2V0RmxhZyhyZXN1bHQodmlldywgJ2luaXRGbGFnJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdFZpZXdVcGRhdGUodmlldywgZmxhZywgdmlldy5VUERBVEVfUFJJT1JJVFksIG9wdCk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICBvbkltYWdlRHJhZ1N0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gcHJldmVudCBpbWFnZSBkcmFnZ2luZyBpbiBGaXJlZm94IHRoYXQgd29ya3MuXG4gICAgICAgIC8vIFNldHRpbmcgLW1vei11c2VyLXNlbGVjdDogbm9uZSwgZHJhZ2dhYmxlPVwiZmFsc2VcIiBhdHRyaWJ1dGUgb3IgdXNlci1kcmFnOiBub25lIGRpZG4ndCBoZWxwLlxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzZXRWaWV3czogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgY2VsbHMgfHwgKGNlbGxzID0gW10pO1xuICAgICAgICB0aGlzLl9yZXNldFVwZGF0ZXMoKTtcbiAgICAgICAgLy8gY2xlYXJpbmcgdmlld3MgcmVtb3ZlcyBhbnkgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlVmlld3MoKTtcbiAgICAgICAgLy8gQWxsb3dzIHRvIHVuZnJlZXplIG5vcm1hbGx5IHdoaWxlIGluIHRoZSBpZGxlIHN0YXRlIHVzaW5nIGF1dG9GcmVlemUgb3B0aW9uXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMub3B0aW9ucy5hdXRvRnJlZXplID8gbnVsbCA6ICdyZXNldCc7XG4gICAgICAgIHRoaXMuZnJlZXplKHsga2V5IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KGNlbGxzW2ldLCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5mcmVlemUoeyBrZXkgfSk7XG4gICAgICAgIHRoaXMuc29ydFZpZXdzKCk7XG4gICAgfSxcblxuICAgIHJlbW92ZVZpZXdzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpbnZva2UodGhpcy5fdmlld3MsICdyZW1vdmUnKTtcblxuICAgICAgICB0aGlzLl92aWV3cyA9IHt9O1xuICAgIH0sXG5cbiAgICBzb3J0Vmlld3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0V4YWN0U29ydGluZygpKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNGcm96ZW4oKSkge1xuICAgICAgICAgICAgLy8gc29ydCB2aWV3cyBvbmNlIHVuZnJvemVuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVzLnNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydFZpZXdzRXhhY3QoKTtcbiAgICB9LFxuXG4gICAgc29ydFZpZXdzRXhhY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFJ1biBpbnNlcnRpb24gc29ydCBhbGdvcml0aG0gaW4gb3JkZXIgdG8gZWZmaWNpZW50bHkgc29ydCBET00gZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZWlyXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgbW9kZWwgYHpgIGF0dHJpYnV0ZS5cblxuICAgICAgICB2YXIgJGNlbGxzID0gJCh0aGlzLmNlbGxzKS5jaGlsZHJlbignW21vZGVsLWlkXScpO1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLm1vZGVsLmdldCgnY2VsbHMnKTtcblxuICAgICAgICBzb3J0RWxlbWVudHMoJGNlbGxzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY2VsbEEgPSBjZWxscy5nZXQoYS5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJykpO1xuICAgICAgICAgICAgdmFyIGNlbGxCID0gY2VsbHMuZ2V0KGIuZ2V0QXR0cmlidXRlKCdtb2RlbC1pZCcpKTtcbiAgICAgICAgICAgIHZhciB6QSA9IGNlbGxBLmF0dHJpYnV0ZXMueiB8fCAwO1xuICAgICAgICAgICAgdmFyIHpCID0gY2VsbEIuYXR0cmlidXRlcy56IHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gKHpBID09PSB6QikgPyAwIDogKHpBIDwgekIpID8gLTEgOiAxO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0VmlldzogZnVuY3Rpb24odmlldywgaXNJbml0aWFsSW5zZXJ0KSB7XG4gICAgICAgIGNvbnN0IGxheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLkNFTExTKTtcbiAgICAgICAgY29uc3QgeyBlbCwgbW9kZWwgfSA9IHZpZXc7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNvcnRpbmcpIHtcbiAgICAgICAgICAgIGNhc2Ugc29ydGluZ1R5cGVzLkFQUFJPWDpcbiAgICAgICAgICAgICAgICBsYXllclZpZXcuaW5zZXJ0U29ydGVkTm9kZShlbCwgbW9kZWwuZ2V0KCd6JykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb3J0aW5nVHlwZXMuRVhBQ1Q6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxheWVyVmlldy5pbnNlcnROb2RlKGVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2aWV3Lm9uTW91bnQoaXNJbml0aWFsSW5zZXJ0KTtcbiAgICB9LFxuXG4gICAgZGV0YWNoVmlldyh2aWV3KSB7XG4gICAgICAgIHZpZXcudW5tb3VudCgpO1xuICAgICAgICB2aWV3Lm9uRGV0YWNoKCk7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG94LCBveSkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoc3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFYubWF0cml4VG9TY2FsZSh0aGlzLm1hdHJpeCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICBpZiAoc3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3kgPSBzeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3ggPSAwO1xuICAgICAgICAgICAgb3kgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMudHJhbnNsYXRlKCk7XG5cbiAgICAgICAgaWYgKG94IHx8IG95IHx8IHRyYW5zbGF0ZS50eCB8fCB0cmFuc2xhdGUudHkpIHtcbiAgICAgICAgICAgIHZhciBuZXdUeCA9IHRyYW5zbGF0ZS50eCAtIG94ICogKHN4IC0gMSk7XG4gICAgICAgICAgICB2YXIgbmV3VHkgPSB0cmFuc2xhdGUudHkgLSBveSAqIChzeSAtIDEpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUobmV3VHgsIG5ld1R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN4ID0gTWF0aC5tYXgoc3ggfHwgMCwgdGhpcy5NSU5fU0NBTEUpO1xuICAgICAgICBzeSA9IE1hdGgubWF4KHN5IHx8IDAsIHRoaXMuTUlOX1NDQUxFKTtcblxuICAgICAgICB2YXIgY3RtID0gdGhpcy5tYXRyaXgoKTtcbiAgICAgICAgY3RtLmEgPSBzeDtcbiAgICAgICAgY3RtLmQgPSBzeTtcblxuICAgICAgICB0aGlzLm1hdHJpeChjdG0pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2NhbGUnLCBzeCwgc3ksIG94LCBveSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4cGVyaW1lbnRhbCAtIGRvIG5vdCB1c2UgaW4gcHJvZHVjdGlvbi5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBjeCwgY3kpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBWLm1hdHJpeFRvUm90YXRlKHRoaXMubWF0cml4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dGVyXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbiBpcyBub3Qgc2V0IGV4cGxpY2l0ZWx5LCByb3RhdGUgYXJvdW5kIHRoZSBjZW50ZXIuIE5vdGUgdGhhdFxuICAgICAgICAvLyB3ZSBtdXN0IHVzZSB0aGUgcGxhaW4gYm91bmRpbmcgYm94IChgdGhpcy5lbC5nZXRCQm94KClgIGluc3RlYWQgb2YgdGhlIG9uZSB0aGF0IGdpdmVzIHVzXG4gICAgICAgIC8vIHRoZSByZWFsIGJvdW5kaW5nIGJveCAoYGJib3goKWApIGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnMpLlxuICAgICAgICBpZiAoY3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmNlbGxzLmdldEJCb3goKTtcbiAgICAgICAgICAgIGN4ID0gYmJveC53aWR0aCAvIDI7XG4gICAgICAgICAgICBjeSA9IGJib3guaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdG0gPSB0aGlzLm1hdHJpeCgpLnRyYW5zbGF0ZShjeCwgY3kpLnJvdGF0ZShhbmdsZSkudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgdGhpcy5tYXRyaXgoY3RtKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBWLm1hdHJpeFRvVHJhbnNsYXRlKHRoaXMubWF0cml4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9yaWdpbiwgZHJhd0dyaWQgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHR4IHx8ICh0eCA9IDApO1xuICAgICAgICB0eSB8fCAodHkgPSAwKTtcblxuICAgICAgICBjb25zdCBjdG0gPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgICBpZiAoY3RtLmUgPT09IHR4ICYmIGN0bS5mID09PSB0eSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGN0bS5lID0gdHg7XG4gICAgICAgIGN0bS5mID0gdHk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXgoY3RtKTtcblxuICAgICAgICBjb25zdCB7IHR4OiBveCwgdHk6IG95IH0gPSB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICBvcmlnaW4ueCA9IG94O1xuICAgICAgICBvcmlnaW4ueSA9IG95O1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcigndHJhbnNsYXRlJywgb3gsIG95KTtcblxuICAgICAgICBpZiAoZHJhd0dyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCB2aWV3IGNsaW1iaW5nIHVwIHRoZSBET00gdHJlZSBzdGFydGluZyBhdCBlbGVtZW50IGBlbGAuIE5vdGUgdGhhdCBgZWxgIGNhbiBhbHNvXG4gICAgLy8gYmUgYSBzZWxlY3RvciBvciBhIGpRdWVyeSBvYmplY3QuXG4gICAgZmluZFZpZXc6IGZ1bmN0aW9uKCRlbCkge1xuXG4gICAgICAgIHZhciBlbCA9IGlzU3RyaW5nKCRlbClcbiAgICAgICAgICAgID8gdGhpcy5jZWxscy5xdWVyeVNlbGVjdG9yKCRlbClcbiAgICAgICAgICAgIDogJGVsIGluc3RhbmNlb2YgJCA/ICRlbFswXSA6ICRlbDtcblxuICAgICAgICB2YXIgaWQgPSB0aGlzLmZpbmRBdHRyaWJ1dGUoJ21vZGVsLWlkJywgZWwpO1xuICAgICAgICBpZiAoaWQpIHJldHVybiB0aGlzLl92aWV3c1tpZF07XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhIHZpZXcgZm9yIGEgbW9kZWwgYGNlbGxgLiBgY2VsbGAgY2FuIGFsc28gYmUgYSBzdHJpbmcgb3IgbnVtYmVyIHJlcHJlc2VudGluZyBhIG1vZGVsIGBpZGAuXG4gICAgZmluZFZpZXdCeU1vZGVsOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgdmFyIGlkID0gKGlzU3RyaW5nKGNlbGwpIHx8IGlzTnVtYmVyKGNlbGwpKSA/IGNlbGwgOiAoY2VsbCAmJiBjZWxsLmlkKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3NbaWRdO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCB2aWV3cyBhdCBnaXZlbiBwb2ludFxuICAgIGZpbmRWaWV3c0Zyb21Qb2ludDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHAgPSBuZXcgUG9pbnQocCk7XG5cbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5tb2RlbC5nZXRFbGVtZW50cygpLm1hcCh0aGlzLmZpbmRWaWV3QnlNb2RlbCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdzLmZpbHRlcihmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldyAmJiB2aWV3LnZlbC5nZXRCQm94KHsgdGFyZ2V0OiB0aGlzLmNlbGxzIH0pLmNvbnRhaW5zUG9pbnQocCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCB2aWV3cyBpbiBnaXZlbiBhcmVhXG4gICAgZmluZFZpZXdzSW5BcmVhOiBmdW5jdGlvbihyZWN0LCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBkZWZhdWx0cyhvcHQgfHwge30sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgcmVjdCA9IG5ldyBSZWN0KHJlY3QpO1xuXG4gICAgICAgIHZhciB2aWV3cyA9IHRoaXMubW9kZWwuZ2V0RWxlbWVudHMoKS5tYXAodGhpcy5maW5kVmlld0J5TW9kZWwsIHRoaXMpO1xuICAgICAgICB2YXIgbWV0aG9kID0gb3B0LnN0cmljdCA/ICdjb250YWluc1JlY3QnIDogJ2ludGVyc2VjdCc7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdzLmZpbHRlcihmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldyAmJiByZWN0W21ldGhvZF0odmlldy52ZWwuZ2V0QkJveCh7IHRhcmdldDogdGhpcy5jZWxscyB9KSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICByZW1vdmVUb29sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb29sc0V2ZW50KCdyZW1vdmUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGVUb29sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb29sc0V2ZW50KCdoaWRlJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93VG9vbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG9vbHNFdmVudCgnc2hvdycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hUb29sc0V2ZW50OiBmdW5jdGlvbihldmVudCwgLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Rvb2xzOmV2ZW50JywgZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0sXG5cblxuICAgIGdldE1vZGVsQnlJZDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRDZWxsKGlkKTtcbiAgICB9LFxuXG4gICAgc25hcFRvR3JpZDogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIC8vIENvbnZlcnQgZ2xvYmFsIGNvb3JkaW5hdGVzIHRvIHRoZSBsb2NhbCBvbmVzIG9mIHRoZSBgdmlld3BvcnRgLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIGltcHJvcGVyIHRyYW5zZm9ybWF0aW9uIHdvdWxkIGJlIGFwcGxpZWQgd2hlbiB0aGUgdmlld3BvcnQgZ2V0cyB0cmFuc2Zvcm1lZCAoc2NhbGVkL3JvdGF0ZWQpLlxuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRUb0xvY2FsUG9pbnQoeCwgeSkuc25hcFRvR3JpZCh0aGlzLm9wdGlvbnMuZ3JpZFNpemUpO1xuICAgIH0sXG5cbiAgICBsb2NhbFRvUGFwZXJQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIHBhcGVyUG9pbnQgPSBWLnRyYW5zZm9ybVBvaW50KGxvY2FsUG9pbnQsIHRoaXMubWF0cml4KCkpO1xuICAgICAgICByZXR1cm4gcGFwZXJQb2ludDtcbiAgICB9LFxuXG4gICAgbG9jYWxUb1BhcGVyUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSByZWN0YW5nbGUgYW5kIHJlc3QgYXJndW1lbnRzIHVuZGVmaW5lZFxuICAgICAgICB2YXIgbG9jYWxSZWN0ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBwYXBlclJlY3QgPSBWLnRyYW5zZm9ybVJlY3QobG9jYWxSZWN0LCB0aGlzLm1hdHJpeCgpKTtcbiAgICAgICAgcmV0dXJuIHBhcGVyUmVjdDtcbiAgICB9LFxuXG4gICAgcGFwZXJUb0xvY2FsUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIHBhcGVyUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gVi50cmFuc2Zvcm1Qb2ludChwYXBlclBvaW50LCB0aGlzLm1hdHJpeCgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbFBvaW50O1xuICAgIH0sXG5cbiAgICBwYXBlclRvTG9jYWxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHJlY3RhbmdsZSBhbmQgcmVzdCBhcmd1bWVudHMgdW5kZWZpbmVkXG4gICAgICAgIHZhciBwYXBlclJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGxvY2FsUmVjdCA9IFYudHJhbnNmb3JtUmVjdChwYXBlclJlY3QsIHRoaXMubWF0cml4KCkuaW52ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsUmVjdDtcbiAgICB9LFxuXG4gICAgbG9jYWxUb0NsaWVudFBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgY2xpZW50UG9pbnQgPSBWLnRyYW5zZm9ybVBvaW50KGxvY2FsUG9pbnQsIHRoaXMuY2xpZW50TWF0cml4KCkpO1xuICAgICAgICByZXR1cm4gY2xpZW50UG9pbnQ7XG4gICAgfSxcblxuICAgIGxvY2FsVG9DbGllbnRSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBsb2NhbFJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBWLnRyYW5zZm9ybVJlY3QobG9jYWxSZWN0LCB0aGlzLmNsaWVudE1hdHJpeCgpKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfSxcblxuICAgIC8vIFRyYW5zZm9ybSBjbGllbnQgY29vcmRpbmF0ZXMgdG8gdGhlIHBhcGVyIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgIC8vIFVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgbW91c2UgZXZlbnQgb2JqZWN0IGFuZCB5b3UnZCBsaWtlIHRvIGdldCBjb29yZGluYXRlc1xuICAgIC8vIGluc2lkZSB0aGUgcGFwZXIgdGhhdCBjb3JyZXNwb25kIHRvIGBldnQuY2xpZW50WGAgYW5kIGBldnQuY2xpZW50WWAgcG9pbnQuXG4gICAgLy8gRXhhbXBsZTogdmFyIGxvY2FsUG9pbnQgPSBwYXBlci5jbGllbnRUb0xvY2FsUG9pbnQoeyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfSk7XG4gICAgY2xpZW50VG9Mb2NhbFBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBjbGllbnRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSBWLnRyYW5zZm9ybVBvaW50KGNsaWVudFBvaW50LCB0aGlzLmNsaWVudE1hdHJpeCgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbFBvaW50O1xuICAgIH0sXG5cbiAgICBjbGllbnRUb0xvY2FsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgbG9jYWxSZWN0ID0gVi50cmFuc2Zvcm1SZWN0KGNsaWVudFJlY3QsIHRoaXMuY2xpZW50TWF0cml4KCkuaW52ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsUmVjdDtcbiAgICB9LFxuXG4gICAgbG9jYWxUb1BhZ2VQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsVG9QYXBlclBvaW50KHgsIHkpLm9mZnNldCh0aGlzLnBhZ2VPZmZzZXQoKSk7XG4gICAgfSxcblxuICAgIGxvY2FsVG9QYWdlUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsVG9QYXBlclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkub2Zmc2V0KHRoaXMucGFnZU9mZnNldCgpKTtcbiAgICB9LFxuXG4gICAgcGFnZVRvTG9jYWxQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHZhciBwYWdlUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHZhciBwYXBlclBvaW50ID0gcGFnZVBvaW50LmRpZmZlcmVuY2UodGhpcy5wYWdlT2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXBlclRvTG9jYWxQb2ludChwYXBlclBvaW50KTtcbiAgICB9LFxuXG4gICAgcGFnZVRvTG9jYWxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSB0aGlzLnBhZ2VPZmZzZXQoKTtcbiAgICAgICAgdmFyIHBhcGVyUmVjdCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwYXBlclJlY3QueCAtPSBwYWdlT2Zmc2V0Lng7XG4gICAgICAgIHBhcGVyUmVjdC55IC09IHBhZ2VPZmZzZXQueTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFwZXJUb0xvY2FsUmVjdChwYXBlclJlY3QpO1xuICAgIH0sXG5cbiAgICBjbGllbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbGllbnRSZWN0ID0gdGhpcy5zdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoY2xpZW50UmVjdC5sZWZ0LCBjbGllbnRSZWN0LnRvcCk7XG4gICAgfSxcblxuICAgIHBhZ2VPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9mZnNldCgpLm9mZnNldCh3aW5kb3cuc2Nyb2xsWCwgd2luZG93LnNjcm9sbFkpO1xuICAgIH0sXG5cbiAgICBsaW5rQWxsb3dlZDogZnVuY3Rpb24obGlua1ZpZXcpIHtcblxuICAgICAgICBpZiAoIShsaW5rVmlldyBpbnN0YW5jZW9mIExpbmtWaWV3KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBsaW5rVmlldy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rID0gbGlua1ZpZXcubW9kZWw7XG4gICAgICAgIHZhciBwYXBlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBncmFwaCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBucyA9IGdyYXBoLmNvbnN0cnVjdG9yLnZhbGlkYXRpb25zO1xuXG4gICAgICAgIGlmICghcGFwZXJPcHRpb25zLm11bHRpTGlua3MpIHtcbiAgICAgICAgICAgIGlmICghbnMubXVsdGlMaW5rcy5jYWxsKHRoaXMsIGdyYXBoLCBsaW5rKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXBlck9wdGlvbnMubGlua1Bpbm5pbmcpIHtcbiAgICAgICAgICAgIC8vIExpbmsgcGlubmluZyBpcyBub3QgYWxsb3dlZCBhbmQgdGhlIGxpbmsgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKCFucy5saW5rUGlubmluZy5jYWxsKHRoaXMsIGdyYXBoLCBsaW5rKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXBlck9wdGlvbnMuYWxsb3dMaW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIXBhcGVyT3B0aW9ucy5hbGxvd0xpbmsuY2FsbCh0aGlzLCBsaW5rVmlldywgdGhpcykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0TGluazogZnVuY3Rpb24oY2VsbFZpZXcsIG1hZ25ldCkge1xuXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5kZWZhdWx0TGluaylcbiAgICAgICAgLy8gZGVmYXVsdCBsaW5rIGlzIGEgZnVuY3Rpb24gcHJvZHVjaW5nIGxpbmsgbW9kZWxcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmRlZmF1bHRMaW5rLmNhbGwodGhpcywgY2VsbFZpZXcsIG1hZ25ldClcbiAgICAgICAgLy8gZGVmYXVsdCBsaW5rIGlzIHRoZSBCYWNrYm9uZSBtb2RlbFxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMuZGVmYXVsdExpbmsuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2VsbCBoaWdobGlnaHRpbmcuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXNvbHZlSGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgbGV0IHsgaGlnaGxpZ2h0ZXI6IGhpZ2hsaWdodGVyRGVmLCB0eXBlIH0gPSBvcHQ7XG4gICAgICAgIGNvbnN0IHsgaGlnaGxpZ2h0aW5nLGhpZ2hsaWdodGVyTmFtZXNwYWNlICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBFeHBlY3Rpbmcgb3B0LmhpZ2hsaWdodGVyIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2hpZ2hsaWdodGVyLW5hbWUnLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc29tZTogJ3ZhbHVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyRGVmID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgLy8gSXMgaGlnaGxpZ2h0aW5nIGRpc2FibGVkP1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBidWlsdC1pbiB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlckRlZiA9IGhpZ2hsaWdodGluZ1t0eXBlXTtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIHNwZWNpZmljIHR5cGUgaGlnaGxpZ2h0IGRpc2FibGVkP1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlckRlZiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXJEZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlIG5vdCBkZWZpbmVkIHVzZSBkZWZhdWx0IGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVyRGVmID0gaGlnaGxpZ2h0aW5nWydkZWZhdWx0J107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9wdC5oaWdobGlnaHRlciBpcyBmYWxzeS5cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIGNhc2UgdG8gbm90IGhpZ2hsaWdodCBjZWxsKHMpIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byBOT1QgaGlnaGxpZ2h0IHdoZW4gZW1iZWRkaW5nIGVsZW1lbnRzXG4gICAgICAgIC8vIG9yIHVzZSBhIGN1c3RvbSBoaWdobGlnaHRlci5cbiAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlZikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgYSBoaWdobGlnaHRlciBieSBuYW1lLlxuICAgICAgICBpZiAoaXNTdHJpbmcoaGlnaGxpZ2h0ZXJEZWYpKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRlckRlZiA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBoaWdobGlnaHRlckRlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBoaWdobGlnaHRlckRlZi5uYW1lO1xuICAgICAgICBjb25zdCBoaWdobGlnaHRlciA9IGhpZ2hsaWdodGVyTmFtZXNwYWNlW25hbWVdO1xuXG4gICAgICAgIC8vIEhpZ2hsaWdodGVyIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKCFoaWdobGlnaHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhpZ2hsaWdodGVyIChcIicgKyBuYW1lICsgJ1wiKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hsaWdodGVyIChcIicgKyBuYW1lICsgJ1wiKSBpcyBtaXNzaW5nIHJlcXVpcmVkIGhpZ2hsaWdodCgpIG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGlnaGxpZ2h0ZXIgKFwiJyArIG5hbWUgKyAnXCIpIGlzIG1pc3NpbmcgcmVxdWlyZWQgdW5oaWdobGlnaHQoKSBtZXRob2QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdobGlnaHRlcixcbiAgICAgICAgICAgIG9wdGlvbnM6IGhpZ2hsaWdodGVyRGVmLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG9uQ2VsbEhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHQpIHtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yID0gdGhpcy5yZXNvbHZlSGlnaGxpZ2h0ZXIob3B0KTtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlc2NyaXB0b3IpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBoaWdobGlnaHRlciwgb3B0aW9ucyB9ID0gaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yO1xuICAgICAgICBoaWdobGlnaHRlci5oaWdobGlnaHQoY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgb25DZWxsVW5oaWdobGlnaHQ6IGZ1bmN0aW9uKGNlbGxWaWV3LCBtYWduZXRFbCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyRGVzY3JpcHRvciA9IHRoaXMucmVzb2x2ZUhpZ2hsaWdodGVyKG9wdCk7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaGlnaGxpZ2h0ZXIsIG9wdGlvbnMgfSA9IGhpZ2hsaWdodGVyRGVzY3JpcHRvcjtcbiAgICAgICAgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24uXG4gICAgLy8gLS0tLS0tLS0tLS0tXG5cbiAgICBwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIG1hZ25ldHBvaW50ZXJkYmxjbGljayBjYW4gc3RvcCBwcm9wYWdhdGlvblxuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2dC50YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5wb2ludGVyZGJsY2xpY2soZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICAvLyBtYWduZXRwb2ludGVyY2xpY2sgY2FuIHN0b3AgcHJvcGFnYXRpb25cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgb25seSBpZiBtb3VzZSBoYXMgbm90IG1vdmVkLlxuICAgICAgICBpZiAoZGF0YS5tb3VzZW1vdmVkIDw9IHRoaXMub3B0aW9ucy5jbGlja1RocmVzaG9sZCkge1xuXG4gICAgICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZ0LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5wb2ludGVyY2xpY2soZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVyY2xpY2snLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50Q29udGV4dE1lbnUpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51RmlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICB0aGlzLmNvbnRleHRNZW51VHJpZ2dlcihldnQpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0TWVudVRyaWdnZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZ0LnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHRtZW51KGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOmNvbnRleHRtZW51JywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGJ1dHRvbiB9ID0gZXZ0O1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpc0NvbnRleHRNZW51ID0gKGJ1dHRvbiA9PT0gMik7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcblxuICAgICAgICAgICAgaWYgKCFpc0NvbnRleHRNZW51ICYmIHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldEZvcm1Ob2RlID0gdGhpcy5GT1JNX0NPTlRST0xfVEFHX05BTUVTLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdFZpZXdBY3Rpb24gJiYgIWlzVGFyZ2V0Rm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgZm9ybSBlbGVtZW50LCB3ZSBkbyBub3Qgd2FudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNlbGVjdCB0ZXh0IGluIGEgdGV4dCBpbnB1dCBvclxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gY2xpY2sgb24gYSBjaGVja2JveC5cbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0Rm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgZm9ybSBlbGVtZW50LCB3ZSBkbyBub3Qgd2FudCB0byBzdGFydCBkcmFnZ2luZyB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNlbGVjdCB0ZXh0IGJ5IGRyYWdnaW5nIHRoZSBtb3VzZS5cbiAgICAgICAgICAgICAgICB2aWV3LnByZXZlbnREZWZhdWx0SW50ZXJhY3Rpb24oZXZ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBjb25zdCBldmVudEV2dCA9IHRoaXMuY3VzdG9tRXZlbnRUcmlnZ2VyKGV2dCwgdmlldyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRFdnQpIHtcbiAgICAgICAgICAgIC8vIGBvbmV2ZW50YCBjb3VsZCBoYXZlIHN0b3BwZWQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBldmVudEV2dC5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGVtZW50IG1hZ25ldFxuICAgICAgICAgICAgY29uc3QgbWFnbmV0Tm9kZSA9IHRhcmdldC5jbG9zZXN0KCdbbWFnbmV0XScpO1xuICAgICAgICAgICAgaWYgKG1hZ25ldE5vZGUgJiYgdmlldy5lbCAhPT0gbWFnbmV0Tm9kZSAmJiB2aWV3LmVsLmNvbnRhaW5zKG1hZ25ldE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFnbmV0RXZ0ID0gbm9ybWFsaXplRXZlbnQoJC5FdmVudChldnQub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBldnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSB0aGUgZXZlbnQgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIHRoZSBtYWduZXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogbWFnbmV0Tm9kZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubWFnbmV0KG1hZ25ldEV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hZ25ldEV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYG9ubWFnbmV0YCBzdG9wcyBwcm9wYWdhdGlvbiB3aGVuIGBhZGRMaW5rRnJvbU1hZ25ldGAgaXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGlmIChtYWduZXRFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgbWFnbmV0OnBvaW50ZXJtb3ZlYCBhbmQgYG1hZ25ldDpwb2ludGVydXBgIGV2ZW50cyBtdXN0IGJlIGZpcmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbnRleHRNZW51KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVEcmFnRXZlbnRzKHZpZXcsIG1hZ25ldEV2dC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IG1hZ25ldEV2dC5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0bWVudUV2dCA9ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHsgdHlwZTogJ2NvbnRleHRtZW51JywgZGF0YTogZXZ0LmRhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51VHJpZ2dlcihjb250ZXh0bWVudUV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHZpZXcucG9pbnRlcmRvd24oZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHRCbGFua0FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVyZG93bicsIGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlRHJhZ0V2ZW50cyh2aWV3LCBldnQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgLy8gbW91c2UgbW92ZWQgY291bnRlclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGlmICghZGF0YS5tb3VzZW1vdmVkKSB7XG4gICAgICAgICAgICBkYXRhLm1vdXNlbW92ZWQgPSAwO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgZXZlbnRzIGxpa2UgYG1vdXNlZW50ZXJgIGFuZCBgbW91c2VsZWF2ZWAgYXJlXG4gICAgICAgICAgICAvLyBub3QgdHJpZ2dlcmVkIHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nIGEgY2VsbFZpZXcuXG4gICAgICAgICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBldmVudHMgYXJlIHVuZGVsZWdhdGVkIGFmdGVyIHRoZSBmaXJzdCBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgICAgICAgICAgLy8gTm90IG9uIGBwb2ludGVyZG93bmAgdG8gbWFrZSBzdXJlIHRoYXQgYGRibHRhcGAgaXMgcmVjb2duaXplZC5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZW1vdmVkID0gKytkYXRhLm1vdXNlbW92ZWQ7XG5cbiAgICAgICAgaWYgKG1vdXNlbW92ZWQgPD0gdGhpcy5vcHRpb25zLm1vdmVUaHJlc2hvbGQpIHJldHVybjtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSBkYXRhLnNvdXJjZVZpZXc7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LnBvaW50ZXJtb3ZlKGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVybW92ZScsIGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCBkYXRhKTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcnVwOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB0aGlzLnVuZGVsZWdhdGVEb2N1bWVudEV2ZW50cygpO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkRXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChub3JtYWxpemVkRXZ0LmNsaWVudFgsIG5vcm1hbGl6ZWRFdnQuY2xpZW50WSk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmV2ZW50RGF0YShldnQpLnNvdXJjZVZpZXc7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LnBvaW50ZXJ1cChub3JtYWxpemVkRXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOnBvaW50ZXJ1cCcsIG5vcm1hbGl6ZWRFdnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9ybWFsaXplZEV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJjbGljaygkLkV2ZW50KGV2dC5vcmlnaW5hbEV2ZW50LCB7IHR5cGU6ICdjbGljaycsIGRhdGE6IGV2dC5kYXRhIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3Lm1vdXNlb3ZlcihldnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbCA9PT0gZXZ0LnRhcmdldCkgcmV0dXJuOyAvLyBwcmV2ZW50IGJvcmRlciBvZiBwYXBlciBmcm9tIHRyaWdnZXJpbmcgdGhpc1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazptb3VzZW92ZXInLCBldnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3Lm1vdXNlb3V0KGV2dCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsID09PSBldnQudGFyZ2V0KSByZXR1cm47IC8vIHByZXZlbnQgYm9yZGVyIG9mIHBhcGVyIGZyb20gdHJpZ2dlcmluZyB0aGlzXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOm1vdXNlb3V0JywgZXZ0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZWVudGVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldCwgLy8gVGhlIEV2ZW50VGFyZ2V0IHRoZSBwb2ludGluZyBkZXZpY2UgZW50ZXJlZCB0b1xuICAgICAgICAgICAgcmVsYXRlZFRhcmdldCwgLy8gVGhlIEV2ZW50VGFyZ2V0IHRoZSBwb2ludGluZyBkZXZpY2UgZXhpdGVkIGZyb21cbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgLy8gVGhlIEV2ZW50VGFyZ2V0IG9uIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciB3YXMgcmVnaXN0ZXJlZFxuICAgICAgICB9ID0gZXZ0O1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRWaWV3ID0gdGhpcy5maW5kVmlldyhyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGVkVmlldyA9PT0gdmlldykge1xuICAgICAgICAgICAgICAgIC8vIE1vdXNlIGxlZnQgYSBjZWxsIHRvb2xcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3Lm1vdXNlZW50ZXIoZXZ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBvaW50ZXIgcmVtYWlucyBpbnNpZGUgdGhlIHBhcGVyLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRlZFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBgbW91c2VlbnRlcmAgZXZlbnQgaWYgdGhlIGByZWxhdGVkVGFyZ2V0YCBpcyBvdXRzaWRlIHRoZSBwYXBlclxuICAgICAgICAvLyAobW91c2VlbnRlciBtZXRob2Qgd291bGQgYmUgZmlyZWQgdHdpY2UpXG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICAvLyBgcGFwZXJgIChtb3JlIGRlc2NyaXB0aXZlKSwgbm90IGBibGFua2BcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6bW91c2VlbnRlcicsIGV2dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXQsIC8vIFRoZSBFdmVudFRhcmdldCB0aGUgcG9pbnRpbmcgZGV2aWNlIGV4aXRlZCBmcm9tXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0LCAvLyBUaGUgRXZlbnRUYXJnZXQgdGhlIHBvaW50aW5nIGRldmljZSBlbnRlcmVkIHRvXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0IC8vIFRoZSBFdmVudFRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2FzIHJlZ2lzdGVyZWRcbiAgICAgICAgfSA9IGV2dDtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuZmluZFZpZXcodGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCByZWxhdGVkVmlldyA9IHRoaXMuZmluZFZpZXcocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAocmVsYXRlZFZpZXcgPT09IHZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3VzZSBlbnRlcmVkIGEgY2VsbCB0b29sXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5tb3VzZWxlYXZlKGV2dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwb2ludGVyIGhhcyBleGl0ZWQgYSBjZWxsVmlldy4gVGhlIHBvaW50ZXIgaXMgc3RpbGwgaW5zaWRlIG9mIHRoZSBwYXBlci5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0ZWRWaWV3KSB7XG4gICAgICAgICAgICAvLyBUaGUgcG9pbnRlciBoYXMgZW50ZXJlZCBhIG5ldyBjZWxsVmlld1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGBtb3VzZWxlYXZlYCBldmVudCBpZiB0aGUgYHJlbGF0ZWRUYXJnZXRgIGlzIG91dHNpZGUgdGhlIHBhcGVyXG4gICAgICAgIC8vIChtb3VzZWxlYXZlIG1ldGhvZCB3b3VsZCBiZSBmaXJlZCB0d2ljZSlcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNlbGxWaWV3IHVuZGVyIHRoZSBwb2ludGVyLCBub3IgdGhlIGJsYW5rIGFyZWEgb2YgdGhlIHBhcGVyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhcGVyOm1vdXNlbGVhdmUnLCBldnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9jZXNzTW91c2VXaGVlbEV2dEJ1ZjogZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnQsIGRlbHRhcyB9ID0gdGhpcy5fbXdfZXZ0X2J1ZmZlcjtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gZGVsdGFzLnJlZHVjZSgoYWNjLCBkZWx0YVkpID0+IGFjYyArIGNhcChkZWx0YVksIFdIRUVMX0NBUCksIDApO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMC45OTUsIGRlbHRhWSk7IC8vIDEuMDA1IGZvciBpbnZlcnRlZCBwaW5jaC96b29tXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5jbGllbnRUb0xvY2FsUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6cGluY2gnLCBldmVudCwgeCwgeSwgc2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX213X2V2dF9idWZmZXIgPSB7XG4gICAgICAgICAgICBldmVudDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhczogW10sXG4gICAgICAgIH07XG4gICAgfSwgV0hFRUxfV0FJVF9NUywgeyBtYXhXYWl0OiBXSEVFTF9XQUlUX01TIH0pLFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBldnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChvcmlnaW5hbEV2ZW50LmNsaWVudFgsIG9yaWdpbmFsRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IG5vcm1hbGl6ZVdoZWVsKG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIGNvbnN0IHBpbmNoSGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbJ3BhcGVyOnBpbmNoJ107XG5cbiAgICAgICAgLy8gVG91Y2hwYWQgZGV2aWNlcyB3aWxsIHNlbmQgYSBmYWtlIENUUkwgcHJlc3Mgd2hlbiBhIHBpbmNoIGlzIHBlcmZvcm1lZFxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgc3Vic2NyaWJlcnMgdG8gcGFwZXI6cGluY2ggZXZlbnQuIElmIHRoZXJlIGFyZSBub25lLFxuICAgICAgICAvLyBqdXN0IHNraXAgdGhlIGVudGlyZSBibG9jayBvZiBjb2RlICh3ZSBkb24ndCB3YW50IHRvIGJsaW5kbHkgY2FsbFxuICAgICAgICAvLyAucHJldmVudERlZmF1bHQoKSBpZiB3ZSByZWFsbHkgZG9uJ3QgaGF2ZSB0bykuXG4gICAgICAgIGlmIChldnQuY3RybEtleSAmJiBwaW5jaEhhbmRsZXJzICYmIHBpbmNoSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHBpbmNoIGdlc3R1cmUsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCB3ZSBtdXN0IGNhbGwgLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX213X2V2dF9idWZmZXIuZXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fbXdfZXZ0X2J1ZmZlci5kZWx0YXMucHVzaChkZWx0YVkpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc01vdXNlV2hlZWxFdnRCdWYoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSkpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICB2aWV3Lm1vdXNld2hlZWwoZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSwgZGVsdGEpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6bW91c2V3aGVlbCcsIGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnksIGRlbHRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYXBlcjpwYW4nLCBldnQsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbmV2ZW50OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB2YXIgZXZlbnROb2RlID0gZXZ0LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudE5vZGUuZ2V0QXR0cmlidXRlKCdldmVudCcpO1xuICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZlbnROb2RlKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG5cbiAgICAgICAgICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgdmlldy5vbmV2ZW50KGV2dCwgZXZlbnROYW1lLCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFnbmV0RXZlbnQ6IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xuXG4gICAgICAgIHZhciBtYWduZXROb2RlID0gZXZ0LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHZhciBtYWduZXRWYWx1ZSA9IG1hZ25ldE5vZGUuZ2V0QXR0cmlidXRlKCdtYWduZXQnKTtcbiAgICAgICAgaWYgKG1hZ25ldFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcobWFnbmV0Tm9kZSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHZpZXcsIGV2dCwgbWFnbmV0Tm9kZSwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9ubWFnbmV0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBpZiAoZXZ0LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudUZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFnbmV0Q29udGV4dE1lbnVGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0bWVudUV2dCA9ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29udGV4dG1lbnUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGV2dC5kYXRhLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGV2dC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51VHJpZ2dlcihjb250ZXh0bWVudUV2dCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dG1lbnVFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFnbmV0RXZlbnQoZXZ0LCBmdW5jdGlvbih2aWV3LCBldnQsIF8sIHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2aWV3Lm9ubWFnbmV0KGV2dCwgeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubWFnbmV0RXZlbnQoZXZ0LCBmdW5jdGlvbih2aWV3LCBldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICAgICAgdmlldy5tYWduZXRwb2ludGVyZGJsY2xpY2soZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0Y29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRDb250ZXh0TWVudSkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWFnbmV0Q29udGV4dE1lbnVGaXJlZCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRDb250ZXh0TWVudUZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51VHJpZ2dlcihldnQpO1xuICAgIH0sXG5cbiAgICBtYWduZXRDb250ZXh0TWVudVRyaWdnZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGlzLm1hZ25ldEV2ZW50KGV2dCwgZnVuY3Rpb24odmlldywgZXZ0LCBtYWduZXQsIHgsIHkpIHtcbiAgICAgICAgICAgIHZpZXcubWFnbmV0Y29udGV4dG1lbnUoZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25sYWJlbDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsTm9kZSA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhsYWJlbE5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgICAgIGNvbnN0IGV2ZW50RXZ0ID0gdGhpcy5jdXN0b21FdmVudFRyaWdnZXIoZXZ0LCB2aWV3LCBsYWJlbE5vZGUpO1xuICAgICAgICBpZiAoZXZlbnRFdnQpIHtcbiAgICAgICAgICAgIC8vIGBvbmV2ZW50YCBjb3VsZCBoYXZlIHN0b3BwZWQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgIGlmIChldmVudEV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2dC5kYXRhID0gZXZlbnRFdnQuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgIHZpZXcub25sYWJlbChldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRlckFyZ3MoZXZ0KSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuc25hcFRvR3JpZChub3JtYWxpemVkRXZ0LmNsaWVudFgsIG5vcm1hbGl6ZWRFdnQuY2xpZW50WSk7XG4gICAgICAgIHJldHVybiBbbm9ybWFsaXplZEV2dCwgeCwgeV07XG4gICAgfSxcblxuICAgIGRlbGVnYXRlRHJhZ0V2ZW50czogZnVuY3Rpb24odmlldywgZGF0YSkge1xuXG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSB7fSk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKHsgZGF0YTogZGF0YSB9LCB7IHNvdXJjZVZpZXc6IHZpZXcgfHwgbnVsbCwgbW91c2Vtb3ZlZDogMCB9KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKG51bGwsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvLyBHdWFyZCB0aGUgc3BlY2lmaWVkIGV2ZW50LiBJZiB0aGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQsIGd1YXJkIHJldHVybnMgYHRydWVgLlxuICAgIC8vIE90aGVyd2lzZSwgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgIGd1YXJkOiBmdW5jdGlvbihldnQsIHZpZXcpIHtcblxuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2dC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZWQgYXMgYGNvbnRleHRtZW51YCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3VhcmQgJiYgdGhpcy5vcHRpb25zLmd1YXJkKGV2dCwgdmlldykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2dC5kYXRhICYmIGV2dC5kYXRhLmd1YXJkZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2dC5kYXRhLmd1YXJkZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZ0O1xuXG4gICAgICAgIGlmICh0aGlzLkdVQVJERURfVEFHX05BTUVTLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlldyAmJiB2aWV3Lm1vZGVsICYmICh2aWV3Lm1vZGVsIGluc3RhbmNlb2YgQ2VsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN2ZyA9PT0gdGFyZ2V0IHx8IHRoaXMuZWwgPT09IHRhcmdldCB8fCAkLmNvbnRhaW5zKHRoaXMuc3ZnLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgLy8gRXZlbnQgZ3VhcmRlZC4gUGFwZXIgc2hvdWxkIG5vdCByZWFjdCBvbiBpdCBpbiBhbnkgd2F5LlxuICAgIH0sXG5cbiAgICBzZXRHcmlkU2l6ZTogZnVuY3Rpb24oZ3JpZFNpemUpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kcmF3R3JpZCAmJiAhb3B0aW9ucy5kcmF3R3JpZFNpemUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZWRyYXcgdGhlIGdyaWQgaWYgdGhlIGBkcmF3R3JpZFNpemVgIGlzIHNldC5cbiAgICAgICAgICAgIHRoaXMuZHJhd0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhckdyaWQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLiRncmlkKSB7XG4gICAgICAgICAgICB0aGlzLiRncmlkLmNzcygnYmFja2dyb3VuZEltYWdlJywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2dldEdyaWRSZWZzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2dyaWRDYWNoZSkge1xuXG4gICAgICAgICAgICB0aGlzLl9ncmlkQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgcm9vdDogVignc3ZnJywgeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9LCBWKCdkZWZzJykpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm5zOiB7fSxcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCB2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgVih0aGlzLnJvb3Qubm9kZS5jaGlsZE5vZGVzWzBdKS5hcHBlbmQodmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXR0ZXJuc1tpZF0gPSB2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5hcHBlbmQoVigncmVjdCcsIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIGZpbGw6ICd1cmwoIycgKyBpZCArICcpJyB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm5zW2lkXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4aXN0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuc1tpZF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWRDYWNoZTtcbiAgICB9LFxuXG4gICAgc2V0R3JpZDogZnVuY3Rpb24oZHJhd0dyaWQpIHtcblxuICAgICAgICB0aGlzLmNsZWFyR3JpZCgpO1xuXG4gICAgICAgIHRoaXMuX2dyaWRDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dyaWRTZXR0aW5ncyA9IFtdO1xuXG4gICAgICAgIHZhciBvcHRpb25zTGlzdCA9IEFycmF5LmlzQXJyYXkoZHJhd0dyaWQpID8gZHJhd0dyaWQgOiBbZHJhd0dyaWQgfHwge31dO1xuICAgICAgICBvcHRpb25zTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRTZXR0aW5ncy5wdXNoLmFwcGx5KHRoaXMuX2dyaWRTZXR0aW5ncywgdGhpcy5fcmVzb2x2ZURyYXdHcmlkT3B0aW9uKGl0ZW0pKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZURyYXdHcmlkT3B0aW9uOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5ncmlkUGF0dGVybnM7XG4gICAgICAgIGlmIChpc1N0cmluZyhvcHQpICYmIEFycmF5LmlzQXJyYXkobmFtZXNwYWNlW29wdF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlW29wdF0ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHQgfHwgeyBhcmdzOiBbe31dIH07XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShvcHRpb25zKTtcbiAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5ICYmICFuYW1lICYmICFvcHRpb25zLm1hcmt1cCkge1xuICAgICAgICAgICAgbmFtZSA9ICdkb3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgJiYgQXJyYXkuaXNBcnJheShuYW1lc3BhY2VbbmFtZV0pKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IG5hbWVzcGFjZVtuYW1lXS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmFyZ3MpID8gb3B0aW9ucy5hcmdzIDogW29wdGlvbnMuYXJncyB8fCB7fV07XG5cbiAgICAgICAgICAgIGRlZmF1bHRzKGFyZ3NbMF0sIG9taXQob3B0LCAnYXJncycpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihwYXR0ZXJuW2ldLCBhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gb3B0aW9ucyA6IFtvcHRpb25zXTtcbiAgICB9LFxuXG4gICAgZHJhd0dyaWQ6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIGNvbnN0IGdyaWRTaXplID0gdGhpcy5vcHRpb25zLmRyYXdHcmlkU2l6ZSB8fCB0aGlzLm9wdGlvbnMuZ3JpZFNpemU7XG4gICAgICAgIGlmIChncmlkU2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhckdyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbE9wdGlvbnMgPSBBcnJheS5pc0FycmF5KG9wdCkgPyBvcHQgOiBbb3B0XTtcblxuICAgICAgICB2YXIgY3RtID0gdGhpcy5tYXRyaXgoKTtcbiAgICAgICAgdmFyIHJlZnMgPSB0aGlzLl9nZXRHcmlkUmVmcygpO1xuXG4gICAgICAgIHRoaXMuX2dyaWRTZXR0aW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGdyaWRMYXllclNldHRpbmcsIGluZGV4KSB7XG5cbiAgICAgICAgICAgIHZhciBpZCA9ICdwYXR0ZXJuXycgKyBpbmRleDtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gbWVyZ2UoZ3JpZExheWVyU2V0dGluZywgbG9jYWxPcHRpb25zW2luZGV4XSwge1xuICAgICAgICAgICAgICAgIHN4OiBjdG0uYSB8fCAxLFxuICAgICAgICAgICAgICAgIHN5OiBjdG0uZCB8fCAxLFxuICAgICAgICAgICAgICAgIG94OiBjdG0uZSB8fCAwLFxuICAgICAgICAgICAgICAgIG95OiBjdG0uZiB8fCAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3B0aW9ucy53aWR0aCA9IGdyaWRTaXplICogKGN0bS5hIHx8IDEpICogKG9wdGlvbnMuc2NhbGVGYWN0b3IgfHwgMSk7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IGdyaWRTaXplICogKGN0bS5kIHx8IDEpICogKG9wdGlvbnMuc2NhbGVGYWN0b3IgfHwgMSk7XG5cbiAgICAgICAgICAgIGlmICghcmVmcy5leGlzdChpZCkpIHtcbiAgICAgICAgICAgICAgICByZWZzLmFkZChpZCwgVigncGF0dGVybicsIHsgaWQ6IGlkLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZScgfSwgVihvcHRpb25zLm1hcmt1cCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdHRlcm5EZWZWZWwgPSByZWZzLmdldChpZCk7XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMudXBkYXRlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXBkYXRlKHBhdHRlcm5EZWZWZWwubm9kZS5jaGlsZE5vZGVzWzBdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHggPSBvcHRpb25zLm94ICUgb3B0aW9ucy53aWR0aDtcbiAgICAgICAgICAgIGlmICh4IDwgMCkgeCArPSBvcHRpb25zLndpZHRoO1xuXG4gICAgICAgICAgICB2YXIgeSA9IG9wdGlvbnMub3kgJSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIGlmICh5IDwgMCkgeSArPSBvcHRpb25zLmhlaWdodDtcblxuICAgICAgICAgICAgcGF0dGVybkRlZlZlbC5hdHRyKHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXR0ZXJuVXJpID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhyZWZzLnJvb3Qubm9kZSk7XG4gICAgICAgIHBhdHRlcm5VcmkgPSAndXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJyArIGJ0b2EocGF0dGVyblVyaSkgKyAnKSc7XG5cbiAgICAgICAgdGhpcy4kZ3JpZC5jc3MoJ2JhY2tncm91bmRJbWFnZScsIHBhdHRlcm5VcmkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1cGRhdGVCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgYmFja2dyb3VuZFBvc2l0aW9uID0gb3B0LnBvc2l0aW9uIHx8ICdjZW50ZXInO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFNpemUgPSBvcHQuc2l6ZSB8fCAnYXV0byBhdXRvJztcblxuICAgICAgICB2YXIgY3VycmVudFNjYWxlID0gdGhpcy5zY2FsZSgpO1xuICAgICAgICB2YXIgY3VycmVudFRyYW5zbGF0ZSA9IHRoaXMudHJhbnNsYXRlKCk7XG5cbiAgICAgICAgLy8gYmFja2dyb3VuZFBvc2l0aW9uXG4gICAgICAgIGlmIChpc09iamVjdChiYWNrZ3JvdW5kUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGN1cnJlbnRUcmFuc2xhdGUudHggKyAoY3VycmVudFNjYWxlLnN4ICogKGJhY2tncm91bmRQb3NpdGlvbi54IHx8IDApKTtcbiAgICAgICAgICAgIHZhciB5ID0gY3VycmVudFRyYW5zbGF0ZS50eSArIChjdXJyZW50U2NhbGUuc3kgKiAoYmFja2dyb3VuZFBvc2l0aW9uLnkgfHwgMCkpO1xuICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uID0geCArICdweCAnICsgeSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrZ3JvdW5kU2l6ZVxuICAgICAgICBpZiAoaXNPYmplY3QoYmFja2dyb3VuZFNpemUpKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA9IG5ldyBSZWN0KGJhY2tncm91bmRTaXplKS5zY2FsZShjdXJyZW50U2NhbGUuc3gsIGN1cnJlbnRTY2FsZS5zeSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmRTaXplLndpZHRoICsgJ3B4ICcgKyBiYWNrZ3JvdW5kU2l6ZS5oZWlnaHQgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kYmFja2dyb3VuZC5jc3Moe1xuICAgICAgICAgICAgYmFja2dyb3VuZFNpemU6IGJhY2tncm91bmRTaXplLFxuICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBiYWNrZ3JvdW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRyYXdCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uKGltZywgb3B0KSB7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGJhY2tncm91bmQgaW1hZ2UgaWYgbm8gaW1hZ2UgcHJvdmlkZWRcbiAgICAgICAgaWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuJGJhY2tncm91bmQuY3NzKCdiYWNrZ3JvdW5kSW1hZ2UnLCAnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2JhY2tncm91bmQgfHwgdGhpcy5fYmFja2dyb3VuZC5pZCAhPT0gb3B0LmlkKSB7XG4gICAgICAgICAgICAvLyBEcmF3IG9ubHkgdGhlIGxhc3QgaW1hZ2UgcmVxdWVzdGVkIChzZWUgZHJhd0JhY2tncm91bmQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgYmFja2dyb3VuZEltYWdlO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFNpemUgPSBvcHQuc2l6ZTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRSZXBlYXQgPSBvcHQucmVwZWF0IHx8ICduby1yZXBlYXQnO1xuICAgICAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBvcHQub3BhY2l0eSB8fCAxO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFF1YWxpdHkgPSBNYXRoLmFicyhvcHQucXVhbGl0eSkgfHwgMTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRQYXR0ZXJuID0gdGhpcy5jb25zdHJ1Y3Rvci5iYWNrZ3JvdW5kUGF0dGVybnNbY2FtZWxDYXNlKGJhY2tncm91bmRSZXBlYXQpXTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihiYWNrZ3JvdW5kUGF0dGVybikpIHtcbiAgICAgICAgICAgIC8vICdmbGlwLXgnLCAnZmxpcC15JywgJ2ZsaXAteHknLCAnd2F0ZXJtYXJrJyBhbmQgY3VzdG9tXG4gICAgICAgICAgICBpbWcud2lkdGggKj0gYmFja2dyb3VuZFF1YWxpdHk7XG4gICAgICAgICAgICBpbWcuaGVpZ2h0ICo9IGJhY2tncm91bmRRdWFsaXR5O1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGJhY2tncm91bmRQYXR0ZXJuKGltZywgb3B0KTtcbiAgICAgICAgICAgIGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLlBhcGVyOiBiYWNrZ3JvdW5kIHBhdHRlcm4gbXVzdCByZXR1cm4gYW4gSFRNTCBDYW52YXMgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0ID0gJ3JlcGVhdCc7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoYmFja2dyb3VuZFNpemUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHRpbGUgc2l6ZSBpZiBhbiBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFNpemUud2lkdGggKj0gY2FudmFzLndpZHRoIC8gaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRTaXplLmhlaWdodCAqPSBjYW52YXMuaGVpZ2h0IC8gaW1nLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFja2dyb3VuZFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdGlsZSBzaXplIGlmIG5vIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgb3B0LnNpemUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGggLyBiYWNrZ3JvdW5kUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0IC8gYmFja2dyb3VuZFF1YWxpdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmFja2dyb3VuZFJlcGVhdDpcbiAgICAgICAgICAgIC8vIG5vLXJlcGVhdCcsICdyb3VuZCcsICdzcGFjZScsICdyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBpbWcuc3JjO1xuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSBpbWFnZSBzaXplIGZvciAgdGhlIGJhY2tncm91bmRTaXplIGlmIG5vIHNpemUgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBvcHQuc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGJhY2tncm91bmQuY3NzKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IGJhY2tncm91bmRPcGFjaXR5LFxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogYmFja2dyb3VuZFJlcGVhdCxcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgYmFja2dyb3VuZEltYWdlICsgJyknXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZEltYWdlKG9wdCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcblxuICAgICAgICB0aGlzLiRlbC5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGNvbG9yIHx8ICcnKTtcbiAgICB9LFxuXG4gICAgZHJhd0JhY2tncm91bmQ6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJhY2tncm91bmRDb2xvcihvcHQuY29sb3IpO1xuXG4gICAgICAgIGlmIChvcHQuaW1hZ2UpIHtcbiAgICAgICAgICAgIG9wdCA9IHRoaXMuX2JhY2tncm91bmQgPSBjbG9uZURlZXAob3B0KTtcbiAgICAgICAgICAgIGd1aWQob3B0KTtcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSB0aGlzLmRyYXdCYWNrZ3JvdW5kSW1hZ2UuYmluZCh0aGlzLCBpbWcsIG9wdCk7XG4gICAgICAgICAgICBpbWcuc3JjID0gb3B0LmltYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZEltYWdlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0SW50ZXJhY3Rpdml0eTogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgPSB2YWx1ZTtcblxuICAgICAgICBpbnZva2UodGhpcy5fdmlld3MsICdzZXRJbnRlcmFjdGl2aXR5JywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBQYXBlciBkZWZpbml0aW9ucy5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGlzRGVmaW5lZDogZnVuY3Rpb24oZGVmSWQpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLnN2Zy5nZXRFbGVtZW50QnlJZChkZWZJZCk7XG4gICAgfSxcblxuICAgIGRlZmluZUZpbHRlcjogZnVuY3Rpb24oZmlsdGVyKSB7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChmaWx0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZUZpbHRlcigpIHJlcXVpcmVzIDEuIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJJZCA9IGZpbHRlci5pZDtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWx0ZXIubmFtZTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3RyaW5naWZpZWQgZmlsdGVyIGRlZmluaXRpb24uIFRoaXMgZ2l2ZXMgdXNcbiAgICAgICAgLy8gYSB1bmlxdWUgZmlsdGVyIElEIGZvciBkaWZmZXJlbnQgZGVmaW5pdGlvbnMuXG4gICAgICAgIGlmICghZmlsdGVySWQpIHtcbiAgICAgICAgICAgIGZpbHRlcklkID0gbmFtZSArIHRoaXMuc3ZnLmlkICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkoZmlsdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGZpbHRlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgYW5kIHdlIGNhbiBqdXN0IHVzZSBpdCAocmVmZXJlbmNlIGl0IHVzaW5nIGB1cmwoKWApLlxuICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGlmICghdGhpcy5pc0RlZmluZWQoZmlsdGVySWQpKSB7XG5cbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBfZmlsdGVyO1xuICAgICAgICAgICAgdmFyIGZpbHRlclNWR1N0cmluZyA9IG5hbWVzcGFjZVtuYW1lXSAmJiBuYW1lc3BhY2VbbmFtZV0oZmlsdGVyLmFyZ3MgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJTVkdTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leGlzdGluZyBmaWx0ZXIgJyArIG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZpbHRlciBhcmVhIHRvIGJlIDN4IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGNlbGxcbiAgICAgICAgICAgIC8vIGFuZCBjZW50ZXIgdGhlIGZpbHRlciBhcm91bmQgdGhlIGNlbGwuXG4gICAgICAgICAgICB2YXIgZmlsdGVyQXR0cnMgPSBhc3NpZ24oe1xuICAgICAgICAgICAgICAgIGZpbHRlclVuaXRzOiAnb2JqZWN0Qm91bmRpbmdCb3gnLFxuICAgICAgICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgICAgICAgIHk6IC0xLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICAgICAgICAgIGhlaWdodDogM1xuICAgICAgICAgICAgfSwgZmlsdGVyLmF0dHJzLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGZpbHRlcklkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVihmaWx0ZXJTVkdTdHJpbmcsIGZpbHRlckF0dHJzKS5hcHBlbmRUbyh0aGlzLmRlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgIH0sXG5cbiAgICBkZWZpbmVHcmFkaWVudDogZnVuY3Rpb24oZ3JhZGllbnQpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChncmFkaWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5QYXBlcjogZGVmaW5lR3JhZGllbnQoKSByZXF1aXJlcyAxLiBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdmcsIGRlZnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggY29kZSBmcm9tIHRoZSBzdHJpbmdpZmllZCBmaWx0ZXIgZGVmaW5pdGlvbi4gVGhpcyBnaXZlcyB1c1xuICAgICAgICAgICAgLy8gYSB1bmlxdWUgZmlsdGVyIElEIGZvciBkaWZmZXJlbnQgZGVmaW5pdGlvbnMuXG4gICAgICAgICAgICBpZCA9IHR5cGUgKyBzdmcuaWQgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShncmFkaWVudCkpLFxuICAgICAgICAgICAgc3RvcHMsXG4gICAgICAgICAgICBhdHRycyA9IHt9XG4gICAgICAgIH0gPSBncmFkaWVudDtcbiAgICAgICAgLy8gSWYgdGhlIGdyYWRpZW50IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudCxcbiAgICAgICAgLy8gd2UncmUgZG9uZSBhbmQgd2UgY2FuIGp1c3QgdXNlIGl0IChyZWZlcmVuY2UgaXQgdXNpbmcgYHVybCgpYCkuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmaW5lZChpZCkpIHJldHVybiBpZDtcbiAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lLlxuICAgICAgICBjb25zdCBzdG9wVkVscyA9IHRvQXJyYXkoc3RvcHMpLm1hcCgoeyBvZmZzZXQsIGNvbG9yLCBvcGFjaXR5IH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBWKCdzdG9wJykuYXR0cih7XG4gICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAnc3RvcC1jb2xvcic6IGNvbG9yLFxuICAgICAgICAgICAgICAgICdzdG9wLW9wYWNpdHknOiBOdW1iZXIuaXNGaW5pdGUob3BhY2l0eSkgPyBvcGFjaXR5IDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBncmFkaWVudFZFbCA9IFYodHlwZSwgYXR0cnMsIHN0b3BWRWxzKTtcbiAgICAgICAgZ3JhZGllbnRWRWwuaWQgPSBpZDtcbiAgICAgICAgZ3JhZGllbnRWRWwuYXBwZW5kVG8oZGVmcyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuXG4gICAgZGVmaW5lUGF0dGVybjogZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHBhdHRlcm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZVBhdHRlcm4oKSByZXF1aXJlcyAxLiBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdmcsIGRlZnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBjb2RlIGZyb20gdGhlIHN0cmluZ2lmaWVkIGZpbHRlciBkZWZpbml0aW9uLiBUaGlzIGdpdmVzIHVzXG4gICAgICAgICAgICAvLyBhIHVuaXF1ZSBmaWx0ZXIgSUQgZm9yIGRpZmZlcmVudCBkZWZpbml0aW9ucy5cbiAgICAgICAgICAgIGlkID0gc3ZnLmlkICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkocGF0dGVybikpLFxuICAgICAgICAgICAgbWFya3VwLFxuICAgICAgICAgICAgYXR0cnMgPSB7fVxuICAgICAgICB9ID0gcGF0dGVybjtcbiAgICAgICAgaWYgKCFtYXJrdXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5QYXBlcjogZGVmaW5lUGF0dGVybigpIHJlcXVpcmVzIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZ3JhZGllbnQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50LFxuICAgICAgICAvLyB3ZSdyZSBkb25lIGFuZCB3ZSBjYW4ganVzdCB1c2UgaXQgKHJlZmVyZW5jZSBpdCB1c2luZyBgdXJsKClgKS5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZpbmVkKGlkKSkgcmV0dXJuIGlkO1xuICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGNvbnN0IHBhdHRlcm5WRWwgPSBWKCdwYXR0ZXJuJywge1xuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgICAgIH0pO1xuICAgICAgICBwYXR0ZXJuVkVsLmlkID0gaWQ7XG4gICAgICAgIHBhdHRlcm5WRWwuYXR0cihhdHRycyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVyblZFbC5hcHBlbmQoVihtYXJrdXApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhZ21lbnQgfSA9IHBhcnNlRE9NSlNPTihtYXJrdXApO1xuICAgICAgICAgICAgcGF0dGVyblZFbC5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhdHRlcm5WRWwuYXBwZW5kVG8oZGVmcyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuXG4gICAgZGVmaW5lTWFya2VyOiBmdW5jdGlvbihtYXJrZXIpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChtYXJrZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZU1hcmtlcigpIHJlcXVpcmVzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdmcsIGRlZnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBjb2RlIGZyb20gdGhlIHN0cmluZ2lmaWVkIGZpbHRlciBkZWZpbml0aW9uLiBUaGlzIGdpdmVzIHVzXG4gICAgICAgICAgICAvLyBhIHVuaXF1ZSBmaWx0ZXIgSUQgZm9yIGRpZmZlcmVudCBkZWZpbml0aW9ucy5cbiAgICAgICAgICAgIGlkID0gc3ZnLmlkICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkobWFya2VyKSksXG4gICAgICAgICAgICAvLyB1c2VyLXByb3ZpZGVkIG1hcmt1cFxuICAgICAgICAgICAgLy8gKGUuZy4gZGVmaW5lZCB3aGVuIGNyZWF0aW5nIGxpbmsgdmlhIGBhdHRycy9saW5lL3NvdXJjZU1hcmtlci9tYXJrdXBgKVxuICAgICAgICAgICAgbWFya3VwLFxuICAgICAgICAgICAgLy8gdXNlci1wcm92aWRlZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyAoZS5nLiBkZWZpbmVkIHdoZW4gY3JlYXRpbmcgbGluayB2aWEgYGF0dHJzL2xpbmUvc291cmNlTWFya2VyL2F0dHJzYClcbiAgICAgICAgICAgIC8vIG5vdGU6IGB0cmFuc2Zvcm1gIGF0dHJzIGFyZSBpZ25vcmVkIGJ5IGJyb3dzZXJzXG4gICAgICAgICAgICBhdHRycyA9IHt9LFxuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCAtIHVzZSBgYXR0cnMvbWFya2VyVW5pdHNgIGluc3RlYWQgKHdoaWNoIGhhcyBoaWdoZXIgcHJpb3JpdHkpXG4gICAgICAgICAgICBtYXJrZXJVbml0cyA9ICd1c2VyU3BhY2VPblVzZSdcbiAgICAgICAgfSA9IG1hcmtlcjtcbiAgICAgICAgLy8gSWYgdGhlIG1hcmtlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgYW5kIHdlIGNhbiBqdXN0IHVzZSBpdCAocmVmZXJlbmNlIGl0IHVzaW5nIGB1cmwoKWApLlxuICAgICAgICBpZiAodGhpcy5pc0RlZmluZWQoaWQpKSByZXR1cm4gaWQ7XG4gICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgICAgY29uc3QgbWFya2VyVkVsID0gVignbWFya2VyJywge1xuICAgICAgICAgICAgb3JpZW50OiAnYXV0bycsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgbWFya2VyVW5pdHM6IG1hcmtlclVuaXRzXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXJWRWwuaWQgPSBpZDtcbiAgICAgICAgbWFya2VyVkVsLmF0dHIoYXR0cnMpO1xuICAgICAgICBsZXQgbWFya2VyQ29udGVudFZFbDtcbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgICAgbGV0IG1hcmt1cFZFbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIE1hcmtlciBvYmplY3QgaGFzIGEgYG1hcmt1cGAgcHJvcGVydHkgb2YgdHlwZSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgLy8gLSBDb25zdHJ1Y3QgViBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgbWFya3VwVkVsID0gVihtYXJrdXApO1xuICAgICAgICAgICAgICAgIC8vIGBtYXJrdXBWRWxgIGlzIG5vdyBlaXRoZXIgYSBzaW5nbGUgVkVsLCBvciBhbiBhcnJheSBvZiBWRWxzLlxuICAgICAgICAgICAgICAgIC8vIC0gQ29lcmNlIGl0IHRvIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgIG1hcmt1cFZFbCA9IChBcnJheS5pc0FycmF5KG1hcmt1cFZFbCkgPyBtYXJrdXBWRWwgOiBbbWFya3VwVkVsXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1hcmtlciBvYmplY3QgaGFzIGEgYG1hcmt1cGAgcHJvcGVydHkgb2YgdHlwZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gLSBDb25zdHJ1Y3QgViBmcm9tIHRoZSBvYmplY3QgYnkgcGFyc2luZyBpdCBhcyBET00gSlNPTi5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyYWdtZW50IH0gPSBwYXJzZURPTUpTT04obWFya3VwKTtcbiAgICAgICAgICAgICAgICBtYXJrdXBWRWwgPSBWKGZyYWdtZW50KS5jaGlsZHJlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYG1hcmt1cFZFbGAgaXMgYW4gYXJyYXkgd2l0aCBvbmUgb3IgbW9yZSBWRWxzIGluc2lkZS5cbiAgICAgICAgICAgIC8vIC0gSWYgdGhlcmUgYXJlIG11bHRpcGxlIFZFbHMsIHdyYXAgdGhlbSBpbiBhIG5ld2x5LWNvbnN0cnVjdGVkIDxnPiBlbGVtZW50XG4gICAgICAgICAgICBpZiAobWFya3VwVkVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJDb250ZW50VkVsID0gVignZycpLmFwcGVuZChtYXJrdXBWRWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJDb250ZW50VkVsID0gbWFya3VwVkVsWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFya2VyIG9iamVjdCBpcyBhIGZsYXQgc3RydWN0dXJlLlxuICAgICAgICAgICAgLy8gLSBDb25zdHJ1Y3QgYSBuZXcgViBvZiB0eXBlIGBtYXJrZXIudHlwZWAuXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgPSAncGF0aCcgfSA9IG1hcmtlcjtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnRWRWwgPSBWKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBtYXJrZXJDb250ZW50VkVsYCBpcyBhIHNpbmdsZSBWRWwuXG4gICAgICAgIC8vIEFzc2lnbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gaXQgKD0gY29udGV4dCBhdHRyaWJ1dGVzICsgbWFya2VyIGF0dHJpYnV0ZXMpOlxuICAgICAgICAvLyAtIEF0dHJpYnV0ZSB2YWx1ZXMgYXJlIHRha2VuIGZyb20gbm9uLXNwZWNpYWwgcHJvcGVydGllcyBvZiBgbWFya2VyYC5cbiAgICAgICAgY29uc3QgbWFya2VyQXR0cnMgPSBvbWl0KG1hcmtlciwgJ3R5cGUnLCAnaWQnLCAnbWFya3VwJywgJ2F0dHJzJywgJ21hcmtlclVuaXRzJyk7XG4gICAgICAgIGNvbnN0IG1hcmtlckF0dHJzS2V5cyA9IE9iamVjdC5rZXlzKG1hcmtlckF0dHJzKTtcbiAgICAgICAgbWFya2VyQXR0cnNLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXJrZXJBdHRyc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbWFya3VwVmFsdWUgPSBtYXJrZXJDb250ZW50VkVsLmF0dHIoa2V5KTsgLy8gdmFsdWUgY29taW5nIGZyb20gbWFya3VwVkVsIChpZiBhbnkpID0gaGlnaGVyIHByaW9yaXR5XG4gICAgICAgICAgICBpZiAobWFya3VwVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgbG9naWM6XG4gICAgICAgICAgICAgICAgbWFya2VyQ29udGVudFZFbC5hdHRyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIHdpdGggc3BlY2lhbCBsb2dpYyBzaG91bGQgYmUgYWRkZWQgYXMgY2FzZXMgdG8gdGhpcyBzd2l0Y2ggYmxvY2s6XG4gICAgICAgICAgICAgICAgc3dpdGNoKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBQcmVwZW5kIGB0cmFuc2Zvcm1gIHRvIGV4aXN0aW5nIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyQ29udGVudFZFbC5hdHRyKGtleSwgKHZhbHVlICsgJyAnICsgbWFya3VwVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlckNvbnRlbnRWRWwuYXBwZW5kVG8obWFya2VyVkVsKTtcbiAgICAgICAgbWFya2VyVkVsLmFwcGVuZFRvKGRlZnMpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIGN1c3RvbUV2ZW50VHJpZ2dlcjogZnVuY3Rpb24oZXZ0LCB2aWV3LCByb290Tm9kZSA9IHZpZXcuZWwpIHtcblxuICAgICAgICBjb25zdCBldmVudE5vZGUgPSBldnQudGFyZ2V0LmNsb3Nlc3QoJ1tldmVudF0nKTtcblxuICAgICAgICBpZiAoZXZlbnROb2RlICYmIHJvb3ROb2RlICE9PSBldmVudE5vZGUgJiYgdmlldy5lbC5jb250YWlucyhldmVudE5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudEV2dCA9IG5vcm1hbGl6ZUV2ZW50KCQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBldnQuZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IHRoZSBldmVudCBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG8gdGhlIGV2ZW50IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnROb2RlXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMub25ldmVudChldmVudEV2dCk7XG5cbiAgICAgICAgICAgIGlmIChldmVudEV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRFdnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbn0sIHtcblxuICAgIHNvcnRpbmc6IHNvcnRpbmdUeXBlcyxcblxuICAgIExheWVyczogTGF5ZXJzTmFtZXMsXG5cbiAgICBiYWNrZ3JvdW5kUGF0dGVybnM6IHtcblxuICAgICAgICBmbGlwWHk6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBiXG4gICAgICAgICAgICAvLyBxIHBcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDIgKiBpbWdXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyICogaW1nSGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAvLyB0b3AtbGVmdCBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8geHktZmxpcHBlZCBib3R0b20tcmlnaHQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLTEsIDAsIDAsIC0xLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8geC1mbGlwcGVkIHRvcC1yaWdodCBpbWFnZVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgtMSwgMCwgMCwgMSwgY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHktZmxpcHBlZCBib3R0b20tbGVmdCBpbWFnZVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcFg6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBiXG4gICAgICAgICAgICAvLyBkIGJcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoICogMjtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIC8vIGxlZnQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGZsaXBwZWQgcmlnaHQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMiAqIGltZ1dpZHRoLCAwKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcFk6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBkXG4gICAgICAgICAgICAvLyBxIHFcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZ0hlaWdodCAqIDI7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIC8vIHRvcCBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8gZmxpcHBlZCBib3R0b20gaW1hZ2VcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgMiAqIGltZ0hlaWdodCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhdGVybWFyazogZnVuY3Rpb24oaW1nLCBvcHQpIHtcbiAgICAgICAgICAgIC8vICAgZFxuICAgICAgICAgICAgLy8gZFxuXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIHZhciBpbWdIZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWdXaWR0aCAqIDM7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0ICogMztcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gaXNOdW1iZXIob3B0LndhdGVybWFya0FuZ2xlKSA/IC1vcHQud2F0ZXJtYXJrQW5nbGUgOiAtMjA7XG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IHRvUmFkKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzdGVwWCA9IGNhbnZhcy53aWR0aCAvIDQ7XG4gICAgICAgICAgICB2YXIgc3RlcFkgPSBjYW52YXMuaGVpZ2h0IC8gNDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyBqKSAlIDIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgKDIgKiBpIC0gMSkgKiBzdGVwWCwgKDIgKiBqIC0gMSkgKiBzdGVwWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHJhZGlhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIC1pbWdXaWR0aCAvIDIsIC1pbWdIZWlnaHQgLyAyLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBncmlkUGF0dGVybnM6IHtcbiAgICAgICAgZG90OiBbe1xuICAgICAgICAgICAgY29sb3I6ICcjQUFBQUFBJyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgIG1hcmt1cDogJ3JlY3QnLFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbCwgb3B0KSB7XG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvcHQudGhpY2tuZXNzICogb3B0LnN4LFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdC50aGlja25lc3MgKiBvcHQuc3ksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdC5jb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZml4ZWREb3Q6IFt7XG4gICAgICAgICAgICBjb2xvcjogJyNBQUFBQUEnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgbWFya3VwOiAncmVjdCcsXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG9wdC5zeCA8PSAxID8gb3B0LnRoaWNrbmVzcyAqIG9wdC5zeCA6IG9wdC50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIGZpbGw6IG9wdC5jb2xvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIG1lc2g6IFt7XG4gICAgICAgICAgICBjb2xvcjogJyNBQUFBQUEnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgbWFya3VwOiAncGF0aCcsXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9wdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gb3B0LnRoaWNrbmVzcztcblxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCAtIHRoaWNrbmVzcyA+PSAwICYmIGhlaWdodCAtIHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBbJ00nLCB3aWR0aCwgMCwgJ0gwIE0wIDAgVjAnLCBoZWlnaHRdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gJ00gMCAwIDAgMCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7ICdkJzogZCwgc3Ryb2tlOiBvcHQuY29sb3IsICdzdHJva2Utd2lkdGgnOiBvcHQudGhpY2tuZXNzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZG91YmxlTWVzaDogW3tcbiAgICAgICAgICAgIGNvbG9yOiAnI0FBQUFBQScsXG4gICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICBtYXJrdXA6ICdwYXRoJyxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oZWwsIG9wdCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gb3B0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBvcHQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSBvcHQudGhpY2tuZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIC0gdGhpY2tuZXNzID49IDAgJiYgaGVpZ2h0IC0gdGhpY2tuZXNzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IFsnTScsIHdpZHRoLCAwLCAnSDAgTTAgMCBWMCcsIGhlaWdodF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnTSAwIDAgMCAwJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBWKGVsKS5hdHRyKHsgJ2QnOiBkLCBzdHJva2U6IG9wdC5jb2xvciwgJ3N0cm9rZS13aWR0aCc6IG9wdC50aGlja25lc3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICB0aGlja25lc3M6IDMsXG4gICAgICAgICAgICBzY2FsZUZhY3RvcjogNCxcbiAgICAgICAgICAgIG1hcmt1cDogJ3BhdGgnLFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbCwgb3B0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBvcHQud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IG9wdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRoaWNrbmVzcyA9IG9wdC50aGlja25lc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggLSB0aGlja25lc3MgPj0gMCAmJiBoZWlnaHQgLSB0aGlja25lc3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gWydNJywgd2lkdGgsIDAsICdIMCBNMCAwIFYwJywgaGVpZ2h0XS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICdNIDAgMCAwIDAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFYoZWwpLmF0dHIoeyAnZCc6IGQsIHN0cm9rZTogb3B0LmNvbG9yLCAnc3Ryb2tlLXdpZHRoJzogb3B0LnRoaWNrbmVzcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbIlYiLCJpc051bWJlciIsImFzc2lnbiIsIm5leHRGcmFtZSIsImlzT2JqZWN0IiwiY2FuY2VsRnJhbWUiLCJkZWZhdWx0cyIsImRlZmF1bHRzRGVlcCIsImFkZENsYXNzTmFtZVByZWZpeCIsIm5vcm1hbGl6ZVNpZGVzIiwiaXNGdW5jdGlvbiIsImlzUGxhaW5PYmplY3QiLCJnZXRCeVBhdGgiLCJzb3J0RWxlbWVudHMiLCJpc1N0cmluZyIsImd1aWQiLCJub3JtYWxpemVFdmVudCIsIm5vcm1hbGl6ZVdoZWVsIiwiY2FwIiwiZGVib3VuY2UiLCJvbWl0IiwicmVzdWx0IiwibWVyZ2UiLCJjYW1lbENhc2UiLCJjbG9uZURlZXAiLCJpbnZva2UiLCJoYXNoQ29kZSIsImZpbHRlciIsIl9maWx0ZXIiLCJwYXJzZURPTUpTT04iLCJ0b0FycmF5IiwiaGFzIiwiUmVjdCIsIlBvaW50IiwidG9SYWQiLCJWaWV3Iiwidmlld3MiLCJDZWxsVmlldyIsIkVsZW1lbnRWaWV3IiwiTGlua1ZpZXciLCJMaW5rIiwiQ2VsbCIsIkdyYXBoIiwiTGF5ZXJzTmFtZXMiLCJQYXBlckxheWVyIiwiaGlnaGxpZ2h0ZXJzIiwibGlua0FuY2hvcnMiLCJjb25uZWN0aW9uUG9pbnRzIiwiYW5jaG9ycyIsIiQiLCJCYWNrYm9uZSIsInNvcnRpbmdUeXBlcyIsIk5PTkUiLCJBUFBST1giLCJFWEFDVCIsIldIRUVMX0NBUCIsIldIRUVMX1dBSVRfTVMiLCJNT1VOVF9CQVRDSF9TSVpFIiwiVVBEQVRFX0JBVENIX1NJWkUiLCJJbmZpbml0eSIsIk1JTl9QUklPUklUWSIsIkhpZ2hsaWdodGluZ1R5cGVzIiwiSGlnaGxpZ2h0aW5nIiwiZGVmYXVsdEhpZ2hsaWdodGluZyIsIkRFRkFVTFQiLCJuYW1lIiwib3B0aW9ucyIsInBhZGRpbmciLCJNQUdORVRfQVZBSUxBQklMSVRZIiwiY2xhc3NOYW1lIiwiRUxFTUVOVF9BVkFJTEFCSUxJVFkiLCJkZWZhdWx0TGF5ZXJzIiwiQkFDSyIsIkNFTExTIiwiTEFCRUxTIiwiRlJPTlQiLCJUT09MUyIsIlBhcGVyIiwiZXh0ZW5kIiwid2lkdGgiLCJoZWlnaHQiLCJvcmlnaW4iLCJ4IiwieSIsImdyaWRTaXplIiwiZHJhd0dyaWQiLCJkcmF3R3JpZFNpemUiLCJiYWNrZ3JvdW5kIiwicGVycGVuZGljdWxhckxpbmtzIiwiZWxlbWVudFZpZXciLCJsaW5rVmlldyIsInNuYXBMYWJlbHMiLCJzbmFwTGlua3MiLCJzbmFwTGlua3NTZWxmIiwibGFiZWxzTGF5ZXIiLCJtdWx0aUxpbmtzIiwiZ3VhcmQiLCJldnQiLCJ2aWV3IiwiaGlnaGxpZ2h0aW5nIiwicHJldmVudENvbnRleHRNZW51IiwicHJldmVudERlZmF1bHRCbGFua0FjdGlvbiIsInByZXZlbnREZWZhdWx0Vmlld0FjdGlvbiIsInJlc3RyaWN0VHJhbnNsYXRlIiwibWFya0F2YWlsYWJsZSIsImRlZmF1bHRMaW5rIiwiZGVmYXVsdENvbm5lY3RvciIsImRlZmF1bHRSb3V0ZXIiLCJkZWZhdWx0QW5jaG9yIiwiZGVmYXVsdExpbmtBbmNob3IiLCJkZWZhdWx0Q29ubmVjdGlvblBvaW50IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwidmFsaWRhdGVNYWduZXQiLCJfY2VsbFZpZXciLCJtYWduZXQiLCJfZXZ0IiwiZ2V0QXR0cmlidXRlIiwidmFsaWRhdGVDb25uZWN0aW9uIiwiY2VsbFZpZXdTIiwiX21hZ25ldFMiLCJjZWxsVmlld1QiLCJfbWFnbmV0VCIsImVuZCIsIl9saW5rVmlldyIsImVtYmVkZGluZ01vZGUiLCJ2YWxpZGF0ZUVtYmVkZGluZyIsImNoaWxkVmlldyIsInBhcmVudFZpZXciLCJ2YWxpZGF0ZVVuZW1iZWRkaW5nIiwiZmluZFBhcmVudEJ5IiwiZnJvbnRQYXJlbnRPbmx5IiwiaW50ZXJhY3RpdmUiLCJsYWJlbE1vdmUiLCJsaW5rUGlubmluZyIsImFsbG93TGluayIsImNsaWNrVGhyZXNob2xkIiwibW92ZVRocmVzaG9sZCIsIm1hZ25ldFRocmVzaG9sZCIsInNvcnRpbmciLCJmcm96ZW4iLCJhdXRvRnJlZXplIiwib25WaWV3VXBkYXRlIiwiZmxhZyIsInByaW9yaXR5Iiwib3B0IiwicGFwZXIiLCJGTEFHX0lOU0VSVCIsIkZMQUdfUkVNT1ZFIiwibW91bnRpbmciLCJpc29sYXRlIiwicmVxdWVzdENvbm5lY3RlZExpbmtzVXBkYXRlIiwib25WaWV3UG9zdHBvbmVkIiwiZm9yY2VQb3N0cG9uZWRWaWV3VXBkYXRlIiwiYmVmb3JlUmVuZGVyIiwiYWZ0ZXJSZW5kZXIiLCJ2aWV3cG9ydCIsImNlbGxWaWV3TmFtZXNwYWNlIiwicm91dGVyTmFtZXNwYWNlIiwiY29ubmVjdG9yTmFtZXNwYWNlIiwiaGlnaGxpZ2h0ZXJOYW1lc3BhY2UiLCJhbmNob3JOYW1lc3BhY2UiLCJsaW5rQW5jaG9yTmFtZXNwYWNlIiwiY29ubmVjdGlvblBvaW50TmFtZXNwYWNlIiwib3ZlcmZsb3ciLCJldmVudHMiLCJkb2N1bWVudEV2ZW50cyIsInN2ZyIsImRlZnMiLCJ0b29scyIsIiRiYWNrZ3JvdW5kIiwibGF5ZXJzIiwiJGdyaWQiLCIkZG9jdW1lbnQiLCJfdmlld3BvcnRNYXRyaXgiLCJfdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmciLCJfdXBkYXRlcyIsIl9sYXllcnMiLCJTT1JUX0RFTEFZSU5HX0JBVENIRVMiLCJVUERBVEVfREVMQVlJTkdfQkFUQ0hFUyIsIkZPUk1fQ09OVFJPTF9UQUdfTkFNRVMiLCJHVUFSREVEX1RBR19OQU1FUyIsIk1JTl9TQ0FMRSIsImluaXQiLCJlbCIsImpvaW50Iiwic2hhcGVzIiwibW9kZWwiLCJzZXRHcmlkIiwiY2xvbmVPcHRpb25zIiwicmVuZGVyIiwiX3NldERpbWVuc2lvbnMiLCJzdGFydExpc3RlbmluZyIsIl92aWV3cyIsIl9td19ldnRfYnVmZmVyIiwiZXZlbnQiLCJkZWx0YXMiLCJvd25lckRvY3VtZW50IiwicmVzZXRWaWV3cyIsImF0dHJpYnV0ZXMiLCJjZWxscyIsIm1vZGVscyIsImlzRnJvemVuIiwiaXNBc3luYyIsInVwZGF0ZVZpZXdzQXN5bmMiLCJfcmVzZXRVcGRhdGVzIiwiaWQiLCJwcmlvcml0aWVzIiwidW5tb3VudGVkQ2lkcyIsIm1vdW50ZWRDaWRzIiwidW5tb3VudGVkIiwibW91bnRlZCIsImNvdW50Iiwia2V5RnJvemVuIiwiZnJlZXplS2V5Iiwic29ydCIsImRpc2FibGVkIiwiaWRsZSIsImxpc3RlblRvIiwib25DZWxsQWRkZWQiLCJvbkNlbGxSZW1vdmVkIiwib25DZWxsQ2hhbmdlIiwib25HcmFwaFJlc2V0Iiwib25HcmFwaFNvcnQiLCJvbkdyYXBoQmF0Y2hTdG9wIiwib24iLCJvbkNlbGxIaWdobGlnaHQiLCJvbkNlbGxVbmhpZ2hsaWdodCIsInVwZGF0ZSIsImNlbGwiLCJfIiwicG9zaXRpb24iLCJyZW5kZXJWaWV3IiwibWF4UG9zaXRpb24iLCJmcmVlemUiLCJrZXkiLCJ1bmZyZWV6ZSIsImZpbmRWaWV3QnlNb2RlbCIsInJlcXVlc3RWaWV3VXBkYXRlIiwiVVBEQVRFX1BSSU9SSVRZIiwiaGFzQ2hhbmdlZCIsImNvbGxlY3Rpb24iLCJyZXNldExheWVycyIsImhhc0FjdGl2ZUJhdGNoIiwic29ydFZpZXdzIiwiZGF0YSIsImJhdGNoTmFtZSIsImdyYXBoIiwidXBkYXRlRGVsYXlpbmdCYXRjaGVzIiwiaW5jbHVkZXMiLCJ1cGRhdGVWaWV3cyIsInNvcnREZWxheWluZ0JhdGNoZXMiLCJjaGlsZHJlbiIsIm5zIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwieGh0bWwiLCJ0YWdOYW1lIiwic2VsZWN0b3IiLCJ4bGluayIsImhhc0xheWVyVmlldyIsImxheWVyTmFtZSIsImdldExheWVyVmlldyIsIkVycm9yIiwiZ2V0TGF5ZXJOb2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwiZ3JpZCIsInN0eWxlIiwicmVuZGVyTGF5ZXJzIiwiZW5zdXJlSWQiLCJkcmF3QmFja2dyb3VuZCIsInJlbW92ZUxheWVycyIsImZvckVhY2giLCJzb3J0ZWQiLCJsYXllclZpZXciLCJhcHBlbmRDaGlsZCIsImNlbGxzTGF5ZXJWaWV3IiwidG9vbHNMYXllclZpZXciLCJsYWJlbHNMYXllclZpZXciLCJ2ZWwiLCJhZGRDbGFzcyIsIk9iamVjdCIsImtleXMiLCJyZW1vdmUiLCJyZW1vdmVQaXZvdHMiLCJfYmFja2dyb3VuZCIsInVwZGF0ZUJhY2tncm91bmRJbWFnZSIsIm1hdHJpeCIsImN0bSIsInVuZGVmaW5lZCIsInRyYW5zZm9ybVN0cmluZyIsImdldENUTSIsImNyZWF0ZVNWR01hdHJpeCIsImN0bVN0cmluZyIsIm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nIiwic2V0QXR0cmlidXRlIiwiY2xpZW50TWF0cml4IiwiZ2V0U2NyZWVuQ1RNIiwibGlua3MiLCJnZXRDb25uZWN0ZWRMaW5rcyIsImoiLCJuIiwibGVuZ3RoIiwibGluayIsImZsYWdMYWJlbHMiLCJnZXRUYXJnZXRDZWxsIiwicHVzaCIsImdldFNvdXJjZUNlbGwiLCJuZXh0UHJpb3JpdHkiLCJNYXRoIiwibWF4Iiwic2NoZWR1bGVWaWV3VXBkYXRlIiwiZ2V0RmxhZyIsImlzRWxlbWVudCIsImR1bXBPcHRpb25zIiwic2lsZW50Iiwic291cmNlRmxhZyIsInNvdXJjZVZpZXciLCJpc1ZpZXdNb3VudGVkIiwiZHVtcFZpZXciLCJ1cGRhdGVFbmRNYWduZXQiLCJ0YXJnZXRGbGFnIiwidGFyZ2V0VmlldyIsImFzeW5jIiwic3RhdHMiLCJub3RpZnlBZnRlclJlbmRlciIsInR5cGUiLCJ1cGRhdGVzIiwiY2lkIiwicHJpb3JpdHlVcGRhdGVzIiwiaSIsInByZXZQcmlvcml0eVVwZGF0ZXMiLCJjdXJyZW50VHlwZSIsInZpZXdVcGRhdGVGbiIsImNhbGwiLCJkdW1wVmlld1VwZGF0ZSIsInJlZ2lzdGVyTW91bnRlZFZpZXciLCJzaG91bGROb3RpZnkiLCJub3RpZnlCZWZvcmVSZW5kZXIiLCJsZWZ0b3ZlciIsInVwZGF0ZVZpZXciLCJ1cGRhdGVkIiwiRkxBR19JTklUIiwicmVtb3ZlVmlldyIsImlzSW5pdGlhbEluc2VydCIsImluc2VydFZpZXciLCJjb25maXJtVXBkYXRlIiwicmVxdWlyZVZpZXciLCJyZWdpc3RlclVubW91bnRlZFZpZXciLCJkdW1wVmlld3MiLCJwYXNzaW5nT3B0IiwiY2hlY2tWaWV3cG9ydCIsImJhdGNoU3RhdHMiLCJ1cGRhdGVDb3VudCIsImJhdGNoQ291bnQiLCJ1cGRhdGVWaWV3c0JhdGNoIiwibWluIiwiZW1wdHkiLCJiYXRjaGVzIiwiaGFzU2NoZWR1bGVkVXBkYXRlcyIsInByaW9yaXR5SW5kZXhlcyIsIl9rZXkiLCJwcm9jZXNzZWQiLCJtb3VudEJhdGNoU2l6ZSIsInVubW91bnRCYXRjaFNpemUiLCJjaGVja1N0YXRzIiwidW5tb3VudENvdW50IiwibW91bnRDb3VudCIsInRvdGFsIiwidHJpZ2dlciIsInByb2dyZXNzRm4iLCJwcm9ncmVzcyIsImJlZm9yZUZuIiwiYWZ0ZXJGbiIsImJhdGNoU2l6ZSIsInBvc3Rwb25lQ291bnQiLCJtYXhQcmlvcml0eSIsInZpZXdwb3J0Rm4iLCJwb3N0cG9uZVZpZXdGbiIsIm1haW4iLCJjdXJyZW50RmxhZyIsImlzRGV0YWNoZWQiLCJERVRBQ0hBQkxFIiwiZGV0YWNoVmlldyIsImxlZnRvdmVyRmxhZyIsInBvc3Rwb25lZCIsImdldFVubW91bnRlZFZpZXdzIiwidW5tb3VudGVkVmlld3MiLCJBcnJheSIsImdldE1vdW50ZWRWaWV3cyIsIm1vdW50ZWRWaWV3cyIsImNoZWNrVW5tb3VudGVkVmlld3MiLCJzcGxpY2UiLCJjaGVja01vdW50ZWRWaWV3cyIsImNoZWNrVmlld1Zpc2liaWxpdHkiLCJjZWxsVmlldyIsInZpc2libGUiLCJpc1VubW91bnRlZCIsImlzTW91bnRlZCIsImluZGV4T2YiLCJ1bm1vdW50ZWRDb3VudCIsIm1vdW50ZWRDb3VudCIsImlzRXhhY3RTb3J0aW5nIiwib25SZW1vdmUiLCJyZW1vdmVWaWV3cyIsImdldENvbXB1dGVkU2l6ZSIsInciLCJoIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzZXREaW1lbnNpb25zIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsImNvbXB1dGVkU2l6ZSIsInJvdW5kIiwiJGVsIiwiY3NzIiwic2V0T3JpZ2luIiwib3giLCJveSIsInRyYW5zbGF0ZSIsImZpdFRvQ29udGVudCIsImdyaWRXaWR0aCIsImdyaWRIZWlnaHQiLCJnZXRGaXRUb0NvbnRlbnRBcmVhIiwic3giLCJzeSIsInNjYWxlIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhXaWR0aCIsIk51bWJlciIsIk1BWF9WQUxVRSIsIm1heEhlaWdodCIsIm5ld09yaWdpbiIsImFsbG93TmV3T3JpZ2luIiwiYXJlYSIsImNvbnRlbnRBcmVhIiwiZ2V0Q29udGVudEFyZWEiLCJjYWxjV2lkdGgiLCJjZWlsIiwiY2FsY0hlaWdodCIsImFsbG93TmVnYXRpdmVCb3R0b21SaWdodCIsInR4IiwibGVmdCIsInR5IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJ0cmFuc2Zvcm1Ub0ZpdENvbnRlbnQiLCJjb250ZW50QkJveCIsImNvbnRlbnRMb2NhbE9yaWdpbiIsImxvY2FsVG9QYXBlclJlY3QiLCJnZXRDb250ZW50QkJveCIsInBhcGVyVG9Mb2NhbFBvaW50IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInNjYWxlR3JpZCIsIm1pblNjYWxlIiwibWF4U2NhbGUiLCJ2ZXJ0aWNhbEFsaWduIiwiaG9yaXpvbnRhbEFsaWduIiwibWluU2NhbGVYIiwibWF4U2NhbGVYIiwibWluU2NhbGVZIiwibWF4U2NhbGVZIiwiZml0dGluZ0JCb3giLCJjdXJyZW50VHJhbnNsYXRlIiwibW92ZUFuZEV4cGFuZCIsImN1cnJlbnRTY2FsZSIsIm5ld1N4IiwibmV3U3kiLCJmbG9vciIsInNjYWxlRGlmZiIsIm5ld094IiwibmV3T3kiLCJzY2FsZUNvbnRlbnRUb0ZpdCIsInVzZU1vZGVsR2VvbWV0cnkiLCJnZXRCQm94IiwiZ2V0QXJlYSIsInBhcGVyVG9Mb2NhbFJlY3QiLCJnZXRSZXN0cmljdGVkQXJlYSIsImFyZ3MiLCJyZXN0cmljdGVkQXJlYSIsImFwcGx5IiwiY3JlYXRlVmlld0Zvck1vZGVsIiwib3B0aW9uYWxWaWV3Q2xhc3MiLCJkZWZhdWx0Vmlld0NsYXNzIiwiZ2V0IiwibmFtZXNwYWNlVmlld0NsYXNzIiwiaXNMaW5rIiwiVmlld0NsYXNzIiwicHJvdG90eXBlIiwiY3JlYXRlIiwib25JbWFnZURyYWdTdGFydCIsInNvcnRWaWV3c0V4YWN0IiwiJGNlbGxzIiwiYSIsImIiLCJjZWxsQSIsImNlbGxCIiwiekEiLCJ6IiwiekIiLCJpbnNlcnRTb3J0ZWROb2RlIiwiaW5zZXJ0Tm9kZSIsIm9uTW91bnQiLCJ1bm1vdW50Iiwib25EZXRhY2giLCJtYXRyaXhUb1NjYWxlIiwibmV3VHgiLCJuZXdUeSIsImQiLCJyb3RhdGUiLCJhbmdsZSIsImN4IiwiY3kiLCJtYXRyaXhUb1JvdGF0ZSIsImJib3giLCJtYXRyaXhUb1RyYW5zbGF0ZSIsImUiLCJmIiwiZmluZFZpZXciLCJxdWVyeVNlbGVjdG9yIiwiZmluZEF0dHJpYnV0ZSIsImZpbmRWaWV3c0Zyb21Qb2ludCIsInAiLCJnZXRFbGVtZW50cyIsIm1hcCIsInRhcmdldCIsImNvbnRhaW5zUG9pbnQiLCJmaW5kVmlld3NJbkFyZWEiLCJyZWN0Iiwic3RyaWN0IiwibWV0aG9kIiwicmVtb3ZlVG9vbHMiLCJkaXNwYXRjaFRvb2xzRXZlbnQiLCJoaWRlVG9vbHMiLCJzaG93VG9vbHMiLCJnZXRNb2RlbEJ5SWQiLCJnZXRDZWxsIiwic25hcFRvR3JpZCIsImNsaWVudFRvTG9jYWxQb2ludCIsImxvY2FsVG9QYXBlclBvaW50IiwibG9jYWxQb2ludCIsInBhcGVyUG9pbnQiLCJ0cmFuc2Zvcm1Qb2ludCIsImxvY2FsUmVjdCIsInBhcGVyUmVjdCIsInRyYW5zZm9ybVJlY3QiLCJpbnZlcnNlIiwibG9jYWxUb0NsaWVudFBvaW50IiwiY2xpZW50UG9pbnQiLCJsb2NhbFRvQ2xpZW50UmVjdCIsImNsaWVudFJlY3QiLCJjbGllbnRUb0xvY2FsUmVjdCIsImxvY2FsVG9QYWdlUG9pbnQiLCJvZmZzZXQiLCJwYWdlT2Zmc2V0IiwibG9jYWxUb1BhZ2VSZWN0IiwicGFnZVRvTG9jYWxQb2ludCIsInBhZ2VQb2ludCIsImRpZmZlcmVuY2UiLCJwYWdlVG9Mb2NhbFJlY3QiLCJjbGllbnRPZmZzZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJzY3JvbGxYIiwic2Nyb2xsWSIsImxpbmtBbGxvd2VkIiwicGFwZXJPcHRpb25zIiwiY29uc3RydWN0b3IiLCJ2YWxpZGF0aW9ucyIsImdldERlZmF1bHRMaW5rIiwiY2xvbmUiLCJyZXNvbHZlSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRlciIsImhpZ2hsaWdodGVyRGVmIiwiaGlnaGxpZ2h0IiwidW5oaWdobGlnaHQiLCJtYWduZXRFbCIsImhpZ2hsaWdodGVyRGVzY3JpcHRvciIsInBvaW50ZXJkYmxjbGljayIsInByZXZlbnREZWZhdWx0IiwiY2xpZW50WCIsImNsaWVudFkiLCJwb2ludGVyY2xpY2siLCJldmVudERhdGEiLCJtb3VzZW1vdmVkIiwiY29udGV4dG1lbnUiLCJjb250ZXh0TWVudUZpcmVkIiwiY29udGV4dE1lbnVUcmlnZ2VyIiwicG9pbnRlcmRvd24iLCJidXR0b24iLCJpc0NvbnRleHRNZW51IiwiaXNUYXJnZXRGb3JtTm9kZSIsInByZXZlbnREZWZhdWx0SW50ZXJhY3Rpb24iLCJldmVudEV2dCIsImN1c3RvbUV2ZW50VHJpZ2dlciIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwibWFnbmV0Tm9kZSIsImNsb3Nlc3QiLCJjb250YWlucyIsIm1hZ25ldEV2dCIsIkV2ZW50Iiwib3JpZ2luYWxFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJvbm1hZ25ldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlbGVnYXRlRHJhZ0V2ZW50cyIsImNvbnRleHRtZW51RXZ0IiwicG9pbnRlcm1vdmUiLCJ1bmRlbGVnYXRlRXZlbnRzIiwicG9pbnRlcnVwIiwidW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzIiwibm9ybWFsaXplZEV2dCIsImRlbGVnYXRlRXZlbnRzIiwibW91c2VvdmVyIiwibW91c2VvdXQiLCJtb3VzZWVudGVyIiwicmVsYXRlZFRhcmdldCIsInJlbGF0ZWRWaWV3IiwibW91c2VsZWF2ZSIsIl9wcm9jZXNzTW91c2VXaGVlbEV2dEJ1ZiIsImRlbHRhWSIsInJlZHVjZSIsImFjYyIsInBvdyIsIm1heFdhaXQiLCJtb3VzZXdoZWVsIiwiZGVsdGFYIiwicGluY2hIYW5kbGVycyIsIl9ldmVudHMiLCJjdHJsS2V5IiwiZGVsdGEiLCJ3aGVlbERlbHRhIiwib25ldmVudCIsImV2ZW50Tm9kZSIsImV2ZW50TmFtZSIsIm1hZ25ldEV2ZW50IiwiaGFuZGxlciIsIm1hZ25ldFZhbHVlIiwibWFnbmV0Q29udGV4dE1lbnVGaXJlZCIsIm1hZ25ldENvbnRleHRNZW51VHJpZ2dlciIsInN0b3BQcm9wYWdhdGlvbiIsIm1hZ25ldHBvaW50ZXJkYmxjbGljayIsIm1hZ25ldGNvbnRleHRtZW51Iiwib25sYWJlbCIsImxhYmVsTm9kZSIsImdldFBvaW50ZXJBcmdzIiwiZGVsZWdhdGVEb2N1bWVudEV2ZW50cyIsImd1YXJkZWQiLCJzZXRHcmlkU2l6ZSIsImNsZWFyR3JpZCIsIl9nZXRHcmlkUmVmcyIsIl9ncmlkQ2FjaGUiLCJyb290IiwicGF0dGVybnMiLCJhZGQiLCJub2RlIiwiYXBwZW5kIiwiZmlsbCIsImV4aXN0IiwiX2dyaWRTZXR0aW5ncyIsIm9wdGlvbnNMaXN0IiwiaXNBcnJheSIsIml0ZW0iLCJfcmVzb2x2ZURyYXdHcmlkT3B0aW9uIiwiZ3JpZFBhdHRlcm5zIiwibWFya3VwIiwicGF0dGVybiIsImxvY2FsT3B0aW9ucyIsInJlZnMiLCJncmlkTGF5ZXJTZXR0aW5nIiwiaW5kZXgiLCJzY2FsZUZhY3RvciIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5EZWZWZWwiLCJhdHRyIiwicGF0dGVyblVyaSIsIlhNTFNlcmlhbGl6ZXIiLCJzZXJpYWxpemVUb1N0cmluZyIsImJ0b2EiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kU2l6ZSIsInNpemUiLCJkcmF3QmFja2dyb3VuZEltYWdlIiwiaW1nIiwiSFRNTEltYWdlRWxlbWVudCIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRSZXBlYXQiLCJyZXBlYXQiLCJiYWNrZ3JvdW5kT3BhY2l0eSIsIm9wYWNpdHkiLCJiYWNrZ3JvdW5kUXVhbGl0eSIsImFicyIsInF1YWxpdHkiLCJiYWNrZ3JvdW5kUGF0dGVybiIsImJhY2tncm91bmRQYXR0ZXJucyIsImNhbnZhcyIsIkhUTUxDYW52YXNFbGVtZW50IiwidG9EYXRhVVJMIiwic3JjIiwidXBkYXRlQmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJpbWFnZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubG9hZCIsImJpbmQiLCJzZXRJbnRlcmFjdGl2aXR5IiwidmFsdWUiLCJpc0RlZmluZWQiLCJkZWZJZCIsImdldEVsZW1lbnRCeUlkIiwiZGVmaW5lRmlsdGVyIiwiVHlwZUVycm9yIiwiZmlsdGVySWQiLCJKU09OIiwic3RyaW5naWZ5IiwiZmlsdGVyU1ZHU3RyaW5nIiwiZmlsdGVyQXR0cnMiLCJmaWx0ZXJVbml0cyIsImF0dHJzIiwiYXBwZW5kVG8iLCJkZWZpbmVHcmFkaWVudCIsImdyYWRpZW50Iiwic3RvcHMiLCJzdG9wVkVscyIsImlzRmluaXRlIiwiZ3JhZGllbnRWRWwiLCJkZWZpbmVQYXR0ZXJuIiwicGF0dGVyblZFbCIsImZyYWdtZW50IiwiZGVmaW5lTWFya2VyIiwibWFya2VyIiwibWFya2VyVW5pdHMiLCJtYXJrZXJWRWwiLCJvcmllbnQiLCJtYXJrZXJDb250ZW50VkVsIiwibWFya3VwVkVsIiwibWFya2VyQXR0cnMiLCJtYXJrZXJBdHRyc0tleXMiLCJtYXJrdXBWYWx1ZSIsInJvb3ROb2RlIiwiTGF5ZXJzIiwiZmxpcFh5IiwiaW1nV2lkdGgiLCJpbWdIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwic2V0VHJhbnNmb3JtIiwiZmxpcFgiLCJmbGlwWSIsIndhdGVybWFyayIsIndhdGVybWFya0FuZ2xlIiwicmFkaWFucyIsInN0ZXBYIiwic3RlcFkiLCJkb3QiLCJ0aGlja25lc3MiLCJmaXhlZERvdCIsIm1lc2giLCJqb2luIiwic3Ryb2tlIiwiZG91YmxlTWVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/Paper.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/PaperLayer.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/jointjs/src/dia/PaperLayer.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayersNames: () => (/* binding */ LayersNames),\n/* harmony export */   PaperLayer: () => (/* binding */ PaperLayer)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/jointjs/src/mvc/View.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n\n\nconst LayersNames = {\n    CELLS: \"cells\",\n    BACK: \"back\",\n    FRONT: \"front\",\n    TOOLS: \"tools\",\n    LABELS: \"labels\"\n};\nconst PaperLayer = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: \"g\",\n    svgElement: true,\n    pivotNodes: null,\n    defaultTheme: null,\n    options: {\n        name: \"\"\n    },\n    className: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix)(`${this.options.name}-layer`);\n    },\n    init: function() {\n        this.pivotNodes = {};\n    },\n    insertSortedNode: function(node, z) {\n        this.el.insertBefore(node, this.insertPivot(z));\n    },\n    insertNode: function(node) {\n        const { el } = this;\n        if (node.parentNode !== el) {\n            el.appendChild(node);\n        }\n    },\n    insertPivot: function(z) {\n        const { el, pivotNodes } = this;\n        z = +z;\n        z || (z = 0);\n        let pivotNode = pivotNodes[z];\n        if (pivotNode) return pivotNode;\n        pivotNode = pivotNodes[z] = document.createComment(\"z-index:\" + (z + 1));\n        let neighborZ = -Infinity;\n        for(let currentZ in pivotNodes){\n            currentZ = +currentZ;\n            if (currentZ < z && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === z - 1) continue;\n            }\n        }\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivotNodes[neighborZ];\n            // Insert After\n            el.insertBefore(pivotNode, neighborPivot.nextSibling);\n        } else {\n            // First Child\n            el.insertBefore(pivotNode, el.firstChild);\n        }\n        return pivotNode;\n    },\n    removePivots: function() {\n        const { el, pivotNodes } = this;\n        for(let z in pivotNodes)el.removeChild(pivotNodes[z]);\n        this.pivotNodes = {};\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL1BhcGVyTGF5ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDYztBQUUvQyxNQUFNRSxjQUFjO0lBQ3ZCQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFFBQVE7QUFDWixFQUFFO0FBRUssTUFBTUMsYUFBYVIsZ0RBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUVsQ0MsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsY0FBYztJQUVkQyxTQUFTO1FBQ0xDLE1BQU07SUFDVjtJQUVBQyxXQUFXO1FBQ1AsT0FBT2Ysa0VBQWtCQSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNhLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMxRDtJQUVBRSxNQUFNO1FBQ0YsSUFBSSxDQUFDTCxVQUFVLEdBQUcsQ0FBQztJQUN2QjtJQUVBTSxrQkFBa0IsU0FBU0MsSUFBSSxFQUFFQyxDQUFDO1FBQzlCLElBQUksQ0FBQ0MsRUFBRSxDQUFDQyxZQUFZLENBQUNILE1BQU0sSUFBSSxDQUFDSSxXQUFXLENBQUNIO0lBQ2hEO0lBRUFJLFlBQVksU0FBU0wsSUFBSTtRQUNyQixNQUFNLEVBQUVFLEVBQUUsRUFBRSxHQUFHLElBQUk7UUFDbkIsSUFBSUYsS0FBS00sVUFBVSxLQUFLSixJQUFJO1lBQ3hCQSxHQUFHSyxXQUFXLENBQUNQO1FBQ25CO0lBQ0o7SUFFQUksYUFBYSxTQUFTSCxDQUFDO1FBQ25CLE1BQU0sRUFBRUMsRUFBRSxFQUFFVCxVQUFVLEVBQUUsR0FBRyxJQUFJO1FBQy9CUSxJQUFJLENBQUNBO1FBQ0xBLEtBQU1BLENBQUFBLElBQUk7UUFDVixJQUFJTyxZQUFZZixVQUFVLENBQUNRLEVBQUU7UUFDN0IsSUFBSU8sV0FBVyxPQUFPQTtRQUN0QkEsWUFBWWYsVUFBVSxDQUFDUSxFQUFFLEdBQUdRLFNBQVNDLGFBQWEsQ0FBQyxhQUFjVCxDQUFBQSxJQUFJO1FBQ3JFLElBQUlVLFlBQVksQ0FBQ0M7UUFDakIsSUFBSyxJQUFJQyxZQUFZcEIsV0FBWTtZQUM3Qm9CLFdBQVcsQ0FBQ0E7WUFDWixJQUFJQSxXQUFXWixLQUFLWSxXQUFXRixXQUFXO2dCQUN0Q0EsWUFBWUU7Z0JBQ1osSUFBSUYsY0FBY1YsSUFBSSxHQUFHO1lBQzdCO1FBQ0o7UUFDQSxJQUFJVSxjQUFjLENBQUNDLFVBQVU7WUFDekIsTUFBTUUsZ0JBQWdCckIsVUFBVSxDQUFDa0IsVUFBVTtZQUMzQyxlQUFlO1lBQ2ZULEdBQUdDLFlBQVksQ0FBQ0ssV0FBV00sY0FBY0MsV0FBVztRQUN4RCxPQUFPO1lBQ0gsY0FBYztZQUNkYixHQUFHQyxZQUFZLENBQUNLLFdBQVdOLEdBQUdjLFVBQVU7UUFDNUM7UUFDQSxPQUFPUjtJQUNYO0lBRUFTLGNBQWM7UUFDVixNQUFNLEVBQUVmLEVBQUUsRUFBRVQsVUFBVSxFQUFFLEdBQUcsSUFBSTtRQUMvQixJQUFLLElBQUlRLEtBQUtSLFdBQVlTLEdBQUdnQixXQUFXLENBQUN6QixVQUFVLENBQUNRLEVBQUU7UUFDdEQsSUFBSSxDQUFDUixVQUFVLEdBQUcsQ0FBQztJQUN2QjtBQUVKLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvUGFwZXJMYXllci5tanM/NDBhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWV3IH0gZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBhZGRDbGFzc05hbWVQcmVmaXggfSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuZXhwb3J0IGNvbnN0IExheWVyc05hbWVzID0ge1xuICAgIENFTExTOiAnY2VsbHMnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBUT09MUzogJ3Rvb2xzJyxcbiAgICBMQUJFTFM6ICdsYWJlbHMnXG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJMYXllciA9IFZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIHBpdm90Tm9kZXM6IG51bGwsXG4gICAgZGVmYXVsdFRoZW1lOiBudWxsLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBuYW1lOiAnJ1xuICAgIH0sXG5cbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkQ2xhc3NOYW1lUHJlZml4KGAke3RoaXMub3B0aW9ucy5uYW1lfS1sYXllcmApO1xuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5waXZvdE5vZGVzID0ge307XG4gICAgfSxcblxuICAgIGluc2VydFNvcnRlZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIHopIHtcbiAgICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5pbnNlcnRQaXZvdCh6KSk7XG4gICAgfSxcblxuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gZWwpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFBpdm90OiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGNvbnN0IHsgZWwsIHBpdm90Tm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIHogPSArejtcbiAgICAgICAgeiB8fCAoeiA9IDApO1xuICAgICAgICBsZXQgcGl2b3ROb2RlID0gcGl2b3ROb2Rlc1t6XTtcbiAgICAgICAgaWYgKHBpdm90Tm9kZSkgcmV0dXJuIHBpdm90Tm9kZTtcbiAgICAgICAgcGl2b3ROb2RlID0gcGl2b3ROb2Rlc1t6XSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3otaW5kZXg6JyArICh6ICsgMSkpO1xuICAgICAgICBsZXQgbmVpZ2hib3JaID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50WiBpbiBwaXZvdE5vZGVzKSB7XG4gICAgICAgICAgICBjdXJyZW50WiA9ICtjdXJyZW50WjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50WiA8IHogJiYgY3VycmVudFogPiBuZWlnaGJvclopIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvclogPSBjdXJyZW50WjtcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3JaID09PSB6IC0gMSkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5laWdoYm9yWiAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvclBpdm90ID0gcGl2b3ROb2Rlc1tuZWlnaGJvclpdO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IEFmdGVyXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUocGl2b3ROb2RlLCBuZWlnaGJvclBpdm90Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IENoaWxkXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUocGl2b3ROb2RlLCBlbC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGl2b3ROb2RlO1xuICAgIH0sXG5cbiAgICByZW1vdmVQaXZvdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBwaXZvdE5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCB6IGluIHBpdm90Tm9kZXMpIGVsLnJlbW92ZUNoaWxkKHBpdm90Tm9kZXNbel0pO1xuICAgICAgICB0aGlzLnBpdm90Tm9kZXMgPSB7fTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbIlZpZXciLCJhZGRDbGFzc05hbWVQcmVmaXgiLCJMYXllcnNOYW1lcyIsIkNFTExTIiwiQkFDSyIsIkZST05UIiwiVE9PTFMiLCJMQUJFTFMiLCJQYXBlckxheWVyIiwiZXh0ZW5kIiwidGFnTmFtZSIsInN2Z0VsZW1lbnQiLCJwaXZvdE5vZGVzIiwiZGVmYXVsdFRoZW1lIiwib3B0aW9ucyIsIm5hbWUiLCJjbGFzc05hbWUiLCJpbml0IiwiaW5zZXJ0U29ydGVkTm9kZSIsIm5vZGUiLCJ6IiwiZWwiLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnRQaXZvdCIsImluc2VydE5vZGUiLCJwYXJlbnROb2RlIiwiYXBwZW5kQ2hpbGQiLCJwaXZvdE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUNvbW1lbnQiLCJuZWlnaGJvcloiLCJJbmZpbml0eSIsImN1cnJlbnRaIiwibmVpZ2hib3JQaXZvdCIsIm5leHRTaWJsaW5nIiwiZmlyc3RDaGlsZCIsInJlbW92ZVBpdm90cyIsInJlbW92ZUNoaWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/PaperLayer.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/attributes/calc.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/jointjs/src/dia/attributes/calc.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalCalcAttribute: () => (/* binding */ evalCalcAttribute),\n/* harmony export */   evalCalcExpression: () => (/* binding */ evalCalcExpression),\n/* harmony export */   isCalcAttribute: () => (/* binding */ isCalcAttribute)\n/* harmony export */ });\nconst props = {\n    x: \"x\",\n    y: \"y\",\n    width: \"w\",\n    height: \"h\",\n    minimum: \"s\",\n    maximum: \"l\",\n    diagonal: \"d\"\n};\nconst propsList = Object.keys(props).map((key)=>props[key]).join(\"\");\nconst numberPattern = \"[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?\";\nconst findSpacesRegex = /\\s/g;\nconst parseExpressionRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, \"g\");\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\nfunction evalCalcExpression(expression, bbox) {\n    const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, \"\"));\n    if (!match) throwInvalid(expression);\n    parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n    const [, multiply, property, divide, add] = match;\n    const { x, y, width, height } = bbox;\n    let value = 0;\n    switch(property){\n        case props.width:\n            {\n                value = width;\n                break;\n            }\n        case props.height:\n            {\n                value = height;\n                break;\n            }\n        case props.x:\n            {\n                value = x;\n                break;\n            }\n        case props.y:\n            {\n                value = y;\n                break;\n            }\n        case props.minimum:\n            {\n                value = Math.min(height, width);\n                break;\n            }\n        case props.maximum:\n            {\n                value = Math.max(height, width);\n                break;\n            }\n        case props.diagonal:\n            {\n                value = Math.sqrt(height * height + width * width);\n                break;\n            }\n    }\n    if (multiply) {\n        // e.g \"2*\"\n        value *= parseFloat(multiply);\n    }\n    if (divide) {\n        // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n    }\n    if (add) {\n        value += evalAddExpression(add);\n    }\n    return value;\n}\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch(sign){\n        case \"+\":\n            {\n                return parseFloat(addExpression.substr(1));\n            }\n        case \"-\":\n            {\n                return -parseFloat(addExpression.substr(1));\n            }\n    }\n    return parseFloat(addExpression);\n}\nfunction isCalcAttribute(value) {\n    return typeof value === \"string\" && value.includes(\"calc\");\n}\nconst calcStart = \"calc(\";\nconst calcStartOffset = calcStart.length;\nfunction evalCalcAttribute(attributeValue, refBBox) {\n    let value = attributeValue;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch(value[calcEndIndex]){\n                case \"(\":\n                    {\n                        brackets++;\n                        break;\n                    }\n                case \")\":\n                    {\n                        brackets--;\n                        if (brackets === 0) break findClosingBracket;\n                        break;\n                    }\n                case undefined:\n                    {\n                        // Could not find the closing bracket.\n                        throwInvalid(value);\n                    }\n            }\n            calcEndIndex++;\n        }while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcAttribute(expression)) {\n            expression = evalCalcAttribute(expression, refBBox);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcExpression(expression, refBBox));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    }while (true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL2F0dHJpYnV0ZXMvY2FsYy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsUUFBUTtJQUNWQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNQyxZQUFZQyxPQUFPQyxJQUFJLENBQUNWLE9BQU9XLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT1osS0FBSyxDQUFDWSxJQUFJLEVBQUVDLElBQUksQ0FBQztBQUNqRSxNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLHdCQUF3QixJQUFJQyxPQUFPLENBQUMsRUFBRSxFQUFFSCxjQUFjLE9BQU8sRUFBRU4sVUFBVSxJQUFJLEVBQUVNLGNBQWMsWUFBWSxFQUFFQSxjQUFjLEdBQUcsQ0FBQyxFQUFFO0FBRXJJLFNBQVNJLGFBQWFDLFVBQVU7SUFDNUIsTUFBTSxJQUFJQyxNQUFNLENBQUMsMkJBQTJCLEVBQUVELFdBQVcsQ0FBQztBQUM5RDtBQUVPLFNBQVNFLG1CQUFtQkYsVUFBVSxFQUFFRyxJQUFJO0lBQy9DLE1BQU1DLFFBQVFQLHNCQUFzQlEsSUFBSSxDQUFDTCxXQUFXTSxPQUFPLENBQUNWLGlCQUFpQjtJQUM3RSxJQUFJLENBQUNRLE9BQU9MLGFBQWFDO0lBQ3pCSCxzQkFBc0JVLFNBQVMsR0FBRyxHQUFHLHVDQUF1QztJQUM1RSxNQUFNLEdBQUVDLFVBQVVDLFVBQVVDLFFBQVFDLElBQUksR0FBR1A7SUFDM0MsTUFBTSxFQUFFdEIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdrQjtJQUNoQyxJQUFJUyxRQUFRO0lBQ1osT0FBUUg7UUFDSixLQUFLNUIsTUFBTUcsS0FBSztZQUFFO2dCQUNkNEIsUUFBUTVCO2dCQUNSO1lBQ0o7UUFDQSxLQUFLSCxNQUFNSSxNQUFNO1lBQUU7Z0JBQ2YyQixRQUFRM0I7Z0JBQ1I7WUFDSjtRQUNBLEtBQUtKLE1BQU1DLENBQUM7WUFBRTtnQkFDVjhCLFFBQVE5QjtnQkFDUjtZQUNKO1FBQ0EsS0FBS0QsTUFBTUUsQ0FBQztZQUFFO2dCQUNWNkIsUUFBUTdCO2dCQUNSO1lBQ0o7UUFDQSxLQUFLRixNQUFNSyxPQUFPO1lBQUU7Z0JBQ2hCMEIsUUFBUUMsS0FBS0MsR0FBRyxDQUFDN0IsUUFBUUQ7Z0JBQ3pCO1lBQ0o7UUFDQSxLQUFLSCxNQUFNTSxPQUFPO1lBQUU7Z0JBQ2hCeUIsUUFBUUMsS0FBS0UsR0FBRyxDQUFDOUIsUUFBUUQ7Z0JBQ3pCO1lBQ0o7UUFDQSxLQUFLSCxNQUFNTyxRQUFRO1lBQUU7Z0JBQ2pCd0IsUUFBUUMsS0FBS0csSUFBSSxDQUFDLFNBQVUvQixTQUFXRCxRQUFRQTtnQkFDL0M7WUFDSjtJQUNKO0lBQ0EsSUFBSXdCLFVBQVU7UUFDVixXQUFXO1FBQ1hJLFNBQVNLLFdBQVdUO0lBQ3hCO0lBQ0EsSUFBSUUsUUFBUTtRQUNSLFdBQVc7UUFDWEUsU0FBU0ssV0FBV1AsT0FBT1EsS0FBSyxDQUFDO0lBQ3JDO0lBQ0EsSUFBSVAsS0FBSztRQUNMQyxTQUFTTyxrQkFBa0JSO0lBQy9CO0lBQ0EsT0FBT0M7QUFDWDtBQUVBLFNBQVNPLGtCQUFrQkMsYUFBYTtJQUNwQyxJQUFJLENBQUNBLGVBQWUsT0FBTztJQUMzQixNQUFNLENBQUNDLEtBQUssR0FBR0Q7SUFDZixPQUFRQztRQUNKLEtBQUs7WUFBSztnQkFDTixPQUFPSixXQUFXRyxjQUFjRSxNQUFNLENBQUM7WUFDM0M7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBTyxDQUFDTCxXQUFXRyxjQUFjRSxNQUFNLENBQUM7WUFDNUM7SUFDSjtJQUNBLE9BQU9MLFdBQVdHO0FBQ3RCO0FBRU8sU0FBU0csZ0JBQWdCWCxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxNQUFNWSxRQUFRLENBQUM7QUFDdkQ7QUFFQSxNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLGtCQUFrQkQsVUFBVUUsTUFBTTtBQUVqQyxTQUFTQyxrQkFBa0JDLGNBQWMsRUFBRUMsT0FBTztJQUNyRCxJQUFJbEIsUUFBUWlCO0lBQ1osSUFBSUUsbUJBQW1CO0lBQ3ZCLEdBQUc7UUFDQyxJQUFJQyxZQUFZcEIsTUFBTXFCLE9BQU8sQ0FBQ1IsV0FBV007UUFDekMsSUFBSUMsY0FBYyxDQUFDLEdBQUcsT0FBT3BCO1FBQzdCLElBQUlzQixlQUFlRixZQUFZTjtRQUMvQixJQUFJUyxXQUFXO1FBQ2ZDLG9CQUFvQixHQUFHO1lBQ25CLE9BQVF4QixLQUFLLENBQUNzQixhQUFhO2dCQUN2QixLQUFLO29CQUFLO3dCQUNOQzt3QkFDQTtvQkFDSjtnQkFDQSxLQUFLO29CQUFLO3dCQUNOQTt3QkFDQSxJQUFJQSxhQUFhLEdBQUcsTUFBTUM7d0JBQzFCO29CQUNKO2dCQUNBLEtBQUtDO29CQUFXO3dCQUNaLHNDQUFzQzt3QkFDdEN0QyxhQUFhYTtvQkFDakI7WUFDSjtZQUNBc0I7UUFDSixRQUFTLE1BQU07UUFDZiw2REFBNkQ7UUFDN0QsSUFBSWxDLGFBQWFZLE1BQU1NLEtBQUssQ0FBQ2MsWUFBWU4saUJBQWlCUTtRQUMxRCxJQUFJWCxnQkFBZ0J2QixhQUFhO1lBQzdCQSxhQUFhNEIsa0JBQWtCNUIsWUFBWThCO1FBQy9DO1FBQ0EsbURBQW1EO1FBQ25ELE1BQU1RLFlBQVlDLE9BQU9yQyxtQkFBbUJGLFlBQVk4QjtRQUN4RCxvREFBb0Q7UUFDcERsQixRQUFRQSxNQUFNTSxLQUFLLENBQUMsR0FBR2MsYUFBYU0sWUFBWTFCLE1BQU1NLEtBQUssQ0FBQ2dCLGVBQWU7UUFDM0VILG1CQUFtQkMsWUFBWU0sVUFBVVgsTUFBTTtJQUNuRCxRQUFTLE1BQU07QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvYXR0cmlidXRlcy9jYWxjLm1qcz9mNzRiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByb3BzID0ge1xuICAgIHg6ICd4JyxcbiAgICB5OiAneScsXG4gICAgd2lkdGg6ICd3JyxcbiAgICBoZWlnaHQ6ICdoJyxcbiAgICBtaW5pbXVtOiAncycsXG4gICAgbWF4aW11bTogJ2wnLFxuICAgIGRpYWdvbmFsOiAnZCdcbn07XG5jb25zdCBwcm9wc0xpc3QgPSBPYmplY3Qua2V5cyhwcm9wcykubWFwKGtleSA9PiBwcm9wc1trZXldKS5qb2luKCcnKTtcbmNvbnN0IG51bWJlclBhdHRlcm4gPSAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPyc7XG5jb25zdCBmaW5kU3BhY2VzUmVnZXggPSAvXFxzL2c7XG5jb25zdCBwYXJzZUV4cHJlc3Npb25SZWdFeHAgPSBuZXcgUmVnRXhwKGBeKCR7bnVtYmVyUGF0dGVybn1cXFxcKik/KFske3Byb3BzTGlzdH1dKSgvJHtudW1iZXJQYXR0ZXJufSk/KFstK117MSwyfSR7bnVtYmVyUGF0dGVybn0pPyRgLCAnZycpO1xuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWQoZXhwcmVzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYWxjKCkgZXhwcmVzc2lvbjogJHtleHByZXNzaW9ufWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbENhbGNFeHByZXNzaW9uKGV4cHJlc3Npb24sIGJib3gpIHtcbiAgICBjb25zdCBtYXRjaCA9IHBhcnNlRXhwcmVzc2lvblJlZ0V4cC5leGVjKGV4cHJlc3Npb24ucmVwbGFjZShmaW5kU3BhY2VzUmVnZXgsICcnKSk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3dJbnZhbGlkKGV4cHJlc3Npb24pO1xuICAgIHBhcnNlRXhwcmVzc2lvblJlZ0V4cC5sYXN0SW5kZXggPSAwOyAvLyByZXNldCByZWdleCByZXN1bHRzIGZvciB0aGUgbmV4dCBydW5cbiAgICBjb25zdCBbLG11bHRpcGx5LCBwcm9wZXJ0eSwgZGl2aWRlLCBhZGRdID0gbWF0Y2g7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBiYm94O1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlIHByb3BzLndpZHRoOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBwcm9wcy5oZWlnaHQ6IHtcbiAgICAgICAgICAgIHZhbHVlID0gaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBwcm9wcy54OiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHByb3BzLnk6IHtcbiAgICAgICAgICAgIHZhbHVlID0geTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMubWluaW11bToge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMubWF4aW11bToge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMuZGlhZ29uYWw6IHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5zcXJ0KChoZWlnaHQgKiBoZWlnaHQpICsgKHdpZHRoICogd2lkdGgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtdWx0aXBseSkge1xuICAgICAgICAvLyBlLmcgXCIyKlwiXG4gICAgICAgIHZhbHVlICo9IHBhcnNlRmxvYXQobXVsdGlwbHkpO1xuICAgIH1cbiAgICBpZiAoZGl2aWRlKSB7XG4gICAgICAgIC8vIGUuZyBcIi8yXCJcbiAgICAgICAgdmFsdWUgLz0gcGFyc2VGbG9hdChkaXZpZGUuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhbHVlICs9IGV2YWxBZGRFeHByZXNzaW9uKGFkZCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZXZhbEFkZEV4cHJlc3Npb24oYWRkRXhwcmVzc2lvbikge1xuICAgIGlmICghYWRkRXhwcmVzc2lvbikgcmV0dXJuIDA7XG4gICAgY29uc3QgW3NpZ25dID0gYWRkRXhwcmVzc2lvbjtcbiAgICBzd2l0Y2ggKHNpZ24pIHtcbiAgICAgICAgY2FzZSAnKyc6IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFkZEV4cHJlc3Npb24uc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICctJzoge1xuICAgICAgICAgICAgcmV0dXJuIC1wYXJzZUZsb2F0KGFkZEV4cHJlc3Npb24uc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdChhZGRFeHByZXNzaW9uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsY0F0dHJpYnV0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKCdjYWxjJyk7XG59XG5cbmNvbnN0IGNhbGNTdGFydCA9ICdjYWxjKCc7XG5jb25zdCBjYWxjU3RhcnRPZmZzZXQgPSBjYWxjU3RhcnQubGVuZ3RoO1xuXG5leHBvcnQgZnVuY3Rpb24gZXZhbENhbGNBdHRyaWJ1dGUoYXR0cmlidXRlVmFsdWUsIHJlZkJCb3gpIHtcbiAgICBsZXQgdmFsdWUgPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICBsZXQgc3RhcnRTZWFyY2hJbmRleCA9IDA7XG4gICAgZG8ge1xuICAgICAgICBsZXQgY2FsY0luZGV4ID0gdmFsdWUuaW5kZXhPZihjYWxjU3RhcnQsIHN0YXJ0U2VhcmNoSW5kZXgpO1xuICAgICAgICBpZiAoY2FsY0luZGV4ID09PSAtMSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBsZXQgY2FsY0VuZEluZGV4ID0gY2FsY0luZGV4ICsgY2FsY1N0YXJ0T2Zmc2V0O1xuICAgICAgICBsZXQgYnJhY2tldHMgPSAxO1xuICAgICAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGRvIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWVbY2FsY0VuZEluZGV4XSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNrZXRzKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICcpJzoge1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0cy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMgPT09IDApIGJyZWFrIGZpbmRDbG9zaW5nQnJhY2tldDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIG5vdCBmaW5kIHRoZSBjbG9zaW5nIGJyYWNrZXQuXG4gICAgICAgICAgICAgICAgICAgIHRocm93SW52YWxpZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsY0VuZEluZGV4Kys7XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAvLyBHZXQgdGhlIGNhbGMoKSBleHByZXNzaW9uIHdpdGhvdXQgbmVzdGVkIGNhbGNzIChyZWN1cnNpb24pXG4gICAgICAgIGxldCBleHByZXNzaW9uID0gdmFsdWUuc2xpY2UoY2FsY0luZGV4ICsgY2FsY1N0YXJ0T2Zmc2V0LCBjYWxjRW5kSW5kZXgpO1xuICAgICAgICBpZiAoaXNDYWxjQXR0cmlidXRlKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gZXZhbENhbGNBdHRyaWJ1dGUoZXhwcmVzc2lvbiwgcmVmQkJveCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZhbCB0aGUgY2FsYygpIGV4cHJlc3Npb24gd2l0aG91dCBuZXN0ZWQgY2FsY3MuXG4gICAgICAgIGNvbnN0IGNhbGNWYWx1ZSA9IFN0cmluZyhldmFsQ2FsY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgcmVmQkJveCkpO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjYWxjKCkgZXhwcmVzc2lvbiBhbmQgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2FsY0luZGV4KSArIGNhbGNWYWx1ZSArIHZhbHVlLnNsaWNlKGNhbGNFbmRJbmRleCArIDEpO1xuICAgICAgICBzdGFydFNlYXJjaEluZGV4ID0gY2FsY0luZGV4ICsgY2FsY1ZhbHVlLmxlbmd0aDtcbiAgICB9IHdoaWxlICh0cnVlKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9wcyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJtaW5pbXVtIiwibWF4aW11bSIsImRpYWdvbmFsIiwicHJvcHNMaXN0IiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsImpvaW4iLCJudW1iZXJQYXR0ZXJuIiwiZmluZFNwYWNlc1JlZ2V4IiwicGFyc2VFeHByZXNzaW9uUmVnRXhwIiwiUmVnRXhwIiwidGhyb3dJbnZhbGlkIiwiZXhwcmVzc2lvbiIsIkVycm9yIiwiZXZhbENhbGNFeHByZXNzaW9uIiwiYmJveCIsIm1hdGNoIiwiZXhlYyIsInJlcGxhY2UiLCJsYXN0SW5kZXgiLCJtdWx0aXBseSIsInByb3BlcnR5IiwiZGl2aWRlIiwiYWRkIiwidmFsdWUiLCJNYXRoIiwibWluIiwibWF4Iiwic3FydCIsInBhcnNlRmxvYXQiLCJzbGljZSIsImV2YWxBZGRFeHByZXNzaW9uIiwiYWRkRXhwcmVzc2lvbiIsInNpZ24iLCJzdWJzdHIiLCJpc0NhbGNBdHRyaWJ1dGUiLCJpbmNsdWRlcyIsImNhbGNTdGFydCIsImNhbGNTdGFydE9mZnNldCIsImxlbmd0aCIsImV2YWxDYWxjQXR0cmlidXRlIiwiYXR0cmlidXRlVmFsdWUiLCJyZWZCQm94Iiwic3RhcnRTZWFyY2hJbmRleCIsImNhbGNJbmRleCIsImluZGV4T2YiLCJjYWxjRW5kSW5kZXgiLCJicmFja2V0cyIsImZpbmRDbG9zaW5nQnJhY2tldCIsInVuZGVmaW5lZCIsImNhbGNWYWx1ZSIsIlN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/attributes/calc.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/attributes/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/jointjs/src/dia/attributes/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attributes: () => (/* binding */ attributes)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _calc_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./calc.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/attributes/calc.mjs\");\n/* harmony import */ var _props_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./props.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/attributes/props.mjs\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n\n\n\n\n\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n        return attrs;\n    };\n}\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n        var point = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === \"middle\") {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n        var point = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = \"joint-shape\";\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var $node = jquery__WEBPACK_IMPORTED_MODULE_0__(node);\n        var cache = $node.data(cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            $node.data(cacheName, cache);\n        }\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n        var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n        return shape;\n    };\n}\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].normalizePathData(value));\n    }\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return {\n            transform: \"translate(\" + p.x + \",\" + p.y + \")\"\n        };\n        return {\n            transform: \"translate(\" + p.x + \",\" + p.y + \") rotate(\" + angle + \")\"\n        };\n    };\n}\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\nfunction isTextInUse(_value, _node, attrs) {\n    return attrs.text !== undefined;\n}\nfunction isLinkView() {\n    return this.model.isLink();\n}\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === \"string\") {\n        marker[\"stroke\"] = stroke;\n        marker[\"fill\"] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context.strokeOpacity;\n    if (strokeOpacity === undefined) strokeOpacity = context[\"stroke-opacity\"];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker[\"stroke-opacity\"] = strokeOpacity;\n        marker[\"fill-opacity\"] = strokeOpacity;\n    }\n    return marker;\n}\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = def.type === \"pattern\" ? paper.definePattern(def) : paper.defineGradient(def);\n    return `url(#${url})`;\n}\nconst attributesNS = {\n    xlinkShow: {\n        set: \"xlink:show\"\n    },\n    xlinkRole: {\n        set: \"xlink:role\"\n    },\n    xlinkType: {\n        set: \"xlink:type\"\n    },\n    xlinkArcrole: {\n        set: \"xlink:arcrole\"\n    },\n    xlinkTitle: {\n        set: \"xlink:title\"\n    },\n    xlinkActuate: {\n        set: \"xlink:actuate\"\n    },\n    xmlSpace: {\n        set: \"xml:space\"\n    },\n    xmlBase: {\n        set: \"xml:base\"\n    },\n    xmlLang: {\n        set: \"xml:lang\"\n    },\n    preserveAspectRatio: {\n        set: \"preserveAspectRatio\"\n    },\n    requiredExtension: {\n        set: \"requiredExtension\"\n    },\n    requiredFeatures: {\n        set: \"requiredFeatures\"\n    },\n    systemLanguage: {\n        set: \"systemLanguage\"\n    },\n    externalResourcesRequired: {\n        set: \"externalResourceRequired\"\n    },\n    href: {\n        set: setIfChangedWrapper(\"href\")\n    },\n    xlinkHref: {\n        set: setIfChangedWrapper(\"xlink:href\")\n    },\n    filter: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(filter) {\n            return \"url(#\" + this.paper.defineFilter(filter) + \")\";\n        }\n    },\n    fill: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: setPaintURL\n    },\n    stroke: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: setPaintURL\n    },\n    sourceMarker: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.assign)(contextMarker(attrs), marker);\n            return {\n                \"marker-start\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n            };\n        }\n    },\n    targetMarker: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.assign)(contextMarker(attrs), {\n                \"transform\": \"rotate(180)\"\n            }, marker);\n            return {\n                \"marker-end\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n            };\n        }\n    },\n    vertexMarker: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.assign)(contextMarker(attrs), marker);\n            return {\n                \"marker-mid\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n            };\n        }\n    },\n    text: {\n        qualify: function(_text, _node, attrs) {\n            return !attrs.textWrap || !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject)(attrs.textWrap);\n        },\n        set: function(text, refBBox, node, attrs) {\n            const $node = jquery__WEBPACK_IMPORTED_MODULE_0__(node);\n            const cacheName = \"joint-text\";\n            const cache = $node.data(cacheName);\n            const { lineHeight, annotations, textVerticalAnchor, eol, displayEmpty } = attrs;\n            let textPath = attrs.textPath;\n            // eval `x` if using calc()\n            let x = attrs.x;\n            if ((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute)(x)) {\n                x = (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(x, refBBox);\n            }\n            // eval `font-size` if using calc()\n            let fontSize = attrs[\"font-size\"] || attrs[\"fontSize\"];\n            if ((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute)(fontSize)) {\n                fontSize = (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(fontSize, refBBox);\n            }\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([\n                text,\n                lineHeight,\n                annotations,\n                textVerticalAnchor,\n                eol,\n                displayEmpty,\n                textPath,\n                x,\n                fontSize\n            ]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute(\"font-size\", fontSize);\n                // Text Along Path Selector\n                if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isObject)(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === \"string\") {\n                        const [pathNode] = this.findBySelector(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.assign)({\n                                \"xlink:href\": \"#\" + pathNode.id\n                            }, textPath);\n                        }\n                    }\n                }\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node).text(\"\" + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                $node.data(cacheName, textHash);\n            }\n        }\n    },\n    textWrap: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if ((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute)(width)) {\n                size.width = Number((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if ((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute)(height)) {\n                size.height = Number((0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(height, refBBox));\n            } else {\n                if (value.height === null) {\n                // if height is not specified breakText() does not\n                // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n                const breakTextFn = value.breakText || _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.breakText;\n                const fontSizeAttr = attrs[\"font-size\"] || attrs.fontSize;\n                wrappedText = breakTextFn(\"\" + text, size, {\n                    \"font-weight\": attrs[\"font-weight\"] || attrs.fontWeight,\n                    \"font-size\": (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute)(fontSizeAttr) ? (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(fontSizeAttr, refBBox) : fontSizeAttr,\n                    \"font-family\": attrs[\"font-family\"] || attrs.fontFamily,\n                    \"lineHeight\": attrs.lineHeight,\n                    \"letter-spacing\": \"letter-spacing\" in attrs ? attrs[\"letter-spacing\"] : attrs.letterSpacing\n                }, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = \"\";\n            }\n            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        }\n    },\n    title: {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var $node = jquery__WEBPACK_IMPORTED_MODULE_0__(node);\n            var cacheName = \"joint-title\";\n            var cache = $node.data(cacheName);\n            if (cache === undefined || cache !== title) {\n                $node.data(cacheName, title);\n                if (node.tagName === \"title\") {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === \"title\") {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, \"title\");\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n    lineHeight: {\n        qualify: isTextInUse\n    },\n    textVerticalAnchor: {\n        qualify: isTextInUse\n    },\n    textPath: {\n        qualify: isTextInUse\n    },\n    annotations: {\n        qualify: isTextInUse\n    },\n    eol: {\n        qualify: isTextInUse\n    },\n    displayEmpty: {\n        qualify: isTextInUse\n    },\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    port: {\n        set: function(port) {\n            return port === null || port.id === undefined ? port : port.id;\n        }\n    },\n    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n    style: {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_6__.isPlainObject,\n        set: function(styles, refBBox, node) {\n            jquery__WEBPACK_IMPORTED_MODULE_0__(node).css(styles);\n        }\n    },\n    html: {\n        set: function(html, refBBox, node) {\n            jquery__WEBPACK_IMPORTED_MODULE_0__(node).html(html + \"\");\n        }\n    },\n    // Properties setter (set various properties on the node)\n    props: _props_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n    ref: {\n    },\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n    refX: {\n        position: positionWrapper(\"x\", \"width\", \"origin\")\n    },\n    refY: {\n        position: positionWrapper(\"y\", \"height\", \"origin\")\n    },\n    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n    // coordinate of the reference element.\n    refDx: {\n        position: positionWrapper(\"x\", \"width\", \"corner\")\n    },\n    refDy: {\n        position: positionWrapper(\"y\", \"height\", \"corner\")\n    },\n    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n    refWidth: {\n        set: setWrapper(\"width\", \"width\")\n    },\n    refHeight: {\n        set: setWrapper(\"height\", \"height\")\n    },\n    refRx: {\n        set: setWrapper(\"rx\", \"width\")\n    },\n    refRy: {\n        set: setWrapper(\"ry\", \"height\")\n    },\n    refRInscribed: {\n        set: function(attrName) {\n            var widthFn = setWrapper(attrName, \"width\");\n            var heightFn = setWrapper(attrName, \"height\");\n            return function(value, refBBox) {\n                var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        }(\"r\")\n    },\n    refRCircumscribed: {\n        set: function(value, refBBox) {\n            var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n            var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n            return {\n                r: rValue\n            };\n        }\n    },\n    refCx: {\n        set: setWrapper(\"cx\", \"width\")\n    },\n    refCy: {\n        set: setWrapper(\"cy\", \"height\")\n    },\n    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n    xAlignment: {\n        offset: offsetWrapper(\"x\", \"width\", \"right\")\n    },\n    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n    yAlignment: {\n        offset: offsetWrapper(\"y\", \"height\", \"bottom\")\n    },\n    resetOffset: {\n        offset: function(val, nodeBBox) {\n            return val ? {\n                x: -nodeBBox.x,\n                y: -nodeBBox.y\n            } : {\n                x: 0,\n                y: 0\n            };\n        }\n    },\n    refDResetOffset: {\n        set: dWrapper({\n            resetOffset: true\n        })\n    },\n    refDKeepOffset: {\n        set: dWrapper({\n            resetOffset: false\n        })\n    },\n    refPointsResetOffset: {\n        set: pointsWrapper({\n            resetOffset: true\n        })\n    },\n    refPointsKeepOffset: {\n        set: pointsWrapper({\n            resetOffset: false\n        })\n    },\n    // LinkView Attributes\n    connection: {\n        qualify: isLinkView,\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, {\n                    segmentSubdivisions\n                });\n                const targetParts = path.divideAtLength(-offset, {\n                    segmentSubdivisions\n                });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n            return {\n                d: d || this.getSerializedConnection()\n            };\n        }\n    },\n    atConnectionLengthKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper(\"getTangentAtLength\", {\n            rotate: true\n        })\n    },\n    atConnectionLengthIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper(\"getTangentAtLength\", {\n            rotate: false\n        })\n    },\n    atConnectionRatioKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper(\"getTangentAtRatio\", {\n            rotate: true\n        })\n    },\n    atConnectionRatioIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper(\"getTangentAtRatio\", {\n            rotate: false\n        })\n    }\n};\nattributesNS[\"xlink:href\"] = attributesNS.xlinkHref;\n// Support `calc()` with the following SVG attributes\n[\n    \"transform\",\n    \"d\",\n    \"points\",\n    \"cx\",\n    \"cy\",\n    \"x1\",\n    \"x2\",\n    \"y1\",\n    \"y2\",\n    \"x\",\n    \"y\",\n    \"dx\",\n    \"dy\" // text\n].forEach((attribute)=>{\n    attributesNS[attribute] = {\n        qualify: _calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute,\n        set: function setCalcAttribute(value, refBBox) {\n            return {\n                [attribute]: (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(value, refBBox)\n            };\n        }\n    };\n});\n// Prevent \"A negative value is not valid\" error.\n[\n    \"width\",\n    \"height\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"font-size\",\n    \"stroke-width\" // elements\n].forEach((attribute)=>{\n    attributesNS[attribute] = {\n        qualify: _calc_mjs__WEBPACK_IMPORTED_MODULE_7__.isCalcAttribute,\n        set: function setCalcAttribute(value, refBBox) {\n            return {\n                [attribute]: Math.max(0, (0,_calc_mjs__WEBPACK_IMPORTED_MODULE_7__.evalCalcAttribute)(value, refBBox))\n            };\n        }\n    };\n});\n// Aliases\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\nattributesNS.fontSize = attributesNS[\"font-size\"];\nattributesNS.strokeWidth = attributesNS[\"stroke-width\"];\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight;\n// Aliases for backwards compatibility\nattributesNS[\"ref-x\"] = attributesNS.refX;\nattributesNS[\"ref-y\"] = attributesNS.refY;\nattributesNS[\"ref-dy\"] = attributesNS.refDy;\nattributesNS[\"ref-dx\"] = attributesNS.refDx;\nattributesNS[\"ref-width\"] = attributesNS.refWidth;\nattributesNS[\"ref-height\"] = attributesNS.refHeight;\nattributesNS[\"x-alignment\"] = attributesNS.xAlignment;\nattributesNS[\"y-alignment\"] = attributesNS.yAlignment;\nconst attributes = attributesNS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL2F0dHJpYnV0ZXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDcUM7QUFDL0I7QUFDaEM7QUFDVDtBQUNXO0FBRWxDLFNBQVNhLFdBQVdDLFFBQVEsRUFBRUMsU0FBUztJQUNuQyxPQUFPLFNBQVNDLEtBQUssRUFBRUMsT0FBTztRQUMxQixJQUFJQyxvQkFBb0JaLDREQUFZQSxDQUFDVTtRQUNyQ0EsUUFBUUcsV0FBV0g7UUFDbkIsSUFBSUUsbUJBQW1CO1lBQ25CRixTQUFTO1FBQ2I7UUFFQSxJQUFJSSxRQUFRLENBQUM7UUFDYixJQUFJQyxTQUFTTCxRQUFRO1lBQ2pCLElBQUlNLFlBQVkscUJBQXNCTixTQUFTLEtBQUtBLFNBQVMsSUFDdkRBLFFBQVFDLE9BQU8sQ0FBQ0YsVUFBVSxHQUMxQlEsS0FBS0MsR0FBRyxDQUFDUixRQUFRQyxPQUFPLENBQUNGLFVBQVUsRUFBRTtZQUMzQ0ssS0FBSyxDQUFDTixTQUFTLEdBQUdRO1FBQ3RCO1FBRUEsT0FBT0Y7SUFDWDtBQUNKO0FBRUEsU0FBU0ssZ0JBQWdCQyxJQUFJLEVBQUVYLFNBQVMsRUFBRVksTUFBTTtJQUM1QyxPQUFPLFNBQVNYLEtBQUssRUFBRUMsT0FBTztRQUMxQixJQUFJVyxrQkFBa0J0Qiw0REFBWUEsQ0FBQ1U7UUFDbkNBLFFBQVFHLFdBQVdIO1FBQ25CLElBQUlZLGlCQUFpQjtZQUNqQlosU0FBUztRQUNiO1FBRUEsSUFBSWE7UUFDSixJQUFJUixTQUFTTCxRQUFRO1lBQ2pCLElBQUljLFlBQVliLE9BQU8sQ0FBQ1UsT0FBTztZQUMvQixJQUFJQyxtQkFBbUJaLFFBQVEsS0FBS0EsUUFBUSxHQUFHO2dCQUMzQ2EsUUFBUUMsU0FBUyxDQUFDSixLQUFLLEdBQUdULE9BQU8sQ0FBQ0YsVUFBVSxHQUFHQztZQUNuRCxPQUFPO2dCQUNIYSxRQUFRQyxTQUFTLENBQUNKLEtBQUssR0FBR1Y7WUFDOUI7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UUFBUTtBQUNqRHBGLFlBQVksQ0FBQyxhQUFhLEdBQUdBLGFBQWFxRixTQUFTO0FBQ25EckYsWUFBWSxDQUFDLGNBQWMsR0FBR0EsYUFBYW1HLFVBQVU7QUFDckRuRyxZQUFZLENBQUMsY0FBYyxHQUFHQSxhQUFhcUcsVUFBVTtBQUU5QyxNQUFNZ0MsYUFBYXJJLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvYXR0cmlidXRlcy9pbmRleC5tanM/MzllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCwgUGF0aCwgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBhc3NpZ24sIGlzUGxhaW5PYmplY3QsIGlzT2JqZWN0LCBpc1BlcmNlbnRhZ2UsIGJyZWFrVGV4dCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuaW1wb3J0IHsgaXNDYWxjQXR0cmlidXRlLCBldmFsQ2FsY0F0dHJpYnV0ZSB9IGZyb20gJy4vY2FsYy5tanMnO1xuaW1wb3J0IHByb3BzIGZyb20gJy4vcHJvcHMubWpzJztcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgViBmcm9tICcuLi8uLi9WL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIHNldFdyYXBwZXIoYXR0ck5hbWUsIGRpbWVuc2lvbikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCkge1xuICAgICAgICB2YXIgaXNWYWx1ZVBlcmNlbnRhZ2UgPSBpc1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBpZiAoaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gKGlzVmFsdWVQZXJjZW50YWdlIHx8IHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMSlcbiAgICAgICAgICAgICAgICA/IHZhbHVlICogcmVmQkJveFtkaW1lbnNpb25dXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1heCh2YWx1ZSArIHJlZkJCb3hbZGltZW5zaW9uXSwgMCk7XG4gICAgICAgICAgICBhdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25XcmFwcGVyKGF4aXMsIGRpbWVuc2lvbiwgb3JpZ2luKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgIHZhciB2YWx1ZVBlcmNlbnRhZ2UgPSBpc1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWVQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGE7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciByZWZPcmlnaW4gPSByZWZCQm94W29yaWdpbl0oKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVBlcmNlbnRhZ2UgfHwgdmFsdWUgPiAwICYmIHZhbHVlIDwgMSkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcmVmT3JpZ2luW2F4aXNdICsgcmVmQkJveFtkaW1lbnNpb25dICogdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcmVmT3JpZ2luW2F4aXNdICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludCgpO1xuICAgICAgICBwb2ludFtheGlzXSA9IGRlbHRhIHx8IDA7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXRXcmFwcGVyKGF4aXMsIGRpbWVuc2lvbiwgY29ybmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBub2RlQkJveCkge1xuICAgICAgICB2YXIgZGVsdGE7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIGRlbHRhID0gbm9kZUJCb3hbZGltZW5zaW9uXSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGNvcm5lcikge1xuICAgICAgICAgICAgZGVsdGEgPSBub2RlQkJveFtkaW1lbnNpb25dO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogb3Igbm90IHRvIGRvIGEgYnJlYWtpbmcgY2hhbmdlP1xuICAgICAgICAgICAgZGVsdGEgPSAodmFsdWUgPiAtMSAmJiB2YWx1ZSA8IDEpID8gKC1ub2RlQkJveFtkaW1lbnNpb25dICogdmFsdWUpIDogLXZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGVyY2VudGFnZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlbHRhID0gbm9kZUJCb3hbZGltZW5zaW9uXSAqIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQoKTtcbiAgICAgICAgcG9pbnRbYXhpc10gPSAtKG5vZGVCQm94W2F4aXNdICsgZGVsdGEpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2hhcGVXcmFwcGVyKHNoYXBlQ29uc3RydWN0b3IsIG9wdCkge1xuICAgIHZhciBjYWNoZU5hbWUgPSAnam9pbnQtc2hhcGUnO1xuICAgIHZhciByZXNldE9mZnNldCA9IG9wdCAmJiBvcHQucmVzZXRPZmZzZXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciAkbm9kZSA9ICQobm9kZSk7XG4gICAgICAgIHZhciBjYWNoZSA9ICRub2RlLmRhdGEoY2FjaGVOYW1lKTtcbiAgICAgICAgaWYgKCFjYWNoZSB8fCBjYWNoZS52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVjYWxjdWxhdGUgaWYgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBjYWNoZWRTaGFwZSA9IHNoYXBlQ29uc3RydWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgY2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBjYWNoZWRTaGFwZSxcbiAgICAgICAgICAgICAgICBzaGFwZUJCb3g6IGNhY2hlZFNoYXBlLmJib3goKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRub2RlLmRhdGEoY2FjaGVOYW1lLCBjYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGUgPSBjYWNoZS5zaGFwZS5jbG9uZSgpO1xuICAgICAgICB2YXIgc2hhcGVCQm94ID0gY2FjaGUuc2hhcGVCQm94LmNsb25lKCk7XG4gICAgICAgIHZhciBzaGFwZU9yaWdpbiA9IHNoYXBlQkJveC5vcmlnaW4oKTtcbiAgICAgICAgdmFyIHJlZk9yaWdpbiA9IHJlZkJCb3gub3JpZ2luKCk7XG5cbiAgICAgICAgc2hhcGVCQm94LnggPSByZWZPcmlnaW4ueDtcbiAgICAgICAgc2hhcGVCQm94LnkgPSByZWZPcmlnaW4ueTtcblxuICAgICAgICB2YXIgZml0U2NhbGUgPSByZWZCQm94Lm1heFJlY3RTY2FsZVRvRml0KHNoYXBlQkJveCwgcmVmT3JpZ2luKTtcbiAgICAgICAgLy8gYG1heFJlY3RTY2FsZVRvRml0YCBjYW4gZ2l2ZSBJbmZpbml0eSBpZiB3aWR0aCBvciBoZWlnaHQgaXMgMFxuICAgICAgICB2YXIgc3ggPSAoc2hhcGVCQm94LndpZHRoID09PSAwIHx8IHJlZkJCb3gud2lkdGggPT09IDApID8gMSA6IGZpdFNjYWxlLnN4O1xuICAgICAgICB2YXIgc3kgPSAoc2hhcGVCQm94LmhlaWdodCA9PT0gMCB8fCByZWZCQm94LmhlaWdodCA9PT0gMCkgPyAxIDogZml0U2NhbGUuc3k7XG5cbiAgICAgICAgc2hhcGUuc2NhbGUoc3gsIHN5LCBzaGFwZU9yaWdpbik7XG4gICAgICAgIGlmIChyZXNldE9mZnNldCkge1xuICAgICAgICAgICAgc2hhcGUudHJhbnNsYXRlKC1zaGFwZU9yaWdpbi54LCAtc2hhcGVPcmlnaW4ueSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfTtcbn1cblxuLy8gYGRgIGF0dHJpYnV0ZSBmb3IgU1ZHUGF0aHNcbmZ1bmN0aW9uIGRXcmFwcGVyKG9wdCkge1xuICAgIGZ1bmN0aW9uIHBhdGhDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgoVi5ub3JtYWxpemVQYXRoRGF0YSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IHNoYXBlV3JhcHBlcihwYXRoQ29uc3RydWN0b3IsIG9wdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciBwYXRoID0gc2hhcGUodmFsdWUsIHJlZkJCb3gsIG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZDogcGF0aC5zZXJpYWxpemUoKVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8vIGBwb2ludHNgIGF0dHJpYnV0ZSBmb3IgU1ZHUG9seWxpbmVzIGFuZCBTVkdQb2x5Z29uc1xuZnVuY3Rpb24gcG9pbnRzV3JhcHBlcihvcHQpIHtcbiAgICB2YXIgc2hhcGUgPSBzaGFwZVdyYXBwZXIoUG9seWxpbmUsIG9wdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IHNoYXBlKHZhbHVlLCByZWZCQm94LCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50czogcG9seWxpbmUuc2VyaWFsaXplKClcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhdENvbm5lY3Rpb25XcmFwcGVyKG1ldGhvZCwgb3B0KSB7XG4gICAgdmFyIHplcm9WZWN0b3IgPSBuZXcgUG9pbnQoMSwgMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBwLCBhbmdsZTtcbiAgICAgICAgdmFyIHRhbmdlbnQgPSB0aGlzW21ldGhvZF0odmFsdWUpO1xuICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgICAgYW5nbGUgPSAob3B0LnJvdGF0ZSkgPyB0YW5nZW50LnZlY3RvcigpLnZlY3RvckFuZ2xlKHplcm9WZWN0b3IpIDogMDtcbiAgICAgICAgICAgIHAgPSB0YW5nZW50LnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHRoaXMucGF0aC5zdGFydDtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5nbGUgPT09IDApIHJldHVybiB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgcC54ICsgJywnICsgcC55ICsgJyknIH07XG4gICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgcC54ICsgJywnICsgcC55ICsgJykgcm90YXRlKCcgKyBhbmdsZSArICcpJyB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNldElmQ2hhbmdlZFdyYXBwZXIoYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldElmQ2hhbmdlZCh2YWx1ZSwgXywgbm9kZSkge1xuICAgICAgICBjb25zdCB2ZWwgPSBWKG5vZGUpO1xuICAgICAgICBpZiAodmVsLmF0dHIoYXR0cmlidXRlKSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdmVsLmF0dHIoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNUZXh0SW5Vc2UoX3ZhbHVlLCBfbm9kZSwgYXR0cnMpIHtcbiAgICByZXR1cm4gKGF0dHJzLnRleHQgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGlzTGlua1ZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuaXNMaW5rKCk7XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRNYXJrZXIoY29udGV4dCkge1xuICAgIHZhciBtYXJrZXIgPSB7fTtcbiAgICAvLyBTdHJva2VcbiAgICAvLyBUaGUgY29udGV4dCAnZmlsbCcgaXMgZGlzcmVnYXJlZCBoZXJlLiBUaGUgdXN1YWwgY2FzZSBpcyB0byB1c2UgdGhlIG1hcmtlciB3aXRoIGEgY29ubmVjdGlvblxuICAgIC8vIChmb3Igd2hpY2ggJ2ZpbGwnIGF0dHJpYnV0ZSBpcyBzZXQgdG8gJ25vbmUnKS5cbiAgICB2YXIgc3Ryb2tlID0gY29udGV4dC5zdHJva2U7XG4gICAgaWYgKHR5cGVvZiBzdHJva2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtlclsnc3Ryb2tlJ10gPSBzdHJva2U7XG4gICAgICAgIG1hcmtlclsnZmlsbCddID0gc3Ryb2tlO1xuICAgIH1cbiAgICAvLyBPcGFjaXR5XG4gICAgLy8gQWdhaW4gdGhlIGNvbnRleHQgJ2ZpbGwtb3BhY2l0eScgaXMgaWdub3JlZC5cbiAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGNvbnRleHQuc3Ryb2tlT3BhY2l0eTtcbiAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSBzdHJva2VPcGFjaXR5ID0gY29udGV4dFsnc3Ryb2tlLW9wYWNpdHknXTtcbiAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSBzdHJva2VPcGFjaXR5ID0gY29udGV4dC5vcGFjaXR5O1xuICAgIGlmIChzdHJva2VPcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFya2VyWydzdHJva2Utb3BhY2l0eSddID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgbWFya2VyWydmaWxsLW9wYWNpdHknXSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIHNldFBhaW50VVJMKGRlZikge1xuICAgIGNvbnN0IHsgcGFwZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgdXJsID0gKGRlZi50eXBlID09PSAncGF0dGVybicpXG4gICAgICAgID8gcGFwZXIuZGVmaW5lUGF0dGVybihkZWYpXG4gICAgICAgIDogcGFwZXIuZGVmaW5lR3JhZGllbnQoZGVmKTtcbiAgICByZXR1cm4gYHVybCgjJHt1cmx9KWA7XG59XG5cbmNvbnN0IGF0dHJpYnV0ZXNOUyA9IHtcblxuICAgIHhsaW5rU2hvdzoge1xuICAgICAgICBzZXQ6ICd4bGluazpzaG93J1xuICAgIH0sXG5cbiAgICB4bGlua1JvbGU6IHtcbiAgICAgICAgc2V0OiAneGxpbms6cm9sZSdcbiAgICB9LFxuXG4gICAgeGxpbmtUeXBlOiB7XG4gICAgICAgIHNldDogJ3hsaW5rOnR5cGUnXG4gICAgfSxcblxuICAgIHhsaW5rQXJjcm9sZToge1xuICAgICAgICBzZXQ6ICd4bGluazphcmNyb2xlJ1xuICAgIH0sXG5cbiAgICB4bGlua1RpdGxlOiB7XG4gICAgICAgIHNldDogJ3hsaW5rOnRpdGxlJ1xuICAgIH0sXG5cbiAgICB4bGlua0FjdHVhdGU6IHtcbiAgICAgICAgc2V0OiAneGxpbms6YWN0dWF0ZSdcbiAgICB9LFxuXG4gICAgeG1sU3BhY2U6IHtcbiAgICAgICAgc2V0OiAneG1sOnNwYWNlJ1xuICAgIH0sXG5cbiAgICB4bWxCYXNlOiB7XG4gICAgICAgIHNldDogJ3htbDpiYXNlJ1xuICAgIH0sXG5cbiAgICB4bWxMYW5nOiB7XG4gICAgICAgIHNldDogJ3htbDpsYW5nJ1xuICAgIH0sXG5cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiB7XG4gICAgICAgIHNldDogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXG4gICAgfSxcblxuICAgIHJlcXVpcmVkRXh0ZW5zaW9uOiB7XG4gICAgICAgIHNldDogJ3JlcXVpcmVkRXh0ZW5zaW9uJ1xuICAgIH0sXG5cbiAgICByZXF1aXJlZEZlYXR1cmVzOiB7XG4gICAgICAgIHNldDogJ3JlcXVpcmVkRmVhdHVyZXMnXG4gICAgfSxcblxuICAgIHN5c3RlbUxhbmd1YWdlOiB7XG4gICAgICAgIHNldDogJ3N5c3RlbUxhbmd1YWdlJ1xuICAgIH0sXG5cbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiB7XG4gICAgICAgIHNldDogJ2V4dGVybmFsUmVzb3VyY2VSZXF1aXJlZCdcbiAgICB9LFxuXG4gICAgaHJlZjoge1xuICAgICAgICBzZXQ6IHNldElmQ2hhbmdlZFdyYXBwZXIoJ2hyZWYnKVxuICAgIH0sXG5cbiAgICB4bGlua0hyZWY6IHtcbiAgICAgICAgc2V0OiBzZXRJZkNoYW5nZWRXcmFwcGVyKCd4bGluazpocmVmJylcbiAgICB9LFxuXG4gICAgZmlsdGVyOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMucGFwZXIuZGVmaW5lRmlsdGVyKGZpbHRlcikgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlsbDoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IHNldFBhaW50VVJMXG4gICAgfSxcblxuICAgIHN0cm9rZToge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IHNldFBhaW50VVJMXG4gICAgfSxcblxuICAgIHNvdXJjZU1hcmtlcjoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgbWFya2VyKTtcbiAgICAgICAgICAgIHJldHVybiB7ICdtYXJrZXItc3RhcnQnOiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVNYXJrZXIobWFya2VyKSArICcpJyB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRhcmdldE1hcmtlcjoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgeyAndHJhbnNmb3JtJzogJ3JvdGF0ZSgxODApJyB9LCBtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ21hcmtlci1lbmQnOiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVNYXJrZXIobWFya2VyKSArICcpJyB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZlcnRleE1hcmtlcjoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgbWFya2VyKTtcbiAgICAgICAgICAgIHJldHVybiB7ICdtYXJrZXItbWlkJzogJ3VybCgjJyArIHRoaXMucGFwZXIuZGVmaW5lTWFya2VyKG1hcmtlcikgKyAnKScgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0ZXh0OiB7XG4gICAgICAgIHF1YWxpZnk6IGZ1bmN0aW9uKF90ZXh0LCBfbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiAhYXR0cnMudGV4dFdyYXAgfHwgIWlzUGxhaW5PYmplY3QoYXR0cnMudGV4dFdyYXApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleHQsIHJlZkJCb3gsIG5vZGUsIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCAkbm9kZSA9ICQobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZU5hbWUgPSAnam9pbnQtdGV4dCc7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9ICRub2RlLmRhdGEoY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcixcbiAgICAgICAgICAgICAgICBlb2wsXG4gICAgICAgICAgICAgICAgZGlzcGxheUVtcHR5XG4gICAgICAgICAgICB9ID0gYXR0cnM7XG4gICAgICAgICAgICBsZXQgdGV4dFBhdGggPSBhdHRycy50ZXh0UGF0aDtcbiAgICAgICAgICAgIC8vIGV2YWwgYHhgIGlmIHVzaW5nIGNhbGMoKVxuICAgICAgICAgICAgbGV0IHggPSBhdHRycy54O1xuICAgICAgICAgICAgaWYgKGlzQ2FsY0F0dHJpYnV0ZSh4KSkge1xuICAgICAgICAgICAgICAgIHggPSBldmFsQ2FsY0F0dHJpYnV0ZSh4LCByZWZCQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV2YWwgYGZvbnQtc2l6ZWAgaWYgdXNpbmcgY2FsYygpXG4gICAgICAgICAgICBsZXQgZm9udFNpemUgPSBhdHRyc1snZm9udC1zaXplJ10gfHwgYXR0cnNbJ2ZvbnRTaXplJ107XG4gICAgICAgICAgICBpZiAoaXNDYWxjQXR0cmlidXRlKGZvbnRTaXplKSkge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gZXZhbENhbGNBdHRyaWJ1dGUoZm9udFNpemUsIHJlZkJCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0ZXh0IG9ubHkgaWYgdGhlcmUgd2FzIGEgY2hhbmdlIGluIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIC8vIG9yIGFueSBvZiBpdHMgYXR0cmlidXRlcy5cbiAgICAgICAgICAgIGNvbnN0IHRleHRIYXNoID0gSlNPTi5zdHJpbmdpZnkoW3RleHQsIGxpbmVIZWlnaHQsIGFubm90YXRpb25zLCB0ZXh0VmVydGljYWxBbmNob3IsIGVvbCwgZGlzcGxheUVtcHR5LCB0ZXh0UGF0aCwgeCwgZm9udFNpemVdKTtcbiAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkIHx8IGNhY2hlICE9PSB0ZXh0SGFzaCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBidWc6XG4gICAgICAgICAgICAgICAgLy8gPHRzcGFuPiBwb3NpdGlvbnMgZGVmaW5lZCBhcyBgZW1gIGFyZSBub3QgdXBkYXRlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29udGFpbmVyIGBmb250LXNpemVgIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemUpIG5vZGUuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGV4dCBBbG9uZyBQYXRoIFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRleHRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoU2VsZWN0b3IgPSB0ZXh0UGF0aC5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcGF0aE5vZGVdID0gdGhpcy5maW5kQnlTZWxlY3RvcihwYXRoU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhOb2RlIGluc3RhbmNlb2YgU1ZHUGF0aEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UGF0aCA9IGFzc2lnbih7ICd4bGluazpocmVmJzogJyMnICsgcGF0aE5vZGUuaWQgfSwgdGV4dFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFYobm9kZSkudGV4dCgnJyArIHRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRleHRQYXRoLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIGVvbCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUVtcHR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJG5vZGUuZGF0YShjYWNoZU5hbWUsIHRleHRIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0ZXh0V3JhcDoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSB7fTtcbiAgICAgICAgICAgIC8vIG9wdGlvbiBgd2lkdGhgXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB2YWx1ZS53aWR0aCB8fCAwO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZSh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gcmVmQkJveC53aWR0aCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGNBdHRyaWJ1dGUod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZS53aWR0aCA9IE51bWJlcihldmFsQ2FsY0F0dHJpYnV0ZSh3aWR0aCwgcmVmQkJveCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWtUZXh0KCkgcmVxdWlyZXMgd2lkdGggdG8gYmUgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggPSByZWZCQm94LndpZHRoICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGlvbiBgaGVpZ2h0YFxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHZhbHVlLmhlaWdodCB8fCAwO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZShoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSByZWZCQm94LmhlaWdodCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxjQXR0cmlidXRlKGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IE51bWJlcihldmFsQ2FsY0F0dHJpYnV0ZShoZWlnaHQsIHJlZkJCb3gpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBoZWlnaHQgaXMgbm90IHNwZWNpZmllZCBicmVha1RleHQoKSBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0cmljdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSByZWZCQm94LmhlaWdodCArIGhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcHRpb24gYHRleHRgXG4gICAgICAgICAgICB2YXIgd3JhcHBlZFRleHQ7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHZhbHVlLnRleHQ7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB0ZXh0ID0gYXR0cnMudGV4dDtcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmVha1RleHRGbiA9IHZhbHVlLmJyZWFrVGV4dCB8fCBicmVha1RleHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udFNpemVBdHRyID0gYXR0cnNbJ2ZvbnQtc2l6ZSddIHx8IGF0dHJzLmZvbnRTaXplO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRUZXh0ID0gYnJlYWtUZXh0Rm4oJycgKyB0ZXh0LCBzaXplLCB7XG4gICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodCc6IGF0dHJzWydmb250LXdlaWdodCddIHx8IGF0dHJzLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBpc0NhbGNBdHRyaWJ1dGUoZm9udFNpemVBdHRyKSA/IGV2YWxDYWxjQXR0cmlidXRlKGZvbnRTaXplQXR0ciwgcmVmQkJveCkgOiBmb250U2l6ZUF0dHIsXG4gICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IGF0dHJzWydmb250LWZhbWlseSddIHx8IGF0dHJzLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgICAgICdsaW5lSGVpZ2h0JzogYXR0cnMubGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlci1zcGFjaW5nJyBpbiBhdHRycyA/IGF0dHJzWydsZXR0ZXItc3BhY2luZyddIDogYXR0cnMubGV0dGVyU3BhY2luZ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBhbiBleGlzdGluZyBTVkcgRG9jdW1lbnQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IG9uZSBvdmVyIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBzdmdEb2N1bWVudDogdGhpcy5wYXBlci5zdmcsXG4gICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzOiB2YWx1ZS5lbGxpcHNpcyxcbiAgICAgICAgICAgICAgICAgICAgaHlwaGVuOiB2YWx1ZS5oeXBoZW4sXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogdmFsdWUuc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXhMaW5lQ291bnQ6IHZhbHVlLm1heExpbmVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVTcGFjZXM6IHZhbHVlLnByZXNlcnZlU3BhY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRUZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVzTlMudGV4dC5zZXQuY2FsbCh0aGlzLCB3cmFwcGVkVGV4dCwgcmVmQkJveCwgbm9kZSwgYXR0cnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICAgIHF1YWxpZnk6IGZ1bmN0aW9uKHRpdGxlLCBub2RlKSB7XG4gICAgICAgICAgICAvLyBIVE1MRWxlbWVudCB0aXRsZSBpcyBzcGVjaWZpZWQgdmlhIGFuIGF0dHJpYnV0ZSAoaS5lLiBub3QgYW4gZWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0aXRsZSwgcmVmQkJveCwgbm9kZSkge1xuICAgICAgICAgICAgdmFyICRub2RlID0gJChub2RlKTtcbiAgICAgICAgICAgIHZhciBjYWNoZU5hbWUgPSAnam9pbnQtdGl0bGUnO1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gJG5vZGUuZGF0YShjYWNoZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQgfHwgY2FjaGUgIT09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgJG5vZGUuZGF0YShjYWNoZU5hbWUsIHRpdGxlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBpcyBhIDx0aXRsZT4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYWxseSA8dGl0bGU+IGVsZW1lbnQgc2hvdWxkIGJlIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IG9mIGl0cyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3RpbmcgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0aXRsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAndGl0bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVOb2RlLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKHRpdGxlTm9kZSwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxpbmVIZWlnaHQ6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgdGV4dFZlcnRpY2FsQW5jaG9yOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgIHRleHRQYXRoOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgIGVvbDoge1xuICAgICAgICBxdWFsaWZ5OiBpc1RleHRJblVzZVxuICAgIH0sXG5cbiAgICBkaXNwbGF5RW1wdHk6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgLy8gYHBvcnRgIGF0dHJpYnV0ZSBjb250YWlucyB0aGUgYGlkYCBvZiB0aGUgcG9ydCB0aGF0IHRoZSB1bmRlcmx5aW5nIG1hZ25ldCByZXByZXNlbnRzLlxuICAgIHBvcnQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHBvcnQgPT09IG51bGwgfHwgcG9ydC5pZCA9PT0gdW5kZWZpbmVkKSA/IHBvcnQgOiBwb3J0LmlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlIGlzIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2V0cyB0aGUgQ1NTIHN0eWxlIG9mIHRoZSBzdWJlbGVtZW50LlxuICAgIHN0eWxlOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHNldDogZnVuY3Rpb24oc3R5bGVzLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgICAgICAkKG5vZGUpLmNzcyhzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGh0bWw6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihodG1sLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgICAgICAkKG5vZGUpLmh0bWwoaHRtbCArICcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBQcm9wZXJ0aWVzIHNldHRlciAoc2V0IHZhcmlvdXMgcHJvcGVydGllcyBvbiB0aGUgbm9kZSlcbiAgICBwcm9wcyxcblxuICAgIHJlZjoge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc2V0IGByZWZgIGF0dHJpYnV0ZSBkaXJlY3RseSBvbiBhbiBlbGVtZW50LlxuICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGl0c2VsZiBkb2VzIG5vdCBxdWFsaWZ5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmluZy5cbiAgICB9LFxuXG4gICAgLy8gaWYgYHJlZlhgIGlzIGluIFswLCAxXSB0aGVuIGByZWZYYCBpcyBhIGZyYWN0aW9uIG9mIGJvdW5kaW5nIGJveCB3aWR0aFxuICAgIC8vIGlmIGByZWZYYCBpcyA8IDAgdGhlbiBgcmVmWGAncyBhYnNvbHV0ZSB2YWx1ZXMgaXMgdGhlIHJpZ2h0IGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgIC8vIG90aGVyd2lzZSwgYHJlZlhgIGlzIHRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveFxuXG4gICAgcmVmWDoge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25XcmFwcGVyKCd4JywgJ3dpZHRoJywgJ29yaWdpbicpXG4gICAgfSxcblxuICAgIHJlZlk6IHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uV3JhcHBlcigneScsICdoZWlnaHQnLCAnb3JpZ2luJylcbiAgICB9LFxuXG4gICAgLy8gYHJlZi1keGAgYW5kIGByZWYtZHlgIGRlZmluZSB0aGUgb2Zmc2V0IG9mIHRoZSBzdWJlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSByaWdodCBhbmQvb3IgYm90dG9tXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG5cbiAgICByZWZEeDoge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25XcmFwcGVyKCd4JywgJ3dpZHRoJywgJ2Nvcm5lcicpXG4gICAgfSxcblxuICAgIHJlZkR5OiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbldyYXBwZXIoJ3knLCAnaGVpZ2h0JywgJ2Nvcm5lcicpXG4gICAgfSxcblxuICAgIC8vICdyZWYtd2lkdGgnLydyZWYtaGVpZ2h0JyBkZWZpbmVzIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHN1YmVsZW1lbnQgcmVsYXRpdmVseSB0b1xuICAgIC8vIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzaXplXG4gICAgLy8gdmFsIGluIDAuLjEgICAgICAgICByZWYtd2lkdGggPSAwLjc1IHNldHMgdGhlIHdpZHRoIHRvIDc1JSBvZiB0aGUgcmVmLiBlbC4gd2lkdGhcbiAgICAvLyB2YWwgPCAwIHx8IHZhbCA+IDEgIHJlZi1oZWlnaHQgPSAtMjAgc2V0cyB0aGUgaGVpZ2h0IHRvIHRoZSByZWYuIGVsLiBoZWlnaHQgc2hvcnRlciBieSAyMFxuXG4gICAgcmVmV2lkdGg6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCd3aWR0aCcsICd3aWR0aCcpXG4gICAgfSxcblxuICAgIHJlZkhlaWdodDoge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ2hlaWdodCcsICdoZWlnaHQnKVxuICAgIH0sXG5cbiAgICByZWZSeDoge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ3J4JywgJ3dpZHRoJylcbiAgICB9LFxuXG4gICAgcmVmUnk6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdyeScsICdoZWlnaHQnKVxuICAgIH0sXG5cbiAgICByZWZSSW5zY3JpYmVkOiB7XG4gICAgICAgIHNldDogKGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGhGbiA9IHNldFdyYXBwZXIoYXR0ck5hbWUsICd3aWR0aCcpO1xuICAgICAgICAgICAgdmFyIGhlaWdodEZuID0gc2V0V3JhcHBlcihhdHRyTmFtZSwgJ2hlaWdodCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gKHJlZkJCb3guaGVpZ2h0ID4gcmVmQkJveC53aWR0aCkgPyB3aWR0aEZuIDogaGVpZ2h0Rm47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlLCByZWZCQm94KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCdyJylcbiAgICB9LFxuXG4gICAgcmVmUkNpcmN1bXNjcmliZWQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCkge1xuICAgICAgICAgICAgdmFyIGlzVmFsdWVQZXJjZW50YWdlID0gaXNQZXJjZW50YWdlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaWFnb25hbExlbmd0aCA9IE1hdGguc3FydCgocmVmQkJveC5oZWlnaHQgKiByZWZCQm94LmhlaWdodCkgKyAocmVmQkJveC53aWR0aCAqIHJlZkJCb3gud2lkdGgpKTtcblxuICAgICAgICAgICAgdmFyIHJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UgfHwgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxKSByVmFsdWUgPSB2YWx1ZSAqIGRpYWdvbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGVsc2UgclZhbHVlID0gTWF0aC5tYXgodmFsdWUgKyBkaWFnb25hbExlbmd0aCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHI6IHJWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZkN4OiB7XG4gICAgICAgIHNldDogc2V0V3JhcHBlcignY3gnLCAnd2lkdGgnKVxuICAgIH0sXG5cbiAgICByZWZDeToge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ2N5JywgJ2hlaWdodCcpXG4gICAgfSxcblxuICAgIC8vIGB4LWFsaWdubWVudGAgd2hlbiBzZXQgdG8gYG1pZGRsZWAgY2F1c2VzIGNlbnRlcmluZyBvZiB0aGUgc3ViZWxlbWVudCBhcm91bmQgaXRzIG5ldyB4IGNvb3JkaW5hdGUuXG4gICAgLy8gYHgtYWxpZ25tZW50YCB3aGVuIHNldCB0byBgcmlnaHRgIHVzZXMgdGhlIHggY29vcmRpbmF0ZSBhcyByZWZlcmVuY2VkIHRvIHRoZSByaWdodCBvZiB0aGUgYmJveC5cblxuICAgIHhBbGlnbm1lbnQ6IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRXcmFwcGVyKCd4JywgJ3dpZHRoJywgJ3JpZ2h0JylcbiAgICB9LFxuXG4gICAgLy8gYHktYWxpZ25tZW50YCB3aGVuIHNldCB0byBgbWlkZGxlYCBjYXVzZXMgY2VudGVyaW5nIG9mIHRoZSBzdWJlbGVtZW50IGFyb3VuZCBpdHMgbmV3IHkgY29vcmRpbmF0ZS5cbiAgICAvLyBgeS1hbGlnbm1lbnRgIHdoZW4gc2V0IHRvIGBib3R0b21gIHVzZXMgdGhlIHkgY29vcmRpbmF0ZSBhcyByZWZlcmVuY2VkIHRvIHRoZSBib3R0b20gb2YgdGhlIGJib3guXG5cbiAgICB5QWxpZ25tZW50OiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0V3JhcHBlcigneScsICdoZWlnaHQnLCAnYm90dG9tJylcbiAgICB9LFxuXG4gICAgcmVzZXRPZmZzZXQ6IHtcbiAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbih2YWwsIG5vZGVCQm94KSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbClcbiAgICAgICAgICAgICAgICA/IHsgeDogLW5vZGVCQm94LngsIHk6IC1ub2RlQkJveC55IH1cbiAgICAgICAgICAgICAgICA6IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmVmRFJlc2V0T2Zmc2V0OiB7XG4gICAgICAgIHNldDogZFdyYXBwZXIoeyByZXNldE9mZnNldDogdHJ1ZSB9KVxuICAgIH0sXG5cbiAgICByZWZES2VlcE9mZnNldDoge1xuICAgICAgICBzZXQ6IGRXcmFwcGVyKHsgcmVzZXRPZmZzZXQ6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgIHJlZlBvaW50c1Jlc2V0T2Zmc2V0OiB7XG4gICAgICAgIHNldDogcG9pbnRzV3JhcHBlcih7IHJlc2V0T2Zmc2V0OiB0cnVlIH0pXG4gICAgfSxcblxuICAgIHJlZlBvaW50c0tlZXBPZmZzZXQ6IHtcbiAgICAgICAgc2V0OiBwb2ludHNXcmFwcGVyKHsgcmVzZXRPZmZzZXQ6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgIC8vIExpbmtWaWV3IEF0dHJpYnV0ZXNcblxuICAgIGNvbm5lY3Rpb246IHtcbiAgICAgICAgcXVhbGlmeTogaXNMaW5rVmlldyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih7IHN0dWJzID0gMCB9KSB7XG4gICAgICAgICAgICBsZXQgZDtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShzdHVicykgJiYgc3R1YnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChzdHVicyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpICsgc3R1YnMpIC8gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBzdHVicztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRTdWJkaXZpc2lvbnMgPSB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VQYXJ0cyA9IHBhdGguZGl2aWRlQXRMZW5ndGgob2Zmc2V0LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGFydHMgPSBwYXRoLmRpdmlkZUF0TGVuZ3RoKC1vZmZzZXQsIHsgc2VnbWVudFN1YmRpdmlzaW9ucyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlUGFydHMgJiYgdGFyZ2V0UGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGAke3NvdXJjZVBhcnRzWzBdLnNlcmlhbGl6ZSgpfSAke3RhcmdldFBhcnRzWzFdLnNlcmlhbGl6ZSgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBkOiBkIHx8IHRoaXMuZ2V0U2VyaWFsaXplZENvbm5lY3Rpb24oKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGF0Q29ubmVjdGlvbkxlbmd0aEtlZXBHcmFkaWVudDoge1xuICAgICAgICBxdWFsaWZ5OiBpc0xpbmtWaWV3LFxuICAgICAgICBzZXQ6IGF0Q29ubmVjdGlvbldyYXBwZXIoJ2dldFRhbmdlbnRBdExlbmd0aCcsIHsgcm90YXRlOiB0cnVlIH0pXG4gICAgfSxcblxuICAgIGF0Q29ubmVjdGlvbkxlbmd0aElnbm9yZUdyYWRpZW50OiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHNldDogYXRDb25uZWN0aW9uV3JhcHBlcignZ2V0VGFuZ2VudEF0TGVuZ3RoJywgeyByb3RhdGU6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgIGF0Q29ubmVjdGlvblJhdGlvS2VlcEdyYWRpZW50OiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHNldDogYXRDb25uZWN0aW9uV3JhcHBlcignZ2V0VGFuZ2VudEF0UmF0aW8nLCB7IHJvdGF0ZTogdHJ1ZSB9KVxuICAgIH0sXG5cbiAgICBhdENvbm5lY3Rpb25SYXRpb0lnbm9yZUdyYWRpZW50OiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHNldDogYXRDb25uZWN0aW9uV3JhcHBlcignZ2V0VGFuZ2VudEF0UmF0aW8nLCB7IHJvdGF0ZTogZmFsc2UgfSlcbiAgICB9XG59O1xuXG5hdHRyaWJ1dGVzTlNbJ3hsaW5rOmhyZWYnXSA9IGF0dHJpYnV0ZXNOUy54bGlua0hyZWY7XG5cbi8vIFN1cHBvcnQgYGNhbGMoKWAgd2l0aCB0aGUgZm9sbG93aW5nIFNWRyBhdHRyaWJ1dGVzXG5bXG4gICAgJ3RyYW5zZm9ybScsIC8vIGdcbiAgICAnZCcsIC8vIHBhdGhcbiAgICAncG9pbnRzJywgLy8gcG9seWxpbmUgLyBwb2x5Z29uXG4gICAgJ2N4JywgJ2N5JywgLy8gY2lyY2xlIC8gZWxsaXBzZVxuICAgICd4MScsICd4MicsICd5MScsICd5MicsIC8vIGxpbmVcbiAgICAneCcsICd5JywgLy8gcmVjdCAvIHRleHQgLyBpbWFnZVxuICAgICdkeCcsICdkeScgLy8gdGV4dFxuXS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgYXR0cmlidXRlc05TW2F0dHJpYnV0ZV0gPSB7XG4gICAgICAgIHF1YWxpZnk6IGlzQ2FsY0F0dHJpYnV0ZSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXRDYWxjQXR0cmlidXRlKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgICAgICByZXR1cm4geyBbYXR0cmlidXRlXTogZXZhbENhbGNBdHRyaWJ1dGUodmFsdWUsIHJlZkJCb3gpIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cbi8vIFByZXZlbnQgXCJBIG5lZ2F0aXZlIHZhbHVlIGlzIG5vdCB2YWxpZFwiIGVycm9yLlxuW1xuICAgICd3aWR0aCcsICdoZWlnaHQnLCAvLyByZWN0IC8gaW1hZ2VcbiAgICAncicsIC8vIGNpcmNsZVxuICAgICdyeCcsICdyeScsIC8vIHJlY3QgLyBlbGxpcHNlXG4gICAgJ2ZvbnQtc2l6ZScsIC8vIHRleHRcbiAgICAnc3Ryb2tlLXdpZHRoJyAvLyBlbGVtZW50c1xuXS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgYXR0cmlidXRlc05TW2F0dHJpYnV0ZV0gPSB7XG4gICAgICAgIHF1YWxpZnk6IGlzQ2FsY0F0dHJpYnV0ZSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXRDYWxjQXR0cmlidXRlKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgICAgICByZXR1cm4geyBbYXR0cmlidXRlXTogTWF0aC5tYXgoMCwgZXZhbENhbGNBdHRyaWJ1dGUodmFsdWUsIHJlZkJCb3gpKSB9O1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG4vLyBBbGlhc2VzXG5hdHRyaWJ1dGVzTlMucmVmUiA9IGF0dHJpYnV0ZXNOUy5yZWZSSW5zY3JpYmVkO1xuYXR0cmlidXRlc05TLnJlZkQgPSBhdHRyaWJ1dGVzTlMucmVmRFJlc2V0T2Zmc2V0O1xuYXR0cmlidXRlc05TLnJlZlBvaW50cyA9IGF0dHJpYnV0ZXNOUy5yZWZQb2ludHNSZXNldE9mZnNldDtcbmF0dHJpYnV0ZXNOUy5hdENvbm5lY3Rpb25MZW5ndGggPSBhdHRyaWJ1dGVzTlMuYXRDb25uZWN0aW9uTGVuZ3RoS2VlcEdyYWRpZW50O1xuYXR0cmlidXRlc05TLmF0Q29ubmVjdGlvblJhdGlvID0gYXR0cmlidXRlc05TLmF0Q29ubmVjdGlvblJhdGlvS2VlcEdyYWRpZW50O1xuYXR0cmlidXRlc05TLmZvbnRTaXplID0gYXR0cmlidXRlc05TWydmb250LXNpemUnXTtcbmF0dHJpYnV0ZXNOUy5zdHJva2VXaWR0aCA9IGF0dHJpYnV0ZXNOU1snc3Ryb2tlLXdpZHRoJ107XG5cbi8vIFRoaXMgYWxsb3dzIHRvIGNvbWJpbmUgYm90aCBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUgcG9zaXRpb25pbmdcbi8vIHJlZlg6IDUwJSwgcmVmWDI6IDIwXG5hdHRyaWJ1dGVzTlMucmVmWDIgPSBhdHRyaWJ1dGVzTlMucmVmWDtcbmF0dHJpYnV0ZXNOUy5yZWZZMiA9IGF0dHJpYnV0ZXNOUy5yZWZZO1xuYXR0cmlidXRlc05TLnJlZldpZHRoMiA9IGF0dHJpYnV0ZXNOUy5yZWZXaWR0aDtcbmF0dHJpYnV0ZXNOUy5yZWZIZWlnaHQyID0gYXR0cmlidXRlc05TLnJlZkhlaWdodDtcblxuLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmF0dHJpYnV0ZXNOU1sncmVmLXgnXSA9IGF0dHJpYnV0ZXNOUy5yZWZYO1xuYXR0cmlidXRlc05TWydyZWYteSddID0gYXR0cmlidXRlc05TLnJlZlk7XG5hdHRyaWJ1dGVzTlNbJ3JlZi1keSddID0gYXR0cmlidXRlc05TLnJlZkR5O1xuYXR0cmlidXRlc05TWydyZWYtZHgnXSA9IGF0dHJpYnV0ZXNOUy5yZWZEeDtcbmF0dHJpYnV0ZXNOU1sncmVmLXdpZHRoJ10gPSBhdHRyaWJ1dGVzTlMucmVmV2lkdGg7XG5hdHRyaWJ1dGVzTlNbJ3JlZi1oZWlnaHQnXSA9IGF0dHJpYnV0ZXNOUy5yZWZIZWlnaHQ7XG5hdHRyaWJ1dGVzTlNbJ3gtYWxpZ25tZW50J10gPSBhdHRyaWJ1dGVzTlMueEFsaWdubWVudDtcbmF0dHJpYnV0ZXNOU1sneS1hbGlnbm1lbnQnXSA9IGF0dHJpYnV0ZXNOUy55QWxpZ25tZW50O1xuXG5leHBvcnQgY29uc3QgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNOUztcblxuIl0sIm5hbWVzIjpbIlBvaW50IiwiUGF0aCIsIlBvbHlsaW5lIiwiYXNzaWduIiwiaXNQbGFpbk9iamVjdCIsImlzT2JqZWN0IiwiaXNQZXJjZW50YWdlIiwiYnJlYWtUZXh0IiwiaXNDYWxjQXR0cmlidXRlIiwiZXZhbENhbGNBdHRyaWJ1dGUiLCJwcm9wcyIsIiQiLCJWIiwic2V0V3JhcHBlciIsImF0dHJOYW1lIiwiZGltZW5zaW9uIiwidmFsdWUiLCJyZWZCQm94IiwiaXNWYWx1ZVBlcmNlbnRhZ2UiLCJwYXJzZUZsb2F0IiwiYXR0cnMiLCJpc0Zpbml0ZSIsImF0dHJWYWx1ZSIsIk1hdGgiLCJtYXgiLCJwb3NpdGlvbldyYXBwZXIiLCJheGlzIiwib3JpZ2luIiwidmFsdWVQZXJjZW50YWdlIiwiZGVsdGEiLCJyZWZPcmlnaW4iLCJwb2ludCIsIm9mZnNldFdyYXBwZXIiLCJjb3JuZXIiLCJub2RlQkJveCIsInNoYXBlV3JhcHBlciIsInNoYXBlQ29uc3RydWN0b3IiLCJvcHQiLCJjYWNoZU5hbWUiLCJyZXNldE9mZnNldCIsIm5vZGUiLCIkbm9kZSIsImNhY2hlIiwiZGF0YSIsImNhY2hlZFNoYXBlIiwic2hhcGUiLCJzaGFwZUJCb3giLCJiYm94IiwiY2xvbmUiLCJzaGFwZU9yaWdpbiIsIngiLCJ5IiwiZml0U2NhbGUiLCJtYXhSZWN0U2NhbGVUb0ZpdCIsInN4Iiwid2lkdGgiLCJzeSIsImhlaWdodCIsInNjYWxlIiwidHJhbnNsYXRlIiwiZFdyYXBwZXIiLCJwYXRoQ29uc3RydWN0b3IiLCJub3JtYWxpemVQYXRoRGF0YSIsInBhdGgiLCJkIiwic2VyaWFsaXplIiwicG9pbnRzV3JhcHBlciIsInBvbHlsaW5lIiwicG9pbnRzIiwiYXRDb25uZWN0aW9uV3JhcHBlciIsIm1ldGhvZCIsInplcm9WZWN0b3IiLCJwIiwiYW5nbGUiLCJ0YW5nZW50Iiwicm90YXRlIiwidmVjdG9yIiwidmVjdG9yQW5nbGUiLCJzdGFydCIsInRyYW5zZm9ybSIsInNldElmQ2hhbmdlZFdyYXBwZXIiLCJhdHRyaWJ1dGUiLCJzZXRJZkNoYW5nZWQiLCJfIiwidmVsIiwiYXR0ciIsImlzVGV4dEluVXNlIiwiX3ZhbHVlIiwiX25vZGUiLCJ0ZXh0IiwidW5kZWZpbmVkIiwiaXNMaW5rVmlldyIsIm1vZGVsIiwiaXNMaW5rIiwiY29udGV4dE1hcmtlciIsImNvbnRleHQiLCJtYXJrZXIiLCJzdHJva2UiLCJzdHJva2VPcGFjaXR5Iiwib3BhY2l0eSIsInNldFBhaW50VVJMIiwiZGVmIiwicGFwZXIiLCJ1cmwiLCJ0eXBlIiwiZGVmaW5lUGF0dGVybiIsImRlZmluZUdyYWRpZW50IiwiYXR0cmlidXRlc05TIiwieGxpbmtTaG93Iiwic2V0IiwieGxpbmtSb2xlIiwieGxpbmtUeXBlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtUaXRsZSIsInhsaW5rQWN0dWF0ZSIsInhtbFNwYWNlIiwieG1sQmFzZSIsInhtbExhbmciLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicmVxdWlyZWRFeHRlbnNpb24iLCJyZXF1aXJlZEZlYXR1cmVzIiwic3lzdGVtTGFuZ3VhZ2UiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiaHJlZiIsInhsaW5rSHJlZiIsImZpbHRlciIsInF1YWxpZnkiLCJkZWZpbmVGaWx0ZXIiLCJmaWxsIiwic291cmNlTWFya2VyIiwiZGVmaW5lTWFya2VyIiwidGFyZ2V0TWFya2VyIiwidmVydGV4TWFya2VyIiwiX3RleHQiLCJ0ZXh0V3JhcCIsImxpbmVIZWlnaHQiLCJhbm5vdGF0aW9ucyIsInRleHRWZXJ0aWNhbEFuY2hvciIsImVvbCIsImRpc3BsYXlFbXB0eSIsInRleHRQYXRoIiwiZm9udFNpemUiLCJ0ZXh0SGFzaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRBdHRyaWJ1dGUiLCJwYXRoU2VsZWN0b3IiLCJzZWxlY3RvciIsInBhdGhOb2RlIiwiZmluZEJ5U2VsZWN0b3IiLCJTVkdQYXRoRWxlbWVudCIsImlkIiwic2l6ZSIsIk51bWJlciIsIkluZmluaXR5Iiwid3JhcHBlZFRleHQiLCJicmVha1RleHRGbiIsImZvbnRTaXplQXR0ciIsImZvbnRXZWlnaHQiLCJmb250RmFtaWx5IiwibGV0dGVyU3BhY2luZyIsInN2Z0RvY3VtZW50Iiwic3ZnIiwiZWxsaXBzaXMiLCJoeXBoZW4iLCJzZXBhcmF0b3IiLCJtYXhMaW5lQ291bnQiLCJwcmVzZXJ2ZVNwYWNlcyIsImNhbGwiLCJ0aXRsZSIsIlNWR0VsZW1lbnQiLCJ0YWdOYW1lIiwidGV4dENvbnRlbnQiLCJmaXJzdENoaWxkIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ0aXRsZU5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZVVSSSIsImluc2VydEJlZm9yZSIsInBvcnQiLCJzdHlsZSIsInN0eWxlcyIsImNzcyIsImh0bWwiLCJyZWYiLCJyZWZYIiwicG9zaXRpb24iLCJyZWZZIiwicmVmRHgiLCJyZWZEeSIsInJlZldpZHRoIiwicmVmSGVpZ2h0IiwicmVmUngiLCJyZWZSeSIsInJlZlJJbnNjcmliZWQiLCJ3aWR0aEZuIiwiaGVpZ2h0Rm4iLCJmbiIsInJlZlJDaXJjdW1zY3JpYmVkIiwiZGlhZ29uYWxMZW5ndGgiLCJzcXJ0IiwiclZhbHVlIiwiciIsInJlZkN4IiwicmVmQ3kiLCJ4QWxpZ25tZW50Iiwib2Zmc2V0IiwieUFsaWdubWVudCIsInZhbCIsInJlZkRSZXNldE9mZnNldCIsInJlZkRLZWVwT2Zmc2V0IiwicmVmUG9pbnRzUmVzZXRPZmZzZXQiLCJyZWZQb2ludHNLZWVwT2Zmc2V0IiwiY29ubmVjdGlvbiIsInN0dWJzIiwiZ2V0Q29ubmVjdGlvbkxlbmd0aCIsImdldENvbm5lY3Rpb24iLCJzZWdtZW50U3ViZGl2aXNpb25zIiwiZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucyIsInNvdXJjZVBhcnRzIiwiZGl2aWRlQXRMZW5ndGgiLCJ0YXJnZXRQYXJ0cyIsImdldFNlcmlhbGl6ZWRDb25uZWN0aW9uIiwiYXRDb25uZWN0aW9uTGVuZ3RoS2VlcEdyYWRpZW50IiwiYXRDb25uZWN0aW9uTGVuZ3RoSWdub3JlR3JhZGllbnQiLCJhdENvbm5lY3Rpb25SYXRpb0tlZXBHcmFkaWVudCIsImF0Q29ubmVjdGlvblJhdGlvSWdub3JlR3JhZGllbnQiLCJmb3JFYWNoIiwic2V0Q2FsY0F0dHJpYnV0ZSIsInJlZlIiLCJyZWZEIiwicmVmUG9pbnRzIiwiYXRDb25uZWN0aW9uTGVuZ3RoIiwiYXRDb25uZWN0aW9uUmF0aW8iLCJzdHJva2VXaWR0aCIsInJlZlgyIiwicmVmWTIiLCJyZWZXaWR0aDIiLCJyZWZIZWlnaHQyIiwiYXR0cmlidXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/attributes/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/attributes/props.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/jointjs/src/dia/attributes/props.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\nconst validPropertiesList = [\n    \"checked\",\n    \"selected\",\n    \"disabled\",\n    \"readOnly\",\n    \"contentEditable\",\n    \"value\",\n    \"indeterminate\"\n];\nconst validProperties = validPropertiesList.reduce((acc, key)=>{\n    acc[key] = true;\n    return acc;\n}, {});\nconst props = {\n    qualify: function(properties) {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(properties);\n    },\n    set: function(properties, _, node) {\n        Object.keys(properties).forEach(function(key) {\n            if (validProperties[key] && key in node) {\n                const value = properties[key];\n                if (node.tagName === \"SELECT\" && Array.isArray(value)) {\n                    Array.from(node.options).forEach(function(option, index) {\n                        option.selected = value.includes(option.value);\n                    });\n                } else {\n                    node[key] = value;\n                }\n            }\n        });\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (props);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL2F0dHJpYnV0ZXMvcHJvcHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EO0FBRXBELE1BQU1DLHNCQUFzQjtJQUFDO0lBQVc7SUFBWTtJQUFZO0lBQVk7SUFBbUI7SUFBUztDQUFnQjtBQUV4SCxNQUFNQyxrQkFBa0JELG9CQUFvQkUsTUFBTSxDQUFDLENBQUNDLEtBQUtDO0lBQ3JERCxHQUFHLENBQUNDLElBQUksR0FBRztJQUNYLE9BQU9EO0FBQ1gsR0FBRyxDQUFDO0FBRUosTUFBTUUsUUFBUTtJQUNWQyxTQUFTLFNBQVNDLFVBQVU7UUFDeEIsT0FBT1IsNkRBQWFBLENBQUNRO0lBQ3pCO0lBQ0FDLEtBQUssU0FBU0QsVUFBVSxFQUFFRSxDQUFDLEVBQUVDLElBQUk7UUFDN0JDLE9BQU9DLElBQUksQ0FBQ0wsWUFBWU0sT0FBTyxDQUFDLFNBQVNULEdBQUc7WUFDeEMsSUFBSUgsZUFBZSxDQUFDRyxJQUFJLElBQUlBLE9BQU9NLE1BQU07Z0JBQ3JDLE1BQU1JLFFBQVFQLFVBQVUsQ0FBQ0gsSUFBSTtnQkFDN0IsSUFBSU0sS0FBS0ssT0FBTyxLQUFLLFlBQVlDLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtvQkFDbkRFLE1BQU1FLElBQUksQ0FBQ1IsS0FBS1MsT0FBTyxFQUFFTixPQUFPLENBQUMsU0FBU08sTUFBTSxFQUFFQyxLQUFLO3dCQUNuREQsT0FBT0UsUUFBUSxHQUFHUixNQUFNUyxRQUFRLENBQUNILE9BQU9OLEtBQUs7b0JBQ2pEO2dCQUNKLE9BQU87b0JBQ0hKLElBQUksQ0FBQ04sSUFBSSxHQUFHVTtnQkFDaEI7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUVBLGlFQUFlVCxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL2F0dHJpYnV0ZXMvcHJvcHMubWpzPzEwNjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuXG5jb25zdCB2YWxpZFByb3BlcnRpZXNMaXN0ID0gWydjaGVja2VkJywgJ3NlbGVjdGVkJywgJ2Rpc2FibGVkJywgJ3JlYWRPbmx5JywgJ2NvbnRlbnRFZGl0YWJsZScsICd2YWx1ZScsICdpbmRldGVybWluYXRlJ107XG5cbmNvbnN0IHZhbGlkUHJvcGVydGllcyA9IHZhbGlkUHJvcGVydGllc0xpc3QucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5jb25zdCBwcm9wcyA9IHtcbiAgICBxdWFsaWZ5OiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihwcm9wZXJ0aWVzLCBfLCBub2RlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAodmFsaWRQcm9wZXJ0aWVzW2tleV0gJiYga2V5IGluIG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKG5vZGUub3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihvcHRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BzO1xuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJ2YWxpZFByb3BlcnRpZXNMaXN0IiwidmFsaWRQcm9wZXJ0aWVzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwicHJvcHMiLCJxdWFsaWZ5IiwicHJvcGVydGllcyIsInNldCIsIl8iLCJub2RlIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJ2YWx1ZSIsInRhZ05hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwib3B0aW9ucyIsIm9wdGlvbiIsImluZGV4Iiwic2VsZWN0ZWQiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/attributes/props.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/dia/ports.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/dia/ports.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   elementPortPrototype: () => (/* binding */ elementPortPrototype),\n/* harmony export */   elementViewPortPrototype: () => (/* binding */ elementViewPortPrototype)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/ports/port.mjs */ \"(ssr)/./node_modules/jointjs/src/layout/ports/port.mjs\");\n/* harmony import */ var _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/ports/portLabel.mjs */ \"(ssr)/./node_modules/jointjs/src/layout/ports/portLabel.mjs\");\n\n\n\n\n\nvar PortData = function(data) {\n    var clonedData = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(data) || {};\n    this.ports = [];\n    this.groups = {};\n    this.portLayoutNamespace = _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__;\n    this.portLabelLayoutNamespace = _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__;\n    this._init(clonedData);\n};\nPortData.prototype = {\n    getPorts: function() {\n        return this.ports;\n    },\n    getGroup: function(name) {\n        return this.groups[name] || {};\n    },\n    getPortsByGroup: function(groupName) {\n        return this.ports.filter(function(port) {\n            return port.group === groupName;\n        });\n    },\n    getGroupPortsMetrics: function(groupName, elBBox) {\n        var group = this.getGroup(groupName);\n        var ports = this.getPortsByGroup(groupName);\n        var groupPosition = group.position || {};\n        var groupPositionName = groupPosition.name;\n        var namespace = this.portLayoutNamespace;\n        if (!namespace[groupPositionName]) {\n            groupPositionName = \"left\";\n        }\n        var groupArgs = groupPosition.args || {};\n        var portsArgs = ports.map(function(port) {\n            return port && port.position && port.position.args;\n        });\n        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n        var accumulator = {\n            ports: ports,\n            result: []\n        };\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(groupPortTransformations).reduce((function(res, portTransformation, index) {\n            var port = res.ports[index];\n            res.result.push({\n                portId: port.id,\n                portTransformation: portTransformation,\n                labelTransformation: this._getPortLabelLayout(port, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point)(portTransformation), elBBox),\n                portAttrs: port.attrs,\n                portSize: port.size,\n                labelSize: port.label.size\n            });\n            return res;\n        }).bind(this), accumulator);\n        return accumulator.result;\n    },\n    _getPortLabelLayout: function(port, portPosition, elBBox) {\n        var namespace = this.portLabelLayoutNamespace;\n        var labelPosition = port.label.position.name || \"left\";\n        if (namespace[labelPosition]) {\n            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n        }\n        return null;\n    },\n    _init: function(data) {\n        // prepare groups\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(data.groups)) {\n            var groups = Object.keys(data.groups);\n            for(var i = 0, n = groups.length; i < n; i++){\n                var key = groups[i];\n                this.groups[key] = this._evaluateGroup(data.groups[key]);\n            }\n        }\n        // prepare ports\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(data.items);\n        for(var j = 0, m = ports.length; j < m; j++){\n            this.ports.push(this._evaluatePort(ports[j]));\n        }\n    },\n    _evaluateGroup: function(group) {\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge(group, {\n            position: this._getPosition(group.position, true),\n            label: this._getLabel(group, true)\n        });\n    },\n    _evaluatePort: function(port) {\n        var evaluated = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, port);\n        var group = this.getGroup(port.group);\n        evaluated.markup = evaluated.markup || group.markup;\n        evaluated.attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.attrs, evaluated.attrs);\n        evaluated.position = this._createPositionNode(group, evaluated);\n        evaluated.label = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.label, this._getLabel(evaluated));\n        evaluated.z = this._getZIndex(group, evaluated);\n        evaluated.size = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, group.size, evaluated.size);\n        return evaluated;\n    },\n    _getZIndex: function(group, port) {\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(port.z)) {\n            return port.z;\n        }\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(group.z) || group.z === \"auto\") {\n            return group.z;\n        }\n        return \"auto\";\n    },\n    _createPositionNode: function(group, port) {\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({\n            name: \"left\",\n            args: {}\n        }, group.position, {\n            args: port.args\n        });\n    },\n    _getPosition: function(position, setDefault) {\n        var args = {};\n        var positionName;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(position)) {\n            positionName = \"fn\";\n            args.fn = position;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(position)) {\n            positionName = position;\n        } else if (position === undefined) {\n            positionName = setDefault ? \"left\" : null;\n        } else if (Array.isArray(position)) {\n            positionName = \"absolute\";\n            args.x = position[0];\n            args.y = position[1];\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(position)) {\n            positionName = position.name;\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign(args, position.args);\n        }\n        var result = {\n            args: args\n        };\n        if (positionName) {\n            result.name = positionName;\n        }\n        return result;\n    },\n    _getLabel: function(item, setDefaults) {\n        var label = item.label || {};\n        var ret = label;\n        ret.position = this._getPosition(label.position, setDefaults);\n        return ret;\n    }\n};\nconst elementPortPrototype = {\n    _initializePorts: function() {\n        this._createPortData();\n        this.on(\"change:ports\", function() {\n            this._processRemovedPort();\n            this._createPortData();\n        }, this);\n    },\n    /**\n     * remove links tied wiht just removed element\n     * @private\n     */ _processRemovedPort: function() {\n        var current = this.get(\"ports\") || {};\n        var currentItemsMap = {};\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(current.items).forEach(function(item) {\n            currentItemsMap[item.id] = true;\n        });\n        var previous = this.previous(\"ports\") || {};\n        var removed = {};\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(previous.items).forEach(function(item) {\n            if (!currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n        var graph = this.graph;\n        if (graph && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty(removed)) {\n            var inboundLinks = graph.getConnectedLinks(this, {\n                inbound: true\n            });\n            inboundLinks.forEach(function(link) {\n                if (removed[link.get(\"target\").port]) link.remove();\n            });\n            var outboundLinks = graph.getConnectedLinks(this, {\n                outbound: true\n            });\n            outboundLinks.forEach(function(link) {\n                if (removed[link.get(\"source\").port]) link.remove();\n            });\n        }\n    },\n    /**\n     * @returns {boolean}\n     */ hasPorts: function() {\n        var ports = this.prop(\"ports/items\");\n        return Array.isArray(ports) && ports.length > 0;\n    },\n    /**\n     * @param {string} id\n     * @returns {boolean}\n     */ hasPort: function(id) {\n        return this.getPortIndex(id) !== -1;\n    },\n    /**\n     * @returns {Array<object>}\n     */ getPorts: function() {\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(this.prop(\"ports/items\")) || [];\n    },\n    /**\n     * @returns {Array<object>}\n     */ getGroupPorts: function(groupName) {\n        const groupPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop([\n            \"ports\",\n            \"items\"\n        ])).filter((port)=>port.group === groupName);\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(groupPorts);\n    },\n    /**\n     * @param {string} id\n     * @returns {object}\n     */ getPort: function(id) {\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop(\"ports/items\")).find(function(port) {\n            return port.id && port.id === id;\n        }));\n    },\n    /**\n     * @param {string} groupName\n     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n     */ getPortsPositions: function(groupName) {\n        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.size()));\n        return portsMetrics.reduce(function(positions, metrics) {\n            var transformation = metrics.portTransformation;\n            positions[metrics.portId] = {\n                x: transformation.x,\n                y: transformation.y,\n                angle: transformation.angle\n            };\n            return positions;\n        }, {});\n    },\n    /**\n     * @param {string|Port} port port id or port\n     * @returns {number} port index\n     */ getPortIndex: function(port) {\n        var id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) ? port.id : port;\n        if (!this._isValidPortId(id)) {\n            return -1;\n        }\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop(\"ports/items\")).findIndex(function(item) {\n            return item.id === id;\n        });\n    },\n    /**\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */ addPort: function(port, opt) {\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error(\"Element: addPort requires an object.\");\n        }\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(\"ports/items\"));\n        ports.push(port);\n        this.prop(\"ports/items\", ports, opt);\n        return this;\n    },\n    /**\n     * @param {string|Port|number} before\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */ insertPort: function(before, port, opt) {\n        const index = typeof before === \"number\" ? before : this.getPortIndex(before);\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error(\"dia.Element: insertPort requires an object.\");\n        }\n        const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(\"ports/items\"));\n        ports.splice(index, 0, port);\n        this.prop(\"ports/items\", ports, opt);\n        return this;\n    },\n    /**\n     * @param {string} portId\n     * @param {string|object=} path\n     * @param {*=} value\n     * @param {object=} opt\n     * @returns {joint.dia.Element}\n     */ portProp: function(portId, path, value, opt) {\n        var index = this.getPortIndex(portId);\n        if (index === -1) {\n            throw new Error(\"Element: unable to find port with id \" + portId);\n        }\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (Array.isArray(path)) {\n            args[0] = [\n                \"ports\",\n                \"items\",\n                index\n            ].concat(path);\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(path)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = [\n                \"ports/items/\",\n                index,\n                \"/\",\n                path\n            ].join(\"\");\n        } else {\n            args = [\n                \"ports/items/\" + index\n            ];\n            if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(path)) {\n                args.push(path);\n                args.push(value);\n            }\n        }\n        return this.prop.apply(this, args);\n    },\n    _validatePorts: function() {\n        var portsAttr = this.get(\"ports\") || {};\n        var errorMessages = [];\n        portsAttr = portsAttr || {};\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsAttr.items);\n        ports.forEach(function(p) {\n            if (typeof p !== \"object\") {\n                errorMessages.push(\"Element: invalid port \", p);\n            }\n            if (!this._isValidPortId(p.id)) {\n                p.id = this.generatePortId();\n            }\n        }, this);\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq(ports, \"id\").length !== ports.length) {\n            errorMessages.push(\"Element: found id duplicities in ports.\");\n        }\n        return errorMessages;\n    },\n    generatePortId: function() {\n        return this.generateId();\n    },\n    /**\n     * @param {string} id port id\n     * @returns {boolean}\n     * @private\n     */ _isValidPortId: function(id) {\n        return id !== null && id !== undefined && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(id);\n    },\n    addPorts: function(ports, opt) {\n        if (ports.length) {\n            this.prop(\"ports/items\", _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(\"ports/items\")).concat(ports), opt);\n        }\n        return this;\n    },\n    removePort: function(port, opt) {\n        const options = opt || {};\n        const index = this.getPortIndex(port);\n        if (index !== -1) {\n            const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop([\n                \"ports\",\n                \"items\"\n            ]));\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.startBatch(\"port-remove\");\n            this.prop([\n                \"ports\",\n                \"items\"\n            ], ports, options);\n            this.stopBatch(\"port-remove\");\n        }\n        return this;\n    },\n    removePorts: function(portsForRemoval, opt) {\n        let options, newPorts;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length === 0) return this.this;\n            const currentPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop([\n                \"ports\",\n                \"items\"\n            ]));\n            newPorts = currentPorts.filter(function(cp) {\n                return !portsForRemoval.some(function(rp) {\n                    const rpId = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(rp) ? rp.id : rp;\n                    return cp.id === rpId;\n                });\n            });\n        } else {\n            options = portsForRemoval || {};\n            newPorts = [];\n        }\n        this.startBatch(\"port-remove\");\n        options.rewrite = true;\n        this.prop([\n            \"ports\",\n            \"items\"\n        ], newPorts, options);\n        this.stopBatch(\"port-remove\");\n        return this;\n    },\n    /**\n     * @private\n     */ _createPortData: function() {\n        var err = this._validatePorts();\n        if (err.length > 0) {\n            this.set(\"ports\", this.previous(\"ports\"));\n            throw new Error(err.join(\" \"));\n        }\n        var prevPortData;\n        if (this._portSettingsData) {\n            prevPortData = this._portSettingsData.getPorts();\n        }\n        this._portSettingsData = new PortData(this.get(\"ports\"));\n        var curPortData = this._portSettingsData.getPorts();\n        if (prevPortData) {\n            var added = curPortData.filter(function(item) {\n                if (!prevPortData.find(function(prevPort) {\n                    return prevPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n            var removed = prevPortData.filter(function(item) {\n                if (!curPortData.find(function(curPort) {\n                    return curPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n            if (removed.length > 0) {\n                this.trigger(\"ports:remove\", this, removed);\n            }\n            if (added.length > 0) {\n                this.trigger(\"ports:add\", this, added);\n            }\n        }\n    }\n};\nconst elementViewPortPrototype = {\n    portContainerMarkup: \"g\",\n    portMarkup: [\n        {\n            tagName: \"circle\",\n            selector: \"circle\",\n            attributes: {\n                \"r\": 10,\n                \"fill\": \"#FFFFFF\",\n                \"stroke\": \"#000000\"\n            }\n        }\n    ],\n    portLabelMarkup: [\n        {\n            tagName: \"text\",\n            selector: \"text\",\n            attributes: {\n                \"fill\": \"#000000\"\n            }\n        }\n    ],\n    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */ _portElementsCache: null,\n    /**\n     * @private\n     */ _initializePorts: function() {\n        this._cleanPortsCache();\n    },\n    /**\n     * @typedef {Object} Port\n     *\n     * @property {string} id\n     * @property {Object} position\n     * @property {Object} label\n     * @property {Object} attrs\n     * @property {string} markup\n     * @property {string} group\n     */ /**\n     * @private\n     */ _refreshPorts: function() {\n        this._removePorts();\n        this._cleanPortsCache();\n        this._renderPorts();\n    },\n    _cleanPortsCache: function() {\n        this._portElementsCache = {};\n    },\n    /**\n     * @private\n     */ _renderPorts: function() {\n        // references to rendered elements without z-index\n        var elementReferences = [];\n        var elem = this._getContainerElement();\n        for(var i = 0, count = elem.node.childNodes.length; i < count; i++){\n            elementReferences.push(elem.node.childNodes[i]);\n        }\n        var portsGropsByZ = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.groupBy(this.model._portSettingsData.getPorts(), \"z\");\n        var withoutZKey = \"auto\";\n        // render non-z first\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n            var portElement = this._getPortElement(port);\n            elem.append(portElement);\n            elementReferences.push(portElement);\n        }, this);\n        var groupNames = Object.keys(portsGropsByZ);\n        for(var k = 0; k < groupNames.length; k++){\n            var groupName = groupNames[k];\n            if (groupName !== withoutZKey) {\n                var z = parseInt(groupName, 10);\n                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n            }\n        }\n        this._updatePorts();\n    },\n    /**\n     * @returns {V}\n     * @private\n     */ _getContainerElement: function() {\n        return this.rotatableNode || this.vel;\n    },\n    /**\n     * @param {Array<Port>}ports\n     * @param {number} z\n     * @param refs\n     * @private\n     */ _appendPorts: function(ports, z, refs) {\n        var containerElement = this._getContainerElement();\n        var portElements = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(ports).map(this._getPortElement, this);\n        if (refs[z] || z < 0) {\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(refs[Math.max(z, 0)]).before(portElements);\n        } else {\n            containerElement.append(portElements);\n        }\n    },\n    /**\n     * Try to get element from cache,\n     * @param port\n     * @returns {*}\n     * @private\n     */ _getPortElement: function(port) {\n        if (this._portElementsCache[port.id]) {\n            return this._portElementsCache[port.id].portElement;\n        }\n        return this._createPortElement(port);\n    },\n    findPortNode: function(portId, selector) {\n        const portCache = this._portElementsCache[portId];\n        if (!portCache) return null;\n        if (!selector) return portCache.portContentElement.node;\n        const portRoot = portCache.portElement.node;\n        const portSelectors = portCache.portSelectors;\n        const [node = null] = this.findBySelector(selector, portRoot, portSelectors);\n        return node;\n    },\n    /**\n     * @private\n     */ _updatePorts: function() {\n        // layout ports without group\n        this._updatePortGroup(undefined);\n        // layout ports with explicit group\n        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n        groupsNames.forEach(this._updatePortGroup, this);\n    },\n    /**\n     * @private\n     */ _removePorts: function() {\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.invoke(this._portElementsCache, \"portElement.remove\");\n    },\n    /**\n     * @param {Port} port\n     * @returns {V}\n     * @private\n     */ _createPortElement: function(port) {\n        let portElement;\n        let labelElement;\n        let labelSelectors;\n        let portSelectors;\n        var portContainerElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.portContainerMarkup).addClass(\"joint-port\");\n        var portMarkup = this._getPortMarkup(port);\n        if (Array.isArray(portMarkup)) {\n            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n            var portFragment = portDoc.fragment;\n            if (portFragment.childNodes.length > 1) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"g\").append(portFragment);\n            } else {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portFragment.firstChild);\n            }\n            portSelectors = portDoc.selectors;\n        } else {\n            portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portMarkup);\n            if (Array.isArray(portElement)) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"g\").append(portElement);\n            }\n        }\n        if (!portElement) {\n            throw new Error(\"ElementView: Invalid port markup.\");\n        }\n        portElement.attr({\n            \"port\": port.id,\n            \"port-group\": port.group\n        });\n        const labelMarkupDef = this._getPortLabelMarkup(port.label);\n        if (Array.isArray(labelMarkupDef)) {\n            // JSON Markup\n            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n            const childCount = fragment.childNodes.length;\n            if (childCount > 0) {\n                labelSelectors = selectors;\n                labelElement = childCount === 1 ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fragment.firstChild) : (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"g\").append(fragment);\n            }\n        } else {\n            // String Markup\n            labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(labelMarkupDef);\n            if (Array.isArray(labelElement)) {\n                labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"g\").append(labelElement);\n            }\n        }\n        var portContainerSelectors;\n        if (portSelectors && labelSelectors) {\n            for(var key in labelSelectors){\n                if (portSelectors[key] && key !== this.selector) throw new Error(\"ElementView: selectors within port must be unique.\");\n            }\n            portContainerSelectors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, portSelectors, labelSelectors);\n        } else {\n            portContainerSelectors = portSelectors || labelSelectors || {};\n        }\n        // The `portRootSelector` points to the root SVGNode of the port.\n        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n        // Or the single SVGNode of the port.\n        const portRootSelector = \"portRoot\";\n        // The `labelRootSelector` points to the root SVGNode of the label.\n        const labelRootSelector = \"labelRoot\";\n        // The `labelTextSelector` points to all text SVGNodes of the label.\n        const labelTextSelector = \"labelText\";\n        if (!(portRootSelector in portContainerSelectors)) {\n            portContainerSelectors[portRootSelector] = portElement.node;\n        }\n        if (labelElement) {\n            const labelNode = labelElement.node;\n            if (!(labelRootSelector in portContainerSelectors)) {\n                portContainerSelectors[labelRootSelector] = labelNode;\n            }\n            if (!(labelTextSelector in portContainerSelectors)) {\n                // If the label is a <text> element, we can use it directly.\n                // Otherwise, we need to find the <text> element within the label.\n                const labelTextNode = labelElement.tagName() === \"TEXT\" ? labelNode : Array.from(labelNode.querySelectorAll(\"text\"));\n                portContainerSelectors[labelTextSelector] = labelTextNode;\n                if (!labelSelectors) labelSelectors = {};\n                labelSelectors[labelTextSelector] = labelTextNode;\n            }\n        }\n        portContainerElement.append(portElement.addClass(\"joint-port-body\"));\n        if (labelElement) {\n            portContainerElement.append(labelElement.addClass(\"joint-port-label\"));\n        }\n        this._portElementsCache[port.id] = {\n            portElement: portContainerElement,\n            portLabelElement: labelElement,\n            portSelectors: portContainerSelectors,\n            portLabelSelectors: labelSelectors,\n            portContentElement: portElement,\n            portContentSelectors: portSelectors\n        };\n        return portContainerElement;\n    },\n    /**\n     * @param {string=} groupName\n     * @private\n     */ _updatePortGroup: function(groupName) {\n        var elementBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.model.size());\n        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n        for(var i = 0, n = portsMetrics.length; i < n; i++){\n            var metrics = portsMetrics[i];\n            var portId = metrics.portId;\n            var cached = this._portElementsCache[portId] || {};\n            var portTransformation = metrics.portTransformation;\n            var labelTransformation = metrics.labelTransformation;\n            if (labelTransformation && cached.portLabelElement) {\n                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                    rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.labelSize),\n                    selectors: cached.portLabelSelectors\n                });\n                this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);\n            }\n            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.portSize),\n                selectors: cached.portSelectors\n            });\n            this.applyPortTransform(cached.portElement, portTransformation);\n        }\n    },\n    /**\n     * @param {Vectorizer} element\n     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n     * @param {number=} initialAngle\n     * @constructor\n     */ applyPortTransform: function(element, transformData, initialAngle) {\n        var matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);\n        element.transform(matrix, {\n            absolute: true\n        });\n    },\n    /**\n     * @param {Port} port\n     * @returns {string}\n     * @private\n     */ _getPortMarkup: function(port) {\n        return port.markup || this.model.get(\"portMarkup\") || this.model.portMarkup || this.portMarkup;\n    },\n    /**\n     * @param {Object} label\n     * @returns {string}\n     * @private\n     */ _getPortLabelMarkup: function(label) {\n        return label.markup || this.model.get(\"portLabelMarkup\") || this.model.portLabelMarkup || this.portLabelMarkup;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZGlhL3BvcnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwQztBQUNYO0FBQ2M7QUFDSTtBQUNVO0FBRTNELElBQUlNLFdBQVcsU0FBU0MsSUFBSTtJQUV4QixJQUFJQyxhQUFhUixzREFBYyxDQUFDTyxTQUFTLENBQUM7SUFDMUMsSUFBSSxDQUFDRyxLQUFLLEdBQUcsRUFBRTtJQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7SUFDZixJQUFJLENBQUNDLG1CQUFtQixHQUFHUixtREFBSUE7SUFDL0IsSUFBSSxDQUFDUyx3QkFBd0IsR0FBR1Isd0RBQVNBO0lBRXpDLElBQUksQ0FBQ1MsS0FBSyxDQUFDTjtBQUNmO0FBRUFGLFNBQVNTLFNBQVMsR0FBRztJQUVqQkMsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDTixLQUFLO0lBQ3JCO0lBRUFPLFVBQVUsU0FBU0MsSUFBSTtRQUNuQixPQUFPLElBQUksQ0FBQ1AsTUFBTSxDQUFDTyxLQUFLLElBQUksQ0FBQztJQUNqQztJQUVBQyxpQkFBaUIsU0FBU0MsU0FBUztRQUUvQixPQUFPLElBQUksQ0FBQ1YsS0FBSyxDQUFDVyxNQUFNLENBQUMsU0FBU0MsSUFBSTtZQUNsQyxPQUFPQSxLQUFLQyxLQUFLLEtBQUtIO1FBQzFCO0lBQ0o7SUFFQUksc0JBQXNCLFNBQVNKLFNBQVMsRUFBRUssTUFBTTtRQUU1QyxJQUFJRixRQUFRLElBQUksQ0FBQ04sUUFBUSxDQUFDRztRQUMxQixJQUFJVixRQUFRLElBQUksQ0FBQ1MsZUFBZSxDQUFDQztRQUVqQyxJQUFJTSxnQkFBZ0JILE1BQU1JLFFBQVEsSUFBSSxDQUFDO1FBQ3ZDLElBQUlDLG9CQUFvQkYsY0FBY1IsSUFBSTtRQUMxQyxJQUFJVyxZQUFZLElBQUksQ0FBQ2pCLG1CQUFtQjtRQUN4QyxJQUFJLENBQUNpQixTQUFTLENBQUNELGtCQUFrQixFQUFFO1lBQy9CQSxvQkFBb0I7UUFDeEI7UUFF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QUFHLENBQUMsaUJBQWlCLElBQUksQ0FBQ2lHLEtBQUssQ0FBQ2xCLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVU7SUFDbEc7SUFFQTs7OztLQUlDLEdBQ0QwRCxxQkFBcUIsU0FBU3RMLEtBQUs7UUFFL0IsT0FBT0EsTUFBTXFCLE1BQU0sSUFBSSxJQUFJLENBQUN5SCxLQUFLLENBQUNqRyxHQUFHLENBQUMsc0JBQXNCLElBQUksQ0FBQ2lHLEtBQUssQ0FBQ2QsZUFBZSxJQUFJLElBQUksQ0FBQ0EsZUFBZTtJQUNsSDtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9kaWEvcG9ydHMubWpzP2VmNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0LCBQb2ludCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIFBvcnQgZnJvbSAnLi4vbGF5b3V0L3BvcnRzL3BvcnQubWpzJztcbmltcG9ydCAqIGFzIFBvcnRMYWJlbCBmcm9tICcuLi9sYXlvdXQvcG9ydHMvcG9ydExhYmVsLm1qcyc7XG5cbnZhciBQb3J0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBjbG9uZWREYXRhID0gdXRpbC5jbG9uZURlZXAoZGF0YSkgfHwge307XG4gICAgdGhpcy5wb3J0cyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5wb3J0TGF5b3V0TmFtZXNwYWNlID0gUG9ydDtcbiAgICB0aGlzLnBvcnRMYWJlbExheW91dE5hbWVzcGFjZSA9IFBvcnRMYWJlbDtcblxuICAgIHRoaXMuX2luaXQoY2xvbmVkRGF0YSk7XG59O1xuXG5Qb3J0RGF0YS5wcm90b3R5cGUgPSB7XG5cbiAgICBnZXRQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnRzO1xuICAgIH0sXG5cbiAgICBnZXRHcm91cDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbbmFtZV0gfHwge307XG4gICAgfSxcblxuICAgIGdldFBvcnRzQnlHcm91cDogZnVuY3Rpb24oZ3JvdXBOYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9ydHMuZmlsdGVyKGZ1bmN0aW9uKHBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3J0Lmdyb3VwID09PSBncm91cE5hbWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRHcm91cFBvcnRzTWV0cmljczogZnVuY3Rpb24oZ3JvdXBOYW1lLCBlbEJCb3gpIHtcblxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwTmFtZSk7XG4gICAgICAgIHZhciBwb3J0cyA9IHRoaXMuZ2V0UG9ydHNCeUdyb3VwKGdyb3VwTmFtZSk7XG5cbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSBncm91cC5wb3NpdGlvbiB8fCB7fTtcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25OYW1lID0gZ3JvdXBQb3NpdGlvbi5uYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5wb3J0TGF5b3V0TmFtZXNwYWNlO1xuICAgICAgICBpZiAoIW5hbWVzcGFjZVtncm91cFBvc2l0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25OYW1lID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwQXJncyA9IGdyb3VwUG9zaXRpb24uYXJncyB8fCB7fTtcbiAgICAgICAgdmFyIHBvcnRzQXJncyA9IHBvcnRzLm1hcChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9ydCAmJiBwb3J0LnBvc2l0aW9uICYmIHBvcnQucG9zaXRpb24uYXJncztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBncm91cFBvcnRUcmFuc2Zvcm1hdGlvbnMgPSBuYW1lc3BhY2VbZ3JvdXBQb3NpdGlvbk5hbWVdKHBvcnRzQXJncywgZWxCQm94LCBncm91cEFyZ3MpO1xuXG4gICAgICAgIHZhciBhY2N1bXVsYXRvciA9IHtcbiAgICAgICAgICAgIHBvcnRzOiBwb3J0cyxcbiAgICAgICAgICAgIHJlc3VsdDogW11cbiAgICAgICAgfTtcblxuICAgICAgICB1dGlsLnRvQXJyYXkoZ3JvdXBQb3J0VHJhbnNmb3JtYXRpb25zKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBwb3J0VHJhbnNmb3JtYXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcG9ydCA9IHJlcy5wb3J0c1tpbmRleF07XG4gICAgICAgICAgICByZXMucmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHBvcnRJZDogcG9ydC5pZCxcbiAgICAgICAgICAgICAgICBwb3J0VHJhbnNmb3JtYXRpb246IHBvcnRUcmFuc2Zvcm1hdGlvbixcbiAgICAgICAgICAgICAgICBsYWJlbFRyYW5zZm9ybWF0aW9uOiB0aGlzLl9nZXRQb3J0TGFiZWxMYXlvdXQocG9ydCwgUG9pbnQocG9ydFRyYW5zZm9ybWF0aW9uKSwgZWxCQm94KSxcbiAgICAgICAgICAgICAgICBwb3J0QXR0cnM6IHBvcnQuYXR0cnMsXG4gICAgICAgICAgICAgICAgcG9ydFNpemU6IHBvcnQuc2l6ZSxcbiAgICAgICAgICAgICAgICBsYWJlbFNpemU6IHBvcnQubGFiZWwuc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LmJpbmQodGhpcyksIGFjY3VtdWxhdG9yKTtcblxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IucmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZ2V0UG9ydExhYmVsTGF5b3V0OiBmdW5jdGlvbihwb3J0LCBwb3J0UG9zaXRpb24sIGVsQkJveCkge1xuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLnBvcnRMYWJlbExheW91dE5hbWVzcGFjZTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBwb3J0LmxhYmVsLnBvc2l0aW9uLm5hbWUgfHwgJ2xlZnQnO1xuXG4gICAgICAgIGlmIChuYW1lc3BhY2VbbGFiZWxQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VbbGFiZWxQb3NpdGlvbl0ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIHBvcnQubGFiZWwucG9zaXRpb24uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2luaXQ6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBwcmVwYXJlIGdyb3Vwc1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChkYXRhLmdyb3VwcykpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBPYmplY3Qua2V5cyhkYXRhLmdyb3Vwcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2tleV0gPSB0aGlzLl9ldmFsdWF0ZUdyb3VwKGRhdGEuZ3JvdXBzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSBwb3J0c1xuICAgICAgICB2YXIgcG9ydHMgPSB1dGlsLnRvQXJyYXkoZGF0YS5pdGVtcyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcG9ydHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLnBvcnRzLnB1c2godGhpcy5fZXZhbHVhdGVQb3J0KHBvcnRzW2pdKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2V2YWx1YXRlR3JvdXA6IGZ1bmN0aW9uKGdyb3VwKSB7XG5cbiAgICAgICAgcmV0dXJuIHV0aWwubWVyZ2UoZ3JvdXAsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLl9nZXRQb3NpdGlvbihncm91cC5wb3NpdGlvbiwgdHJ1ZSksXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5fZ2V0TGFiZWwoZ3JvdXAsIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZXZhbHVhdGVQb3J0OiBmdW5jdGlvbihwb3J0KSB7XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IHV0aWwuYXNzaWduKHt9LCBwb3J0KTtcblxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKHBvcnQuZ3JvdXApO1xuXG4gICAgICAgIGV2YWx1YXRlZC5tYXJrdXAgPSBldmFsdWF0ZWQubWFya3VwIHx8IGdyb3VwLm1hcmt1cDtcbiAgICAgICAgZXZhbHVhdGVkLmF0dHJzID0gdXRpbC5tZXJnZSh7fSwgZ3JvdXAuYXR0cnMsIGV2YWx1YXRlZC5hdHRycyk7XG4gICAgICAgIGV2YWx1YXRlZC5wb3NpdGlvbiA9IHRoaXMuX2NyZWF0ZVBvc2l0aW9uTm9kZShncm91cCwgZXZhbHVhdGVkKTtcbiAgICAgICAgZXZhbHVhdGVkLmxhYmVsID0gdXRpbC5tZXJnZSh7fSwgZ3JvdXAubGFiZWwsIHRoaXMuX2dldExhYmVsKGV2YWx1YXRlZCkpO1xuICAgICAgICBldmFsdWF0ZWQueiA9IHRoaXMuX2dldFpJbmRleChncm91cCwgZXZhbHVhdGVkKTtcbiAgICAgICAgZXZhbHVhdGVkLnNpemUgPSB1dGlsLmFzc2lnbih7fSwgZ3JvdXAuc2l6ZSwgZXZhbHVhdGVkLnNpemUpO1xuXG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQ7XG4gICAgfSxcblxuICAgIF9nZXRaSW5kZXg6IGZ1bmN0aW9uKGdyb3VwLCBwb3J0KSB7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNOdW1iZXIocG9ydC56KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQuejtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5pc051bWJlcihncm91cC56KSB8fCBncm91cC56ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cC56O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnYXV0byc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb3NpdGlvbk5vZGU6IGZ1bmN0aW9uKGdyb3VwLCBwb3J0KSB7XG5cbiAgICAgICAgcmV0dXJuIHV0aWwubWVyZ2Uoe1xuICAgICAgICAgICAgbmFtZTogJ2xlZnQnLFxuICAgICAgICAgICAgYXJnczoge31cbiAgICAgICAgfSwgZ3JvdXAucG9zaXRpb24sIHsgYXJnczogcG9ydC5hcmdzIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBzZXREZWZhdWx0KSB7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSB7fTtcbiAgICAgICAgdmFyIHBvc2l0aW9uTmFtZTtcblxuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gJ2ZuJztcbiAgICAgICAgICAgIGFyZ3MuZm4gPSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyaW5nKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gc2V0RGVmYXVsdCA/ICdsZWZ0JyA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTmFtZSA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBhcmdzLnggPSBwb3NpdGlvblswXTtcbiAgICAgICAgICAgIGFyZ3MueSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk5hbWUgPSBwb3NpdGlvbi5uYW1lO1xuICAgICAgICAgICAgdXRpbC5hc3NpZ24oYXJncywgcG9zaXRpb24uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0geyBhcmdzOiBhcmdzIH07XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBwb3NpdGlvbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsOiBmdW5jdGlvbihpdGVtLCBzZXREZWZhdWx0cykge1xuXG4gICAgICAgIHZhciBsYWJlbCA9IGl0ZW0ubGFiZWwgfHwge307XG5cbiAgICAgICAgdmFyIHJldCA9IGxhYmVsO1xuICAgICAgICByZXQucG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihsYWJlbC5wb3NpdGlvbiwgc2V0RGVmYXVsdHMpO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVsZW1lbnRQb3J0UHJvdG90eXBlID0ge1xuXG4gICAgX2luaXRpYWxpemVQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlUG9ydERhdGEoKTtcbiAgICAgICAgdGhpcy5vbignY2hhbmdlOnBvcnRzJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NSZW1vdmVkUG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUG9ydERhdGEoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBsaW5rcyB0aWVkIHdpaHQganVzdCByZW1vdmVkIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzUmVtb3ZlZFBvcnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXQoJ3BvcnRzJykgfHwge307XG4gICAgICAgIHZhciBjdXJyZW50SXRlbXNNYXAgPSB7fTtcblxuICAgICAgICB1dGlsLnRvQXJyYXkoY3VycmVudC5pdGVtcykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBjdXJyZW50SXRlbXNNYXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzKCdwb3J0cycpIHx8IHt9O1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHt9O1xuXG4gICAgICAgIHV0aWwudG9BcnJheShwcmV2aW91cy5pdGVtcykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRJdGVtc01hcFtpdGVtLmlkXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICBpZiAoZ3JhcGggJiYgIXV0aWwuaXNFbXB0eShyZW1vdmVkKSkge1xuXG4gICAgICAgICAgICB2YXIgaW5ib3VuZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBpbmJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgaW5ib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbbGluay5nZXQoJ3RhcmdldCcpLnBvcnRdKSBsaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvdXRib3VuZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBvdXRib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG91dGJvdW5kTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFtsaW5rLmdldCgnc291cmNlJykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvcnRzID0gdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwb3J0cykgJiYgcG9ydHMubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUG9ydDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb3J0SW5kZXgoaWQpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PG9iamVjdD59XG4gICAgICovXG4gICAgZ2V0UG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB1dGlsLmNsb25lRGVlcCh0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpIHx8IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8b2JqZWN0Pn1cbiAgICAgKi9cbiAgICBnZXRHcm91cFBvcnRzOiBmdW5jdGlvbihncm91cE5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBQb3J0cyA9IHV0aWwudG9BcnJheSh0aGlzLnByb3AoWydwb3J0cycsJ2l0ZW1zJ10pKS5maWx0ZXIocG9ydCA9PiBwb3J0Lmdyb3VwID09PSBncm91cE5hbWUpO1xuICAgICAgICByZXR1cm4gdXRpbC5jbG9uZURlZXAoZ3JvdXBQb3J0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0UG9ydDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdXRpbC5jbG9uZURlZXAodXRpbC50b0FycmF5KHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSkuZmluZChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9ydC5pZCAmJiBwb3J0LmlkID09PSBpZDtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lXG4gICAgICogQHJldHVybnMge09iamVjdDxwb3J0SWQsIHt4OiBudW1iZXIsIHk6IG51bWJlciwgYW5nbGU6IG51bWJlcn0+fVxuICAgICAqL1xuICAgIGdldFBvcnRzUG9zaXRpb25zOiBmdW5jdGlvbihncm91cE5hbWUpIHtcblxuICAgICAgICB2YXIgcG9ydHNNZXRyaWNzID0gdGhpcy5fcG9ydFNldHRpbmdzRGF0YS5nZXRHcm91cFBvcnRzTWV0cmljcyhncm91cE5hbWUsIFJlY3QodGhpcy5zaXplKCkpKTtcblxuICAgICAgICByZXR1cm4gcG9ydHNNZXRyaWNzLnJlZHVjZShmdW5jdGlvbihwb3NpdGlvbnMsIG1ldHJpY3MpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG1ldHJpY3MucG9ydFRyYW5zZm9ybWF0aW9uO1xuICAgICAgICAgICAgcG9zaXRpb25zW21ldHJpY3MucG9ydElkXSA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1hdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybWF0aW9uLnksXG4gICAgICAgICAgICAgICAgYW5nbGU6IHRyYW5zZm9ybWF0aW9uLmFuZ2xlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICAgICAgfSwge30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQb3J0fSBwb3J0IHBvcnQgaWQgb3IgcG9ydFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvcnQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRQb3J0SW5kZXg6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICB2YXIgaWQgPSB1dGlsLmlzT2JqZWN0KHBvcnQpID8gcG9ydC5pZCA6IHBvcnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkUG9ydElkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwudG9BcnJheSh0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9ydFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0XVxuICAgICAqIEByZXR1cm5zIHtqb2ludC5kaWEuRWxlbWVudH1cbiAgICAgKi9cbiAgICBhZGRQb3J0OiBmdW5jdGlvbihwb3J0LCBvcHQpIHtcblxuICAgICAgICBpZiAoIXV0aWwuaXNPYmplY3QocG9ydCkgfHwgQXJyYXkuaXNBcnJheShwb3J0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50OiBhZGRQb3J0IHJlcXVpcmVzIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3J0cyA9IHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpO1xuICAgICAgICBwb3J0cy5wdXNoKHBvcnQpO1xuICAgICAgICB0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJywgcG9ydHMsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFBvcnR8bnVtYmVyfSBiZWZvcmVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9ydFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0XVxuICAgICAqIEByZXR1cm5zIHtqb2ludC5kaWEuRWxlbWVudH1cbiAgICAgKi9cbiAgICBpbnNlcnRQb3J0OiBmdW5jdGlvbihiZWZvcmUsIHBvcnQsIG9wdCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICh0eXBlb2YgYmVmb3JlID09PSAnbnVtYmVyJykgPyBiZWZvcmUgOiB0aGlzLmdldFBvcnRJbmRleChiZWZvcmUpO1xuXG4gICAgICAgIGlmICghdXRpbC5pc09iamVjdChwb3J0KSB8fCBBcnJheS5pc0FycmF5KHBvcnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5FbGVtZW50OiBpbnNlcnRQb3J0IHJlcXVpcmVzIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcnRzID0gdXRpbC5hc3NpZ24oW10sIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSk7XG4gICAgICAgIHBvcnRzLnNwbGljZShpbmRleCwgMCwgcG9ydCk7XG4gICAgICAgIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnLCBwb3J0cywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvcnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdD19IHBhdGhcbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0XG4gICAgICogQHJldHVybnMge2pvaW50LmRpYS5FbGVtZW50fVxuICAgICAqL1xuICAgIHBvcnRQcm9wOiBmdW5jdGlvbihwb3J0SWQsIHBhdGgsIHZhbHVlLCBvcHQpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldFBvcnRJbmRleChwb3J0SWQpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudDogdW5hYmxlIHRvIGZpbmQgcG9ydCB3aXRoIGlkICcgKyBwb3J0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgYXJnc1swXSA9IFsncG9ydHMnLCAnaXRlbXMnLCBpbmRleF0uY29uY2F0KHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpIHtcblxuICAgICAgICAgICAgLy8gR2V0L3NldCBhbiBhdHRyaWJ1dGUgYnkgYSBzcGVjaWFsIHBhdGggc3ludGF4IHRoYXQgZGVsaW1pdHNcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzIGJ5IHRoZSBjb2xvbiBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBhcmdzWzBdID0gWydwb3J0cy9pdGVtcy8nLCBpbmRleCwgJy8nLCBwYXRoXS5qb2luKCcnKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBhcmdzID0gWydwb3J0cy9pdGVtcy8nICsgaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChwYXRoKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb3J0c0F0dHIgPSB0aGlzLmdldCgncG9ydHMnKSB8fCB7fTtcblxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBwb3J0c0F0dHIgPSBwb3J0c0F0dHIgfHwge307XG4gICAgICAgIHZhciBwb3J0cyA9IHV0aWwudG9BcnJheShwb3J0c0F0dHIuaXRlbXMpO1xuXG4gICAgICAgIHBvcnRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKCdFbGVtZW50OiBpbnZhbGlkIHBvcnQgJywgcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFBvcnRJZChwLmlkKSkge1xuICAgICAgICAgICAgICAgIHAuaWQgPSB0aGlzLmdlbmVyYXRlUG9ydElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICh1dGlsLnVuaXEocG9ydHMsICdpZCcpLmxlbmd0aCAhPT0gcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goJ0VsZW1lbnQ6IGZvdW5kIGlkIGR1cGxpY2l0aWVzIGluIHBvcnRzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZXM7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlUG9ydElkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgcG9ydCBpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzVmFsaWRQb3J0SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNPYmplY3QoaWQpO1xuICAgIH0sXG5cbiAgICBhZGRQb3J0czogZnVuY3Rpb24ocG9ydHMsIG9wdCkge1xuXG4gICAgICAgIGlmIChwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnLCB1dGlsLmFzc2lnbihbXSwgdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpKS5jb25jYXQocG9ydHMpLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVBvcnQ6IGZ1bmN0aW9uKHBvcnQsIG9wdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gb3B0IHx8IHt9O1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UG9ydEluZGV4KHBvcnQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0cyA9IHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoWydwb3J0cycsICdpdGVtcyddKSk7XG4gICAgICAgICAgICBwb3J0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgICAgIHRoaXMucHJvcChbJ3BvcnRzJywgJ2l0ZW1zJ10sIHBvcnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCdwb3J0LXJlbW92ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVQb3J0czogZnVuY3Rpb24ocG9ydHNGb3JSZW1vdmFsLCBvcHQpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMsIG5ld1BvcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3J0c0ZvclJlbW92YWwpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0IHx8IHt9O1xuICAgICAgICAgICAgaWYgKHBvcnRzRm9yUmVtb3ZhbC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnRoaXM7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9ydHMgPSB1dGlsLmFzc2lnbihbXSwgdGhpcy5wcm9wKFsncG9ydHMnLCAnaXRlbXMnXSkpO1xuICAgICAgICAgICAgbmV3UG9ydHMgPSBjdXJyZW50UG9ydHMuZmlsdGVyKGZ1bmN0aW9uKGNwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwb3J0c0ZvclJlbW92YWwuc29tZShmdW5jdGlvbihycCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBycElkID0gdXRpbC5pc09iamVjdChycCkgPyBycC5pZCA6IHJwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuaWQgPT09IHJwSWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwb3J0c0ZvclJlbW92YWwgfHwge307XG4gICAgICAgICAgICBuZXdQb3J0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9wKFsncG9ydHMnLCAnaXRlbXMnXSwgbmV3UG9ydHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0b3BCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVBvcnREYXRhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZXJyID0gdGhpcy5fdmFsaWRhdGVQb3J0cygpO1xuXG4gICAgICAgIGlmIChlcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3BvcnRzJywgdGhpcy5wcmV2aW91cygncG9ydHMnKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldlBvcnREYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb3J0U2V0dGluZ3NEYXRhKSB7XG5cbiAgICAgICAgICAgIHByZXZQb3J0RGF0YSA9IHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEuZ2V0UG9ydHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEgPSBuZXcgUG9ydERhdGEodGhpcy5nZXQoJ3BvcnRzJykpO1xuXG4gICAgICAgIHZhciBjdXJQb3J0RGF0YSA9IHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEuZ2V0UG9ydHMoKTtcblxuICAgICAgICBpZiAocHJldlBvcnREYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBhZGRlZCA9IGN1clBvcnREYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UG9ydERhdGEuZmluZChmdW5jdGlvbihwcmV2UG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlBvcnQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gcHJldlBvcnREYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJQb3J0RGF0YS5maW5kKGZ1bmN0aW9uKGN1clBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1clBvcnQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BvcnRzOnJlbW92ZScsIHRoaXMsIHJlbW92ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncG9ydHM6YWRkJywgdGhpcywgYWRkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVsZW1lbnRWaWV3UG9ydFByb3RvdHlwZSA9IHtcblxuICAgIHBvcnRDb250YWluZXJNYXJrdXA6ICdnJyxcbiAgICBwb3J0TWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdjaXJjbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAncic6IDEwLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyMwMDAwMDAnXG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBwb3J0TGFiZWxNYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICd0ZXh0JyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywge3BvcnRFbGVtZW50OiBWZWN0b3JpemVyLCBwb3J0TGFiZWxFbGVtZW50OiBWZWN0b3JpemVyfT59ICovXG4gICAgX3BvcnRFbGVtZW50c0NhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFBvcnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZFxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwb3NpdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsYWJlbFxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhdHRyc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXJrdXBcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZ3JvdXBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZnJlc2hQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9ydHMoKTtcbiAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclBvcnRzKCk7XG4gICAgfSxcblxuICAgIF9jbGVhblBvcnRzQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byByZW5kZXJlZCBlbGVtZW50cyB3aXRob3V0IHotaW5kZXhcbiAgICAgICAgdmFyIGVsZW1lbnRSZWZlcmVuY2VzID0gW107XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IGVsZW0ubm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2VzLnB1c2goZWxlbS5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnRzR3JvcHNCeVogPSB1dGlsLmdyb3VwQnkodGhpcy5tb2RlbC5fcG9ydFNldHRpbmdzRGF0YS5nZXRQb3J0cygpLCAneicpO1xuICAgICAgICB2YXIgd2l0aG91dFpLZXkgPSAnYXV0byc7XG5cbiAgICAgICAgLy8gcmVuZGVyIG5vbi16IGZpcnN0XG4gICAgICAgIHV0aWwudG9BcnJheShwb3J0c0dyb3BzQnlaW3dpdGhvdXRaS2V5XSkuZm9yRWFjaChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICB2YXIgcG9ydEVsZW1lbnQgPSB0aGlzLl9nZXRQb3J0RWxlbWVudChwb3J0KTtcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kKHBvcnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2VzLnB1c2gocG9ydEVsZW1lbnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgZ3JvdXBOYW1lcyA9IE9iamVjdC5rZXlzKHBvcnRzR3JvcHNCeVopO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyb3VwTmFtZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cE5hbWUgPSBncm91cE5hbWVzW2tdO1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSAhPT0gd2l0aG91dFpLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHBhcnNlSW50KGdyb3VwTmFtZSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZFBvcnRzKHBvcnRzR3JvcHNCeVpbZ3JvdXBOYW1lXSwgeiwgZWxlbWVudFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUG9ydHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Z9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29udGFpbmVyRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRhYmxlTm9kZSB8fCB0aGlzLnZlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxQb3J0Pn1wb3J0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAgICogQHBhcmFtIHJlZnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBlbmRQb3J0czogZnVuY3Rpb24ocG9ydHMsIHosIHJlZnMpIHtcblxuICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHRoaXMuX2dldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICAgICAgdmFyIHBvcnRFbGVtZW50cyA9IHV0aWwudG9BcnJheShwb3J0cykubWFwKHRoaXMuX2dldFBvcnRFbGVtZW50LCB0aGlzKTtcblxuICAgICAgICBpZiAocmVmc1t6XSB8fCB6IDwgMCkge1xuICAgICAgICAgICAgVihyZWZzW01hdGgubWF4KHosIDApXSkuYmVmb3JlKHBvcnRFbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZChwb3J0RWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyeSB0byBnZXQgZWxlbWVudCBmcm9tIGNhY2hlLFxuICAgICAqIEBwYXJhbSBwb3J0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UG9ydEVsZW1lbnQ6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICBpZiAodGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydC5pZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0LmlkXS5wb3J0RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUG9ydEVsZW1lbnQocG9ydCk7XG4gICAgfSxcblxuICAgIGZpbmRQb3J0Tm9kZTogZnVuY3Rpb24ocG9ydElkLCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBwb3J0Q2FjaGUgPSB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0SWRdO1xuICAgICAgICBpZiAoIXBvcnRDYWNoZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghc2VsZWN0b3IpIHJldHVybiBwb3J0Q2FjaGUucG9ydENvbnRlbnRFbGVtZW50Lm5vZGU7XG4gICAgICAgIGNvbnN0IHBvcnRSb290ID0gcG9ydENhY2hlLnBvcnRFbGVtZW50Lm5vZGU7XG4gICAgICAgIGNvbnN0IHBvcnRTZWxlY3RvcnMgPSBwb3J0Q2FjaGUucG9ydFNlbGVjdG9ycztcbiAgICAgICAgY29uc3QgW25vZGUgPSBudWxsXSA9IHRoaXMuZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHBvcnRSb290LCBwb3J0U2VsZWN0b3JzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVBvcnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBsYXlvdXQgcG9ydHMgd2l0aG91dCBncm91cFxuICAgICAgICB0aGlzLl91cGRhdGVQb3J0R3JvdXAodW5kZWZpbmVkKTtcbiAgICAgICAgLy8gbGF5b3V0IHBvcnRzIHdpdGggZXhwbGljaXQgZ3JvdXBcbiAgICAgICAgdmFyIGdyb3Vwc05hbWVzID0gT2JqZWN0LmtleXModGhpcy5tb2RlbC5fcG9ydFNldHRpbmdzRGF0YS5ncm91cHMpO1xuICAgICAgICBncm91cHNOYW1lcy5mb3JFYWNoKHRoaXMuX3VwZGF0ZVBvcnRHcm91cCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC5pbnZva2UodGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGUsICdwb3J0RWxlbWVudC5yZW1vdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0XG4gICAgICogQHJldHVybnMge1Z9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlUG9ydEVsZW1lbnQ6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICBsZXQgcG9ydEVsZW1lbnQ7XG4gICAgICAgIGxldCBsYWJlbEVsZW1lbnQ7XG4gICAgICAgIGxldCBsYWJlbFNlbGVjdG9ycztcbiAgICAgICAgbGV0IHBvcnRTZWxlY3RvcnM7XG5cbiAgICAgICAgdmFyIHBvcnRDb250YWluZXJFbGVtZW50ID0gVih0aGlzLnBvcnRDb250YWluZXJNYXJrdXApLmFkZENsYXNzKCdqb2ludC1wb3J0Jyk7XG5cbiAgICAgICAgdmFyIHBvcnRNYXJrdXAgPSB0aGlzLl9nZXRQb3J0TWFya3VwKHBvcnQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3J0TWFya3VwKSkge1xuICAgICAgICAgICAgdmFyIHBvcnREb2MgPSB0aGlzLnBhcnNlRE9NSlNPTihwb3J0TWFya3VwLCBwb3J0Q29udGFpbmVyRWxlbWVudC5ub2RlKTtcbiAgICAgICAgICAgIHZhciBwb3J0RnJhZ21lbnQgPSBwb3J0RG9jLmZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKHBvcnRGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBwb3J0RWxlbWVudCA9IFYoJ2cnKS5hcHBlbmQocG9ydEZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9ydEVsZW1lbnQgPSBWKHBvcnRGcmFnbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRTZWxlY3RvcnMgPSBwb3J0RG9jLnNlbGVjdG9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcnRFbGVtZW50ID0gVihwb3J0TWFya3VwKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvcnRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHBvcnRFbGVtZW50ID0gVignZycpLmFwcGVuZChwb3J0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnRWaWV3OiBJbnZhbGlkIHBvcnQgbWFya3VwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9ydEVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgICAncG9ydCc6IHBvcnQuaWQsXG4gICAgICAgICAgICAncG9ydC1ncm91cCc6IHBvcnQuZ3JvdXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbGFiZWxNYXJrdXBEZWYgPSB0aGlzLl9nZXRQb3J0TGFiZWxNYXJrdXAocG9ydC5sYWJlbCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhYmVsTWFya3VwRGVmKSkge1xuICAgICAgICAgICAgLy8gSlNPTiBNYXJrdXBcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHNlbGVjdG9ycyB9ID0gdGhpcy5wYXJzZURPTUpTT04obGFiZWxNYXJrdXBEZWYsIHBvcnRDb250YWluZXJFbGVtZW50Lm5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxTZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gKGNoaWxkQ291bnQgPT09IDEpID8gVihmcmFnbWVudC5maXJzdENoaWxkKSA6IFYoJ2cnKS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RyaW5nIE1hcmt1cFxuICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gVihsYWJlbE1hcmt1cERlZik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gVignZycpLmFwcGVuZChsYWJlbEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnRDb250YWluZXJTZWxlY3RvcnM7XG4gICAgICAgIGlmIChwb3J0U2VsZWN0b3JzICYmIGxhYmVsU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGFiZWxTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9ydFNlbGVjdG9yc1trZXldICYmIGtleSAhPT0gdGhpcy5zZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50Vmlldzogc2VsZWN0b3JzIHdpdGhpbiBwb3J0IG11c3QgYmUgdW5pcXVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9ycyA9IHV0aWwuYXNzaWduKHt9LCBwb3J0U2VsZWN0b3JzLCBsYWJlbFNlbGVjdG9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzID0gcG9ydFNlbGVjdG9ycyB8fCBsYWJlbFNlbGVjdG9ycyB8fCB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBgcG9ydFJvb3RTZWxlY3RvcmAgcG9pbnRzIHRvIHRoZSByb290IFNWR05vZGUgb2YgdGhlIHBvcnQuXG4gICAgICAgIC8vIEVpdGhlciB0aGUgaW1wbGljaXQgd3JhcHBpbmcgZ3JvdXAgPGcvPiBpbiBjYXNlIHRoZSBwb3J0IGNvbnNpc3Qgb2YgbXVsdGlwbGUgU1ZHTm9kZXMuXG4gICAgICAgIC8vIE9yIHRoZSBzaW5nbGUgU1ZHTm9kZSBvZiB0aGUgcG9ydC5cbiAgICAgICAgY29uc3QgcG9ydFJvb3RTZWxlY3RvciA9ICdwb3J0Um9vdCc7XG4gICAgICAgIC8vIFRoZSBgbGFiZWxSb290U2VsZWN0b3JgIHBvaW50cyB0byB0aGUgcm9vdCBTVkdOb2RlIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgY29uc3QgbGFiZWxSb290U2VsZWN0b3IgPSAnbGFiZWxSb290JztcbiAgICAgICAgLy8gVGhlIGBsYWJlbFRleHRTZWxlY3RvcmAgcG9pbnRzIHRvIGFsbCB0ZXh0IFNWR05vZGVzIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgY29uc3QgbGFiZWxUZXh0U2VsZWN0b3IgPSAnbGFiZWxUZXh0JztcblxuICAgICAgICBpZiAoIShwb3J0Um9vdFNlbGVjdG9yIGluIHBvcnRDb250YWluZXJTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW3BvcnRSb290U2VsZWN0b3JdID0gcG9ydEVsZW1lbnQubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTm9kZSA9IGxhYmVsRWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCEobGFiZWxSb290U2VsZWN0b3IgaW4gcG9ydENvbnRhaW5lclNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW2xhYmVsUm9vdFNlbGVjdG9yXSA9IGxhYmVsTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGxhYmVsVGV4dFNlbGVjdG9yIGluIHBvcnRDb250YWluZXJTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGlzIGEgPHRleHQ+IGVsZW1lbnQsIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIDx0ZXh0PiBlbGVtZW50IHdpdGhpbiB0aGUgbGFiZWwuXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0Tm9kZSA9IChsYWJlbEVsZW1lbnQudGFnTmFtZSgpID09PSAnVEVYVCcpXG4gICAgICAgICAgICAgICAgICAgID8gbGFiZWxOb2RlXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbShsYWJlbE5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dCcpKTtcbiAgICAgICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW2xhYmVsVGV4dFNlbGVjdG9yXSA9IGxhYmVsVGV4dE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFsYWJlbFNlbGVjdG9ycykgbGFiZWxTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsYWJlbFNlbGVjdG9yc1tsYWJlbFRleHRTZWxlY3Rvcl0gPSBsYWJlbFRleHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9ydENvbnRhaW5lckVsZW1lbnQuYXBwZW5kKHBvcnRFbGVtZW50LmFkZENsYXNzKCdqb2ludC1wb3J0LWJvZHknKSk7XG4gICAgICAgIGlmIChsYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHBvcnRDb250YWluZXJFbGVtZW50LmFwcGVuZChsYWJlbEVsZW1lbnQuYWRkQ2xhc3MoJ2pvaW50LXBvcnQtbGFiZWwnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0LmlkXSA9IHtcbiAgICAgICAgICAgIHBvcnRFbGVtZW50OiBwb3J0Q29udGFpbmVyRWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRMYWJlbEVsZW1lbnQ6IGxhYmVsRWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRTZWxlY3RvcnM6IHBvcnRDb250YWluZXJTZWxlY3RvcnMsXG4gICAgICAgICAgICBwb3J0TGFiZWxTZWxlY3RvcnM6IGxhYmVsU2VsZWN0b3JzLFxuICAgICAgICAgICAgcG9ydENvbnRlbnRFbGVtZW50OiBwb3J0RWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRDb250ZW50U2VsZWN0b3JzOiBwb3J0U2VsZWN0b3JzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBvcnRDb250YWluZXJFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGdyb3VwTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVBvcnRHcm91cDogZnVuY3Rpb24oZ3JvdXBOYW1lKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRCQm94ID0gUmVjdCh0aGlzLm1vZGVsLnNpemUoKSk7XG4gICAgICAgIHZhciBwb3J0c01ldHJpY3MgPSB0aGlzLm1vZGVsLl9wb3J0U2V0dGluZ3NEYXRhLmdldEdyb3VwUG9ydHNNZXRyaWNzKGdyb3VwTmFtZSwgZWxlbWVudEJCb3gpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9ydHNNZXRyaWNzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBwb3J0c01ldHJpY3NbaV07XG4gICAgICAgICAgICB2YXIgcG9ydElkID0gbWV0cmljcy5wb3J0SWQ7XG4gICAgICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydElkXSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBwb3J0VHJhbnNmb3JtYXRpb24gPSBtZXRyaWNzLnBvcnRUcmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgICAgIHZhciBsYWJlbFRyYW5zZm9ybWF0aW9uID0gbWV0cmljcy5sYWJlbFRyYW5zZm9ybWF0aW9uO1xuICAgICAgICAgICAgaWYgKGxhYmVsVHJhbnNmb3JtYXRpb24gJiYgY2FjaGVkLnBvcnRMYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKGNhY2hlZC5wb3J0TGFiZWxFbGVtZW50Lm5vZGUsIGxhYmVsVHJhbnNmb3JtYXRpb24uYXR0cnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEJCb3g6IG5ldyBSZWN0KG1ldHJpY3MubGFiZWxTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBjYWNoZWQucG9ydExhYmVsU2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvcnRUcmFuc2Zvcm0oY2FjaGVkLnBvcnRMYWJlbEVsZW1lbnQsIGxhYmVsVHJhbnNmb3JtYXRpb24sICgtcG9ydFRyYW5zZm9ybWF0aW9uLmFuZ2xlIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXMoY2FjaGVkLnBvcnRFbGVtZW50Lm5vZGUsIG1ldHJpY3MucG9ydEF0dHJzLCB7XG4gICAgICAgICAgICAgICAgcm9vdEJCb3g6IG5ldyBSZWN0KG1ldHJpY3MucG9ydFNpemUpLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczogY2FjaGVkLnBvcnRTZWxlY3RvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBvcnRUcmFuc2Zvcm0oY2FjaGVkLnBvcnRFbGVtZW50LCBwb3J0VHJhbnNmb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VmVjdG9yaXplcn0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2R4Om51bWJlciwgZHk6bnVtYmVyLCBhbmdsZTogbnVtYmVyLCBhdHRyczogT2JqZWN0LCB4Om51bWJlcjogeTpudW1iZXJ9fSB0cmFuc2Zvcm1EYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBpbml0aWFsQW5nbGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBhcHBseVBvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGVsZW1lbnQsIHRyYW5zZm9ybURhdGEsIGluaXRpYWxBbmdsZSkge1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpXG4gICAgICAgICAgICAucm90YXRlKGluaXRpYWxBbmdsZSB8fCAwKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2Zvcm1EYXRhLnggfHwgMCwgdHJhbnNmb3JtRGF0YS55IHx8IDApXG4gICAgICAgICAgICAucm90YXRlKHRyYW5zZm9ybURhdGEuYW5nbGUgfHwgMCk7XG5cbiAgICAgICAgZWxlbWVudC50cmFuc2Zvcm0obWF0cml4LCB7IGFic29sdXRlOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBvcnRNYXJrdXA6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICByZXR1cm4gcG9ydC5tYXJrdXAgfHwgdGhpcy5tb2RlbC5nZXQoJ3BvcnRNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLnBvcnRNYXJrdXAgfHwgdGhpcy5wb3J0TWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBvcnRMYWJlbE1hcmt1cDogZnVuY3Rpb24obGFiZWwpIHtcblxuICAgICAgICByZXR1cm4gbGFiZWwubWFya3VwIHx8IHRoaXMubW9kZWwuZ2V0KCdwb3J0TGFiZWxNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLnBvcnRMYWJlbE1hcmt1cCB8fCB0aGlzLnBvcnRMYWJlbE1hcmt1cDtcbiAgICB9XG59O1xuXG4iXSwibmFtZXMiOlsidXRpbCIsIlYiLCJSZWN0IiwiUG9pbnQiLCJQb3J0IiwiUG9ydExhYmVsIiwiUG9ydERhdGEiLCJkYXRhIiwiY2xvbmVkRGF0YSIsImNsb25lRGVlcCIsInBvcnRzIiwiZ3JvdXBzIiwicG9ydExheW91dE5hbWVzcGFjZSIsInBvcnRMYWJlbExheW91dE5hbWVzcGFjZSIsIl9pbml0IiwicHJvdG90eXBlIiwiZ2V0UG9ydHMiLCJnZXRHcm91cCIsIm5hbWUiLCJnZXRQb3J0c0J5R3JvdXAiLCJncm91cE5hbWUiLCJmaWx0ZXIiLCJwb3J0IiwiZ3JvdXAiLCJnZXRHcm91cFBvcnRzTWV0cmljcyIsImVsQkJveCIsImdyb3VwUG9zaXRpb24iLCJwb3NpdGlvbiIsImdyb3VwUG9zaXRpb25OYW1lIiwibmFtZXNwYWNlIiwiZ3JvdXBBcmdzIiwiYXJncyIsInBvcnRzQXJncyIsIm1hcCIsImdyb3VwUG9ydFRyYW5zZm9ybWF0aW9ucyIsImFjY3VtdWxhdG9yIiwicmVzdWx0IiwidG9BcnJheSIsInJlZHVjZSIsInJlcyIsInBvcnRUcmFuc2Zvcm1hdGlvbiIsImluZGV4IiwicHVzaCIsInBvcnRJZCIsImlkIiwibGFiZWxUcmFuc2Zvcm1hdGlvbiIsIl9nZXRQb3J0TGFiZWxMYXlvdXQiLCJwb3J0QXR0cnMiLCJhdHRycyIsInBvcnRTaXplIiwic2l6ZSIsImxhYmVsU2l6ZSIsImxhYmVsIiwiYmluZCIsInBvcnRQb3NpdGlvbiIsImxhYmVsUG9zaXRpb24iLCJpc09iamVjdCIsIk9iamVjdCIsImtleXMiLCJpIiwibiIsImxlbmd0aCIsImtleSIsIl9ldmFsdWF0ZUdyb3VwIiwiaXRlbXMiLCJqIiwibSIsIl9ldmFsdWF0ZVBvcnQiLCJtZXJnZSIsIl9nZXRQb3NpdGlvbiIsIl9nZXRMYWJlbCIsImV2YWx1YXRlZCIsImFzc2lnbiIsIm1hcmt1cCIsIl9jcmVhdGVQb3NpdGlvbk5vZGUiLCJ6IiwiX2dldFpJbmRleCIsImlzTnVtYmVyIiwic2V0RGVmYXVsdCIsInBvc2l0aW9uTmFtZSIsImlzRnVuY3Rpb24iLCJmbiIsImlzU3RyaW5nIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwieCIsInkiLCJpdGVtIiwic2V0RGVmYXVsdHMiLCJyZXQiLCJlbGVtZW50UG9ydFByb3RvdHlwZSIsIl9pbml0aWFsaXplUG9ydHMiLCJfY3JlYXRlUG9ydERhdGEiLCJvbiIsIl9wcm9jZXNzUmVtb3ZlZFBvcnQiLCJjdXJyZW50IiwiZ2V0IiwiY3VycmVudEl0ZW1zTWFwIiwiZm9yRWFjaCIsInByZXZpb3VzIiwicmVtb3ZlZCIsImdyYXBoIiwiaXNFbXB0eSIsImluYm91bmRMaW5rcyIsImdldENvbm5lY3RlZExpbmtzIiwiaW5ib3VuZCIsImxpbmsiLCJyZW1vdmUiLCJvdXRib3VuZExpbmtzIiwib3V0Ym91bmQiLCJoYXNQb3J0cyIsInByb3AiLCJoYXNQb3J0IiwiZ2V0UG9ydEluZGV4IiwiZ2V0R3JvdXBQb3J0cyIsImdyb3VwUG9ydHMiLCJnZXRQb3J0IiwiZmluZCIsImdldFBvcnRzUG9zaXRpb25zIiwicG9ydHNNZXRyaWNzIiwiX3BvcnRTZXR0aW5nc0RhdGEiLCJwb3NpdGlvbnMiLCJtZXRyaWNzIiwidHJhbnNmb3JtYXRpb24iLCJhbmdsZSIsIl9pc1ZhbGlkUG9ydElkIiwiZmluZEluZGV4IiwiYWRkUG9ydCIsIm9wdCIsIkVycm9yIiwiaW5zZXJ0UG9ydCIsImJlZm9yZSIsInNwbGljZSIsInBvcnRQcm9wIiwicGF0aCIsInZhbHVlIiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwiY29uY2F0Iiwiam9pbiIsImlzUGxhaW5PYmplY3QiLCJhcHBseSIsIl92YWxpZGF0ZVBvcnRzIiwicG9ydHNBdHRyIiwiZXJyb3JNZXNzYWdlcyIsInAiLCJnZW5lcmF0ZVBvcnRJZCIsInVuaXEiLCJnZW5lcmF0ZUlkIiwiYWRkUG9ydHMiLCJyZW1vdmVQb3J0Iiwib3B0aW9ucyIsInJld3JpdGUiLCJzdGFydEJhdGNoIiwic3RvcEJhdGNoIiwicmVtb3ZlUG9ydHMiLCJwb3J0c0ZvclJlbW92YWwiLCJuZXdQb3J0cyIsInRoaXMiLCJjdXJyZW50UG9ydHMiLCJjcCIsInNvbWUiLCJycCIsInJwSWQiLCJlcnIiLCJzZXQiLCJwcmV2UG9ydERhdGEiLCJjdXJQb3J0RGF0YSIsImFkZGVkIiwicHJldlBvcnQiLCJjdXJQb3J0IiwidHJpZ2dlciIsImVsZW1lbnRWaWV3UG9ydFByb3RvdHlwZSIsInBvcnRDb250YWluZXJNYXJrdXAiLCJwb3J0TWFya3VwIiwidGFnTmFtZSIsInNlbGVjdG9yIiwiYXR0cmlidXRlcyIsInBvcnRMYWJlbE1hcmt1cCIsIl9wb3J0RWxlbWVudHNDYWNoZSIsIl9jbGVhblBvcnRzQ2FjaGUiLCJfcmVmcmVzaFBvcnRzIiwiX3JlbW92ZVBvcnRzIiwiX3JlbmRlclBvcnRzIiwiZWxlbWVudFJlZmVyZW5jZXMiLCJlbGVtIiwiX2dldENvbnRhaW5lckVsZW1lbnQiLCJjb3VudCIsIm5vZGUiLCJjaGlsZE5vZGVzIiwicG9ydHNHcm9wc0J5WiIsImdyb3VwQnkiLCJtb2RlbCIsIndpdGhvdXRaS2V5IiwicG9ydEVsZW1lbnQiLCJfZ2V0UG9ydEVsZW1lbnQiLCJhcHBlbmQiLCJncm91cE5hbWVzIiwiayIsInBhcnNlSW50IiwiX2FwcGVuZFBvcnRzIiwiX3VwZGF0ZVBvcnRzIiwicm90YXRhYmxlTm9kZSIsInZlbCIsInJlZnMiLCJjb250YWluZXJFbGVtZW50IiwicG9ydEVsZW1lbnRzIiwiTWF0aCIsIm1heCIsIl9jcmVhdGVQb3J0RWxlbWVudCIsImZpbmRQb3J0Tm9kZSIsInBvcnRDYWNoZSIsInBvcnRDb250ZW50RWxlbWVudCIsInBvcnRSb290IiwicG9ydFNlbGVjdG9ycyIsImZpbmRCeVNlbGVjdG9yIiwiX3VwZGF0ZVBvcnRHcm91cCIsImdyb3Vwc05hbWVzIiwiaW52b2tlIiwibGFiZWxFbGVtZW50IiwibGFiZWxTZWxlY3RvcnMiLCJwb3J0Q29udGFpbmVyRWxlbWVudCIsImFkZENsYXNzIiwiX2dldFBvcnRNYXJrdXAiLCJwb3J0RG9jIiwicGFyc2VET01KU09OIiwicG9ydEZyYWdtZW50IiwiZnJhZ21lbnQiLCJmaXJzdENoaWxkIiwic2VsZWN0b3JzIiwiYXR0ciIsImxhYmVsTWFya3VwRGVmIiwiX2dldFBvcnRMYWJlbE1hcmt1cCIsImNoaWxkQ291bnQiLCJwb3J0Q29udGFpbmVyU2VsZWN0b3JzIiwicG9ydFJvb3RTZWxlY3RvciIsImxhYmVsUm9vdFNlbGVjdG9yIiwibGFiZWxUZXh0U2VsZWN0b3IiLCJsYWJlbE5vZGUiLCJsYWJlbFRleHROb2RlIiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwb3J0TGFiZWxFbGVtZW50IiwicG9ydExhYmVsU2VsZWN0b3JzIiwicG9ydENvbnRlbnRTZWxlY3RvcnMiLCJlbGVtZW50QkJveCIsImNhY2hlZCIsInVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzIiwicm9vdEJCb3giLCJhcHBseVBvcnRUcmFuc2Zvcm0iLCJlbGVtZW50IiwidHJhbnNmb3JtRGF0YSIsImluaXRpYWxBbmdsZSIsIm1hdHJpeCIsImNyZWF0ZVNWR01hdHJpeCIsInJvdGF0ZSIsInRyYW5zbGF0ZSIsInRyYW5zZm9ybSIsImFic29sdXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/dia/ports.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/env/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/env/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\nconst env = {\n    _results: {},\n    _tests: {\n        svgforeignobject: function() {\n            return !!document.createElementNS && /SVGForeignObject/.test(({}).toString.call(document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\")));\n        }\n    },\n    addTest: function(name, fn) {\n        return this._tests[name] = fn;\n    },\n    test: function(name) {\n        var fn = this._tests[name];\n        if (!fn) {\n            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        }\n        var result = this._results[name];\n        if (typeof result !== \"undefined\") {\n            return result;\n        }\n        try {\n            result = fn();\n        } catch (error) {\n            result = false;\n        }\n        // Cache the test result.\n        this._results[name] = result;\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZW52L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsTUFBTTtJQUVmQyxVQUFVLENBQUM7SUFFWEMsUUFBUTtRQUVKQyxrQkFBa0I7WUFDZCxPQUFPLENBQUMsQ0FBQ0MsU0FBU0MsZUFBZSxJQUM3QixtQkFBbUJDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR0MsUUFBUSxDQUFDQyxJQUFJLENBQUNKLFNBQVNDLGVBQWUsQ0FBQyw4QkFBOEI7UUFDMUc7SUFDSjtJQUVBSSxTQUFTLFNBQVNDLElBQUksRUFBRUMsRUFBRTtRQUV0QixPQUFPLElBQUksQ0FBQ1QsTUFBTSxDQUFDUSxLQUFLLEdBQUdDO0lBQy9CO0lBRUFMLE1BQU0sU0FBU0ksSUFBSTtRQUVmLElBQUlDLEtBQUssSUFBSSxDQUFDVCxNQUFNLENBQUNRLEtBQUs7UUFFMUIsSUFBSSxDQUFDQyxJQUFJO1lBQ0wsTUFBTSxJQUFJQyxNQUFNLHdCQUF3QkYsT0FBTztRQUNuRDtRQUVBLElBQUlHLFNBQVMsSUFBSSxDQUFDWixRQUFRLENBQUNTLEtBQUs7UUFFaEMsSUFBSSxPQUFPRyxXQUFXLGFBQWE7WUFDL0IsT0FBT0E7UUFDWDtRQUVBLElBQUk7WUFDQUEsU0FBU0Y7UUFDYixFQUFFLE9BQU9HLE9BQU87WUFDWkQsU0FBUztRQUNiO1FBRUEseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1osUUFBUSxDQUFDUyxLQUFLLEdBQUdHO1FBRXRCLE9BQU9BO0lBQ1g7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZW52L2luZGV4Lm1qcz82Y2Q0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBlbnYgPSB7XG5cbiAgICBfcmVzdWx0czoge30sXG5cbiAgICBfdGVzdHM6IHtcblxuICAgICAgICBzdmdmb3JlaWdub2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJlxuICAgICAgICAgICAgICAgIC9TVkdGb3JlaWduT2JqZWN0Ly50ZXN0KCh7fSkudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2ZvcmVpZ25PYmplY3QnKSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFRlc3Q6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3RzW25hbWVdID0gZm47XG4gICAgfSxcblxuICAgIHRlc3Q6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICB2YXIgZm4gPSB0aGlzLl90ZXN0c1tuYW1lXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgbm90IGRlZmluZWQgKFwiJyArIG5hbWUgKyAnXCIpLiBVc2UgYGpvaW50LmVudi5hZGRUZXN0KG5hbWUsIGZuKSB0byBhZGQgYSBuZXcgdGVzdC5gJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVzdWx0c1tuYW1lXTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIHRlc3QgcmVzdWx0LlxuICAgICAgICB0aGlzLl9yZXN1bHRzW25hbWVdID0gcmVzdWx0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJlbnYiLCJfcmVzdWx0cyIsIl90ZXN0cyIsInN2Z2ZvcmVpZ25vYmplY3QiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInRlc3QiLCJ0b1N0cmluZyIsImNhbGwiLCJhZGRUZXN0IiwibmFtZSIsImZuIiwiRXJyb3IiLCJyZXN1bHQiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/env/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/bezier.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/g/bezier.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezier: () => (/* binding */ bezier)\n/* harmony export */ });\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/jointjs/src/g/curve.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n\n\n\nconst bezier = {\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n        console.warn(\"deprecated\");\n        return new _path_mjs__WEBPACK_IMPORTED_MODULE_0__.Path(_curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.throughPoints(points)).serialize();\n    },\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n        console.warn(\"deprecated\");\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n            return [\n                firstControlPoints,\n                secondControlPoints\n            ];\n        }\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n        // Set right hand side X values.\n        for(i = 1; i < n - 1; i++){\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n        // Set right hand side Y values.\n        for(i = 1; i < n - 1; ++i){\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n        // Fill output arrays.\n        for(i = 0; i < n; i++){\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x[i], y[i]));\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n        }\n        return [\n            firstControlPoints,\n            secondControlPoints\n        ];\n    },\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n        console.warn(\"deprecated\");\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n        return function divideCurve(t) {\n            var divided = curve.divide(t);\n            return [\n                {\n                    p0: divided[0].start,\n                    p1: divided[0].controlPoint1,\n                    p2: divided[0].controlPoint2,\n                    p3: divided[0].end\n                },\n                {\n                    p0: divided[1].start,\n                    p1: divided[1].controlPoint1,\n                    p2: divided[1].controlPoint2,\n                    p3: divided[1].end\n                }\n            ];\n        };\n    },\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n        console.warn(\"deprecated\");\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n        x[0] = rhs[0] / b;\n        // Decomposition and forward substitution.\n        for(var i = 1; i < n; i++){\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n        for(i = 1; i < n; i++){\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n        return x;\n    },\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n        console.warn(\"deprecated\");\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n        return function solveInversion(p) {\n            return curve.closestPointT(p);\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9iZXppZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDRTtBQUNBO0FBRTdCLE1BQU1HLFNBQVM7SUFFbEIsMENBQTBDO0lBQzFDLGNBQWM7SUFDZCwrRUFBK0U7SUFDL0UsZ0RBQWdEO0lBQ2hEQyxvQkFBb0IsU0FBU0MsTUFBTTtRQUUvQkMsUUFBUUMsSUFBSSxDQUFDO1FBRWIsT0FBTyxJQUFJUCwyQ0FBSUEsQ0FBQ0MsNkNBQUtBLENBQUNPLGFBQWEsQ0FBQ0gsU0FBU0ksU0FBUztJQUMxRDtJQUVBLCtDQUErQztJQUMvQyxjQUFjO0lBQ2QsdUVBQXVFO0lBQ3ZFLDJGQUEyRjtJQUMzRiw2RkFBNkY7SUFDN0ZDLHVCQUF1QixTQUFTQyxLQUFLO1FBRWpDTCxRQUFRQyxJQUFJLENBQUM7UUFFYixJQUFJSyxxQkFBcUIsRUFBRTtRQUMzQixJQUFJQyxzQkFBc0IsRUFBRTtRQUM1QixJQUFJQyxJQUFJSCxNQUFNSSxNQUFNLEdBQUc7UUFDdkIsSUFBSUM7UUFFSix3REFBd0Q7UUFDeEQsSUFBSUYsS0FBSyxHQUFHO1lBQ1IsaUJBQWlCO1lBQ2pCRixrQkFBa0IsQ0FBQyxFQUFFLEdBQUcsSUFBSVYsNkNBQUtBLENBQzdCLENBQUMsSUFBSVMsS0FBSyxDQUFDLEVBQUUsQ0FBQ00sQ0FBQyxHQUFHTixLQUFLLENBQUMsRUFBRSxDQUFDTSxDQUFDLElBQUksR0FDaEMsQ0FBQyxJQUFJTixLQUFLLENBQUMsRUFBRSxDQUFDTyxDQUFDLEdBQUdQLEtBQUssQ0FBQyxFQUFFLENBQUNPLENBQUMsSUFBSTtZQUdwQyxnQkFBZ0I7WUFDaEJMLG1CQUFtQixDQUFDLEVBQUUsR0FBRyxJQUFJWCw2Q0FBS0EsQ0FDOUIsSUFBSVUsa0JBQWtCLENBQUMsRUFBRSxDQUFDSyxDQUFDLEdBQUdOLEtBQUssQ0FBQyxFQUFFLENBQUNNLENBQUMsRUFDeEMsSUFBSUwsa0JBQWtCLENBQUMsRUFBRSxDQUFDTSxD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LEVBQUUsSUFBSXFCO1FBQ2pDO1FBRUEsSUFBS3JCLElBQUksR0FBR0EsSUFBSUYsR0FBR0UsSUFBSztZQUNwQixvQkFBb0I7WUFDcEJDLENBQUMsQ0FBQ0gsSUFBSUUsSUFBSSxFQUFFLElBQUlvQixHQUFHLENBQUN0QixJQUFJRSxFQUFFLEdBQUdDLENBQUMsQ0FBQ0gsSUFBSUUsRUFBRTtRQUN6QztRQUVBLE9BQU9DO0lBQ1g7SUFFQSx1RkFBdUY7SUFDdkYsNkVBQTZFO0lBQzdFLG1DQUFtQztJQUNuQyxjQUFjO0lBQ2QsaUVBQWlFO0lBQ2pFLHlEQUF5RDtJQUN6RHFCLG9CQUFvQixTQUFTZixFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFO1FBRXZDcEIsUUFBUUMsSUFBSSxDQUFDO1FBRWIsSUFBSW9CLFFBQVEsSUFBSTFCLDZDQUFLQSxDQUFDc0IsSUFBSUMsSUFBSUMsSUFBSUM7UUFFbEMsT0FBTyxTQUFTYSxlQUFlQyxDQUFDO1lBRTVCLE9BQU9iLE1BQU1jLGFBQWEsQ0FBQ0Q7UUFDL0I7SUFDSjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL2Jlemllci5tanM/MzI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9wYXRoLm1qcyc7XG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4vY3VydmUubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuXG5leHBvcnQgY29uc3QgYmV6aWVyID0ge1xuXG4gICAgLy8gQ3ViaWMgQmV6aWVyIGN1cnZlIHBhdGggdGhyb3VnaCBwb2ludHMuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAvLyBAcGFyYW0ge2FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzIHRocm91Z2ggd2hpY2ggdGhlIHNtb290aCBsaW5lIHdpbGwgZ28uXG4gICAgLy8gQHJldHVybiB7YXJyYXl9IFNWRyBQYXRoIGNvbW1hbmRzIGFzIGFuIGFycmF5XG4gICAgY3VydmVUaHJvdWdoUG9pbnRzOiBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBhdGgoQ3VydmUudGhyb3VnaFBvaW50cyhwb2ludHMpKS5zZXJpYWxpemUoKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IG9wZW4tZW5kZWQgQmV6aWVyIFNwbGluZSBDb250cm9sIFBvaW50cy5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBrbm90cyBJbnB1dCBLbm90IEJlemllciBzcGxpbmUgcG9pbnRzIChBdCBsZWFzdCB0d28gcG9pbnRzISkuXG4gICAgLy8gQHBhcmFtIGZpcnN0Q29udHJvbFBvaW50cyBPdXRwdXQgRmlyc3QgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIC8vIEBwYXJhbSBzZWNvbmRDb250cm9sUG9pbnRzIE91dHB1dCBTZWNvbmQgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIGdldEN1cnZlQ29udHJvbFBvaW50czogZnVuY3Rpb24oa25vdHMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICB2YXIgZmlyc3RDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzZWNvbmRDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBuID0ga25vdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBCZXppZXIgY3VydmUgc2hvdWxkIGJlIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgLy8gM1AxID0gMlAwICsgUDNcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoMiAqIGtub3RzWzBdLnggKyBrbm90c1sxXS54KSAvIDMsXG4gICAgICAgICAgICAgICAgKDIgKiBrbm90c1swXS55ICsga25vdHNbMV0ueSkgLyAzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBQMiA9IDJQMSDigJMgUDBcbiAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHNbMF0gPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgMiAqIGZpcnN0Q29udHJvbFBvaW50c1swXS54IC0ga25vdHNbMF0ueCxcbiAgICAgICAgICAgICAgICAyICogZmlyc3RDb250cm9sUG9pbnRzWzBdLnkgLSBrbm90c1swXS55XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gW2ZpcnN0Q29udHJvbFBvaW50cywgc2Vjb25kQ29udHJvbFBvaW50c107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgZmlyc3QgQmV6aWVyIGNvbnRyb2wgcG9pbnRzLlxuICAgICAgICAvLyBSaWdodCBoYW5kIHNpZGUgdmVjdG9yLlxuICAgICAgICB2YXIgcmhzID0gW107XG5cbiAgICAgICAgLy8gU2V0IHJpZ2h0IGhhbmQgc2lkZSBYIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS54ICsgMiAqIGtub3RzW2kgKyAxXS54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmhzWzBdID0ga25vdHNbMF0ueCArIDIgKiBrbm90c1sxXS54O1xuICAgICAgICByaHNbbiAtIDFdID0gKDggKiBrbm90c1tuIC0gMV0ueCArIGtub3RzW25dLngpIC8gMi4wO1xuXG4gICAgICAgIC8vIEdldCBmaXJzdCBjb250cm9sIHBvaW50cyBYLXZhbHVlcy5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG4gICAgICAgIC8vIFNldCByaWdodCBoYW5kIHNpZGUgWSB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICByaHNbaV0gPSA0ICoga25vdHNbaV0ueSArIDIgKiBrbm90c1tpICsgMV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJoc1swXSA9IGtub3RzWzBdLnkgKyAyICoga25vdHNbMV0ueTtcbiAgICAgICAgcmhzW24gLSAxXSA9ICg4ICoga25vdHNbbiAtIDFdLnkgKyBrbm90c1tuXS55KSAvIDIuMDtcblxuICAgICAgICAvLyBHZXQgZmlyc3QgY29udHJvbCBwb2ludHMgWS12YWx1ZXMuXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAvLyBGaWxsIG91dHB1dCBhcnJheXMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoeFtpXSwgeVtpXSkpO1xuXG4gICAgICAgICAgICAvLyBTZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAgIGlmIChpIDwgbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAyICoga25vdHMgW2kgKyAxXS54IC0geFtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIDIgKiBrbm90c1tpICsgMV0ueSAtIHlbaSArIDFdXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgKGtub3RzW25dLnggKyB4W24gLSAxXSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0ueSArIHlbbiAtIDFdKSAvIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250cm9sUG9pbnRzLCBzZWNvbmRDb250cm9sUG9pbnRzXTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlIGEgQmV6aWVyIGN1cnZlIGludG8gdHdvIGF0IHBvaW50IGRlZmluZWQgYnkgdmFsdWUgJ3QnIDwwLDE+LlxuICAgIC8vIFVzaW5nIGRlQ2FzdGVsamF1IGFsZ29yaXRobS4gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8zMTc4NjdcbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBjb250cm9sIHBvaW50cyAoc3RhcnQsIGNvbnRyb2wgc3RhcnQsIGNvbnRyb2wgZW5kLCBlbmQpXG4gICAgLy8gQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0IGFuZCByZXR1cm5zIDIgY3VydmVzLlxuICAgIGdldEN1cnZlRGl2aWRlcjogZnVuY3Rpb24ocDAsIHAxLCBwMiwgcDMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUocDAsIHAxLCBwMiwgcDMpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkaXZpZGVDdXJ2ZSh0KSB7XG5cbiAgICAgICAgICAgIHZhciBkaXZpZGVkID0gY3VydmUuZGl2aWRlKHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBwMDogZGl2aWRlZFswXS5zdGFydCxcbiAgICAgICAgICAgICAgICBwMTogZGl2aWRlZFswXS5jb250cm9sUG9pbnQxLFxuICAgICAgICAgICAgICAgIHAyOiBkaXZpZGVkWzBdLmNvbnRyb2xQb2ludDIsXG4gICAgICAgICAgICAgICAgcDM6IGRpdmlkZWRbMF0uZW5kXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcDA6IGRpdmlkZWRbMV0uc3RhcnQsXG4gICAgICAgICAgICAgICAgcDE6IGRpdmlkZWRbMV0uY29udHJvbFBvaW50MSxcbiAgICAgICAgICAgICAgICBwMjogZGl2aWRlZFsxXS5jb250cm9sUG9pbnQyLFxuICAgICAgICAgICAgICAgIHAzOiBkaXZpZGVkWzFdLmVuZFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFNvbHZlcyBhIHRyaWRpYWdvbmFsIHN5c3RlbSBmb3Igb25lIG9mIGNvb3JkaW5hdGVzICh4IG9yIHkpIG9mIGZpcnN0IEJlemllciBjb250cm9sIHBvaW50cy5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSByaHMgUmlnaHQgaGFuZCBzaWRlIHZlY3Rvci5cbiAgICAvLyBAcmV0dXJuIFNvbHV0aW9uIHZlY3Rvci5cbiAgICBnZXRGaXJzdENvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKHJocykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBuID0gcmhzLmxlbmd0aDtcbiAgICAgICAgLy8gYHhgIGlzIGEgc29sdXRpb24gdmVjdG9yLlxuICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgIHZhciBiID0gMi4wO1xuXG4gICAgICAgIHhbMF0gPSByaHNbMF0gLyBiO1xuXG4gICAgICAgIC8vIERlY29tcG9zaXRpb24gYW5kIGZvcndhcmQgc3Vic3RpdHV0aW9uLlxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gMSAvIGI7XG4gICAgICAgICAgICBiID0gKGkgPCBuIC0gMSA/IDQuMCA6IDMuNSkgLSB0bXBbaV07XG4gICAgICAgICAgICB4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBCYWNrc3Vic3RpdHV0aW9uLlxuICAgICAgICAgICAgeFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAvLyBTb2x2ZXMgYW4gaW52ZXJzaW9uIHByb2JsZW0gLS0gR2l2ZW4gdGhlICh4LCB5KSBjb29yZGluYXRlcyBvZiBhIHBvaW50IHdoaWNoIGxpZXMgb25cbiAgICAvLyBhIHBhcmFtZXRyaWMgY3VydmUgeCA9IHgodCkvdyh0KSwgeSA9IHkodCkvdyh0KSwg76yBbmQgdGhlIHBhcmFtZXRlciB2YWx1ZSB0XG4gICAgLy8gd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhhdCBwb2ludC5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBjb250cm9sIHBvaW50cyAoc3RhcnQsIGNvbnRyb2wgc3RhcnQsIGNvbnRyb2wgZW5kLCBlbmQpXG4gICAgLy8gQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHBvaW50IGFuZCByZXR1cm5zIHQuXG4gICAgZ2V0SW52ZXJzaW9uU29sdmVyOiBmdW5jdGlvbihwMCwgcDEsIHAyLCBwMykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZShwMCwgcDEsIHAyLCBwMyk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNvbHZlSW52ZXJzaW9uKHApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLmNsb3Nlc3RQb2ludFQocCk7XG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJQYXRoIiwiQ3VydmUiLCJQb2ludCIsImJlemllciIsImN1cnZlVGhyb3VnaFBvaW50cyIsInBvaW50cyIsImNvbnNvbGUiLCJ3YXJuIiwidGhyb3VnaFBvaW50cyIsInNlcmlhbGl6ZSIsImdldEN1cnZlQ29udHJvbFBvaW50cyIsImtub3RzIiwiZmlyc3RDb250cm9sUG9pbnRzIiwic2Vjb25kQ29udHJvbFBvaW50cyIsIm4iLCJsZW5ndGgiLCJpIiwieCIsInkiLCJyaHMiLCJnZXRGaXJzdENvbnRyb2xQb2ludHMiLCJwdXNoIiwiZ2V0Q3VydmVEaXZpZGVyIiwicDAiLCJwMSIsInAyIiwicDMiLCJjdXJ2ZSIsImRpdmlkZUN1cnZlIiwidCIsImRpdmlkZWQiLCJkaXZpZGUiLCJzdGFydCIsImNvbnRyb2xQb2ludDEiLCJjb250cm9sUG9pbnQyIiwiZW5kIiwidG1wIiwiYiIsImdldEludmVyc2lvblNvbHZlciIsInNvbHZlSW52ZXJzaW9uIiwicCIsImNsb3Nlc3RQb2ludFQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/bezier.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/curve.mjs":
/*!**********************************************!*\
  !*** ./node_modules/jointjs/src/g/curve.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n\n\n\n\n\nconst { abs, sqrt, min, max, pow } = Math;\nconst Curve = function(p1, p2, p3, p4) {\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n    this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p3);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p4);\n};\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = function() {\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n            return [\n                firstControlPoints,\n                secondControlPoints\n            ];\n        }\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n        // Set right hand side X values.\n        for(i = 1; i < n - 1; i++){\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n        // Set right hand side Y values.\n        for(i = 1; i < n - 1; ++i){\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n        // Fill output arrays.\n        for(i = 0; i < n; i++){\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x[i], y[i]));\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n        }\n        return [\n            firstControlPoints,\n            secondControlPoints\n        ];\n    }\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n        x[0] = rhs[0] / b;\n        // Decomposition and forward substitution.\n        for(var i = 1; i < n; i++){\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n        for(i = 1; i < n; i++){\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n        return x;\n    }\n    return function(points) {\n        if (!points || Array.isArray(points) && points.length < 2) {\n            throw new Error(\"At least 2 points are required\");\n        }\n        var controlPoints = getCurveControlPoints(points);\n        var curves = [];\n        var n = controlPoints[0].length;\n        for(var i = 0; i < n; i++){\n            var controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[1][i].x, controlPoints[1][i].y);\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n        return curves;\n    };\n}();\nCurve.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Curve,\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [\n            new Array(),\n            new Array()\n        ];\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n        for(var i = 0; i < 2; ++i){\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) tvalues.push(t);\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n            if (b2ac < 0) continue;\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) tvalues.push(t1);\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) tvalues.push(t2);\n        }\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n            points[j] = {\n                X: x,\n                Y: y\n            };\n        }\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n        points[jlen] = {\n            X: x0,\n            Y: y0\n        };\n        points[jlen + 1] = {\n            X: x3,\n            Y: y3\n        };\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, right - left, bottom - top);\n    },\n    clone: function() {\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n    closestPointLength: function(p, opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        var localOpt = {\n            precision: precision,\n            subdivisions: subdivisions\n        };\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n    closestPointNormalizedLength: function(p, opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        var localOpt = {\n            precision: precision,\n            subdivisions: subdivisions\n        };\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n        return cpLength / length;\n    },\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        // does not use localOpt\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = n ? 1 / n : 0;\n        for(var i = 0; i < n; i++){\n            var currentSubdivision = subdivisions[i];\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || sumDist < minSumDist) {\n                investigatedSubdivision = currentSubdivision;\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n                distFromStart = startDist;\n                distFromEnd = endDist;\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n                minSumDist = sumDist;\n            }\n        }\n        var precisionRatio = pow(10, -precision);\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while(true){\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n            var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n            var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n            var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n            var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n            }\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n            } else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n    closestPointTangent: function(p, opt) {\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n        var t = this.tAt(ratio, opt);\n        return this.divideAtT(t);\n    },\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n        var t = this.tAtLength(length, opt);\n        return this.divideAtT(t);\n    },\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n        var dividerPoints = this.getSkeletonPoints(t);\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n        return this.start.distance(this.end);\n    },\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n        return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n    },\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n        var midpoint1 = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(start, control1).pointAt(t);\n        var midpoint2 = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control1, control2).pointAt(t);\n        var midpoint3 = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control2, end).pointAt(t);\n        var subControl1 = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint1, midpoint2).pointAt(t);\n        var subControl2 = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint2, midpoint3).pointAt(t);\n        var divider = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(subControl1, subControl2).pointAt(t);\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n        return output;\n    },\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n        var subdivisions = [\n            new Curve(start, control1, control2, end)\n        ];\n        if (precision === 0) return subdivisions;\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n        var previousLength = this.endpointDistance();\n        var precisionRatio = pow(10, -precision);\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;\n        if (isLine) {\n            minIterations = 2 * precision;\n        }\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while(true){\n            iteration += 1;\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for(var i = 0; i < numSubdivisions; i++){\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for(var j = 0; j < numNewSubdivisions; j++){\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n    isDifferentiable: function() {\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        // not using localOpt\n        var length = 0;\n        var n = subdivisions.length;\n        for(var i = 0; i < n; i++){\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n        return length;\n    },\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n        if (t <= 0) return 0;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({\n            precision: precision\n        });\n        return subCurveLength;\n    },\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n        var t = this.tAt(ratio, opt);\n        return this.pointAtT(t);\n    },\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n        var t = this.tAtLength(length, opt);\n        return this.pointAtT(t);\n    },\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n        return this.getSkeletonPoints(t).divider;\n    },\n    // Default precision\n    PRECISION: 3,\n    round: function(precision) {\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n        if (!this.isDifferentiable()) return null;\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n        var t = this.tAt(ratio, opt);\n        return this.tangentAtT(t);\n    },\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n        if (!this.isDifferentiable()) return null;\n        var t = this.tAtLength(length, opt);\n        return this.tangentAtT(t);\n    },\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n        if (!this.isDifferentiable()) return null;\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n        var skeletonPoints = this.getSkeletonPoints(t);\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n        var tangentStart = skeletonPoints.divider;\n        var tangentLine = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n        return tangentLine;\n    },\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        var localOpt = {\n            precision: precision,\n            subdivisions: subdivisions\n        };\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n        return this.tAtLength(length, localOpt);\n    },\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        var localOpt = {\n            precision: precision,\n            subdivisions: subdivisions\n        };\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for(var i = 0; i < n; i++){\n            var index = fromStart ? i : n - 1 - i;\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n            if (length <= l + d) {\n                investigatedSubdivision = currentSubdivision;\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n                baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n                baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n                break;\n            }\n            l += d;\n        }\n        if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n        var curveLength = this.length(localOpt);\n        var precisionRatio = pow(10, -precision);\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while(true){\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n            if (baselinePointDistFromStart <= baseline1Length) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n            } else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n            precision: precision\n        }) : opt.subdivisions;\n        // not using localOpt\n        var points = [\n            subdivisions[0].start.clone()\n        ];\n        var n = subdivisions.length;\n        for(var i = 0; i < n; i++){\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n        return points;\n    },\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n        return new _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__.Polyline(this.toPoints(opt));\n    },\n    toString: function() {\n        return this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n    },\n    translate: function(tx, ty) {\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\nCurve.prototype.divide = Curve.prototype.divideAtT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9jdXJ2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ0Y7QUFDQTtBQUNRO0FBQ047QUFFcEMsTUFBTSxFQUNGSyxHQUFHLEVBQ0hDLElBQUksRUFDSkMsR0FBRyxFQUNIQyxHQUFHLEVBQ0hDLEdBQUcsRUFDTixHQUFHQztBQUVHLE1BQU1DLFFBQVEsU0FBU0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRTtJQUV4QyxJQUFJLENBQUUsS0FBSSxZQUFZSixLQUFJLEdBQUk7UUFDMUIsT0FBTyxJQUFJQSxNQUFNQyxJQUFJQyxJQUFJQyxJQUFJQztJQUNqQztJQUVBLElBQUlILGNBQWNELE9BQU87UUFDckIsT0FBTyxJQUFJQSxNQUFNQyxHQUFHSSxLQUFLLEVBQUVKLEdBQUdLLGFBQWEsRUFBRUwsR0FBR00sYUFBYSxFQUFFTixHQUFHTyxHQUFHO0lBQ3pFO0lBRUEsSUFBSSxDQUFDSCxLQUFLLEdBQUcsSUFBSWhCLDZDQUFLQSxDQUFDWTtJQUN2QixJQUFJLENBQUNLLGFBQWEsR0FBRyxJQUFJakIsNkNBQUtBLENBQUNhO0lBQy9CLElBQUksQ0FBQ0ssYUFBYSxHQUFHLElBQUlsQiw2Q0FBS0EsQ0FBQ2M7SUFDL0IsSUFBSSxDQUFDSyxHQUFHLEdBQUcsSUFBSW5CLDZDQUFLQSxDQUFDZTtBQUN6QixFQUFFO0FBRUYsZ0NBQWdDO0FBQ2hDLHFJQUFxSTtBQUNySSwrRUFBK0U7QUFDL0UsMEJBQTBCO0FBQzFCSixNQUFNUyxhQUFhLEdBQUc7SUFFbEIsK0NBQStDO0lBQy9DLHVFQUF1RTtJQUN2RSwyRkFBMkY7SUFDM0YsNkZBQTZGO0lBQzdGLFNBQVNDLHNCQUFzQkMsS0FBSztRQUVoQyxJQUFJQyxxQkFBcUIsRUFBRTtRQUMzQixJQUFJQyxzQkFBc0IsRUFBRTtRQUM1QixJQUFJQyxJQUFJSCxNQUFNSSxNQUFNLEdBQUc7UUFDdkIsSUFBSUM7UUFFSix3REFB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QzVDLElBQUk5QyxJQUFJd0QsYUFBYXZELE1BQU07UUFDM0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLEdBQUdFLElBQUs7WUFFeEIsSUFBSW9FLHFCQUFxQmQsWUFBWSxDQUFDdEQsRUFBRTtZQUN4Q1EsT0FBT0gsSUFBSSxDQUFDK0QsbUJBQW1CNUUsR0FBRyxDQUFDb0QsS0FBSztRQUM1QztRQUVBLE9BQU9wQztJQUNYO0lBRUEsNEhBQTRIO0lBQzVILGdGQUFnRjtJQUNoRm9GLFlBQVksU0FBUzdDLEdBQUc7UUFFcEIsT0FBTyxJQUFJdkUsbURBQVFBLENBQUMsSUFBSSxDQUFDc0wsUUFBUSxDQUFDL0c7SUFDdEM7SUFFQWdILFVBQVU7UUFFTixPQUFPLElBQUksQ0FBQzFLLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQ0MsYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDQyxhQUFhLEdBQUcsTUFBTSxJQUFJLENBQUNDLEdBQUc7SUFDNUY7SUFFQTBKLFdBQVcsU0FBU2MsRUFBRSxFQUFFQyxFQUFFO1FBRXRCLElBQUksQ0FBQzVLLEtBQUssQ0FBQzZKLFNBQVMsQ0FBQ2MsSUFBSUM7UUFDekIsSUFBSSxDQUFDM0ssYUFBYSxDQUFDNEosU0FBUyxDQUFDYyxJQUFJQztRQUNqQyxJQUFJLENBQUMxSyxhQUFhLENBQUMySixTQUFTLENBQUNjLElBQUlDO1FBQ2pDLElBQUksQ0FBQ3pLLEdBQUcsQ0FBQzBKLFNBQVMsQ0FBQ2MsSUFBSUM7UUFDdkIsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUVBakwsTUFBTThCLFNBQVMsQ0FBQ21FLE1BQU0sR0FBR2pHLE1BQU04QixTQUFTLENBQUNpRixTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9jdXJ2ZS5tanM/OTRhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICcuL2xpbmUubWpzJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi9wb2x5bGluZS5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBhYnMsXG4gICAgc3FydCxcbiAgICBtaW4sXG4gICAgbWF4LFxuICAgIHBvd1xufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBDdXJ2ZSA9IGZ1bmN0aW9uKHAxLCBwMiwgcDMsIHA0KSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VydmUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUocDEsIHAyLCBwMywgcDQpO1xuICAgIH1cblxuICAgIGlmIChwMSBpbnN0YW5jZW9mIEN1cnZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUocDEuc3RhcnQsIHAxLmNvbnRyb2xQb2ludDEsIHAxLmNvbnRyb2xQb2ludDIsIHAxLmVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludChwMSk7XG4gICAgdGhpcy5jb250cm9sUG9pbnQxID0gbmV3IFBvaW50KHAyKTtcbiAgICB0aGlzLmNvbnRyb2xQb2ludDIgPSBuZXcgUG9pbnQocDMpO1xuICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KHA0KTtcbn07XG5cbi8vIEN1cnZlIHBhc3NpbmcgdGhyb3VnaCBwb2ludHMuXG4vLyBQb3J0ZWQgZnJvbSBDIyBpbXBsZW1lbnRhdGlvbiBieSBPbGVnIFYuIFBvbGlrYXJwb3RjaGtpbiBhbmQgUGV0ZXIgTGVlIChodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9LQi9ncmFwaGljcy9CZXppZXJTcGxpbmUuYXNweCkuXG4vLyBAcGFyYW0ge2FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzIHRocm91Z2ggd2hpY2ggdGhlIHNtb290aCBsaW5lIHdpbGwgZ28uXG4vLyBAcmV0dXJuIHthcnJheX0gY3VydmVzLlxuQ3VydmUudGhyb3VnaFBvaW50cyA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIEdldCBvcGVuLWVuZGVkIEJlemllciBTcGxpbmUgQ29udHJvbCBQb2ludHMuXG4gICAgLy8gQHBhcmFtIGtub3RzIElucHV0IEtub3QgQmV6aWVyIHNwbGluZSBwb2ludHMgKEF0IGxlYXN0IHR3byBwb2ludHMhKS5cbiAgICAvLyBAcGFyYW0gZmlyc3RDb250cm9sUG9pbnRzIE91dHB1dCBGaXJzdCBDb250cm9sIHBvaW50cy4gQXJyYXkgb2Yga25vdHMubGVuZ3RoIC0gMSBsZW5ndGguXG4gICAgLy8gQHBhcmFtIHNlY29uZENvbnRyb2xQb2ludHMgT3V0cHV0IFNlY29uZCBDb250cm9sIHBvaW50cy4gQXJyYXkgb2Yga25vdHMubGVuZ3RoIC0gMSBsZW5ndGguXG4gICAgZnVuY3Rpb24gZ2V0Q3VydmVDb250cm9sUG9pbnRzKGtub3RzKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0Q29udHJvbFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc2Vjb25kQ29udHJvbFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgbiA9IGtub3RzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogQmV6aWVyIGN1cnZlIHNob3VsZCBiZSBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgIGlmIChuID09IDEpIHtcbiAgICAgICAgICAgIC8vIDNQMSA9IDJQMCArIFAzXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMF0gPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgKDIgKiBrbm90c1swXS54ICsga25vdHNbMV0ueCkgLyAzLFxuICAgICAgICAgICAgICAgICgyICoga25vdHNbMF0ueSArIGtub3RzWzFdLnkpIC8gM1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUDIgPSAyUDEg4oCTIFAwXG4gICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzWzBdID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIDIgKiBmaXJzdENvbnRyb2xQb2ludHNbMF0ueCAtIGtub3RzWzBdLngsXG4gICAgICAgICAgICAgICAgMiAqIGZpcnN0Q29udHJvbFBvaW50c1swXS55IC0ga25vdHNbMF0ueVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtmaXJzdENvbnRyb2xQb2ludHMsIHNlY29uZENvbnRyb2xQb2ludHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZpcnN0IEJlemllciBjb250cm9sIHBvaW50cy5cbiAgICAgICAgLy8gUmlnaHQgaGFuZCBzaWRlIHZlY3Rvci5cbiAgICAgICAgdmFyIHJocyA9IFtdO1xuXG4gICAgICAgIC8vIFNldCByaWdodCBoYW5kIHNpZGUgWCB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICByaHNbaV0gPSA0ICoga25vdHNbaV0ueCArIDIgKiBrbm90c1tpICsgMV0ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJoc1swXSA9IGtub3RzWzBdLnggKyAyICoga25vdHNbMV0ueDtcbiAgICAgICAgcmhzW24gLSAxXSA9ICg4ICoga25vdHNbbiAtIDFdLnggKyBrbm90c1tuXS54KSAvIDIuMDtcblxuICAgICAgICAvLyBHZXQgZmlyc3QgY29udHJvbCBwb2ludHMgWC12YWx1ZXMuXG4gICAgICAgIHZhciB4ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cbiAgICAgICAgLy8gU2V0IHJpZ2h0IGhhbmQgc2lkZSBZIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS55ICsgMiAqIGtub3RzW2kgKyAxXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmhzWzBdID0ga25vdHNbMF0ueSArIDIgKiBrbm90c1sxXS55O1xuICAgICAgICByaHNbbiAtIDFdID0gKDggKiBrbm90c1tuIC0gMV0ueSArIGtub3RzW25dLnkpIC8gMi4wO1xuXG4gICAgICAgIC8vIEdldCBmaXJzdCBjb250cm9sIHBvaW50cyBZLXZhbHVlcy5cbiAgICAgICAgdmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAvLyBGaWxsIG91dHB1dCBhcnJheXMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoeFtpXSwgeVtpXSkpO1xuXG4gICAgICAgICAgICAvLyBTZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAgIGlmIChpIDwgbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAyICoga25vdHMgW2kgKyAxXS54IC0geFtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIDIgKiBrbm90c1tpICsgMV0ueSAtIHlbaSArIDFdXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgKGtub3RzW25dLnggKyB4W24gLSAxXSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0ueSArIHlbbiAtIDFdKSAvIDJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250cm9sUG9pbnRzLCBzZWNvbmRDb250cm9sUG9pbnRzXTtcbiAgICB9XG5cbiAgICAvLyBTb2x2ZXMgYSB0cmlkaWFnb25hbCBzeXN0ZW0gZm9yIG9uZSBvZiBjb29yZGluYXRlcyAoeCBvciB5KSBvZiBmaXJzdCBCZXppZXIgY29udHJvbCBwb2ludHMuXG4gICAgLy8gQHBhcmFtIHJocyBSaWdodCBoYW5kIHNpZGUgdmVjdG9yLlxuICAgIC8vIEByZXR1cm4gU29sdXRpb24gdmVjdG9yLlxuICAgIGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblxuICAgICAgICB2YXIgbiA9IHJocy5sZW5ndGg7XG4gICAgICAgIC8vIGB4YCBpcyBhIHNvbHV0aW9uIHZlY3Rvci5cbiAgICAgICAgdmFyIHggPSBbXTtcbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICB2YXIgYiA9IDIuMDtcblxuICAgICAgICB4WzBdID0gcmhzWzBdIC8gYjtcblxuICAgICAgICAvLyBEZWNvbXBvc2l0aW9uIGFuZCBmb3J3YXJkIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRtcFtpXSA9IDEgLyBiO1xuICAgICAgICAgICAgYiA9IChpIDwgbiAtIDEgPyA0LjAgOiAzLjUpIC0gdG1wW2ldO1xuICAgICAgICAgICAgeFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgLy8gQmFja3N1YnN0aXR1dGlvbi5cbiAgICAgICAgICAgIHhbbiAtIGkgLSAxXSAtPSB0bXBbbiAtIGldICogeFtuIC0gaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgICAgaWYgKCFwb2ludHMgfHwgKEFycmF5LmlzQXJyYXkocG9pbnRzKSAmJiBwb2ludHMubGVuZ3RoIDwgMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3QgMiBwb2ludHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IGdldEN1cnZlQ29udHJvbFBvaW50cyhwb2ludHMpO1xuXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBjb250cm9sUG9pbnRzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludDEgPSBuZXcgUG9pbnQoY29udHJvbFBvaW50c1swXVtpXS54LCBjb250cm9sUG9pbnRzWzBdW2ldLnkpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludDIgPSBuZXcgUG9pbnQoY29udHJvbFBvaW50c1sxXVtpXS54LCBjb250cm9sUG9pbnRzWzFdW2ldLnkpO1xuXG4gICAgICAgICAgICBjdXJ2ZXMucHVzaChuZXcgQ3VydmUocG9pbnRzW2ldLCBjb250cm9sUG9pbnQxLCBjb250cm9sUG9pbnQyLCBwb2ludHNbaSArIDFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgIH07XG59KSgpO1xuXG5DdXJ2ZS5wcm90b3R5cGUgPSB7XG5cbiAgICB0eXBlOiB0eXBlcy5DdXJ2ZSxcblxuICAgIC8vIFJldHVybnMgYSBiYm94IHRoYXQgdGlnaHRseSBlbnZlbG9wcyB0aGUgY3VydmUuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnQyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgdmFyIHgwID0gc3RhcnQueDtcbiAgICAgICAgdmFyIHkwID0gc3RhcnQueTtcbiAgICAgICAgdmFyIHgxID0gY29udHJvbFBvaW50MS54O1xuICAgICAgICB2YXIgeTEgPSBjb250cm9sUG9pbnQxLnk7XG4gICAgICAgIHZhciB4MiA9IGNvbnRyb2xQb2ludDIueDtcbiAgICAgICAgdmFyIHkyID0gY29udHJvbFBvaW50Mi55O1xuICAgICAgICB2YXIgeDMgPSBlbmQueDtcbiAgICAgICAgdmFyIHkzID0gZW5kLnk7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheSgpOyAvLyBsb2NhbCBleHRyZW1lc1xuICAgICAgICB2YXIgdHZhbHVlcyA9IG5ldyBBcnJheSgpOyAvLyB0IHZhbHVlcyBvZiBsb2NhbCBleHRyZW1lc1xuICAgICAgICB2YXIgYm91bmRzID0gW25ldyBBcnJheSgpLCBuZXcgQXJyYXkoKV07XG5cbiAgICAgICAgdmFyIGEsIGIsIGMsIHQ7XG4gICAgICAgIHZhciB0MSwgdDI7XG4gICAgICAgIHZhciBiMmFjLCBzcXJ0YjJhYztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgICAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgICAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7IC8vIE51bWVyaWNhbCByb2J1c3RuZXNzXG4gICAgICAgICAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7IC8vIE51bWVyaWNhbCByb2J1c3RuZXNzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKCgwIDwgdCkgJiYgKHQgPCAxKSkgdHZhbHVlcy5wdXNoKHQpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgICAgICAgIHNxcnRiMmFjID0gc3FydChiMmFjKTtcblxuICAgICAgICAgICAgaWYgKGIyYWMgPCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKCgwIDwgdDEpICYmICh0MSA8IDEpKSB0dmFsdWVzLnB1c2godDEpO1xuXG4gICAgICAgICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgICAgICBpZiAoKDAgPCB0MikgJiYgKHQyIDwgMSkpIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IHR2YWx1ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgamxlbiA9IGo7XG4gICAgICAgIHZhciBtdDtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuXG4gICAgICAgICAgICB4ID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgICAgICAgYm91bmRzWzBdW2pdID0geDtcblxuICAgICAgICAgICAgeSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICAgICAgICAgIGJvdW5kc1sxXVtqXSA9IHk7XG5cbiAgICAgICAgICAgIHBvaW50c1tqXSA9IHsgWDogeCwgWTogeSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHZhbHVlc1tqbGVuXSA9IDA7XG4gICAgICAgIHR2YWx1ZXNbamxlbiArIDFdID0gMTtcblxuICAgICAgICBwb2ludHNbamxlbl0gPSB7IFg6IHgwLCBZOiB5MCB9O1xuICAgICAgICBwb2ludHNbamxlbiArIDFdID0geyBYOiB4MywgWTogeTMgfTtcblxuICAgICAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICAgICAgYm91bmRzWzFdW2psZW5dID0geTA7XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgICAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG5cbiAgICAgICAgdHZhbHVlcy5sZW5ndGggPSBqbGVuICsgMjtcbiAgICAgICAgYm91bmRzWzBdLmxlbmd0aCA9IGpsZW4gKyAyO1xuICAgICAgICBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG4gICAgICAgIHBvaW50cy5sZW5ndGggPSBqbGVuICsgMjtcblxuICAgICAgICB2YXIgbGVmdCA9IG1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pO1xuICAgICAgICB2YXIgdG9wID0gbWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gICAgICAgIHZhciByaWdodCA9IG1heC5hcHBseShudWxsLCBib3VuZHNbMF0pO1xuICAgICAgICB2YXIgYm90dG9tID0gbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGxlZnQsIHRvcCwgKHJpZ2h0IC0gbGVmdCksIChib3R0b20gLSB0b3ApKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUodGhpcy5zdGFydCwgdGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIGN1cnZlIGNsb3Nlc3QgdG8gcG9pbnQgYHBgXG4gICAgY2xvc2VzdFBvaW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0VCh0aGlzLmNsb3Nlc3RQb2ludFQocCwgb3B0KSk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aEF0VCh0aGlzLmNsb3Nlc3RQb2ludFQocCwgbG9jYWxPcHQpLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGg6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICB2YXIgY3BMZW5ndGggPSB0aGlzLmNsb3Nlc3RQb2ludExlbmd0aChwLCBsb2NhbE9wdCk7XG4gICAgICAgIGlmICghY3BMZW5ndGgpIHJldHVybiAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAwO1xuXG4gICAgICAgIHJldHVybiBjcExlbmd0aCAvIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdGAgb2YgdGhlIHBvaW50IG9uIHRoZSBjdXJ2ZSBjbG9zZXN0IHRvIHBvaW50IGBwYFxuICAgIGNsb3Nlc3RQb2ludFQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gZG9lcyBub3QgdXNlIGxvY2FsT3B0XG5cbiAgICAgICAgLy8gaWRlbnRpZnkgdGhlIHN1YmRpdmlzaW9uIHRoYXQgY29udGFpbnMgdGhlIHBvaW50OlxuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb247XG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VDsgLy8gYXNzdW1lIHRoYXQgc3ViZGl2aXNpb25zIGFyZSBldmVubHkgc3BhY2VkXG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQ7XG4gICAgICAgIHZhciBkaXN0RnJvbVN0YXJ0OyAvLyBkaXN0YW5jZSBvZiBwb2ludCBmcm9tIHN0YXJ0IG9mIGJhc2VsaW5lXG4gICAgICAgIHZhciBkaXN0RnJvbUVuZDsgLy8gZGlzdGFuY2Ugb2YgcG9pbnQgZnJvbSBlbmQgb2YgYmFzZWxpbmVcbiAgICAgICAgdmFyIGNob3JkTGVuZ3RoOyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHN1YmRpdmlzaW9uXG4gICAgICAgIHZhciBtaW5TdW1EaXN0OyAvLyBsb3dlc3Qgb2JzZXJ2ZWQgc3VtIG9mIHRoZSB0d28gZGlzdGFuY2VzXG4gICAgICAgIHZhciBuID0gc3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9uU2l6ZSA9IChuID8gKDEgLyBuKSA6IDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb25zW2ldO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnREaXN0ID0gY3VycmVudFN1YmRpdmlzaW9uLnN0YXJ0LmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIGVuZERpc3QgPSBjdXJyZW50U3ViZGl2aXNpb24uZW5kLmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIHN1bURpc3QgPSBzdGFydERpc3QgKyBlbmREaXN0O1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBwb2ludCBpcyBjbG9zZXN0IHRvIGN1cnJlbnQgc3ViZGl2aXNpb24gYW5kIG5vdCBhbnkgb3RoZXJcbiAgICAgICAgICAgIGlmICghbWluU3VtRGlzdCB8fCAoc3VtRGlzdCA8IG1pblN1bURpc3QpKSB7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBjdXJyZW50U3ViZGl2aXNpb247XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VCA9IGkgKiBzdWJkaXZpc2lvblNpemU7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUID0gKGkgKyAxKSAqIHN1YmRpdmlzaW9uU2l6ZTtcblxuICAgICAgICAgICAgICAgIGRpc3RGcm9tU3RhcnQgPSBzdGFydERpc3Q7XG4gICAgICAgICAgICAgICAgZGlzdEZyb21FbmQgPSBlbmREaXN0O1xuXG4gICAgICAgICAgICAgICAgY2hvcmRMZW5ndGggPSBjdXJyZW50U3ViZGl2aXNpb24uc3RhcnQuZGlzdGFuY2UoY3VycmVudFN1YmRpdmlzaW9uLmVuZCk7XG5cbiAgICAgICAgICAgICAgICBtaW5TdW1EaXN0ID0gc3VtRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVjaXNpb25SYXRpbyA9IHBvdygxMCwgLXByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZGl2aWRlIGludmVzdGlnYXRlZCBzdWJkaXZpc2lvbjpcbiAgICAgICAgLy8gdW50aWwgZGlzdGFuY2UgYmV0d2VlbiBiYXNlbGluZVBvaW50IGFuZCBjbG9zZXN0IHBhdGggZW5kcG9pbnQgaXMgd2l0aGluIDEwXigtcHJlY2lzaW9uKVxuICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgY2xvc2VzdCBlbmRwb2ludCBvZiB0aGF0IGZpbmFsIHN1YmRpdmlzaW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgb2JzZXJ2ZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICAvLyAtIGNhbGN1bGF0ZWQgYXM6IHRoZSBkaWZmZXJlbmNlIGluIGRpc3RhbmNlcyBmcm9tIHBvaW50IHRvIHN0YXJ0IGFuZCBlbmQgZGl2aWRlZCBieSB0aGUgZGlzdGFuY2VcbiAgICAgICAgICAgIC8vIC0gbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgbm90IG1vbm90b25pYyA9IGl0IGRvZXNuJ3QgY29udmVyZ2Ugc3RhYmx5IGJ1dCBoYXMgXCJ0ZWV0aFwiXG4gICAgICAgICAgICAvLyAtIHRoZSBmdW5jdGlvbiBkZWNyZWFzZXMgd2hpbGUgb25lIG9mIHRoZSBlbmRwb2ludHMgaXMgZml4ZWQgYnV0IFwianVtcHNcIiB3aGVuZXZlciB3ZSBzd2l0Y2hcbiAgICAgICAgICAgIC8vIC0gdGhpcyBjcml0ZXJpb24gd29ya3Mgd2VsbCBmb3IgcG9pbnRzIGx5aW5nIGZhciBhd2F5IGZyb20gdGhlIGN1cnZlXG4gICAgICAgICAgICB2YXIgc3RhcnRQcmVjaXNpb25SYXRpbyA9IChkaXN0RnJvbVN0YXJ0ID8gKGFicyhkaXN0RnJvbVN0YXJ0IC0gZGlzdEZyb21FbmQpIC8gZGlzdEZyb21TdGFydCkgOiAwKTtcbiAgICAgICAgICAgIHZhciBlbmRQcmVjaXNpb25SYXRpbyA9IChkaXN0RnJvbUVuZCA/IChhYnMoZGlzdEZyb21TdGFydCAtIGRpc3RGcm9tRW5kKSAvIGRpc3RGcm9tRW5kKSA6IDApO1xuICAgICAgICAgICAgdmFyIGhhc1JlcXVpcmVkUHJlY2lzaW9uID0gKChzdGFydFByZWNpc2lvblJhdGlvIDwgcHJlY2lzaW9uUmF0aW8pIHx8IChlbmRQcmVjaXNpb25SYXRpbyA8IHByZWNpc2lvblJhdGlvKSk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWluaW1hbCBkaXN0YW5jZVxuICAgICAgICAgICAgLy8gLSBjYWxjdWxhdGVkIGFzOiB0aGUgc3ViZGl2aXNpb24gY2hvcmQgbGVuZ3RoIG11bHRpcGxpZWQgYnkgcHJlY2lzaW9uUmF0aW9cbiAgICAgICAgICAgIC8vIC0gY2FsY3VsYXRpb24gaXMgcmVsYXRpdmUgc28gaXQgd2lsbCB3b3JrIGZvciBhcmJpdHJhcmlseSBsYXJnZS9zbWFsbCBjdXJ2ZXMgYW5kIHRoZWlyIHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgLy8gLSB0aGlzIGlzIGEgYmFja3VwIGNyaXRlcmlvbiB0aGF0IHdvcmtzIHdlbGwgZm9yIHBvaW50cyBseWluZyBcImFsbW9zdCBhdFwiIHRoZSBjdXJ2ZVxuICAgICAgICAgICAgdmFyIGhhc01pbmltYWxTdGFydERpc3RhbmNlID0gKGRpc3RGcm9tU3RhcnQgPyAoZGlzdEZyb21TdGFydCA8IChjaG9yZExlbmd0aCAqIHByZWNpc2lvblJhdGlvKSkgOiB0cnVlKTtcbiAgICAgICAgICAgIHZhciBoYXNNaW5pbWFsRW5kRGlzdGFuY2UgPSAoZGlzdEZyb21FbmQgPyAoZGlzdEZyb21FbmQgPCAoY2hvcmRMZW5ndGggKiBwcmVjaXNpb25SYXRpbykpIDogdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgaGFzTWluaW1hbERpc3RhbmNlID0gKGhhc01pbmltYWxTdGFydERpc3RhbmNlIHx8IGhhc01pbmltYWxFbmREaXN0YW5jZSk7XG5cbiAgICAgICAgICAgIC8vIGRvIHdlIHN0b3Agbm93P1xuICAgICAgICAgICAgaWYgKGhhc1JlcXVpcmVkUHJlY2lzaW9uIHx8IGhhc01pbmltYWxEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGRpc3RGcm9tU3RhcnQgPD0gZGlzdEZyb21FbmQpID8gaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQgOiBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCB1cCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhciBkaXZpZGVkID0gaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24uZGl2aWRlKDAuNSk7XG4gICAgICAgICAgICBzdWJkaXZpc2lvblNpemUgLz0gMjtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0RGlzdDEgPSBkaXZpZGVkWzBdLnN0YXJ0LmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIGVuZERpc3QxID0gZGl2aWRlZFswXS5lbmQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgc3VtRGlzdDEgPSBzdGFydERpc3QxICsgZW5kRGlzdDE7XG5cbiAgICAgICAgICAgIHZhciBzdGFydERpc3QyID0gZGl2aWRlZFsxXS5zdGFydC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBlbmREaXN0MiA9IGRpdmlkZWRbMV0uZW5kLmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIHN1bURpc3QyID0gc3RhcnREaXN0MiArIGVuZERpc3QyO1xuXG4gICAgICAgICAgICBpZiAoc3VtRGlzdDEgPD0gc3VtRGlzdDIpIHtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGRpdmlkZWRbMF07XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQgLT0gc3ViZGl2aXNpb25TaXplOyAvLyBzdWJkaXZpc2lvblNpemUgd2FzIGFscmVhZHkgaGFsdmVkXG5cbiAgICAgICAgICAgICAgICBkaXN0RnJvbVN0YXJ0ID0gc3RhcnREaXN0MTtcbiAgICAgICAgICAgICAgICBkaXN0RnJvbUVuZCA9IGVuZERpc3QxO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gZGl2aWRlZFsxXTtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUICs9IHN1YmRpdmlzaW9uU2l6ZTsgLy8gc3ViZGl2aXNpb25TaXplIHdhcyBhbHJlYWR5IGhhbHZlZFxuXG4gICAgICAgICAgICAgICAgZGlzdEZyb21TdGFydCA9IHN0YXJ0RGlzdDI7XG4gICAgICAgICAgICAgICAgZGlzdEZyb21FbmQgPSBlbmREaXN0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUYW5nZW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXRUKHRoaXMuY2xvc2VzdFBvaW50VChwLCBvcHQpKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZWEgc3Vycm91bmRlZCBieSB0aGUgY3VydmUgY29udGFpbnMgdGhlIHBvaW50IGBwYC5cbiAgICAvLyBJbXBsZW1lbnRzIHRoZSBldmVuLW9kZCBhbGdvcml0aG0gKHNlbGYtaW50ZXJzZWN0aW9ucyBhcmUgXCJvdXRzaWRlXCIpLlxuICAgIC8vIENsb3NlcyBvcGVuIGN1cnZlcyAoYWx3YXlzIGltYWdpbmVzIGEgY2xvc2luZyBzZWdtZW50KS5cbiAgICAvLyBQcmVjaXNpb24gbWF5IGJlIGFkanVzdGVkIGJ5IHBhc3NpbmcgYW4gYG9wdGAgb2JqZWN0LlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMudG9Qb2x5bGluZShvcHQpO1xuICAgICAgICByZXR1cm4gcG9seWxpbmUuY29udGFpbnNQb2ludChwKTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgY3VydmUgaW50byB0d28gYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gRm9yIGEgZnVuY3Rpb24gdGhhdCB1c2VzIGB0YCwgdXNlIEN1cnZlLmRpdmlkZUF0VCgpLlxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgaWYgKHJhdGlvIDw9IDApIHJldHVybiB0aGlzLmRpdmlkZUF0VCgwKTtcbiAgICAgICAgaWYgKHJhdGlvID49IDEpIHJldHVybiB0aGlzLmRpdmlkZUF0VCgxKTtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0KHJhdGlvLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgY3VydmUgaW50byB0d28gYXQgcmVxdWVzdGVkIGBsZW5ndGhgIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXRMZW5ndGgobGVuZ3RoLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgY3VydmUgaW50byB0d28gYXQgcG9pbnQgZGVmaW5lZCBieSBgdGAgYmV0d2VlbiAwIGFuZCAxLlxuICAgIC8vIFVzaW5nIGRlIENhc3RlbGphdSdzIGFsZ29yaXRobSAoaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8zMTc4NjcpLlxuICAgIC8vIEFkZGl0aW9uYWwgcmVzb3VyY2U6IGh0dHBzOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2RlY2FzdGVsamF1XG4gICAgZGl2aWRlQXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnQyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgLy8gc2hvcnRjdXRzIGZvciBgdGAgdmFsdWVzIHRoYXQgYXJlIG91dCBvZiByYW5nZVxuICAgICAgICBpZiAodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBDdXJ2ZShzdGFydCwgc3RhcnQsIHN0YXJ0LCBzdGFydCksXG4gICAgICAgICAgICAgICAgbmV3IEN1cnZlKHN0YXJ0LCBjb250cm9sUG9pbnQxLCBjb250cm9sUG9pbnQyLCBlbmQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgQ3VydmUoc3RhcnQsIGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIGVuZCksXG4gICAgICAgICAgICAgICAgbmV3IEN1cnZlKGVuZCwgZW5kLCBlbmQsIGVuZClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGl2aWRlclBvaW50cyA9IHRoaXMuZ2V0U2tlbGV0b25Qb2ludHModCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0Q29udHJvbDEgPSBkaXZpZGVyUG9pbnRzLnN0YXJ0Q29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIHN0YXJ0Q29udHJvbDIgPSBkaXZpZGVyUG9pbnRzLnN0YXJ0Q29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBkaXZpZGVyUG9pbnRzLmRpdmlkZXI7XG4gICAgICAgIHZhciBkaXZpZGVyQ29udHJvbDEgPSBkaXZpZGVyUG9pbnRzLmRpdmlkZXJDb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgZGl2aWRlckNvbnRyb2wyID0gZGl2aWRlclBvaW50cy5kaXZpZGVyQ29udHJvbFBvaW50MjtcblxuICAgICAgICAvLyByZXR1cm4gYXJyYXkgd2l0aCB0d28gbmV3IGN1cnZlc1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEN1cnZlKHN0YXJ0LCBzdGFydENvbnRyb2wxLCBzdGFydENvbnRyb2wyLCBkaXZpZGVyKSxcbiAgICAgICAgICAgIG5ldyBDdXJ2ZShkaXZpZGVyLCBkaXZpZGVyQ29udHJvbDEsIGRpdmlkZXJDb250cm9sMiwgZW5kKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJ2ZSdzIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLlxuICAgIGVuZHBvaW50RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIGN1cnZlcyBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGMpIHtcblxuICAgICAgICByZXR1cm4gISFjICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnggPT09IGMuc3RhcnQueCAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydC55ID09PSBjLnN0YXJ0LnkgJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MS54ID09PSBjLmNvbnRyb2xQb2ludDEueCAmJlxuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnkgPT09IGMuY29udHJvbFBvaW50MS55ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIueCA9PT0gYy5jb250cm9sUG9pbnQyLnggJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi55ID09PSBjLmNvbnRyb2xQb2ludDIueSAmJlxuICAgICAgICAgICAgdGhpcy5lbmQueCA9PT0gYy5lbmQueCAmJlxuICAgICAgICAgICAgdGhpcy5lbmQueSA9PT0gYy5lbmQueTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBmaXZlIGhlbHBlciBwb2ludHMgbmVjZXNzYXJ5IGZvciBjdXJ2ZSBkaXZpc2lvbi5cbiAgICBnZXRTa2VsZXRvblBvaW50czogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2wyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgLy8gc2hvcnRjdXRzIGZvciBgdGAgdmFsdWVzIHRoYXQgYXJlIG91dCBvZiByYW5nZVxuICAgICAgICBpZiAodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50MTogc3RhcnQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDI6IHN0YXJ0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlcjogc3RhcnQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MTogY29udHJvbDEuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MjogY29udHJvbDIuY2xvbmUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQxOiBjb250cm9sMS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50MjogY29udHJvbDIuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyOiBlbmQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MTogZW5kLmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDI6IGVuZC5jbG9uZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pZHBvaW50MSA9IChuZXcgTGluZShzdGFydCwgY29udHJvbDEpKS5wb2ludEF0KHQpO1xuICAgICAgICB2YXIgbWlkcG9pbnQyID0gKG5ldyBMaW5lKGNvbnRyb2wxLCBjb250cm9sMikpLnBvaW50QXQodCk7XG4gICAgICAgIHZhciBtaWRwb2ludDMgPSAobmV3IExpbmUoY29udHJvbDIsIGVuZCkpLnBvaW50QXQodCk7XG5cbiAgICAgICAgdmFyIHN1YkNvbnRyb2wxID0gKG5ldyBMaW5lKG1pZHBvaW50MSwgbWlkcG9pbnQyKSkucG9pbnRBdCh0KTtcbiAgICAgICAgdmFyIHN1YkNvbnRyb2wyID0gKG5ldyBMaW5lKG1pZHBvaW50MiwgbWlkcG9pbnQzKSkucG9pbnRBdCh0KTtcblxuICAgICAgICB2YXIgZGl2aWRlciA9IChuZXcgTGluZShzdWJDb250cm9sMSwgc3ViQ29udHJvbDIpKS5wb2ludEF0KHQpO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDE6IG1pZHBvaW50MSxcbiAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50Mjogc3ViQ29udHJvbDEsXG4gICAgICAgICAgICBkaXZpZGVyOiBkaXZpZGVyLFxuICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDE6IHN1YkNvbnRyb2wyLFxuICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDI6IG1pZHBvaW50M1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBsaXN0IG9mIGN1cnZlcyB3aG9zZSBmbGF0dGVuZWQgbGVuZ3RoIGlzIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYC5cbiAgICAvLyBUaGF0IGlzLCBvYnNlcnZlZCBkaWZmZXJlbmNlIGluIGxlbmd0aCBiZXR3ZWVuIHJlY3Vyc2lvbnMgaXMgbGVzcyB0aGFuIDEwXigtMykgPSAwLjAwMSA9IDAuMSVcbiAgICAvLyAoT2JzZXJ2ZWQgZGlmZmVyZW5jZSBpcyBub3QgcmVhbCBwcmVjaXNpb24sIGJ1dCBjbG9zZSBlbm91Z2ggYXMgbG9uZyBhcyBzcGVjaWFsIGNhc2VzIGFyZSBjb3ZlcmVkKVxuICAgIC8vIEFzIGEgcnVsZSBvZiB0aHVtYiwgaW5jcmVhc2luZyBgcHJlY2lzaW9uYCBieSAxIHJlcXVpcmVzIDIgbW9yZSBpdGVyYXRpb25zICg9IGxldmVscyBvZiBkaXZpc2lvbiBvcGVyYXRpb25zKVxuICAgIC8vIC0gUHJlY2lzaW9uIDAgKGVuZHBvaW50RGlzdGFuY2UpIC0gMCBpdGVyYXRpb25zID0+IHRvdGFsIG9mIDJeMCAtIDEgPSAwIG9wZXJhdGlvbnMgKDEgc3ViZGl2aXNpb24pXG4gICAgLy8gLSBQcmVjaXNpb24gMSAoPDEwJSBlcnJvcikgLSAyIGl0ZXJhdGlvbnMgPT4gdG90YWwgb2YgMl4yIC0gMSA9IDMgb3BlcmF0aW9ucyAoNCBzdWJkaXZpc2lvbnMpXG4gICAgLy8gLSBQcmVjaXNpb24gMiAoPDElIGVycm9yKSAtIDQgaXRlcmF0aW9ucyA9PiB0b3RhbCBvZiAyXjQgLSAxID0gMTUgb3BlcmF0aW9ucyByZXF1aXJlcyA0IGRpdmlzaW9uIG9wZXJhdGlvbnMgb24gYWxsIGVsZW1lbnRzICgxNSBvcGVyYXRpb25zIHRvdGFsKSAoMTYgc3ViZGl2aXNpb25zKVxuICAgIC8vIC0gUHJlY2lzaW9uIDMgKDwwLjElIGVycm9yKSAtIDYgaXRlcmF0aW9ucyA9PiB0b3RhbCBvZiAyXjYgLSAxID0gNjMgb3BlcmF0aW9ucyAtIGFjY2VwdGFibGUgd2hlbiBkcmF3aW5nICg2NCBzdWJkaXZpc2lvbnMpXG4gICAgLy8gLSBQcmVjaXNpb24gNCAoPDAuMDElIGVycm9yKSAtIDggaXRlcmF0aW9ucyA9PiB0b3RhbCBvZiAyXjggLSAxID0gMjU1IG9wZXJhdGlvbnMgLSBoaWdoIHJlc29sdXRpb24sIGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIGB0YCAoMjU2IHN1YmRpdmlzaW9ucylcbiAgICAvLyAoVmFyaWF0aW9uIG9mIDEgcmVjdXJzaW9uIHdvcnNlIG9yIGJldHRlciBpcyBwb3NzaWJsZSBkZXBlbmRpbmcgb24gdGhlIGN1cnZlLCBkb3VibGluZy9oYWx2aW5nIHRoZSBudW1iZXIgb2Ygb3BlcmF0aW9ucyBhY2NvcmRpbmdseSlcbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICAvLyBub3QgdXNpbmcgb3B0LnN1YmRpdmlzaW9uc1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sMiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBbbmV3IEN1cnZlKHN0YXJ0LCBjb250cm9sMSwgY29udHJvbDIsIGVuZCldO1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSAwKSByZXR1cm4gc3ViZGl2aXNpb25zO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSAjMTogcG9pbnQtbGlrZSBjdXJ2ZXNcbiAgICAgICAgLy8gLSBubyBuZWVkIHRvIGNhbGN1bGF0ZSBzdWJkaXZpc2lvbnMsIHRoZXkgd291bGQgYWxsIGJlIGlkZW50aWNhbFxuICAgICAgICB2YXIgaXNQb2ludCA9ICF0aGlzLmlzRGlmZmVyZW50aWFibGUoKTtcbiAgICAgICAgaWYgKGlzUG9pbnQpIHJldHVybiBzdWJkaXZpc2lvbnM7XG5cbiAgICAgICAgdmFyIHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbmRwb2ludERpc3RhbmNlKCk7XG5cbiAgICAgICAgdmFyIHByZWNpc2lvblJhdGlvID0gcG93KDEwLCAtcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgIzI6IHNpbmUtbGlrZSBjdXJ2ZXMgbWF5IGhhdmUgdGhlIHNhbWUgb2JzZXJ2ZWQgbGVuZ3RoIGluIGl0ZXJhdGlvbiAwIGFuZCAxIC0gc2tpcCBpdGVyYXRpb24gMVxuICAgICAgICAvLyAtIG5vdCBhIHByb2JsZW0gZm9yIGZ1cnRoZXIgaXRlcmF0aW9ucyBiZWNhdXNlIGN1YmljIGN1cnZlcyBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gdHdvIGxvY2FsIGV4dHJlbWFcbiAgICAgICAgLy8gLSAoaS5lLiBjdWJpYyBjdXJ2ZXMgY2Fubm90IGludGVyc2VjdCB0aGUgYmFzZWxpbmUgbW9yZSB0aGFuIG9uY2UpXG4gICAgICAgIC8vIC0gdGhlcmVmb3JlIHN0YXJ0aW5nIGZyb20gaXRlcmF0aW9uID0gMiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCBpdGVyYXRpb25zIGRvIG5vdCBwcm9kdWNlIHNhbXBsaW5nIHdpdGggZXF1YWwgbGVuZ3RoXG4gICAgICAgIC8vIC0gKHVubGVzcyBpdCdzIGEgc3RyYWlnaHQtbGluZSBjdXJ2ZSwgc2VlIGJlbG93KVxuICAgICAgICB2YXIgbWluSXRlcmF0aW9ucyA9IDI7IC8vID0gMioxXG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlICMzOiBzdHJhaWdodC1saW5lIGN1cnZlcyBoYXZlIHRoZSBzYW1lIG9ic2VydmVkIGxlbmd0aCBpbiBhbGwgaXRlcmF0aW9uc1xuICAgICAgICAvLyAtIHRoaXMgY2F1c2VzIG9ic2VydmVkIHByZWNpc2lvbiByYXRpbyB0byBhbHdheXMgYmUgMCAoPSBsb3dlciB0aGFuIGBwcmVjaXNpb25SYXRpb2AsIHdoaWNoIGlzIG91ciBleGl0IGNvbmRpdGlvbilcbiAgICAgICAgLy8gLSB3ZSBlbmZvcmNlIHRoZSBleHBlY3RlZCBudW1iZXIgb2YgaXRlcmF0aW9ucyA9IDIgKiBwcmVjaXNpb25cbiAgICAgICAgdmFyIGlzTGluZSA9ICgoY29udHJvbDEuY3Jvc3Moc3RhcnQsIGVuZCkgPT09IDApICYmIChjb250cm9sMi5jcm9zcyhzdGFydCwgZW5kKSA9PT0gMCkpO1xuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICBtaW5JdGVyYXRpb25zID0gKDIgKiBwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZGl2aWRlIGN1cnZlIGF0IGB0ID0gMC41YFxuICAgICAgICAvLyB1bnRpbCB3ZSByZWFjaCBgbWluSXRlcmF0aW9uc2BcbiAgICAgICAgLy8gYW5kIHVudGlsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb2JzZXJ2ZWQgbGVuZ3RoIGF0IHN1YnNlcXVlbnQgaXRlcmF0aW9ucyBpcyBsb3dlciB0aGFuIGBwcmVjaXNpb25gXG4gICAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaXRlcmF0aW9uICs9IDE7XG5cbiAgICAgICAgICAgIC8vIGRpdmlkZSBhbGwgc3ViZGl2aXNpb25zXG4gICAgICAgICAgICB2YXIgbmV3U3ViZGl2aXNpb25zID0gW107XG4gICAgICAgICAgICB2YXIgbnVtU3ViZGl2aXNpb25zID0gc3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3ViZGl2aXNpb25zOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJyZW50U3ViZGl2aXNpb24uZGl2aWRlKDAuNSk7IC8vIGRpdmlkaW5nIGF0IHQgPSAwLjUgKG5vdCBhdCBtaWRkbGUgbGVuZ3RoISlcbiAgICAgICAgICAgICAgICBuZXdTdWJkaXZpc2lvbnMucHVzaChkaXZpZGVkWzBdLCBkaXZpZGVkWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWVhc3VyZSBuZXcgbGVuZ3RoXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciBudW1OZXdTdWJkaXZpc2lvbnMgPSBuZXdTdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1OZXdTdWJkaXZpc2lvbnM7IGorKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROZXdTdWJkaXZpc2lvbiA9IG5ld1N1YmRpdmlzaW9uc1tqXTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gY3VycmVudE5ld1N1YmRpdmlzaW9uLmVuZHBvaW50RGlzdGFuY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIG1pbmltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb24gPj0gbWluSXRlcmF0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIHJlcXVpcmVkIG9ic2VydmVkIHByZWNpc2lvblxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlZFByZWNpc2lvblJhdGlvID0gKChsZW5ndGggIT09IDApID8gKChsZW5ndGggLSBwcmV2aW91c0xlbmd0aCkgLyBsZW5ndGgpIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPCBwcmVjaXNpb25SYXRpbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U3ViZGl2aXNpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBzZXQgdXAgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICBzdWJkaXZpc2lvbnMgPSBuZXdTdWJkaXZpc2lvbnM7XG4gICAgICAgICAgICBwcmV2aW91c0xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sMiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHJldHVybiAhKHN0YXJ0LmVxdWFscyhjb250cm9sMSkgJiYgY29udHJvbDEuZXF1YWxzKGNvbnRyb2wyKSAmJiBjb250cm9sMi5lcXVhbHMoZW5kKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZmxhdHRlbmVkIGxlbmd0aCBvZiB0aGUgY3VydmUgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjsgLy8gb3B0LnByZWNpc2lvbiBvbmx5IHVzZWQgaW4gZ2V0U3ViZGl2aXNpb25zKCkgY2FsbFxuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBuID0gc3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjdXJyZW50U3ViZGl2aXNpb24uZW5kcG9pbnREaXN0YW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdXAgdG8gYHRgIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmAuIChOb3QgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgLilcbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKHQsIG9wdCkge1xuXG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICAvLyBub3QgdXNpbmcgb3B0LnN1YmRpdmlzaW9uc1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgc3ViQ3VydmUgPSB0aGlzLmRpdmlkZSh0KVswXTtcbiAgICAgICAgdmFyIHN1YkN1cnZlTGVuZ3RoID0gc3ViQ3VydmUubGVuZ3RoKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSk7XG5cbiAgICAgICAgcmV0dXJuIHN1YkN1cnZlTGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHBvaW50IGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMSB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIE1pcnJvcnMgTGluZS5wb2ludEF0KCkgZnVuY3Rpb24uXG4gICAgLy8gRm9yIGEgZnVuY3Rpb24gdGhhdCB0cmFja3MgYHRgLCB1c2UgQ3VydmUucG9pbnRBdFQoKS5cbiAgICBwb2ludEF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgaWYgKHJhdGlvIDw9IDApIHJldHVybiB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGlmIChyYXRpbyA+PSAxKSByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0KHJhdGlvLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHBvaW50IGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBwb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXRMZW5ndGgobGVuZ3RoLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBwb2ludCBhdCBwcm92aWRlZCBgdGAgYmV0d2VlbiAwIGFuZCAxLlxuICAgIC8vIGB0YCBkb2VzIG5vdCB0cmFjayBkaXN0YW5jZSBhbG9uZyBjdXJ2ZSBhcyBpdCBkb2VzIGluIExpbmUgb2JqZWN0cy5cbiAgICAvLyBOb24tbGluZWFyIHJlbGF0aW9uc2hpcCwgc3BlZWRzIHVwIGFuZCBzbG93cyBkb3duIGFzIGN1cnZlIHdhcnBzIVxuICAgIC8vIEZvciBsaW5lYXIgbGVuZ3RoLWJhc2VkIHNvbHV0aW9uLCB1c2UgQ3VydmUucG9pbnRBdCgpLlxuICAgIHBvaW50QXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIHRoaXMuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2tlbGV0b25Qb2ludHModCkuZGl2aWRlcjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICBQUkVDSVNJT046IDMsXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5lbmQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYHJhdGlvYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgdGFuZ2VudEF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMCkgcmF0aW8gPSAwO1xuICAgICAgICBlbHNlIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0KHJhdGlvLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSB0YW5nZW50IGxpbmUgYXQgcmVxdWVzdGVkIGBsZW5ndGhgIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdExlbmd0aChsZW5ndGgsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYHRgLlxuICAgIHRhbmdlbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAodCA8IDApIHQgPSAwO1xuICAgICAgICBlbHNlIGlmICh0ID4gMSkgdCA9IDE7XG5cbiAgICAgICAgdmFyIHNrZWxldG9uUG9pbnRzID0gdGhpcy5nZXRTa2VsZXRvblBvaW50cyh0KTtcblxuICAgICAgICB2YXIgcDEgPSBza2VsZXRvblBvaW50cy5zdGFydENvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBwMiA9IHNrZWxldG9uUG9pbnRzLmRpdmlkZXJDb250cm9sUG9pbnQxO1xuXG4gICAgICAgIHZhciB0YW5nZW50U3RhcnQgPSBza2VsZXRvblBvaW50cy5kaXZpZGVyO1xuXG4gICAgICAgIHZhciB0YW5nZW50TGluZSA9IG5ldyBMaW5lKHAxLCBwMik7XG4gICAgICAgIHRhbmdlbnRMaW5lLnRyYW5zbGF0ZSh0YW5nZW50U3RhcnQueCAtIHAxLngsIHRhbmdlbnRTdGFydC55IC0gcDEueSk7IC8vIG1vdmUgc28gdGhhdCB0YW5nZW50IGxpbmUgc3RhcnRzIGF0IHRoZSBwb2ludCByZXF1ZXN0ZWRcblxuICAgICAgICByZXR1cm4gdGFuZ2VudExpbmU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRgIGF0IHJlcXVlc3RlZCBgcmF0aW9gIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKHJhdGlvID49IDEpIHJldHVybiAxO1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICB2YXIgY3VydmVMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjdXJ2ZUxlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRBdExlbmd0aChsZW5ndGgsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdGAgYXQgcmVxdWVzdGVkIGBsZW5ndGhgIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIFVzZXMgYHByZWNpc2lvbmAgdG8gYXBwcm94aW1hdGUgbGVuZ3RoIHdpdGhpbiBgcHJlY2lzaW9uYCAoYWx3YXlzIHVuZGVyZXN0aW1hdGVzKVxuICAgIC8vIFRoZW4gdXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgYHRgIG9mIGEgc3ViZGl2aXNpb24gZW5kcG9pbnQgdGhhdCBpcyBjbG9zZSAod2l0aGluIGBwcmVjaXNpb25gKSB0byB0aGUgYGxlbmd0aGAsIGlmIHRoZSBjdXJ2ZSB3YXMgYXMgbG9uZyBhcyBhcHByb3hpbWF0ZWRcbiAgICAvLyBBcyBhIHJ1bGUgb2YgdGh1bWIsIGluY3JlYXNpbmcgYHByZWNpc2lvbmAgYnkgMSBjYXVzZXMgdGhlIGFsZ29yaXRobSB0byBnbyAyXihwcmVjaXNpb24gLSAxKSBkZWVwZXJcbiAgICAvLyAtIFByZWNpc2lvbiAwIChjaG9vc2VzIG9uZSBvZiB0aGUgdHdvIGVuZHBvaW50cykgLSAwIGxldmVsc1xuICAgIC8vIC0gUHJlY2lzaW9uIDEgKGNob29zZXMgb25lIG9mIDUgcG9pbnRzLCA8MTAlIGVycm9yKSAtIDEgbGV2ZWxcbiAgICAvLyAtIFByZWNpc2lvbiAyICg8MSUgZXJyb3IpIC0gMyBsZXZlbHNcbiAgICAvLyAtIFByZWNpc2lvbiAzICg8MC4xJSBlcnJvcikgLSA3IGxldmVsc1xuICAgIC8vIC0gUHJlY2lzaW9uIDQgKDwwLjAxJSBlcnJvcikgLSAxNSBsZXZlbHNcbiAgICB0QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIC8vIGlkZW50aWZ5IHRoZSBzdWJkaXZpc2lvbiB0aGF0IGNvbnRhaW5zIHRoZSBwb2ludCBhdCByZXF1ZXN0ZWQgYGxlbmd0aGA6XG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbjtcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUOyAvLyBhc3N1bWUgdGhhdCBzdWJkaXZpc2lvbnMgYXJlIGV2ZW5seSBzcGFjZWRcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVDtcbiAgICAgICAgLy92YXIgYmFzZWxpbmU7IC8vIHN0cmFpZ2h0ZW5lZCB2ZXJzaW9uIG9mIHN1YmRpdmlzaW9uIHRvIGludmVzdGlnYXRlXG4gICAgICAgIC8vdmFyIGJhc2VsaW5lUG9pbnQ7IC8vIHBvaW50IG9uIHRoZSBiYXNlbGluZSB0aGF0IGlzIHRoZSByZXF1ZXN0ZWQgZGlzdGFuY2UgYXdheSBmcm9tIHN0YXJ0XG4gICAgICAgIHZhciBiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDsgLy8gZGlzdGFuY2Ugb2YgYmFzZWxpbmVQb2ludCBmcm9tIHN0YXJ0IG9mIGJhc2VsaW5lXG4gICAgICAgIHZhciBiYXNlbGluZVBvaW50RGlzdEZyb21FbmQ7IC8vIGRpc3RhbmNlIG9mIGJhc2VsaW5lUG9pbnQgZnJvbSBlbmQgb2YgYmFzZWxpbmVcbiAgICAgICAgdmFyIGwgPSAwOyAvLyBsZW5ndGggc28gZmFyXG4gICAgICAgIHZhciBuID0gc3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9uU2l6ZSA9IDEgLyBuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobiAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnJlbnRTdWJkaXZpc2lvbi5lbmRwb2ludERpc3RhbmNlKCk7IC8vIGxlbmd0aCBvZiBjdXJyZW50IHN1YmRpdmlzaW9uXG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gKGwgKyBkKSkge1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gY3VycmVudFN1YmRpdmlzaW9uO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQgPSBpbmRleCAqIHN1YmRpdmlzaW9uU2l6ZTtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQgPSAoaW5kZXggKyAxKSAqIHN1YmRpdmlzaW9uU2l6ZTtcblxuICAgICAgICAgICAgICAgIGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0ID0gKGZyb21TdGFydCA/IChsZW5ndGggLSBsKSA6ICgoZCArIGwpIC0gbGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmVQb2ludERpc3RGcm9tRW5kID0gKGZyb21TdGFydCA/ICgoZCArIGwpIC0gbGVuZ3RoKSA6IChsZW5ndGggLSBsKSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbikgcmV0dXJuIChmcm9tU3RhcnQgPyAxIDogMCk7IC8vIGxlbmd0aCByZXF1ZXN0ZWQgaXMgb3V0IG9mIHJhbmdlIC0gcmV0dXJuIG1heGltdW0gdFxuICAgICAgICAvLyBub3RlIHRoYXQgcHJlY2lzaW9uIGFmZmVjdHMgd2hhdCBsZW5ndGggaXMgcmVjb3JkZWRcbiAgICAgICAgLy8gKGltcHJlY2lzZSBtZWFzdXJlbWVudHMgdW5kZXJlc3RpbWF0ZSBsZW5ndGggYnkgdXAgdG8gMTBeKC1wcmVjaXNpb24pIG9mIHRoZSBwcmVjaXNlIGxlbmd0aClcbiAgICAgICAgLy8gZS5nLiBhdCBwcmVjaXNpb24gMSwgdGhlIGxlbmd0aCBtYXkgYmUgdW5kZXJlc3RpbWF0ZWQgYnkgdXAgdG8gMTAlIGFuZCBjYXVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiAxXG5cbiAgICAgICAgdmFyIGN1cnZlTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuXG4gICAgICAgIHZhciBwcmVjaXNpb25SYXRpbyA9IHBvdygxMCwgLXByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZGl2aWRlIGludmVzdGlnYXRlZCBzdWJkaXZpc2lvbjpcbiAgICAgICAgLy8gdW50aWwgZGlzdGFuY2UgYmV0d2VlbiBiYXNlbGluZVBvaW50IGFuZCBjbG9zZXN0IHBhdGggZW5kcG9pbnQgaXMgd2l0aGluIDEwXigtcHJlY2lzaW9uKVxuICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgY2xvc2VzdCBlbmRwb2ludCBvZiB0aGF0IGZpbmFsIHN1YmRpdmlzaW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCByZXF1aXJlZCBvYnNlcnZlZCBwcmVjaXNpb25cbiAgICAgICAgICAgIHZhciBvYnNlcnZlZFByZWNpc2lvblJhdGlvO1xuXG4gICAgICAgICAgICBvYnNlcnZlZFByZWNpc2lvblJhdGlvID0gKChjdXJ2ZUxlbmd0aCAhPT0gMCkgPyAoYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgLyBjdXJ2ZUxlbmd0aCkgOiAwKTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZFByZWNpc2lvblJhdGlvIDwgcHJlY2lzaW9uUmF0aW8pIHJldHVybiBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VDtcbiAgICAgICAgICAgIG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPSAoKGN1cnZlTGVuZ3RoICE9PSAwKSA/IChiYXNlbGluZVBvaW50RGlzdEZyb21FbmQgLyBjdXJ2ZUxlbmd0aCkgOiAwKTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZFByZWNpc2lvblJhdGlvIDwgcHJlY2lzaW9uUmF0aW8pIHJldHVybiBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQ7XG5cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2V0IHVwIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgdmFyIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0O1xuICAgICAgICAgICAgdmFyIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbUVuZDtcblxuICAgICAgICAgICAgdmFyIGRpdmlkZWQgPSBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbi5kaXZpZGUoMC41KTtcbiAgICAgICAgICAgIHN1YmRpdmlzaW9uU2l6ZSAvPSAyO1xuXG4gICAgICAgICAgICB2YXIgYmFzZWxpbmUxTGVuZ3RoID0gZGl2aWRlZFswXS5lbmRwb2ludERpc3RhbmNlKCk7XG4gICAgICAgICAgICB2YXIgYmFzZWxpbmUyTGVuZ3RoID0gZGl2aWRlZFsxXS5lbmRwb2ludERpc3RhbmNlKCk7XG5cbiAgICAgICAgICAgIGlmIChiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCA8PSBiYXNlbGluZTFMZW5ndGgpIHsgLy8gcG9pbnQgYXQgcmVxdWVzdGVkIGxlbmd0aCBpcyBpbnNpZGUgZGl2aWRlZFswXVxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gZGl2aWRlZFswXTtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVCAtPSBzdWJkaXZpc2lvblNpemU7IC8vIHN1ZGl2aXNpb25TaXplIHdhcyBhbHJlYWR5IGhhbHZlZFxuXG4gICAgICAgICAgICAgICAgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgPSBiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDtcbiAgICAgICAgICAgICAgICBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21FbmQgPSBiYXNlbGluZTFMZW5ndGggLSBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDtcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcG9pbnQgYXQgcmVxdWVzdGVkIGxlbmd0aCBpcyBpbnNpZGUgZGl2aWRlZFsxXVxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gZGl2aWRlZFsxXTtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUICs9IHN1YmRpdmlzaW9uU2l6ZTsgLy8gc3ViZGl2aXNpb25TaXplIHdhcyBhbHJlYWR5IGhhbHZlZFxuXG4gICAgICAgICAgICAgICAgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgPSBiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCAtIGJhc2VsaW5lMUxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21FbmQgPSBiYXNlbGluZTJMZW5ndGggLSBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgPSBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDtcbiAgICAgICAgICAgIGJhc2VsaW5lUG9pbnREaXN0RnJvbUVuZCA9IG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbUVuZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHBvaW50cyB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnZlIHdoZW4gZmxhdHRlbmVkLCB1cCB0byBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBGbGF0dGVuZWQgbGVuZ3RoIGlzIG5vIG1vcmUgdGhhbiAxMF4oLXByZWNpc2lvbikgYXdheSBmcm9tIHJlYWwgY3VydmUgbGVuZ3RoLlxuICAgIHRvUG9pbnRzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjsgLy8gb3B0LnByZWNpc2lvbiBvbmx5IHVzZWQgaW4gZ2V0U3ViZGl2aXNpb25zKCkgY2FsbFxuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtzdWJkaXZpc2lvbnNbMF0uc3RhcnQuY2xvbmUoKV07XG4gICAgICAgIHZhciBuID0gc3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGN1cnJlbnRTdWJkaXZpc2lvbi5lbmQuY2xvbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgcG9seWxpbmUgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJ2ZSB3aGVuIGZsYXR0ZW5lZCwgdXAgdG8gYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gRmxhdHRlbmVkIGxlbmd0aCBpcyBubyBtb3JlIHRoYW4gMTBeKC1wcmVjaXNpb24pIGF3YXkgZnJvbSByZWFsIGN1cnZlIGxlbmd0aC5cbiAgICB0b1BvbHlsaW5lOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHRoaXMudG9Qb2ludHMob3B0KSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArICcgJyArIHRoaXMuY29udHJvbFBvaW50MSArICcgJyArIHRoaXMuY29udHJvbFBvaW50MiArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLmVuZC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuQ3VydmUucHJvdG90eXBlLmRpdmlkZSA9IEN1cnZlLnByb3RvdHlwZS5kaXZpZGVBdFQ7XG4iXSwibmFtZXMiOlsiUG9pbnQiLCJSZWN0IiwiTGluZSIsIlBvbHlsaW5lIiwidHlwZXMiLCJhYnMiLCJzcXJ0IiwibWluIiwibWF4IiwicG93IiwiTWF0aCIsIkN1cnZlIiwicDEiLCJwMiIsInAzIiwicDQiLCJzdGFydCIsImNvbnRyb2xQb2ludDEiLCJjb250cm9sUG9pbnQyIiwiZW5kIiwidGhyb3VnaFBvaW50cyIsImdldEN1cnZlQ29udHJvbFBvaW50cyIsImtub3RzIiwiZmlyc3RDb250cm9sUG9pbnRzIiwic2Vjb25kQ29udHJvbFBvaW50cyIsIm4iLCJsZW5ndGgiLCJpIiwieCIsInkiLCJyaHMiLCJnZXRGaXJzdENvbnRyb2xQb2ludHMiLCJwdXNoIiwidG1wIiwiYiIsInBvaW50cyIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiY29udHJvbFBvaW50cyIsImN1cnZlcyIsInByb3RvdHlwZSIsInR5cGUiLCJiYm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsInR2YWx1ZXMiLCJib3VuZHMiLCJhIiwiYyIsInQiLCJ0MSIsInQyIiwiYjJhYyIsInNxcnRiMmFjIiwiaiIsImpsZW4iLCJtdCIsIlgiLCJZIiwibGVmdCIsImFwcGx5IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjbG9uZSIsImNsb3Nlc3RQb2ludCIsInAiLCJvcHQiLCJwb2ludEF0VCIsImNsb3Nlc3RQb2ludFQiLCJjbG9zZXN0UG9pbnRMZW5ndGgiLCJwcmVjaXNpb24iLCJ1bmRlZmluZWQiLCJQUkVDSVNJT04iLCJzdWJkaXZpc2lvbnMiLCJnZXRTdWJkaXZpc2lvbnMiLCJsb2NhbE9wdCIsImxlbmd0aEF0VCIsImNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgiLCJjcExlbmd0aCIsImludmVzdGlnYXRlZFN1YmRpdmlzaW9uIiwiaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQiLCJpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQiLCJkaXN0RnJvbVN0YXJ0IiwiZGlzdEZyb21FbmQiLCJjaG9yZExlbmd0aCIsIm1pblN1bURpc3QiLCJzdWJkaXZpc2lvblNpemUiLCJjdXJyZW50U3ViZGl2aXNpb24iLCJzdGFydERpc3QiLCJkaXN0YW5jZSIsImVuZERpc3QiLCJzdW1EaXN0IiwicHJlY2lzaW9uUmF0aW8iLCJzdGFydFByZWNpc2lvblJhdGlvIiwiZW5kUHJlY2lzaW9uUmF0aW8iLCJoYXNSZXF1aXJlZFByZWNpc2lvbiIsImhhc01pbmltYWxTdGFydERpc3RhbmNlIiwiaGFzTWluaW1hbEVuZERpc3RhbmNlIiwiaGFzTWluaW1hbERpc3RhbmNlIiwiZGl2aWRlZCIsImRpdmlkZSIsInN0YXJ0RGlzdDEiLCJlbmREaXN0MSIsInN1bURpc3QxIiwic3RhcnREaXN0MiIsImVuZERpc3QyIiwic3VtRGlzdDIiLCJjbG9zZXN0UG9pbnRUYW5nZW50IiwidGFuZ2VudEF0VCIsImNvbnRhaW5zUG9pbnQiLCJwb2x5bGluZSIsInRvUG9seWxpbmUiLCJkaXZpZGVBdCIsInJhdGlvIiwiZGl2aWRlQXRUIiwidEF0IiwiZGl2aWRlQXRMZW5ndGgiLCJ0QXRMZW5ndGgiLCJkaXZpZGVyUG9pbnRzIiwiZ2V0U2tlbGV0b25Qb2ludHMiLCJzdGFydENvbnRyb2wxIiwic3RhcnRDb250cm9sUG9pbnQxIiwic3RhcnRDb250cm9sMiIsInN0YXJ0Q29udHJvbFBvaW50MiIsImRpdmlkZXIiLCJkaXZpZGVyQ29udHJvbDEiLCJkaXZpZGVyQ29udHJvbFBvaW50MSIsImRpdmlkZXJDb250cm9sMiIsImRpdmlkZXJDb250cm9sUG9pbnQyIiwiZW5kcG9pbnREaXN0YW5jZSIsImVxdWFscyIsImNvbnRyb2wxIiwiY29udHJvbDIiLCJtaWRwb2ludDEiLCJwb2ludEF0IiwibWlkcG9pbnQyIiwibWlkcG9pbnQzIiwic3ViQ29udHJvbDEiLCJzdWJDb250cm9sMiIsIm91dHB1dCIsImlzUG9pbnQiLCJpc0RpZmZlcmVudGlhYmxlIiwicHJldmlvdXNMZW5ndGgiLCJtaW5JdGVyYXRpb25zIiwiaXNMaW5lIiwiY3Jvc3MiLCJpdGVyYXRpb24iLCJuZXdTdWJkaXZpc2lvbnMiLCJudW1TdWJkaXZpc2lvbnMiLCJudW1OZXdTdWJkaXZpc2lvbnMiLCJjdXJyZW50TmV3U3ViZGl2aXNpb24iLCJvYnNlcnZlZFByZWNpc2lvblJhdGlvIiwic3ViQ3VydmUiLCJzdWJDdXJ2ZUxlbmd0aCIsInBvaW50QXRMZW5ndGgiLCJyb3VuZCIsInNjYWxlIiwic3giLCJzeSIsIm9yaWdpbiIsInRhbmdlbnRBdCIsInRhbmdlbnRBdExlbmd0aCIsInNrZWxldG9uUG9pbnRzIiwidGFuZ2VudFN0YXJ0IiwidGFuZ2VudExpbmUiLCJ0cmFuc2xhdGUiLCJjdXJ2ZUxlbmd0aCIsImZyb21TdGFydCIsImJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0IiwiYmFzZWxpbmVQb2ludERpc3RGcm9tRW5kIiwibCIsImluZGV4IiwiZCIsIm5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0IiwibmV3QmFzZWxpbmVQb2ludERpc3RGcm9tRW5kIiwiYmFzZWxpbmUxTGVuZ3RoIiwiYmFzZWxpbmUyTGVuZ3RoIiwidG9Qb2ludHMiLCJ0b1N0cmluZyIsInR4IiwidHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/curve.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/ellipse.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/g/ellipse.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse),\n/* harmony export */   ellipse: () => (/* binding */ ellipse)\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n\n\n\nconst { sqrt, round, pow } = Math;\nconst Ellipse = function(c, a, b) {\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n    if (c instanceof Ellipse) {\n        return new Ellipse(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c.x, c.y), c.a, c.b);\n    }\n    c = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\nEllipse.fromRect = function(rect) {\n    rect = new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\nEllipse.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Ellipse,\n    bbox: function() {\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n    /**\n     * @returns {g.Point}\n     */ center: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);\n    },\n    clone: function() {\n        return new Ellipse(this);\n    },\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */ containsPoint: function(p) {\n        return this.normalizedDistance(p) <= 1;\n    },\n    equals: function(ellipse) {\n        return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n    },\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n        if (dy === undefined) {\n            dy = dx;\n        }\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n        return this;\n    },\n    intersectionWithLine: function(line) {\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this));\n        var mDir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(diff.x / (rx * rx), diff.y / (ry * ry));\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n        return intersections;\n    },\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n        if (angle) p.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), angle);\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n            return result;\n        }\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n        var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));\n        x = dx < 0 ? -x : x;\n        var y = m * x;\n        result = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x + x, this.y + y);\n        if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n        return result;\n    },\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */ normalizedDistance: function(point) {\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n        return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n    },\n    round: function(precision) {\n        let f = 1; // case 0\n        if (precision) {\n            switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow(10, precision);\n                    break;\n            }\n        }\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */ tangentTheta: function(p) {\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n        }\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x, y).theta(p);\n    },\n    toString: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y).toString() + \" \" + this.a + \" \" + this.b;\n    }\n};\n// For backwards compatibility:\nconst ellipse = Ellipse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9lbGxpcHNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNFO0FBQ0E7QUFFcEMsTUFBTSxFQUNGRyxJQUFJLEVBQ0pDLEtBQUssRUFDTEMsR0FBRyxFQUNOLEdBQUdDO0FBRUcsTUFBTUMsVUFBVSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUVuQyxJQUFJLENBQUUsS0FBSSxZQUFZSCxPQUFNLEdBQUk7UUFDNUIsT0FBTyxJQUFJQSxRQUFRQyxHQUFHQyxHQUFHQztJQUM3QjtJQUVBLElBQUlGLGFBQWFELFNBQVM7UUFDdEIsT0FBTyxJQUFJQSxRQUFRLElBQUlOLDZDQUFLQSxDQUFDTyxFQUFFRyxDQUFDLEVBQUVILEVBQUVJLENBQUMsR0FBR0osRUFBRUMsQ0FBQyxFQUFFRCxFQUFFRSxDQUFDO0lBQ3BEO0lBRUFGLElBQUksSUFBSVAsNkNBQUtBLENBQUNPO0lBQ2QsSUFBSSxDQUFDRyxDQUFDLEdBQUdILEVBQUVHLENBQUM7SUFDWixJQUFJLENBQUNDLENBQUMsR0FBR0osRUFBRUksQ0FBQztJQUNaLElBQUksQ0FBQ0gsQ0FBQyxHQUFHQTtJQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHQTtBQUNiLEVBQUU7QUFFRkgsUUFBUU0sUUFBUSxHQUFHLFNBQVNDLElBQUk7SUFFNUJBLE9BQU8sSUFBSWQsMkNBQUlBLENBQUNjO0lBQ2hCLE9BQU8sSUFBSVAsUUFBUU8sS0FBS0MsTUFBTSxJQUFJRCxLQUFLRSxLQUFLLEdBQUcsR0FBR0YsS0FBS0csTUFBTSxHQUFHO0FBQ3BFO0FBRUFWLFFBQVFXLFNBQVMsR0FBRztJQUVoQkMsTUFBTWpCLDZDQUFLQSxDQUFDSyxPQUFPO0lBRW5CYSxNQUFNO1FBRUYsT0FBTyxJQUFJcEIsMkNBQUlBLENBQUMsSUFBSSxDQUFDVyxDQUFDLEdBQUcsSUFBSSxDQUFDRixDQUFDLEVBQUUsSUFBSSxDQUFDRyxDQUFDLEdBQUcsSUFBSSxD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QUFBQSxJQUFPNUQsQ0FBQUEsSUFBSUEsSUFBS3NELENBQUFBLEtBQUtMLENBQUFBLENBQUMsSUFBS0E7UUFFakYsT0FBTztZQUNIaEQsSUFBSXNELEtBQUtsRCxPQUFPSCxDQUFDLEdBQUdvRCxLQUFLSyxnQkFBZ0JMLEtBQUtLO1lBQzlDekQsSUFBSSxJQUFLRixJQUFLdUQsQ0FBQUEsS0FBS0ssQ0FBQUEsSUFBTSxJQUFLNUQsSUFBS3NELENBQUFBLEtBQUtMLENBQUFBLElBQU1oRCxDQUFBQSxJQUFJZ0QsQ0FBQUEsSUFBT2xELENBQUFBLElBQUlBLElBQUt3RCxDQUFBQSxLQUFLSyxDQUFBQSxDQUFDLElBQUtBO1FBQ2pGO1FBRUEsT0FBTyxJQUFLckUsNkNBQUtBLENBQUNVLEdBQUdDLEdBQUk2RCxLQUFLLENBQUNsRDtJQUVuQztJQUVBbUQsVUFBVTtRQUVOLE9BQU8sSUFBS3pFLDZDQUFLQSxDQUFDLElBQUksQ0FBQ1UsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsQ0FBQyxFQUFHOEQsUUFBUSxLQUFLLE1BQU0sSUFBSSxDQUFDakUsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDQyxDQUFDO0lBQy9FO0FBQ0o7QUFFQSwrQkFBK0I7QUFDeEIsTUFBTWdCLFVBQVVuQixRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9lbGxpcHNlLm1qcz84MGU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBzcXJ0LFxuICAgIHJvdW5kLFxuICAgIHBvd1xufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBFbGxpcHNlID0gZnVuY3Rpb24oYywgYSwgYikge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVsbGlwc2UpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWxsaXBzZShjLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpZiAoYyBpbnN0YW5jZW9mIEVsbGlwc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKG5ldyBQb2ludChjLngsIGMueSksIGMuYSwgYy5iKTtcbiAgICB9XG5cbiAgICBjID0gbmV3IFBvaW50KGMpO1xuICAgIHRoaXMueCA9IGMueDtcbiAgICB0aGlzLnkgPSBjLnk7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xufTtcblxuRWxsaXBzZS5mcm9tUmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcblxuICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0KTtcbiAgICByZXR1cm4gbmV3IEVsbGlwc2UocmVjdC5jZW50ZXIoKSwgcmVjdC53aWR0aCAvIDIsIHJlY3QuaGVpZ2h0IC8gMik7XG59O1xuXG5FbGxpcHNlLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLkVsbGlwc2UsXG5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54IC0gdGhpcy5hLCB0aGlzLnkgLSB0aGlzLmIsIDIgKiB0aGlzLmEsIDIgKiB0aGlzLmIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Zy5Qb2ludH1cbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2cuUG9pbnR9IHBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZERpc3RhbmNlKHApIDw9IDE7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oZWxsaXBzZSkge1xuXG4gICAgICAgIHJldHVybiAhIWVsbGlwc2UgJiZcbiAgICAgICAgICAgIGVsbGlwc2UueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBlbGxpcHNlLnkgPT09IHRoaXMueSAmJlxuICAgICAgICAgICAgZWxsaXBzZS5hID09PSB0aGlzLmEgJiZcbiAgICAgICAgICAgIGVsbGlwc2UuYiA9PT0gdGhpcy5iO1xuICAgIH0sXG5cbiAgICAvLyBpbmZsYXRlIGJ5IGR4IGFuZCBkeVxuICAgIC8vIEBwYXJhbSBkeCB7ZGVsdGFfeH0gcmVwcmVzZW50aW5nIGFkZGl0aW9uYWwgc2l6ZSB0byB4XG4gICAgLy8gQHBhcmFtIGR5IHtkZWx0YV95fSByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBzaXplIHRvIHkgLVxuICAgIC8vIGR5IHBhcmFtIGlzIG5vdCByZXF1aXJlZCAtPiBpbiB0aGF0IGNhc2UgeSBpcyBzaXplZCBieSBkeFxuICAgIGluZmxhdGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICBpZiAoZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR5ID0gZHg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmEgKz0gMiAqIGR4O1xuICAgICAgICB0aGlzLmIgKz0gMiAqIGR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBhMSA9IGxpbmUuc3RhcnQ7XG4gICAgICAgIHZhciBhMiA9IGxpbmUuZW5kO1xuICAgICAgICB2YXIgcnggPSB0aGlzLmE7XG4gICAgICAgIHZhciByeSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGRpciA9IGxpbmUudmVjdG9yKCk7XG4gICAgICAgIHZhciBkaWZmID0gYTEuZGlmZmVyZW5jZShuZXcgUG9pbnQodGhpcykpO1xuICAgICAgICB2YXIgbURpciA9IG5ldyBQb2ludChkaXIueCAvIChyeCAqIHJ4KSwgZGlyLnkgLyAocnkgKiByeSkpO1xuICAgICAgICB2YXIgbURpZmYgPSBuZXcgUG9pbnQoZGlmZi54IC8gKHJ4ICogcngpLCBkaWZmLnkgLyAocnkgKiByeSkpO1xuXG4gICAgICAgIHZhciBhID0gZGlyLmRvdChtRGlyKTtcbiAgICAgICAgdmFyIGIgPSBkaXIuZG90KG1EaWZmKTtcbiAgICAgICAgdmFyIGMgPSBkaWZmLmRvdChtRGlmZikgLSAxLjA7XG4gICAgICAgIHZhciBkID0gYiAqIGIgLSBhICogYztcblxuICAgICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHNxcnQoZCk7XG4gICAgICAgICAgICB2YXIgdGEgPSAoLWIgLSByb290KSAvIGE7XG4gICAgICAgICAgICB2YXIgdGIgPSAoLWIgKyByb290KSAvIGE7XG5cbiAgICAgICAgICAgIGlmICgodGEgPCAwIHx8IDEgPCB0YSkgJiYgKHRiIDwgMCB8fCAxIDwgdGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCh0YSA8IDAgJiYgdGIgPCAwKSB8fCAodGEgPiAxICYmIHRiID4gMSkpIG91dHNpZGUgZWxzZSBpbnNpZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gdGEgJiYgdGEgPD0gMSkgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gdGIgJiYgdGIgPD0gMSkgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHRiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IC1iIC8gYTtcbiAgICAgICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3V0c2lkZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgcG9pbnQgb24gbWUgd2hlcmUgbGluZSBmcm9tIG15IGNlbnRlciB0b1xuICAgIC8vIHBvaW50IHAgaW50ZXJzZWN0cyBteSBib3VuZGFyeS5cbiAgICAvLyBAcGFyYW0ge251bWJlcn0gYW5nbGUgSWYgYW5nbGUgaXMgc3BlY2lmaWVkLCBpbnRlcnNlY3Rpb24gd2l0aCByb3RhdGVkIGVsbGlwc2UgaXMgY29tcHV0ZWQuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludDogZnVuY3Rpb24ocCwgYW5nbGUpIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuXG4gICAgICAgIGlmIChhbmdsZSkgcC5yb3RhdGUobmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSwgYW5nbGUpO1xuXG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueDtcbiAgICAgICAgdmFyIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmIChkeCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5iYm94KCkucG9pbnROZWFyZXN0VG9Qb2ludChwKTtcbiAgICAgICAgICAgIGlmIChhbmdsZSkgcmV0dXJuIHJlc3VsdC5yb3RhdGUobmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSwgLWFuZ2xlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IGR5IC8gZHg7XG4gICAgICAgIHZhciBtU3F1YXJlZCA9IG0gKiBtO1xuICAgICAgICB2YXIgYVNxdWFyZWQgPSB0aGlzLmEgKiB0aGlzLmE7XG4gICAgICAgIHZhciBiU3F1YXJlZCA9IHRoaXMuYiAqIHRoaXMuYjtcblxuICAgICAgICB2YXIgeCA9IHNxcnQoMSAvICgoMSAvIGFTcXVhcmVkKSArIChtU3F1YXJlZCAvIGJTcXVhcmVkKSkpO1xuICAgICAgICB4ID0gZHggPCAwID8gLXggOiB4O1xuXG4gICAgICAgIHZhciB5ID0gbSAqIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBQb2ludCh0aGlzLnggKyB4LCB0aGlzLnkgKyB5KTtcblxuICAgICAgICBpZiAoYW5nbGUpIHJldHVybiByZXN1bHQucm90YXRlKG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSksIC1hbmdsZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Zy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgPCAxIC0gaW5zaWRlIGVsbGlwc2UsIHJlc3VsdCA9PSAxIC0gb24gZWxsaXBzZSBib3VuZGFyeSwgcmVzdWx0ID4gMSAtIG91dHNpZGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVkRGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHgwID0gcG9pbnQueDtcbiAgICAgICAgdmFyIHkwID0gcG9pbnQueTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgICAgICAgcmV0dXJuICgoeDAgLSB4KSAqICh4MCAtIHgpKSAvIChhICogYSkgKyAoKHkwIC0geSkgKiAoeTAgLSB5KSkgLyAoYiAqIGIpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgbGV0IGYgPSAxOyAvLyBjYXNlIDBcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGYgPSAxMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBmID0gMTAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGYgPSAxMDAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmID0gcG93KDEwLCBwcmVjaXNpb24pOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHJvdW5kKHRoaXMueCAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy55ID0gcm91bmQodGhpcy55ICogZikgLyBmO1xuICAgICAgICB0aGlzLmEgPSByb3VuZCh0aGlzLmEgKiBmKSAvIGY7XG4gICAgICAgIHRoaXMuYiA9IHJvdW5kKHRoaXMuYiAqIGYpIC8gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBDb21wdXRlIGFuZ2xlIGJldHdlZW4gdGFuZ2VudCBhbmQgeCBheGlzXG4gICAgICogQHBhcmFtIHtnLlBvaW50fSBwIFBvaW50IG9mIHRhbmdlbmN5LCBpdCBoYXMgdG8gYmUgb24gZWxsaXBzZSBib3VuZGFyaWVzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGJldHdlZW4gdGFuZ2VudCBhbmQgeCBheGlzXG4gICAgICovXG4gICAgdGFuZ2VudFRoZXRhOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHJlZlBvaW50RGVsdGEgPSAzMDtcbiAgICAgICAgdmFyIHgwID0gcC54O1xuICAgICAgICB2YXIgeTAgPSBwLnk7XG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYmJveCgpLmNlbnRlcigpO1xuICAgICAgICB2YXIgbSA9IGNlbnRlci54O1xuICAgICAgICB2YXIgbiA9IGNlbnRlci55O1xuXG4gICAgICAgIHZhciBxMSA9IHgwID4gY2VudGVyLnggKyBhIC8gMjtcbiAgICAgICAgdmFyIHEzID0geDAgPCBjZW50ZXIueCAtIGEgLyAyO1xuXG4gICAgICAgIHZhciB5LCB4O1xuICAgICAgICBpZiAocTEgfHwgcTMpIHtcbiAgICAgICAgICAgIHkgPSB4MCA+IGNlbnRlci54ID8geTAgLSByZWZQb2ludERlbHRhIDogeTAgKyByZWZQb2ludERlbHRhO1xuICAgICAgICAgICAgeCA9IChhICogYSAvICh4MCAtIG0pKSAtIChhICogYSAqICh5MCAtIG4pICogKHkgLSBuKSkgLyAoYiAqIGIgKiAoeDAgLSBtKSkgKyBtO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0geTAgPiBjZW50ZXIueSA/IHgwICsgcmVmUG9pbnREZWx0YSA6IHgwIC0gcmVmUG9pbnREZWx0YTtcbiAgICAgICAgICAgIHkgPSAoYiAqIGIgLyAoeTAgLSBuKSkgLSAoYiAqIGIgKiAoeDAgLSBtKSAqICh4IC0gbSkpIC8gKGEgKiBhICogKHkwIC0gbikpICsgbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmV3IFBvaW50KHgsIHkpKS50aGV0YShwKTtcblxuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIChuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpKS50b1N0cmluZygpICsgJyAnICsgdGhpcy5hICsgJyAnICsgdGhpcy5iO1xuICAgIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbmV4cG9ydCBjb25zdCBlbGxpcHNlID0gRWxsaXBzZTtcbiJdLCJuYW1lcyI6WyJSZWN0IiwiUG9pbnQiLCJ0eXBlcyIsInNxcnQiLCJyb3VuZCIsInBvdyIsIk1hdGgiLCJFbGxpcHNlIiwiYyIsImEiLCJiIiwieCIsInkiLCJmcm9tUmVjdCIsInJlY3QiLCJjZW50ZXIiLCJ3aWR0aCIsImhlaWdodCIsInByb3RvdHlwZSIsInR5cGUiLCJiYm94IiwiY2xvbmUiLCJjb250YWluc1BvaW50IiwicCIsIm5vcm1hbGl6ZWREaXN0YW5jZSIsImVxdWFscyIsImVsbGlwc2UiLCJpbmZsYXRlIiwiZHgiLCJkeSIsInVuZGVmaW5lZCIsImludGVyc2VjdGlvbldpdGhMaW5lIiwibGluZSIsImludGVyc2VjdGlvbnMiLCJhMSIsInN0YXJ0IiwiYTIiLCJlbmQiLCJyeCIsInJ5IiwiZGlyIiwidmVjdG9yIiwiZGlmZiIsImRpZmZlcmVuY2UiLCJtRGlyIiwibURpZmYiLCJkb3QiLCJkIiwicm9vdCIsInRhIiwidGIiLCJwdXNoIiwibGVycCIsInQiLCJpbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50IiwiYW5nbGUiLCJyb3RhdGUiLCJyZXN1bHQiLCJwb2ludE5lYXJlc3RUb1BvaW50IiwibSIsIm1TcXVhcmVkIiwiYVNxdWFyZWQiLCJiU3F1YXJlZCIsInBvaW50IiwieDAiLCJ5MCIsInByZWNpc2lvbiIsImYiLCJ0YW5nZW50VGhldGEiLCJyZWZQb2ludERlbHRhIiwibiIsInExIiwicTMiLCJ0aGV0YSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/extend.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/g/extend.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: () => (/* binding */ extend)\n/* harmony export */ });\n// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nfunction extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n    var i;\n    var n;\n    var args = [];\n    n = arguments.length;\n    for(i = 1; i < n; i++){\n        args.push(arguments[i]);\n    }\n    if (!obj) throw new Error(\"Missing a parent object.\");\n    var child = Object.create(obj);\n    n = args.length;\n    for(i = 0; i < n; i++){\n        var src = args[i];\n        var inheritedProperty;\n        var key;\n        for(key in src){\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n    return child;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9leHRlbmQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaUVBQWlFO0FBQ2pFLDJDQUEyQztBQUMzQyx1Q0FBdUM7QUFDdkMsaUlBQWlJO0FBQ2pJLGlIQUFpSDtBQUMxRyxTQUFTQSxPQUFPQyxHQUFHO0lBQ3RCLHdLQUF3SztJQUN4Syx3SEFBd0g7SUFDeEgsd0lBQXdJO0lBQ3hJLDZHQUE2RztJQUM3Ryx3SEFBd0g7SUFDeEgsbURBQW1EO0lBQ25ELDhKQUE4SjtJQUM5SixtREFBbUQ7SUFDbkQsNkVBQTZFO0lBQzdFLDJHQUEyRztJQUMzRyw2S0FBNks7SUFDN0sscUZBQXFGO0lBQ3JGLCtFQUErRTtJQUMvRSxvSUFBb0k7SUFDcEksdUdBQXVHO0lBQ3ZHLHdEQUF3RDtJQUN4RCw2SEFBNkg7SUFDN0gsK0NBQStDO0lBQy9DLDBKQUEwSjtJQUMxSix3S0FBd0s7SUFDeEssOEdBQThHO0lBQzlHLCtHQUErRztJQUMvRyxnREFBZ0Q7SUFDaEQscUZBQXFGO0lBQ3JGLHFFQUFxRTtJQUVyRSxJQUFJQztJQUNKLElBQUlDO0lBRUosSUFBSUMsT0FBTyxFQUFFO0lBQ2JELElBQUlFLFVBQVVDLE1BQU07SUFDcEIsSUFBS0osSUFBSSxHQUFHQSxJQUFJQyxHQUFHRCxJQUFLO1FBQ3BCRSxLQUFLRyxJQUFJLENBQUNGLFNBQVMsQ0FBQ0gsRUFBRTtJQUMxQjtJQUVBLElBQUksQ0FBQ0QsS0FBSyxNQUFNLElBQUlPLE1BQU07SUFDMUIsSUFBSUMsUUFBUUMsT0FBT0MsTUFBTSxDQUFDVjtJQUUxQkUsSUFBSUMsS0FBS0UsTUFBTTtJQUNmLElBQUtKLElBQUksR0FBR0EsSUFBSUMsR0FBR0QsSUFBSztRQUVwQixJQUFJVSxNQUFNUixJQUFJLENBQUNGLEVBQUU7UUFFakIsSUFBSVc7UUFDSixJQUFJQztRQUNKLElBQUtBLE9BQU9GLElBQUs7WUFFYixJQUFJQSxJQUFJRyxjQUFjLENBQUNELE1BQU07Z0JBQ3pCLE9BQU9MLEtBQUssQ0FBQ0ssSUFBSSxFQUFFLHdDQUF3QztnQkFDM0RELG9CQUFvQkgsT0FBT00sd0JBQXdCLENBQUNKLEtBQUtFLE1BQU0sMENBQTBDO2dCQUN6R0osT0FBT08sY0FBYyxDQUFDUixPQUFPSyxLQUFLRCxvQkFBb0IsdUVBQXVFO1lBQ2pJO1FBQ0o7SUFDSjtJQUVBLE9BQU9KO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL2V4dGVuZC5tanM/NTZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMb2NhbCBoZWxwZXIgZnVuY3Rpb24uXG4vLyBBZGQgcHJvcGVydGllcyBmcm9tIGFyZ3VtZW50cyBvbiB0b3Agb2YgcHJvcGVydGllcyBmcm9tIGBvYmpgLlxuLy8gVGhpcyBhbGxvd3MgZm9yIHJ1ZGltZW50YXJ5IGluaGVyaXRhbmNlLlxuLy8gLSBUaGUgYG9iamAgYXJndW1lbnQgYWN0cyBhcyBwYXJlbnQuXG4vLyAtIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBhbGwgYG9iamAgcHJvcGVydGllcyBhbmQgYWRkcy9yZXBsYWNlcyB0aG9zZSB0aGF0IGFyZSBwcmVzZW50IGluIGFyZ3VtZW50cy5cbi8vIC0gQSBoaWdoLWxldmVsIGV4YW1wbGU6IGNhbGxpbmcgYGV4dGVuZChWZWhpY2xlLCBDYXIpYCB3b3VsZCBiZSBha2luIHRvIGRlY2xhcmluZyBgY2xhc3MgQ2FyIGV4dGVuZHMgVmVoaWNsZWAuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIC8vIEluIEphdmFTY3JpcHQsIHRoZSBjb21iaW5hdGlvbiBvZiBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIChlLmcuIGBnLkxpbmUgPSBmdW5jdGlvbiguLi4pIHsuLi59YCkgYW5kIHByb3RvdHlwZSAoZS5nLiBgZy5MaW5lLnByb3RvdHlwZSA9IHsuLi59KSBpcyBha2luIHRvIGEgQysrIGNsYXNzLlxuICAgIC8vIC0gV2hlbiBpbmhlcml0YW5jZSBpcyBub3QgbmVjZXNzYXJ5LCB3ZSBjYW4gbGVhdmUgaXQgYXQgdGhhdC4gKFRoaXMgd291bGQgYmUgYWtpbiB0byBjYWxsaW5nIGV4dGVuZCB3aXRoIG9ubHkgYG9iamAuKVxuICAgIC8vIC0gQnV0LCB3aGF0IGlmIHdlIHdhbnRlZCB0aGUgYGcuTGluZWAgcXVhc2ljbGFzcyB0byBpbmhlcml0IGZyb20gYW5vdGhlciBxdWFzaWNsYXNzIChsZXQncyBjYWxsIGl0IGBnLkdlb21ldHJ5T2JqZWN0YCkgaW4gSmF2YVNjcmlwdD9cbiAgICAvLyAtIEZpcnN0LCByZWFsaXplIHRoYXQgYm90aCBvZiB0aG9zZSBxdWFzaWNsYXNzZXMgd291bGQgc3RpbGwgaGF2ZSB0aGVpciBvd24gc2VwYXJhdGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgLy8gLSBTbyB3aGF0IHdlIGFyZSBhY3R1YWxseSBzYXlpbmcgaXMgdGhhdCB3ZSB3YW50IHRoZSBgZy5MaW5lYCBwcm90b3R5cGUgdG8gaW5oZXJpdCBmcm9tIGBnLkdlb21ldHJ5T2JqZWN0YCBwcm90b3R5cGUuXG4gICAgLy8gLSBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIHdheSB0byBkbyBleGFjdGx5IHRoYXQuXG4gICAgLy8gLSBJdCBjb3BpZXMgcGFyZW50IHByb3RvdHlwZSdzIHByb3BlcnRpZXMsIHRoZW4gYWRkcyBleHRyYSBvbmVzIGZyb20gY2hpbGQgcHJvdG90eXBlL292ZXJyaWRlcyBwYXJlbnQgcHJvdG90eXBlIHByb3BlcnRpZXMgd2l0aCBjaGlsZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICAvLyAtIFRoZXJlZm9yZSwgdG8gY29udGludWUgd2l0aCB0aGUgZXhhbXBsZSBhYm92ZTpcbiAgICAvLyAgIC0gYGcuTGluZS5wcm90b3R5cGUgPSBleHRlbmQoZy5HZW9tZXRyeU9iamVjdC5wcm90b3R5cGUsIGxpbmVQcm90b3R5cGUpYFxuICAgIC8vICAgLSBXaGVyZSBgbGluZVByb3RvdHlwZWAgaXMgYSBwcm9wZXJ0aWVzIG9iamVjdCB0aGF0IGxvb2tzIGp1c3QgbGlrZSBgZy5MaW5lLnByb3RvdHlwZWAgZG9lcyByaWdodCBub3cuXG4gICAgLy8gICAtIFRoZW4sIGBnLkxpbmVgIHdvdWxkIGFsbG93IHRoZSBwcm9ncmFtbWVyIHRvIGFjY2VzcyB0byBhbGwgbWV0aG9kcyBjdXJyZW50bHkgaW4gYGcuTGluZS5Qcm90b3R5cGVgLCBwbHVzIGFueSBub24tb3ZlcnJpZGRlbiBtZXRob2RzIGZyb20gYGcuR2VvbWV0cnlPYmplY3QucHJvdG90eXBlYC5cbiAgICAvLyAgIC0gSW4gdGhhdCBhc3BlY3QsIGBnLkdlb21ldHJ5T2JqZWN0YCB3b3VsZCB0aGVuIGFjdCBsaWtlIHRoZSBwYXJlbnQgb2YgYGcuTGluZWAuXG4gICAgLy8gLSBNdWx0aXBsZSBpbmhlcml0YW5jZSBpcyBhbHNvIHBvc3NpYmxlLCBpZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgIC8vIC0gV2hhdCBpZiB3ZSB3YW50ZWQgdG8gYWRkIGFub3RoZXIgbGV2ZWwgb2YgYWJzdHJhY3Rpb24gYmV0d2VlbiBgZy5HZW9tZXRyeU9iamVjdGAgYW5kIGBnLkxpbmVgIChsZXQncyBjYWxsIGl0IGBnLkxpbmVhck9iamVjdGApP1xuICAgIC8vICAgLSBgZy5MaW5lLnByb3RvdHlwZSA9IGV4dGVuZChnLkdlb21ldHJ5T2JqZWN0LnByb3RvdHlwZSwgZy5MaW5lYXJPYmplY3QucHJvdG90eXBlLCBsaW5lUHJvdG90eXBlKWBcbiAgICAvLyAgIC0gVGhlIGFuY2VzdG9ycyBhcmUgYXBwbGllZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgIC8vICAgLSBUaGF0IG1lYW5zIHRoYXQgYGcuTGluZWAgd291bGQgaGF2ZSBpbmhlcml0ZWQgZnJvbSBgZy5MaW5lYXJPYmplY3RgIHRoYXQgd291bGQgaGF2ZSBpbmhlcml0ZWQgZnJvbSBgZy5HZW9tZXRyeU9iamVjdGAuXG4gICAgLy8gICAtIEFueSBudW1iZXIgb2YgYW5jZXN0b3JzIG1heSBiZSBwcm92aWRlZC5cbiAgICAvLyAtIE5vdGUgdGhhdCBuZWl0aGVyIGBvYmpgIG5vciBhbnkgb2YgdGhlIGFyZ3VtZW50cyBuZWVkIHRvIGFjdHVhbGx5IGJlIHByb3RvdHlwZXMgb2YgYW55IEphdmFTY3JpcHQgcXVhc2ljbGFzcywgdGhhdCB3YXMganVzdCBhIHNpbXBsaWZpZWQgZXhwbGFuYXRpb24uXG4gICAgLy8gLSBXZSBjYW4gY3JlYXRlIGEgbmV3IG9iamVjdCBjb21wb3NlZCBmcm9tIHRoZSBwcm9wZXJ0aWVzIG9mIGFueSBudW1iZXIgb2Ygb3RoZXIgb2JqZWN0cyAoc2luY2UgdGhleSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yLCB3ZSBjYW4gdGhpbmsgb2YgdGhvc2UgYXMgaW50ZXJmYWNlcykuXG4gICAgLy8gICAtIGBleHRlbmQoeyBhOiAxLCBiOiAyIH0sIHsgYjogMTAsIGM6IDIwIH0sIHsgYzogMTAwLCBkOiAyMDAgfSlgIGdpdmVzIGB7IGE6IDEsIGI6IDEwLCBjOiAxMDAsIGQ6IDIwMCB9YC5cbiAgICAvLyAgIC0gQmFzaWNhbGx5LCB3aXRoIHRoaXMgZnVuY3Rpb24sIHdlIGNhbiBlbXVsYXRlIHRoZSBgZXh0ZW5kc2Aga2V5d29yZCBhcyB3ZWxsIGFzIHRoZSBgaW1wbGVtZW50c2Aga2V5d29yZC5cbiAgICAvLyAtIFRoZXJlZm9yZSwgYm90aCBvZiB0aGUgZm9sbG93aW5nIGFyZSB2YWxpZDpcbiAgICAvLyAgIC0gYExpbmV0by5wcm90b3R5cGUgPSBleHRlbmQoTGluZS5wcm90b3R5cGUsIHNlZ21lbnRQcm90b3R5cGUsIGxpbmV0b1Byb3RvdHlwZSlgXG4gICAgLy8gICAtIGBNb3ZldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIG1vdmV0b1Byb3RvdHlwZSlgXG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbjtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykgeyAvLyBza2lwIG92ZXIgb2JqXG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghb2JqKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYSBwYXJlbnQgb2JqZWN0LicpO1xuICAgIHZhciBjaGlsZCA9IE9iamVjdC5jcmVhdGUob2JqKTtcblxuICAgIG4gPSBhcmdzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgdmFyIHNyYyA9IGFyZ3NbaV07XG5cbiAgICAgICAgdmFyIGluaGVyaXRlZFByb3BlcnR5O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBzcmMpIHtcblxuICAgICAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkW2tleV07IC8vIGRlbGV0ZSBwcm9wZXJ0eSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRQcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrZXkpOyAvLyBnZXQgbmV3IGRlZmluaXRpb24gb2YgcHJvcGVydHkgZnJvbSBzcmNcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIGtleSwgaW5oZXJpdGVkUHJvcGVydHkpOyAvLyByZS1hZGQgcHJvcGVydHkgd2l0aCBuZXcgZGVmaW5pdGlvbiAoaW5jbHVkZXMgZ2V0dGVyL3NldHRlciBtZXRob2RzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufVxuIl0sIm5hbWVzIjpbImV4dGVuZCIsIm9iaiIsImkiLCJuIiwiYXJncyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInB1c2giLCJFcnJvciIsImNoaWxkIiwiT2JqZWN0IiwiY3JlYXRlIiwic3JjIiwiaW5oZXJpdGVkUHJvcGVydHkiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/extend.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/jointjs/src/g/geometry.helpers.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeAngle: () => (/* binding */ normalizeAngle),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   scale: () => (/* binding */ scale),\n/* harmony export */   snapToGrid: () => (/* binding */ snapToGrid),\n/* harmony export */   toDeg: () => (/* binding */ toDeg),\n/* harmony export */   toRad: () => (/* binding */ toRad)\n/* harmony export */ });\n// Declare shorthands to the most used math functions.\nconst { round, floor, PI } = Math;\nconst scale = {\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;\n    }\n};\nconst normalizeAngle = function(angle) {\n    return angle % 360 + (angle < 0 ? 360 : 0);\n};\nconst snapToGrid = function(value, gridSize) {\n    return gridSize * round(value / gridSize);\n};\nconst toDeg = function(rad) {\n    return 180 * rad / PI % 360;\n};\nconst toRad = function(deg, over360) {\n    over360 = over360 || false;\n    deg = over360 ? deg : deg % 360;\n    return deg * PI / 180;\n};\n// Return a random integer from the interval [min,max], inclusive.\nconst random = function(min, max) {\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = min === undefined ? 1 : min;\n        min = 0;\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return floor(Math.random() * (max - min + 1) + min);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9nZW9tZXRyeS5oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDdEQsTUFBTSxFQUNGQSxLQUFLLEVBQ0xDLEtBQUssRUFDTEMsRUFBRSxFQUNMLEdBQUdDO0FBRUcsTUFBTUMsUUFBUTtJQUVqQixnRkFBZ0Y7SUFDaEZDLFFBQVEsU0FBU0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7UUFFakMsSUFBSUMsYUFBYUgsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUU7UUFDdEMsSUFBSUksWUFBWUgsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7UUFDbkMsT0FBTyxDQUFHQyxRQUFRRixNQUFNLENBQUMsRUFBRSxJQUFJRyxhQUFjQyxZQUFZSCxLQUFLLENBQUMsRUFBRSxJQUFLO0lBQzFFO0FBQ0osRUFBRTtBQUVLLE1BQU1JLGlCQUFpQixTQUFTQyxLQUFLO0lBRXhDLE9BQU8sUUFBUyxNQUFRQSxDQUFBQSxRQUFRLElBQUksTUFBTTtBQUM5QyxFQUFFO0FBRUssTUFBTUMsYUFBYSxTQUFTTCxLQUFLLEVBQUVNLFFBQVE7SUFFOUMsT0FBT0EsV0FBV2QsTUFBTVEsUUFBUU07QUFDcEMsRUFBRTtBQUVLLE1BQU1DLFFBQVEsU0FBU0MsR0FBRztJQUU3QixPQUFPLE1BQU9BLE1BQU1kLEtBQU07QUFDOUIsRUFBRTtBQUVLLE1BQU1lLFFBQVEsU0FBU0MsR0FBRyxFQUFFQyxPQUFPO0lBRXRDQSxVQUFVQSxXQUFXO0lBQ3JCRCxNQUFNQyxVQUFVRCxNQUFPQSxNQUFNO0lBQzdCLE9BQU9BLE1BQU1oQixLQUFLO0FBQ3RCLEVBQUU7QUFFRixrRUFBa0U7QUFDM0QsTUFBTWtCLFNBQVMsU0FBU0MsR0FBRyxFQUFFQyxHQUFHO0lBRW5DLElBQUlBLFFBQVFDLFdBQVc7UUFDbkIsc0NBQXNDO1FBQ3RDRCxNQUFNLFFBQVNDLFlBQWEsSUFBSUY7UUFDaENBLE1BQU07SUFFVixPQUFPLElBQUlDLE1BQU1ELEtBQUs7UUFDbEIscUJBQXFCO1FBQ3JCLE1BQU1HLE9BQU9IO1FBQ2JBLE1BQU1DO1FBQ05BLE1BQU1FO0lBQ1Y7SUFFQSxPQUFPdkIsTUFBTSxLQUFNbUIsTUFBTSxLQUFNRSxDQUFBQSxNQUFNRCxNQUFNLEtBQU1BO0FBQ3JELEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL2dlb21ldHJ5LmhlbHBlcnMubWpzPzdhMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVjbGFyZSBzaG9ydGhhbmRzIHRvIHRoZSBtb3N0IHVzZWQgbWF0aCBmdW5jdGlvbnMuXG5jb25zdCB7XG4gICAgcm91bmQsXG4gICAgZmxvb3IsXG4gICAgUElcbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3Qgc2NhbGUgPSB7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGB2YWx1ZWAgZnJvbSB0aGUgYGRvbWFpbmAgaW50ZXJ2YWwgc2NhbGVkIHRvIHRoZSBgcmFuZ2VgIGludGVydmFsLlxuICAgIGxpbmVhcjogZnVuY3Rpb24oZG9tYWluLCByYW5nZSwgdmFsdWUpIHtcblxuICAgICAgICB2YXIgZG9tYWluU3BhbiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgICAgICAgdmFyIHJhbmdlU3BhbiA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICAgIHJldHVybiAoKCh2YWx1ZSAtIGRvbWFpblswXSkgLyBkb21haW5TcGFuKSAqIHJhbmdlU3BhbiArIHJhbmdlWzBdKSB8fCAwO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVBbmdsZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cbiAgICByZXR1cm4gKGFuZ2xlICUgMzYwKSArIChhbmdsZSA8IDAgPyAzNjAgOiAwKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzbmFwVG9HcmlkID0gZnVuY3Rpb24odmFsdWUsIGdyaWRTaXplKSB7XG5cbiAgICByZXR1cm4gZ3JpZFNpemUgKiByb3VuZCh2YWx1ZSAvIGdyaWRTaXplKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b0RlZyA9IGZ1bmN0aW9uKHJhZCkge1xuXG4gICAgcmV0dXJuICgxODAgKiByYWQgLyBQSSkgJSAzNjA7XG59O1xuXG5leHBvcnQgY29uc3QgdG9SYWQgPSBmdW5jdGlvbihkZWcsIG92ZXIzNjApIHtcblxuICAgIG92ZXIzNjAgPSBvdmVyMzYwIHx8IGZhbHNlO1xuICAgIGRlZyA9IG92ZXIzNjAgPyBkZWcgOiAoZGVnICUgMzYwKTtcbiAgICByZXR1cm4gZGVnICogUEkgLyAxODA7XG59O1xuXG4vLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBmcm9tIHRoZSBpbnRlcnZhbCBbbWluLG1heF0sIGluY2x1c2l2ZS5cbmV4cG9ydCBjb25zdCByYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSBmaXJzdCBhcmd1bWVudCBhcyBtYXgsIG1pbiBpcyAwXG4gICAgICAgIG1heCA9IChtaW4gPT09IHVuZGVmaW5lZCkgPyAxIDogbWluO1xuICAgICAgICBtaW4gPSAwO1xuXG4gICAgfSBlbHNlIGlmIChtYXggPCBtaW4pIHtcbiAgICAgICAgLy8gc3dpdGNoIG1heCBhbmQgbWluXG4gICAgICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluKTtcbn07XG5cbiJdLCJuYW1lcyI6WyJyb3VuZCIsImZsb29yIiwiUEkiLCJNYXRoIiwic2NhbGUiLCJsaW5lYXIiLCJkb21haW4iLCJyYW5nZSIsInZhbHVlIiwiZG9tYWluU3BhbiIsInJhbmdlU3BhbiIsIm5vcm1hbGl6ZUFuZ2xlIiwiYW5nbGUiLCJzbmFwVG9HcmlkIiwiZ3JpZFNpemUiLCJ0b0RlZyIsInJhZCIsInRvUmFkIiwiZGVnIiwib3ZlcjM2MCIsInJhbmRvbSIsIm1pbiIsIm1heCIsInVuZGVmaW5lZCIsInRlbXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/jointjs/src/g/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: () => (/* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve),\n/* harmony export */   Ellipse: () => (/* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.Ellipse),\n/* harmony export */   Line: () => (/* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line),\n/* harmony export */   Path: () => (/* reexport safe */ _path_mjs__WEBPACK_IMPORTED_MODULE_5__.Path),\n/* harmony export */   Point: () => (/* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.Point),\n/* harmony export */   Polygon: () => (/* reexport safe */ _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon),\n/* harmony export */   Polyline: () => (/* reexport safe */ _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__.Polyline),\n/* harmony export */   Rect: () => (/* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.Rect),\n/* harmony export */   bezier: () => (/* reexport safe */ _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__.bezier),\n/* harmony export */   ellipse: () => (/* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.ellipse),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   line: () => (/* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.line),\n/* harmony export */   normalizeAngle: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle),\n/* harmony export */   point: () => (/* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.point),\n/* harmony export */   random: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random),\n/* harmony export */   rect: () => (/* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.rect),\n/* harmony export */   scale: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.scale),\n/* harmony export */   snapToGrid: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid),\n/* harmony export */   toDeg: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg),\n/* harmony export */   toRad: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad),\n/* harmony export */   types: () => (/* reexport safe */ _types_mjs__WEBPACK_IMPORTED_MODULE_10__.types)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier.mjs */ \"(ssr)/./node_modules/jointjs/src/g/bezier.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/jointjs/src/g/curve.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse.mjs */ \"(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.mjs */ \"(ssr)/./node_modules/jointjs/src/g/path.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polygon.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n/* harmony import */ var _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./intersection.mjs */ \"(ssr)/./node_modules/jointjs/src/g/intersection.mjs\");\n// Geometry library.\n// -----------------\n\n\n\n\n\n\n\n\n\n\n\n\nconst intersection = _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUVtQjtBQUNWO0FBQ0Q7QUFDRTtBQUNIO0FBQ0E7QUFDQztBQUNHO0FBQ0Q7QUFDSDtBQUNDO0FBRXdCO0FBQzdDLE1BQU1DLGVBQWVELCtDQUFhQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9pbmRleC5tanM/OGVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW9tZXRyeSBsaWJyYXJ5LlxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0ICogZnJvbSAnLi9nZW9tZXRyeS5oZWxwZXJzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Jlemllci5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jdXJ2ZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGxpcHNlLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpbmUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGF0aC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2x5bGluZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2x5Z29uLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3JlY3QubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMubWpzJztcblxuaW1wb3J0ICogYXMgX2ludGVyc2VjdGlvbiBmcm9tICcuL2ludGVyc2VjdGlvbi5tanMnO1xuZXhwb3J0IGNvbnN0IGludGVyc2VjdGlvbiA9IF9pbnRlcnNlY3Rpb247XG4iXSwibmFtZXMiOlsiX2ludGVyc2VjdGlvbiIsImludGVyc2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/intersection.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/jointjs/src/g/intersection.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ellipseWithEllipse: () => (/* binding */ ellipseWithEllipse),\n/* harmony export */   ellipseWithLine: () => (/* binding */ ellipseWithLine),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   lineWithLine: () => (/* binding */ lineWithLine),\n/* harmony export */   pathWithEllipse: () => (/* binding */ pathWithEllipse),\n/* harmony export */   pathWithLine: () => (/* binding */ pathWithLine),\n/* harmony export */   pathWithPath: () => (/* binding */ pathWithPath),\n/* harmony export */   pathWithPolygon: () => (/* binding */ pathWithPolygon),\n/* harmony export */   pathWithPolyline: () => (/* binding */ pathWithPolyline),\n/* harmony export */   pathWithRect: () => (/* binding */ pathWithRect),\n/* harmony export */   polygonWithEllipse: () => (/* binding */ polygonWithEllipse),\n/* harmony export */   polygonWithLine: () => (/* binding */ polygonWithLine),\n/* harmony export */   polygonWithPolygon: () => (/* binding */ polygonWithPolygon),\n/* harmony export */   polygonWithPolyline: () => (/* binding */ polygonWithPolyline),\n/* harmony export */   polygonWithRect: () => (/* binding */ polygonWithRect),\n/* harmony export */   polylineWithEllipse: () => (/* binding */ polylineWithEllipse),\n/* harmony export */   polylineWithLine: () => (/* binding */ polylineWithLine),\n/* harmony export */   polylineWithPolyline: () => (/* binding */ polylineWithPolyline),\n/* harmony export */   polylineWithRect: () => (/* binding */ polylineWithRect),\n/* harmony export */   rectWithEllipse: () => (/* binding */ rectWithEllipse),\n/* harmony export */   rectWithLine: () => (/* binding */ rectWithLine),\n/* harmony export */   rectWithRect: () => (/* binding */ rectWithRect)\n/* harmony export */ });\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n\n\n\n\nfunction exists(shape1, shape2, shape1opt, shape2opt) {\n    switch(shape1.type){\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return lineWithLine(shape1, shape2);\n                        }\n                }\n                break;\n            }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return ellipseWithLine(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n                        {\n                            return ellipseWithEllipse(shape1, shape2);\n                        }\n                }\n                break;\n            }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return rectWithLine(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n                        {\n                            return rectWithEllipse(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n                        {\n                            return rectWithRect(shape1, shape2);\n                        }\n                }\n                break;\n            }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return polylineWithLine(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n                        {\n                            return polylineWithEllipse(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n                        {\n                            return polylineWithRect(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n                        {\n                            return polylineWithPolyline(shape1, shape2);\n                        }\n                }\n                break;\n            }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return polygonWithLine(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n                        {\n                            return polygonWithEllipse(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n                        {\n                            return polygonWithRect(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n                        {\n                            return polygonWithPolyline(shape1, shape2);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n                        {\n                            return polygonWithPolygon(shape1, shape2);\n                        }\n                }\n                break;\n            }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path:\n            {\n                switch(shape2.type){\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line:\n                        {\n                            return pathWithLine(shape1, shape2, shape1opt);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n                        {\n                            return pathWithEllipse(shape1, shape2, shape1opt);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n                        {\n                            return pathWithRect(shape1, shape2, shape1opt);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n                        {\n                            return pathWithPolyline(shape1, shape2, shape1opt);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n                        {\n                            return pathWithPolygon(shape1, shape2, shape1opt);\n                        }\n                    case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path:\n                        {\n                            return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                        }\n                }\n                break;\n            }\n    }\n    // None of the cases above\n    switch(shape2.type){\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path:\n            {\n                return exists(shape2, shape1, shape2opt, shape1opt);\n            }\n        default:\n            {\n                throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n            }\n    }\n}\n/* Line */ function lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n/* Ellipse */ function ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;\n    }\n    return false;\n}\nfunction ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n/* Rect */ function rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);\n}\nfunction rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(_polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), ellipse);\n}\nfunction rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;\n}\n/* Polyline */ function polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, {\n        interior: false\n    });\n}\nfunction polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, {\n        interior: false\n    });\n}\nfunction polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, {\n        interior: false\n    });\n}\nfunction polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, {\n        interior: false\n    });\n}\n/* Polygon */ function polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, {\n        interior: true\n    });\n}\nfunction polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, {\n        interior: true\n    });\n}\nfunction polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, {\n        interior: true\n    });\n}\nfunction polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, {\n        interior: true\n    });\n}\nfunction polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, {\n        interior: true\n    });\n}\n/* Path */ function pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some((subpath)=>{\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === \"Z\") {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\nfunction pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some((subpath)=>{\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === \"Z\") {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\nfunction pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), pathOpt);\n}\nfunction pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, {\n        interior: false\n    });\n}\nfunction pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, {\n        interior: true\n    });\n}\nfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some((subpath)=>{\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === \"Z\") {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [\n            ...points,\n            start\n        ];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for(let i = 0; i < length - 1; i++){\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [\n            ...points,\n            start\n        ];\n    } else {\n        thisPoints = points;\n    }\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for(let i = 0; i < length - 1; i++){\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some((subpath)=>{\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === \"Z\") {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for(let i = 0; i < length - 1; i++){\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = -2 * A1 * e1.x - C1 * e1.y;\n    let D2 = -2 * A2 * e2.x - C2 * e2.y;\n    let E1 = -C1 * e1.x - 2 * B1 * e1.y;\n    let E2 = -C2 * e2.x - 2 * B2 * e2.y;\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n    const l3 = det3([\n        [\n            A1,\n            C1,\n            D1\n        ],\n        [\n            C1,\n            B1,\n            E1\n        ],\n        [\n            D1,\n            E1,\n            F1\n        ]\n    ]);\n    const l0 = det3([\n        [\n            A2,\n            C2,\n            D2\n        ],\n        [\n            C2,\n            B2,\n            E2\n        ],\n        [\n            D2,\n            E2,\n            F2\n        ]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [\n            A2,\n            C1,\n            D1\n        ],\n        [\n            C2,\n            B1,\n            E1\n        ],\n        [\n            D2,\n            E1,\n            F1\n        ]\n    ]) + det3([\n        [\n            A1,\n            C2,\n            D1\n        ],\n        [\n            C1,\n            B2,\n            E1\n        ],\n        [\n            D1,\n            E2,\n            F1\n        ]\n    ]) + det3([\n        [\n            A1,\n            C1,\n            D2\n        ],\n        [\n            C1,\n            B1,\n            E2\n        ],\n        [\n            D1,\n            E1,\n            F2\n        ]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [\n            A1,\n            C2,\n            D2\n        ],\n        [\n            C1,\n            B2,\n            E2\n        ],\n        [\n            D1,\n            E2,\n            F2\n        ]\n    ]) + det3([\n        [\n            A2,\n            C1,\n            D2\n        ],\n        [\n            C2,\n            B1,\n            E2\n        ],\n        [\n            D2,\n            E1,\n            F2\n        ]\n    ]) + det3([\n        [\n            A2,\n            C2,\n            D1\n        ],\n        [\n            C2,\n            B2,\n            E1\n        ],\n        [\n            D2,\n            E2,\n            F1\n        ]\n    ]));\n    const delta1 = det2([\n        [\n            l3,\n            l2\n        ],\n        [\n            l2,\n            l1\n        ]\n    ]);\n    const delta2 = det2([\n        [\n            l3,\n            l1\n        ],\n        [\n            l2,\n            l0\n        ]\n    ]);\n    const delta3 = det2([\n        [\n            l2,\n            l1\n        ],\n        [\n            l1,\n            l0\n        ]\n    ]);\n    const dP = det2([\n        [\n            2 * delta1,\n            delta2\n        ],\n        [\n            delta2,\n            2 * delta3\n        ]\n    ]);\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9pbnRlcnNlY3Rpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ007QUFDTjtBQUNFO0FBRTdCLFNBQVNJLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLFNBQVM7SUFDdkQsT0FBUUgsT0FBT0ksSUFBSTtRQUNmLEtBQUtOLDZDQUFLQSxDQUFDSCxJQUFJO1lBQUU7Z0JBQ2IsT0FBUU0sT0FBT0csSUFBSTtvQkFDZixLQUFLTiw2Q0FBS0EsQ0FBQ0gsSUFBSTt3QkFBRTs0QkFDYixPQUFPVSxhQUFhTCxRQUFRQzt3QkFDaEM7Z0JBQ0o7Z0JBQ0E7WUFDSjtRQUNBLEtBQUtILDZDQUFLQSxDQUFDUSxPQUFPO1lBQUU7Z0JBQ2hCLE9BQVFMLE9BQU9HLElBQUk7b0JBQ2YsS0FBS04sNkNBQUtBLENBQUNILElBQUk7d0JBQUU7NEJBQ2IsT0FBT1ksZ0JBQWdCUCxRQUFRQzt3QkFDbkM7b0JBQ0EsS0FBS0gsNkNBQUtBLENBQUNRLE9BQU87d0JBQUU7NEJBQ2hCLE9BQU9FLG1CQUFtQlIsUUFBUUM7d0JBQ3RDO2dCQUNKO2dCQUNBO1lBQ0o7UUFDQSxLQUFLSCw2Q0FBS0EsQ0FBQ0QsSUFBSTtZQUFFO2dCQUNiLE9BQVFJLE9BQU9HLElBQUk7b0JBQ2YsS0FBS04sNkNBQUtBLENBQUNILElBQUk7d0JBQUU7NEJBQ2IsT0FBT2MsYUFBYVQsUUFBUUM7d0JBQ2hDO29CQUNBLEtBQUtILDZDQUFLQSxDQUFDUSxPQUFPO3dCQUFFOzRCQUNoQixPQUFPSSxnQkFBZ0JWLFFBQVFDO3dCQUNuQztvQkFDQSxLQUFLSCw2Q0FBS0EsQ0FBQ0QsSUFBSTt3QkFBRTs0QkFDYixPQUFPYyxhQUFhWCxRQUFRQzt3QkFDaEM7Z0JBQ0o7Z0JBQ0E7WUFDSjtRQUNBLEtBQUtILDZDQUFLQSxDQUFDYyxRQUFRO1lBQUU7Z0JBQ2pCLE9BQVFYLE9BQU9H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Q0E7WUFBSUY7U0FBRztLQUNYO0lBRUQsTUFBTU8sS0FBS0gsS0FBSztRQUNaO1lBQUMsSUFBSUQ7WUFBUUU7U0FBTztRQUNwQjtZQUFDQTtZQUFRLElBQUlDO1NBQU87S0FDdkI7SUFFRCxJQUFJQyxLQUFLLEtBQU1MLENBQUFBLEtBQUssS0FBS0QsS0FBSyxJQUFJO1FBQzlCLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUVBLFNBQVNHLEtBQUtJLENBQUM7SUFDWCxPQUFPQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDaEQ7QUFFQSxTQUFTVCxLQUFLUyxDQUFDO0lBQ1gsT0FBT0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FDOUJBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQzNCQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUMzQkEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FDM0JBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQzNCQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2cvaW50ZXJzZWN0aW9uLm1qcz81MzU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmUgfSBmcm9tICcuL2xpbmUubWpzJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL3BvbHlnb24ubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQsIHNoYXBlMm9wdCkge1xuICAgIHN3aXRjaCAoc2hhcGUxLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lV2l0aExpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxsaXBzZVdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGxpcHNlV2l0aEVsbGlwc2Uoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuUmVjdDoge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aEVsbGlwc2Uoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoUmVjdChzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZToge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoTGluZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUmVjdDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoUmVjdChzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lV2l0aFBvbHlsaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHR5cGVzLlBvbHlnb246IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2hhcGUyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoTGluZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbldpdGhFbGxpcHNlKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFJlY3Qoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlBvbHlsaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFBvbHlsaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5Qb2x5Z29uOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFBvbHlnb24oc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuUGF0aDoge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aFJlY3Qoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUG9seWxpbmUoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWdvbjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhQb2x5Z29uKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUGF0aChzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0LCBzaGFwZTJvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vbmUgb2YgdGhlIGNhc2VzIGFib3ZlXG4gICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6XG4gICAgICAgIGNhc2UgdHlwZXMuUmVjdDpcbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZTpcbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5Z29uOlxuICAgICAgICBjYXNlIHR5cGVzLlBhdGg6IHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdHMoc2hhcGUyLCBzaGFwZTEsIHNoYXBlMm9wdCwgc2hhcGUxb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlIGludGVyc2VjdGlvbiBmb3IgJHtzaGFwZTF9IGFuZCAke3NoYXBlMn0gY291bGQgbm90IGJlIGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiBMaW5lICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lV2l0aExpbmUobGluZTEsIGxpbmUyKSB7XG4gICAgY29uc3QgeDEgPSBsaW5lMS5zdGFydC54O1xuICAgIGNvbnN0IHkxID0gbGluZTEuc3RhcnQueTtcbiAgICBjb25zdCB4MiA9IGxpbmUxLmVuZC54O1xuICAgIGNvbnN0IHkyID0gbGluZTEuZW5kLnk7XG4gICAgY29uc3QgeDMgPSBsaW5lMi5zdGFydC54O1xuICAgIGNvbnN0IHkzID0gbGluZTIuc3RhcnQueTtcbiAgICBjb25zdCB4NCA9IGxpbmUyLmVuZC54O1xuICAgIGNvbnN0IHk0ID0gbGluZTIuZW5kLnk7XG4gICAgY29uc3QgczF4ID0geDIgLSB4MTtcbiAgICBjb25zdCBzMXkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IHMyeCA9IHg0IC0geDM7XG4gICAgY29uc3QgczJ5ID0geTQgLSB5MztcbiAgICBjb25zdCBzM3ggPSB4MSAtIHgzO1xuICAgIGNvbnN0IHMzeSA9IHkxIC0geTM7XG4gICAgY29uc3QgcCA9IHMxeCAqIHMyeSAtIHMyeCAqIHMxeTtcbiAgICBjb25zdCBzID0gKHMxeCAqIHMzeSAtIHMxeSAqIHMzeCkgLyBwO1xuICAgIGNvbnN0IHQgPSAoczJ4ICogczN5IC0gczJ5ICogczN4KSAvIHA7XG4gICAgcmV0dXJuIHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMTtcbn1cblxuLyogRWxsaXBzZSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZVdpdGhMaW5lKGVsbGlwc2UsIGxpbmUpIHtcbiAgICBjb25zdCByZXggPSBlbGxpcHNlLmE7XG4gICAgY29uc3QgcmV5ID0gZWxsaXBzZS5iO1xuICAgIGNvbnN0IHhlID0gZWxsaXBzZS54O1xuICAgIGNvbnN0IHllID0gZWxsaXBzZS55O1xuICAgIGNvbnN0IHgxID0gbGluZS5zdGFydC54IC0geGU7XG4gICAgY29uc3QgeDIgPSBsaW5lLmVuZC54IC0geGU7XG4gICAgY29uc3QgeTEgPSBsaW5lLnN0YXJ0LnkgLSB5ZTtcbiAgICBjb25zdCB5MiA9IGxpbmUuZW5kLnkgLSB5ZTtcbiAgICBjb25zdCByZXhfMiA9IHJleCAqIHJleDtcbiAgICBjb25zdCByZXlfMiA9IHJleSAqIHJleTtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IEEgPSBkeCAqIGR4IC8gcmV4XzIgKyBkeSAqIGR5IC8gcmV5XzI7XG4gICAgY29uc3QgQiA9IDIgKiB4MSAqIGR4IC8gcmV4XzIgKyAyICogeTEgKiBkeSAvIHJleV8yO1xuICAgIGNvbnN0IEMgPSB4MSAqIHgxIC8gcmV4XzIgKyB5MSAqIHkxIC8gcmV5XzIgLSAxO1xuICAgIGNvbnN0IEQgPSBCICogQiAtIDQgKiBBICogQztcbiAgICBpZiAoRCA9PT0gMCkge1xuICAgICAgICBjb25zdCB0ID0gLUIgLyAyIC8gQTtcbiAgICAgICAgcmV0dXJuIHQgPj0gMCAmJiB0IDw9IDE7XG4gICAgfSBlbHNlIGlmIChEID4gMCkge1xuICAgICAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KEQpO1xuICAgICAgICBjb25zdCB0MSA9ICgtQiArIHNxcnQpIC8gMiAvIEE7XG4gICAgICAgIGNvbnN0IHQyID0gKC1CIC0gc3FydCkgLyAyIC8gQTtcbiAgICAgICAgcmV0dXJuICh0MSA+PSAwICYmIHQxIDw9IDEpIHx8ICh0MiA+PSAwICYmIHQyIDw9IDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbGxpcHNlV2l0aEVsbGlwc2UoZWxsaXBzZTEsIGVsbGlwc2UyKSB7XG4gICAgcmV0dXJuIF9lbGxpcHNlc0ludGVyc2VjdGlvbihlbGxpcHNlMSwgMCwgZWxsaXBzZTIsIDApO1xufVxuXG4vKiBSZWN0ICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0V2l0aExpbmUocmVjdCwgbGluZSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gbGluZTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgaWYgKFxuICAgICAgICAoc3RhcnQueCA+IHggKyB3aWR0aCAmJiBlbmQueCA+IHggKyB3aWR0aClcbiAgICAgICAgfHwgKHN0YXJ0LnggPCB4ICYmIGVuZC54IDwgeClcbiAgICAgICAgfHwgKHN0YXJ0LnkgPiB5ICsgaGVpZ2h0ICYmIGVuZC55ID4geSArIGhlaWdodClcbiAgICAgICAgfHwgKHN0YXJ0LnkgPCB5ICYmIGVuZC55IDwgeSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVjdC5jb250YWluc1BvaW50KGxpbmUuc3RhcnQpIHx8IHJlY3QuY29udGFpbnNQb2ludChsaW5lLmVuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsaW5lV2l0aExpbmUocmVjdC50b3BMaW5lKCksIGxpbmUpXG4gICAgICAgIHx8IGxpbmVXaXRoTGluZShyZWN0LnJpZ2h0TGluZSgpLCBsaW5lKVxuICAgICAgICB8fCBsaW5lV2l0aExpbmUocmVjdC5ib3R0b21MaW5lKCksIGxpbmUpXG4gICAgICAgIHx8IGxpbmVXaXRoTGluZShyZWN0LmxlZnRMaW5lKCksIGxpbmUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdFdpdGhFbGxpcHNlKHJlY3QsIGVsbGlwc2UpIHtcbiAgICBpZiAoIXJlY3RXaXRoUmVjdChyZWN0LCBSZWN0LmZyb21FbGxpcHNlKGVsbGlwc2UpKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwb2x5Z29uV2l0aEVsbGlwc2UoUG9seWdvbi5mcm9tUmVjdChyZWN0KSwgZWxsaXBzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0V2l0aFJlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgcmV0dXJuIHJlY3QxLnggPCByZWN0Mi54ICsgcmVjdDIud2lkdGhcbiAgICAgICAgJiYgcmVjdDEueCArIHJlY3QxLndpZHRoID4gcmVjdDIueFxuICAgICAgICAmJiByZWN0MS55IDwgcmVjdDIueSArIHJlY3QyLmhlaWdodFxuICAgICAgICAmJiByZWN0MS55ICsgcmVjdDEuaGVpZ2h0ID4gcmVjdDIueTtcbn1cblxuLyogUG9seWxpbmUgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUsIHsgaW50ZXJpb3I6IGZhbHNlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSwgeyBpbnRlcmlvcjogZmFsc2UgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZVdpdGhSZWN0KHBvbHlsaW5lLCByZWN0KSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhSZWN0KHBvbHlsaW5lLCByZWN0LCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhQb2x5bGluZShwb2x5bGluZTEsIHBvbHlsaW5lMiwgeyBpbnRlcmlvcjogZmFsc2UgfSk7XG59XG5cbi8qIFBvbHlnb24gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25XaXRoTGluZShwb2x5Z29uLCBsaW5lKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhMaW5lKHBvbHlnb24sIGxpbmUsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uV2l0aEVsbGlwc2UocG9seWdvbiwgZWxsaXBzZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5Z29uLCBlbGxpcHNlLCB7IGludGVyaW9yOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhSZWN0KHBvbHlnb24sIHJlY3QpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFJlY3QocG9seWdvbiwgcmVjdCwgeyBpbnRlcmlvcjogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25XaXRoUG9seWxpbmUocG9seWdvbiwgcG9seWxpbmUpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlnb24sIHBvbHlsaW5lLCB7IGludGVyaW9yOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhQb2x5Z29uKHBvbHlnb24xLCBwb2x5Z29uMikge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWdvbihwb2x5Z29uMSwgcG9seWdvbjIsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbi8qIFBhdGggKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoTGluZShwYXRoLCBsaW5lLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIHBhdGguZ2V0U3VicGF0aHMoKS5zb21lKHN1YnBhdGggPT4ge1xuICAgICAgICBjb25zdCBbcG9seWxpbmVdID0gc3VicGF0aC50b1BvbHlsaW5lcyhwYXRoT3B0KTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdWJwYXRoLmdldFNlZ21lbnQoLTEpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbldpdGhMaW5lKHBvbHlsaW5lLCBsaW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5bGluZVdpdGhMaW5lKHBvbHlsaW5lLCBsaW5lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhFbGxpcHNlKHBhdGgsIGVsbGlwc2UsIHBhdGhPcHQpIHtcbiAgICByZXR1cm4gcGF0aC5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZV0gPSBzdWJwYXRoLnRvUG9seWxpbmVzKHBhdGhPcHQpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aEVsbGlwc2UocG9seWxpbmUsIGVsbGlwc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lV2l0aEVsbGlwc2UocG9seWxpbmUsIGVsbGlwc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFJlY3QocGF0aCwgcmVjdCwgcGF0aE9wdCkge1xuICAgIHJldHVybiBwYXRoV2l0aFBvbHlnb24ocGF0aCwgUG9seWdvbi5mcm9tUmVjdChyZWN0KSwgcGF0aE9wdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlsaW5lLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIF9wYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlsaW5lLCBwYXRoT3B0LCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoUG9seWdvbihwYXRoLCBwb2x5Z29uLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIF9wYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlnb24sIHBhdGhPcHQsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFBhdGgocGF0aDEsIHBhdGgyLCBwYXRoT3B0MSwgcGF0aE9wdDIpIHtcbiAgICByZXR1cm4gcGF0aDEuZ2V0U3VicGF0aHMoKS5zb21lKHN1YnBhdGggPT4ge1xuICAgICAgICBjb25zdCBbcG9seWxpbmUxXSA9IHN1YnBhdGgudG9Qb2x5bGluZXMocGF0aE9wdDEpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aFBvbHlnb24ocGF0aDIsIHBvbHlsaW5lMSwgcGF0aE9wdDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUG9seWxpbmUocGF0aDIsIHBvbHlsaW5lMSwgcGF0aE9wdDIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhMaW5lKHBvbHlsaW5lLCBsaW5lLCBvcHQgPSB7fSkge1xuICAgIGNvbnN0IHsgaW50ZXJpb3IgPSBmYWxzZSB9ID0gb3B0O1xuICAgIGxldCB0aGlzUG9pbnRzO1xuICAgIGlmIChpbnRlcmlvcikge1xuICAgICAgICBpZiAocG9seWxpbmUuY29udGFpbnNQb2ludChsaW5lLnN0YXJ0KSkge1xuICAgICAgICAgICAgLy8gSWYgYW55IHBvaW50IG9mIHRoZSBwb2x5bGluZSBsaWVzIGluc2lkZSB0aGlzIHBvbHlnb24gKGludGVyaW9yID0gdHJ1ZSlcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiAod2UndmUgY2hvc2VuIHRoZSBzdGFydCBwb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSBwb2x5bGluZTtcbiAgICAgICAgdGhpc1BvaW50cyA9IGVuZC5lcXVhbHMoc3RhcnQpID8gcG9pbnRzIDogWy4uLnBvaW50cywgc3RhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2ludHMgPSBwb2x5bGluZS5wb2ludHM7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzUG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgTGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnQuc3RhcnQgPSB0aGlzUG9pbnRzW2ldO1xuICAgICAgICBzZWdtZW50LmVuZCA9IHRoaXNQb2ludHNbaSArIDFdO1xuICAgICAgICBpZiAobGluZVdpdGhMaW5lKGxpbmUsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhFbGxpcHNlKHBvbHlsaW5lLCBlbGxpcHNlLCBvcHQgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSBwb2x5bGluZTtcbiAgICBpZiAoZWxsaXBzZS5jb250YWluc1BvaW50KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHRoaXNQb2ludHM7XG4gICAgY29uc3QgeyBpbnRlcmlvciA9IGZhbHNlIH0gPSBvcHQ7XG4gICAgaWYgKGludGVyaW9yKSB7XG4gICAgICAgIGlmIChwb2x5bGluZS5jb250YWluc1BvaW50KGVsbGlwc2UuY2VudGVyKCkpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgcG9pbnQgb2YgdGhlIGVsbGlwc2UgbGllcyBpbnNpZGUgdGhpcyBwb2x5Z29uIChpbnRlcmlvciA9IHRydWUpXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24gKHdlJ3ZlIGNob3NlbiB0aGUgY2VudGVyIHBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1BvaW50cyA9IGVuZC5lcXVhbHMoc3RhcnQpID8gcG9pbnRzIDogWy4uLnBvaW50cywgc3RhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2ludHMgPSBwb2ludHM7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHRoaXNQb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudCA9IG5ldyBMaW5lKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgc2VnbWVudC5zdGFydCA9IHRoaXNQb2ludHNbaV07XG4gICAgICAgIHNlZ21lbnQuZW5kID0gdGhpc1BvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChlbGxpcHNlV2l0aExpbmUoZWxsaXBzZSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aFJlY3QocG9seWxpbmUsIHJlY3QsIG9wdCkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBQb2x5Z29uLmZyb21SZWN0KHJlY3QpO1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWdvbihwb2x5bGluZSwgcG9seWdvbiwgb3B0KTtcbn1cblxuZnVuY3Rpb24gX3BhdGhXaXRoUG9seWxpbmUocGF0aCwgcG9seWxpbmUxLCBwYXRoT3B0LCBvcHQpIHtcbiAgICByZXR1cm4gcGF0aC5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZTJdID0gc3VicGF0aC50b1BvbHlsaW5lcyhwYXRoT3B0KTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdWJwYXRoLmdldFNlZ21lbnQoLTEpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlnb24ocG9seWxpbmUxLCBwb2x5bGluZTIsIG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhQb2x5bGluZShwb2x5bGluZTEsIHBvbHlsaW5lMiwgb3B0ID0ge30pIHtcbiAgICBjb25zdCB7IGludGVyaW9yID0gZmFsc2UgfSA9IG9wdDtcbiAgICBsZXQgdGhpc1BvbHlsaW5lO1xuICAgIGlmIChpbnRlcmlvcikge1xuICAgICAgICBjb25zdCB7IHN0YXJ0IH0gPSBwb2x5bGluZTI7XG4gICAgICAgIGlmIChwb2x5bGluZTEuY29udGFpbnNQb2ludChzdGFydCkpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBwb2ludCBvZiB0aGUgcG9seWxpbmUgbGllcyBpbnNpZGUgdGhpcyBwb2x5Z29uIChpbnRlcmlvciA9IHRydWUpXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24gKHdlJ3ZlIGNob3NlbiB0aGUgc3RhcnQgcG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzUG9seWxpbmUgPSBwb2x5bGluZTEuY2xvbmUoKS5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2x5bGluZSA9IHBvbHlsaW5lMTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJQb2ludHMgPSBwb2x5bGluZTIucG9pbnRzO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBvdGhlclBvaW50cztcbiAgICBjb25zdCBzZWdtZW50ID0gbmV3IExpbmUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBzZWdtZW50LnN0YXJ0ID0gb3RoZXJQb2ludHNbaV07XG4gICAgICAgIHNlZ21lbnQuZW5kID0gb3RoZXJQb2ludHNbaSArIDFdO1xuICAgICAgICBpZiAocG9seWxpbmVXaXRoTGluZSh0aGlzUG9seWxpbmUsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhQb2x5Z29uKHBvbHlsaW5lLCBwb2x5Z29uLCBvcHQpIHtcbiAgICByZXR1cm4gcG9seWdvbi5jb250YWluc1BvaW50KHBvbHlsaW5lLnN0YXJ0KSB8fCBfcG9seWxpbmVXaXRoUG9seWxpbmUocG9seWxpbmUsIHBvbHlnb24uY2xvbmUoKS5jbG9zZSgpLCBvcHQpO1xufVxuXG5mdW5jdGlvbiBfZWxsaXBzZXNJbnRlcnNlY3Rpb24oZTEsIHcxLCBlMiwgdzIpIHtcbiAgICBjb25zdCB7IGNvcywgc2luIH0gPSBNYXRoO1xuICAgIGNvbnN0IHNpblcxID0gc2luKHcxKTtcbiAgICBjb25zdCBjb3NXMSA9IGNvcyh3MSk7XG4gICAgY29uc3Qgc2luVzIgPSBzaW4odzIpO1xuICAgIGNvbnN0IGNvc1cyID0gY29zKHcyKTtcbiAgICBjb25zdCBzaW5XMXMgPSBzaW5XMSAqIHNpblcxO1xuICAgIGNvbnN0IGNvc1cxcyA9IGNvc1cxICogY29zVzE7XG4gICAgY29uc3Qgc2luQ29zMSA9IHNpblcxICogY29zVzE7XG4gICAgY29uc3Qgc2luVzJzID0gc2luVzIgKiBzaW5XMjtcbiAgICBjb25zdCBjb3NXMnMgPSBjb3NXMiAqIGNvc1cyO1xuICAgIGNvbnN0IHNpbkNvczIgPSBzaW5XMiAqIGNvc1cyO1xuICAgIGNvbnN0IGExcyA9IGUxLmEgKiBlMS5hO1xuICAgIGNvbnN0IGIxcyA9IGUxLmIgKiBlMS5iO1xuICAgIGNvbnN0IGEycyA9IGUyLmEgKiBlMi5hO1xuICAgIGNvbnN0IGIycyA9IGUyLmIgKiBlMi5iO1xuICAgIGNvbnN0IEExID0gYTFzICogc2luVzFzICsgYjFzICogY29zVzFzO1xuICAgIGNvbnN0IEEyID0gYTJzICogc2luVzJzICsgYjJzICogY29zVzJzO1xuICAgIGNvbnN0IEIxID0gYTFzICogY29zVzFzICsgYjFzICogc2luVzFzO1xuICAgIGNvbnN0IEIyID0gYTJzICogY29zVzJzICsgYjJzICogc2luVzJzO1xuICAgIGxldCBDMSA9IDIgKiAoYjFzIC0gYTFzKSAqIHNpbkNvczE7XG4gICAgbGV0IEMyID0gMiAqIChiMnMgLSBhMnMpICogc2luQ29zMjtcbiAgICBsZXQgRDEgPSAoLTIgKiBBMSAqIGUxLnggLSBDMSAqIGUxLnkpO1xuICAgIGxldCBEMiA9ICgtMiAqIEEyICogZTIueCAtIEMyICogZTIueSk7XG4gICAgbGV0IEUxID0gKC1DMSAqIGUxLnggLSAyICogQjEgKiBlMS55KTtcbiAgICBsZXQgRTIgPSAoLUMyICogZTIueCAtIDIgKiBCMiAqIGUyLnkpO1xuICAgIGNvbnN0IEYxID0gQTEgKiBlMS54ICogZTEueCArIEIxICogZTEueSAqIGUxLnkgKyBDMSAqIGUxLnggKiBlMS55IC0gYTFzICogYjFzO1xuICAgIGNvbnN0IEYyID0gQTIgKiBlMi54ICogZTIueCArIEIyICogZTIueSAqIGUyLnkgKyBDMiAqIGUyLnggKiBlMi55IC0gYTJzICogYjJzO1xuXG4gICAgQzEgPSBDMSAvIDI7XG4gICAgQzIgPSBDMiAvIDI7XG4gICAgRDEgPSBEMSAvIDI7XG4gICAgRDIgPSBEMiAvIDI7XG4gICAgRTEgPSBFMSAvIDI7XG4gICAgRTIgPSBFMiAvIDI7XG5cbiAgICBjb25zdCBsMyA9IGRldDMoW1xuICAgICAgICBbQTEsIEMxLCBEMV0sXG4gICAgICAgIFtDMSwgQjEsIEUxXSxcbiAgICAgICAgW0QxLCBFMSwgRjFdXG4gICAgXSk7XG4gICAgY29uc3QgbDAgPSBkZXQzKFtcbiAgICAgICAgW0EyLCBDMiwgRDJdLFxuICAgICAgICBbQzIsIEIyLCBFMl0sXG4gICAgICAgIFtEMiwgRTIsIEYyXVxuICAgIF0pO1xuICAgIGNvbnN0IGwyID0gMC4zMzMzMzMzMyAqIChkZXQzKFtcbiAgICAgICAgW0EyLCBDMSwgRDFdLFxuICAgICAgICBbQzIsIEIxLCBFMV0sXG4gICAgICAgIFtEMiwgRTEsIEYxXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMSwgQzIsIEQxXSxcbiAgICAgICAgW0MxLCBCMiwgRTFdLFxuICAgICAgICBbRDEsIEUyLCBGMV1cbiAgICBdKSArIGRldDMoW1xuICAgICAgICBbQTEsIEMxLCBEMl0sXG4gICAgICAgIFtDMSwgQjEsIEUyXSxcbiAgICAgICAgW0QxLCBFMSwgRjJdXG4gICAgXSkpO1xuICAgIGNvbnN0IGwxID0gMC4zMzMzMzMzMyAqIChkZXQzKFtcbiAgICAgICAgW0ExLCBDMiwgRDJdLFxuICAgICAgICBbQzEsIEIyLCBFMl0sXG4gICAgICAgIFtEMSwgRTIsIEYyXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMiwgQzEsIEQyXSxcbiAgICAgICAgW0MyLCBCMSwgRTJdLFxuICAgICAgICBbRDIsIEUxLCBGMl1cbiAgICBdKSArIGRldDMoW1xuICAgICAgICBbQTIsIEMyLCBEMV0sXG4gICAgICAgIFtDMiwgQjIsIEUxXSxcbiAgICAgICAgW0QyLCBFMiwgRjFdXG4gICAgXSkpO1xuXG4gICAgY29uc3QgZGVsdGExID0gZGV0MihbXG4gICAgICAgIFtsMywgbDJdLFxuICAgICAgICBbbDIsIGwxXVxuICAgIF0pO1xuICAgIGNvbnN0IGRlbHRhMiA9IGRldDIoW1xuICAgICAgICBbbDMsIGwxXSxcbiAgICAgICAgW2wyLCBsMF1cbiAgICBdKTtcbiAgICBjb25zdCBkZWx0YTMgPSBkZXQyKFtcbiAgICAgICAgW2wyLCBsMV0sXG4gICAgICAgIFtsMSwgbDBdXG4gICAgXSk7XG5cbiAgICBjb25zdCBkUCA9IGRldDIoW1xuICAgICAgICBbMiAqIGRlbHRhMSwgZGVsdGEyXSxcbiAgICAgICAgW2RlbHRhMiwgMiAqIGRlbHRhM11cbiAgICBdKTtcblxuICAgIGlmIChkUCA+IDAgJiYgKGwxID4gMCB8fCBsMiA+IDApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRldDIobSkge1xuICAgIHJldHVybiBtWzBdWzBdICogbVsxXVsxXSAtIG1bMF1bMV0gKiBtWzFdWzBdO1xufVxuXG5mdW5jdGlvbiBkZXQzKG0pIHtcbiAgICByZXR1cm4gbVswXVswXSAqIG1bMV1bMV0gKiBtWzJdWzJdIC1cbiAgICAgICAgbVswXVswXSAqIG1bMV1bMl0gKiBtWzJdWzFdIC1cbiAgICAgICAgbVswXVsxXSAqIG1bMV1bMF0gKiBtWzJdWzJdICtcbiAgICAgICAgbVswXVsxXSAqIG1bMV1bMl0gKiBtWzJdWzBdICtcbiAgICAgICAgbVswXVsyXSAqIG1bMV1bMF0gKiBtWzJdWzFdIC1cbiAgICAgICAgbVswXVsyXSAqIG1bMV1bMV0gKiBtWzJdWzBdO1xufVxuIl0sIm5hbWVzIjpbIkxpbmUiLCJQb2x5Z29uIiwiUmVjdCIsInR5cGVzIiwiZXhpc3RzIiwic2hhcGUxIiwic2hhcGUyIiwic2hhcGUxb3B0Iiwic2hhcGUyb3B0IiwidHlwZSIsImxpbmVXaXRoTGluZSIsIkVsbGlwc2UiLCJlbGxpcHNlV2l0aExpbmUiLCJlbGxpcHNlV2l0aEVsbGlwc2UiLCJyZWN0V2l0aExpbmUiLCJyZWN0V2l0aEVsbGlwc2UiLCJyZWN0V2l0aFJlY3QiLCJQb2x5bGluZSIsInBvbHlsaW5lV2l0aExpbmUiLCJwb2x5bGluZVdpdGhFbGxpcHNlIiwicG9seWxpbmVXaXRoUmVjdCIsInBvbHlsaW5lV2l0aFBvbHlsaW5lIiwicG9seWdvbldpdGhMaW5lIiwicG9seWdvbldpdGhFbGxpcHNlIiwicG9seWdvbldpdGhSZWN0IiwicG9seWdvbldpdGhQb2x5bGluZSIsInBvbHlnb25XaXRoUG9seWdvbiIsIlBhdGgiLCJwYXRoV2l0aExpbmUiLCJwYXRoV2l0aEVsbGlwc2UiLCJwYXRoV2l0aFJlY3QiLCJwYXRoV2l0aFBvbHlsaW5lIiwicGF0aFdpdGhQb2x5Z29uIiwicGF0aFdpdGhQYXRoIiwiRXJyb3IiLCJsaW5lMSIsImxpbmUyIiwieDEiLCJzdGFydCIsIngiLCJ5MSIsInkiLCJ4MiIsImVuZCIsInkyIiwieDMiLCJ5MyIsIng0IiwieTQiLCJzMXgiLCJzMXkiLCJzMngiLCJzMnkiLCJzM3giLCJzM3kiLCJwIiwicyIsInQiLCJlbGxpcHNlIiwibGluZSIsInJleCIsImEiLCJyZXkiLCJiIiwieGUiLCJ5ZSIsInJleF8yIiwicmV5XzIiLCJkeCIsImR5IiwiQSIsIkIiLCJDIiwiRCIsInNxcnQiLCJNYXRoIiwidDEiLCJ0MiIsImVsbGlwc2UxIiwiZWxsaXBzZTIiLCJfZWxsaXBzZXNJbnRlcnNlY3Rpb24iLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJjb250YWluc1BvaW50IiwidG9wTGluZSIsInJpZ2h0TGluZSIsImJvdHRvbUxpbmUiLCJsZWZ0TGluZSIsImZyb21FbGxpcHNlIiwiZnJvbVJlY3QiLCJyZWN0MSIsInJlY3QyIiwicG9seWxpbmUiLCJfcG9seWxpbmVXaXRoTGluZSIsImludGVyaW9yIiwiX3BvbHlsaW5lV2l0aEVsbGlwc2UiLCJfcG9seWxpbmVXaXRoUmVjdCIsInBvbHlsaW5lMSIsInBvbHlsaW5lMiIsIl9wb2x5bGluZVdpdGhQb2x5bGluZSIsInBvbHlnb24iLCJwb2x5Z29uMSIsInBvbHlnb24yIiwiX3BvbHlsaW5lV2l0aFBvbHlnb24iLCJwYXRoIiwicGF0aE9wdCIsImdldFN1YnBhdGhzIiwic29tZSIsInN1YnBhdGgiLCJ0b1BvbHlsaW5lcyIsImdldFNlZ21lbnQiLCJfcGF0aFdpdGhQb2x5bGluZSIsInBhdGgxIiwicGF0aDIiLCJwYXRoT3B0MSIsInBhdGhPcHQyIiwib3B0IiwidGhpc1BvaW50cyIsInBvaW50cyIsImVxdWFscyIsImxlbmd0aCIsInNlZ21lbnQiLCJpIiwiY2VudGVyIiwidGhpc1BvbHlsaW5lIiwiY2xvbmUiLCJjbG9zZSIsIm90aGVyUG9pbnRzIiwiZTEiLCJ3MSIsImUyIiwidzIiLCJjb3MiLCJzaW4iLCJzaW5XMSIsImNvc1cxIiwic2luVzIiLCJjb3NXMiIsInNpblcxcyIsImNvc1cxcyIsInNpbkNvczEiLCJzaW5XMnMiLCJjb3NXMnMiLCJzaW5Db3MyIiwiYTFzIiwiYjFzIiwiYTJzIiwiYjJzIiwiQTEiLCJBMiIsIkIxIiwiQjIiLCJDMSIsIkMyIiwiRDEiLCJEMiIsIkUxIiwiRTIiLCJGMSIsIkYyIiwibDMiLCJkZXQzIiwibDAiLCJsMiIsImwxIiwiZGVsdGExIiwiZGV0MiIsImRlbHRhMiIsImRlbHRhMyIsImRQIiwibSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/intersection.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/line.bearing.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/jointjs/src/g/line.bearing.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bearing: () => (/* binding */ bearing)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\nconst { cos, sin, atan2 } = Math;\nconst bearing = function(p, q) {\n    var lat1 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(p.y);\n    var lat2 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(q.y);\n    var lon1 = p.x;\n    var lon2 = q.x;\n    var dLon = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(atan2(y, x));\n    var bearings = [\n        \"NE\",\n        \"E\",\n        \"SE\",\n        \"S\",\n        \"SW\",\n        \"W\",\n        \"NW\",\n        \"N\"\n    ];\n    var index = brng - 22.5;\n    if (index < 0) index += 360;\n    index = parseInt(index / 45);\n    return bearings[index];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9saW5lLmJlYXJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUZBQWlGO0FBQ2pGLGdGQUFnRjtBQUMxQjtBQUV0RCxNQUFNLEVBQ0ZFLEdBQUcsRUFDSEMsR0FBRyxFQUNIQyxLQUFLLEVBQ1IsR0FBR0M7QUFFRyxNQUFNQyxVQUFVLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztJQUVoQyxJQUFJQyxPQUFPUiw0REFBS0EsQ0FBQ00sRUFBRUcsQ0FBQztJQUNwQixJQUFJQyxPQUFPViw0REFBS0EsQ0FBQ08sRUFBRUUsQ0FBQztJQUNwQixJQUFJRSxPQUFPTCxFQUFFTSxDQUFDO0lBQ2QsSUFBSUMsT0FBT04sRUFBRUssQ0FBQztJQUNkLElBQUlFLE9BQU9kLDREQUFLQSxDQUFDYSxPQUFPRjtJQUN4QixJQUFJRixJQUFJUCxJQUFJWSxRQUFRYixJQUFJUztJQUN4QixJQUFJRSxJQUFJWCxJQUFJTyxRQUFRTixJQUFJUSxRQUFRUixJQUFJTSxRQUFRUCxJQUFJUyxRQUFRVCxJQUFJYTtJQUM1RCxJQUFJQyxPQUFPaEIsNERBQUtBLENBQUNJLE1BQU1NLEdBQUdHO0lBRTFCLElBQUlJLFdBQVc7UUFBQztRQUFNO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBSztRQUFNO0tBQUk7SUFFM0QsSUFBSUMsUUFBUUYsT0FBTztJQUNuQixJQUFJRSxRQUFRLEdBQ1JBLFNBQVM7SUFDYkEsUUFBUUMsU0FBU0QsUUFBUTtJQUV6QixPQUFPRCxRQUFRLENBQUNDLE1BQU07QUFDMUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2cvbGluZS5iZWFyaW5nLm1qcz80NzdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEByZXR1cm4gdGhlIGJlYXJpbmcgKGNhcmRpbmFsIGRpcmVjdGlvbikgb2YgdGhlIGxpbmUuIEZvciBleGFtcGxlIE4sIFcsIG9yIFNFLlxuLy8gQHJldHVybnMge1N0cmluZ30gT25lIG9mIHRoZSBmb2xsb3dpbmcgYmVhcmluZ3MgOiBORSwgRSwgU0UsIFMsIFNXLCBXLCBOVywgTi5cbmltcG9ydCB7IHRvRGVnLCB0b1JhZCB9IGZyb20gJy4vZ2VvbWV0cnkuaGVscGVycy5tanMnO1xuXG5jb25zdCB7XG4gICAgY29zLFxuICAgIHNpbixcbiAgICBhdGFuMlxufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBiZWFyaW5nID0gZnVuY3Rpb24ocCwgcSkge1xuXG4gICAgdmFyIGxhdDEgPSB0b1JhZChwLnkpO1xuICAgIHZhciBsYXQyID0gdG9SYWQocS55KTtcbiAgICB2YXIgbG9uMSA9IHAueDtcbiAgICB2YXIgbG9uMiA9IHEueDtcbiAgICB2YXIgZExvbiA9IHRvUmFkKGxvbjIgLSBsb24xKTtcbiAgICB2YXIgeSA9IHNpbihkTG9uKSAqIGNvcyhsYXQyKTtcbiAgICB2YXIgeCA9IGNvcyhsYXQxKSAqIHNpbihsYXQyKSAtIHNpbihsYXQxKSAqIGNvcyhsYXQyKSAqIGNvcyhkTG9uKTtcbiAgICB2YXIgYnJuZyA9IHRvRGVnKGF0YW4yKHksIHgpKTtcblxuICAgIHZhciBiZWFyaW5ncyA9IFsnTkUnLCAnRScsICdTRScsICdTJywgJ1NXJywgJ1cnLCAnTlcnLCAnTiddO1xuXG4gICAgdmFyIGluZGV4ID0gYnJuZyAtIDIyLjU7XG4gICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgaW5kZXggKz0gMzYwO1xuICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXggLyA0NSk7XG5cbiAgICByZXR1cm4gYmVhcmluZ3NbaW5kZXhdO1xufTtcbiJdLCJuYW1lcyI6WyJ0b0RlZyIsInRvUmFkIiwiY29zIiwic2luIiwiYXRhbjIiLCJNYXRoIiwiYmVhcmluZyIsInAiLCJxIiwibGF0MSIsInkiLCJsYXQyIiwibG9uMSIsIngiLCJsb24yIiwiZExvbiIsImJybmciLCJiZWFyaW5ncyIsImluZGV4IiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/line.bearing.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/line.length.mjs":
/*!****************************************************!*\
  !*** ./node_modules/jointjs/src/g/line.length.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   length: () => (/* binding */ length)\n/* harmony export */ });\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.squaredLength.mjs\");\n\nconst length = function(start, end) {\n    return Math.sqrt((0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredLength)(start, end));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9saW5lLmxlbmd0aC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUQ7QUFFbEQsTUFBTUMsU0FBUyxTQUFTQyxLQUFLLEVBQUVDLEdBQUc7SUFDckMsT0FBT0MsS0FBS0MsSUFBSSxDQUFDTCxzRUFBYUEsQ0FBQ0UsT0FBT0M7QUFDMUMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2cvbGluZS5sZW5ndGgubWpzP2Y4YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3F1YXJlZExlbmd0aCB9IGZyb20gJy4vbGluZS5zcXVhcmVkTGVuZ3RoLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkTGVuZ3RoKHN0YXJ0LCBlbmQpKTtcbn07XG4iXSwibmFtZXMiOlsic3F1YXJlZExlbmd0aCIsImxlbmd0aCIsInN0YXJ0IiwiZW5kIiwiTWF0aCIsInNxcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/line.length.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/line.mjs":
/*!*********************************************!*\
  !*** ./node_modules/jointjs/src/g/line.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   line: () => (/* binding */ line)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.length.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n\n\n\n\n\n\nconst { max, min } = Math;\nconst Line = function(p1, p2) {\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n};\nLine.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Line,\n    // @returns the angle of incline of the line.\n    angle: function() {\n        var horizontalPoint = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n    bbox: function() {\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, right - left, bottom - top);\n    },\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__.bearing)(this.start, this.end);\n    },\n    clone: function() {\n        return new Line(this.start, this.end);\n    },\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n    closestPointLength: function(p) {\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n        var product = this.vector().dot(new Line(this.start, p).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n        return cpNormalizedLength;\n    },\n    closestPointTangent: function(p) {\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n        var start = this.start;\n        var end = this.end;\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n        var length = this.length();\n        if (new Line(start, p).length() > length) return false;\n        if (new Line(p, end).length() > length) return false;\n        // else: `p` lies between start and end of the line\n        return true;\n    },\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n        var dividerPoint = this.pointAt(ratio);\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n        var dividerPoint = this.pointAtLength(length);\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n    equals: function(l) {\n        return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n    },\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n            // Backwards compatibility\n            if (intersection && shape instanceof Line) {\n                intersection = intersection[0];\n            }\n            return intersection;\n        }\n        return null;\n    },\n    intersectionWithLine: function(line) {\n        var pt1Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n        var deltaPt = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n        var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n        return [\n            new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)\n        ];\n    },\n    isDifferentiable: function() {\n        return !this.start.equals(this.end);\n    },\n    // @return {double} length of the line\n    length: function() {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_4__.length)(this.start, this.end);\n    },\n    // @return {point} my midpoint\n    midpoint: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    },\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n        var start = this.start;\n        var end = this.end;\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n        return start.lerp(end, t);\n    },\n    pointAtLength: function(length) {\n        var start = this.start;\n        var end = this.end;\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        var lineLength = this.length();\n        if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n        return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n    },\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n        return determinant / this.length();\n    },\n    rotate: function(origin, angle) {\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n    round: function(precision) {\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n        var currentLength = this.length();\n        if (!currentLength) return this;\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__.squaredLength)(this.start, this.end);\n    },\n    tangentAt: function(t) {\n        if (!this.isDifferentiable()) return null;\n        var start = this.start;\n        var end = this.end;\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n        return tangentLine;\n    },\n    tangentAtLength: function(length) {\n        if (!this.isDifferentiable()) return null;\n        var start = this.start;\n        var end = this.end;\n        var tangentStart = this.pointAtLength(length);\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n        return tangentLine;\n    },\n    toString: function() {\n        return this.start.toString() + \" \" + this.end.toString();\n    },\n    serialize: function() {\n        return this.start.serialize() + \" \" + this.end.serialize();\n    },\n    translate: function(tx, ty) {\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n    // @return vector {point} of the line\n    vector: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n// For backwards compatibility:\nconst line = Line;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9saW5lLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUNGO0FBQ1c7QUFDWTtBQUNkO0FBQ1A7QUFFcEMsTUFBTSxFQUNGTSxHQUFHLEVBQ0hDLEdBQUcsRUFDTixHQUFHQztBQUVHLE1BQU1DLE9BQU8sU0FBU0MsRUFBRSxFQUFFQyxFQUFFO0lBRS9CLElBQUksQ0FBRSxLQUFJLFlBQVlGLElBQUcsR0FBSTtRQUN6QixPQUFPLElBQUlBLEtBQUtDLElBQUlDO0lBQ3hCO0lBRUEsSUFBSUQsY0FBY0QsTUFBTTtRQUNwQixPQUFPLElBQUlBLEtBQUtDLEdBQUdFLEtBQUssRUFBRUYsR0FBR0csR0FBRztJQUNwQztJQUVBLElBQUksQ0FBQ0QsS0FBSyxHQUFHLElBQUlaLDZDQUFLQSxDQUFDVTtJQUN2QixJQUFJLENBQUNHLEdBQUcsR0FBRyxJQUFJYiw2Q0FBS0EsQ0FBQ1c7QUFDekIsRUFBRTtBQUVGRixLQUFLSyxTQUFTLEdBQUc7SUFFYkMsTUFBTVYsNkNBQUtBLENBQUNJLElBQUk7SUFFaEIsNkNBQTZDO0lBQzdDTyxPQUFPO1FBRUgsSUFBSUMsa0JBQWtCLElBQUlqQiw2Q0FBS0EsQ0FBQyxJQUFJLENBQUNZLEtBQUssQ0FBQ00sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDTixLQUFLLENBQUNPLENBQUM7UUFDOUQsT0FBTyxJQUFJLENBQUNQLEtBQUssQ0FBQ1EsWUFBWSxDQUFDLElBQUksQ0FBQ1AsR0FBRyxFQUFFSTtJQUM3QztJQUVBSSxNQUFNO1FBRUYsSUFBSUMsT0FBT2YsSUFBSSxJQUFJLENBQUNLLEtBQUssQ0FBQ00sQ0FBQyxFQUFFLElBQUksQ0FBQ0wsR0FBRyxDQUFDSyxDQUFDO1FBQ3ZDLElBQUlLLE1BQU1oQixJQUFJLElBQUksQ0FBQ0ssS0FBSyxDQUFDTyxDQUFDLEVBQUUsSUFBSSxDQUFDTixHQUFHLENBQUNNLENBQUM7UUFDdEMsSUFBSUssUUFBUWxCLElB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b2ludGpzL3NyYy9nL2xpbmUubWpzPzZkMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9yZWN0Lm1qcyc7XG5pbXBvcnQgeyBiZWFyaW5nIH0gZnJvbSAnLi9saW5lLmJlYXJpbmcubWpzJztcbmltcG9ydCB7IHNxdWFyZWRMZW5ndGggfSBmcm9tICcuL2xpbmUuc3F1YXJlZExlbmd0aC5tanMnO1xuaW1wb3J0IHsgbGVuZ3RoIH0gZnJvbSAnLi9saW5lLmxlbmd0aC5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBtYXgsXG4gICAgbWluXG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IExpbmUgPSBmdW5jdGlvbihwMSwgcDIpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5lKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmUocDEsIHAyKTtcbiAgICB9XG5cbiAgICBpZiAocDEgaW5zdGFuY2VvZiBMaW5lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZShwMS5zdGFydCwgcDEuZW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KHAxKTtcbiAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChwMik7XG59O1xuXG5MaW5lLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLkxpbmUsXG5cbiAgICAvLyBAcmV0dXJucyB0aGUgYW5nbGUgb2YgaW5jbGluZSBvZiB0aGUgbGluZS5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGhvcml6b250YWxQb2ludCA9IG5ldyBQb2ludCh0aGlzLnN0YXJ0LnggKyAxLCB0aGlzLnN0YXJ0LnkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5hbmdsZUJldHdlZW4odGhpcy5lbmQsIGhvcml6b250YWxQb2ludCk7XG4gICAgfSxcblxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsZWZ0ID0gbWluKHRoaXMuc3RhcnQueCwgdGhpcy5lbmQueCk7XG4gICAgICAgIHZhciB0b3AgPSBtaW4odGhpcy5zdGFydC55LCB0aGlzLmVuZC55KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbWF4KHRoaXMuc3RhcnQueCwgdGhpcy5lbmQueCk7XG4gICAgICAgIHZhciBib3R0b20gPSBtYXgodGhpcy5zdGFydC55LCB0aGlzLmVuZC55KTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGVmdCwgdG9wLCAocmlnaHQgLSBsZWZ0KSwgKGJvdHRvbSAtIHRvcCkpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHRoZSBiZWFyaW5nIChjYXJkaW5hbCBkaXJlY3Rpb24pIG9mIHRoZSBsaW5lLiBGb3IgZXhhbXBsZSBOLCBXLCBvciBTRS5cbiAgICAvLyBAcmV0dXJucyB7U3RyaW5nfSBPbmUgb2YgdGhlIGZvbGxvd2luZyBiZWFyaW5ncyA6IE5FLCBFLCBTRSwgUywgU1csIFcsIE5XLCBOLlxuICAgIGJlYXJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmVhcmluZyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgdG8gcG9pbnQgYHBgXG4gICAgY2xvc2VzdFBvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdCh0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCkpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHApICogdGhpcy5sZW5ndGgoKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7bnVtYmVyfSB0aGUgbm9ybWFsaXplZCBsZW5ndGggb2YgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgdG8gcG9pbnQgYHBgXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBwcm9kdWN0ID0gdGhpcy52ZWN0b3IoKS5kb3QoKG5ldyBMaW5lKHRoaXMuc3RhcnQsIHApKS52ZWN0b3IoKSk7XG4gICAgICAgIHZhciBjcE5vcm1hbGl6ZWRMZW5ndGggPSBtaW4oMSwgbWF4KDAsIHByb2R1Y3QgLyB0aGlzLnNxdWFyZWRMZW5ndGgoKSkpO1xuXG4gICAgICAgIC8vIGNwTm9ybWFsaXplZExlbmd0aCByZXR1cm5zIGBOYU5gIGlmIHRoaXMgbGluZSBoYXMgemVybyBsZW5ndGhcbiAgICAgICAgLy8gd2UgY2FuIHdvcmsgd2l0aCB0aGF0IC0gaWYgYE5hTmAsIHJldHVybiAwXG4gICAgICAgIGlmIChjcE5vcm1hbGl6ZWRMZW5ndGggIT09IGNwTm9ybWFsaXplZExlbmd0aCkgcmV0dXJuIDA7IC8vIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIGFuZCBvbmx5IGlmIGNwTm9ybWFsaXplZExlbmd0aCBpcyBgTmFOYFxuICAgICAgICAvLyAoYE5hTmAgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmKVxuXG4gICAgICAgIHJldHVybiBjcE5vcm1hbGl6ZWRMZW5ndGg7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXQodGhpcy5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHApKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGxpZXMgb24gdGhlIGxpbmUuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICBpZiAoc3RhcnQuY3Jvc3MocCwgZW5kKSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBlbHNlOiBjcm9zcyBwcm9kdWN0IG9mIDAgaW5kaWNhdGVzIHRoYXQgdGhpcyBsaW5lIGFuZCB0aGUgdmVjdG9yIHRvIGBwYCBhcmUgY29sbGluZWFyXG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGlmICgobmV3IExpbmUoc3RhcnQsIHApKS5sZW5ndGgoKSA+IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoKG5ldyBMaW5lKHAsIGVuZCkpLmxlbmd0aCgpID4gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGVsc2U6IGBwYCBsaWVzIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBvZiB0aGUgbGluZVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBsaW5lIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMS5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgZGl2aWRlclBvaW50ID0gdGhpcy5wb2ludEF0KHJhdGlvKTtcblxuICAgICAgICAvLyByZXR1cm4gYXJyYXkgd2l0aCB0d28gbGluZXNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBMaW5lKHRoaXMuc3RhcnQsIGRpdmlkZXJQb2ludCksXG4gICAgICAgICAgICBuZXcgTGluZShkaXZpZGVyUG9pbnQsIHRoaXMuZW5kKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBsaW5lIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYC5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGRpdmlkZXJQb2ludCA9IHRoaXMucG9pbnRBdExlbmd0aChsZW5ndGgpO1xuXG4gICAgICAgIC8vIHJldHVybiBhcnJheSB3aXRoIHR3byBuZXcgbGluZXNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBMaW5lKHRoaXMuc3RhcnQsIGRpdmlkZXJQb2ludCksXG4gICAgICAgICAgICBuZXcgTGluZShkaXZpZGVyUG9pbnQsIHRoaXMuZW5kKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGwpIHtcblxuICAgICAgICByZXR1cm4gISFsICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnggPT09IGwuc3RhcnQueCAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydC55ID09PSBsLnN0YXJ0LnkgJiZcbiAgICAgICAgICAgIHRoaXMuZW5kLnggPT09IGwuZW5kLnggJiZcbiAgICAgICAgICAgIHRoaXMuZW5kLnkgPT09IGwuZW5kLnk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3BvaW50fSBQb2ludCB3aGVyZSBJJ20gaW50ZXJzZWN0aW5nIGEgbGluZS5cbiAgICAvLyBAcmV0dXJuIFtwb2ludF0gUG9pbnRzIHdoZXJlIEknbSBpbnRlcnNlY3RpbmcgYSByZWN0YW5nbGUuXG4gICAgLy8gQHNlZSBTcXVlYWsgU21hbGx0YWxrLCBMaW5lU2VnbWVudD4+aW50ZXJzZWN0aW9uV2l0aDpcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHNoYXBlLCBvcHQpIHtcblxuICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaW50ZXJzZWN0aW9uV2l0aExpbmUpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzaGFwZS5pbnRlcnNlY3Rpb25XaXRoTGluZSh0aGlzLCBvcHQpO1xuXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAmJiAoc2hhcGUgaW5zdGFuY2VvZiBMaW5lKSkge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvblswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIHZhciBwdDFEaXIgPSBuZXcgUG9pbnQodGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueCwgdGhpcy5lbmQueSAtIHRoaXMuc3RhcnQueSk7XG4gICAgICAgIHZhciBwdDJEaXIgPSBuZXcgUG9pbnQobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCwgbGluZS5lbmQueSAtIGxpbmUuc3RhcnQueSk7XG4gICAgICAgIHZhciBkZXQgPSAocHQxRGlyLnggKiBwdDJEaXIueSkgLSAocHQxRGlyLnkgKiBwdDJEaXIueCk7XG4gICAgICAgIHZhciBkZWx0YVB0ID0gbmV3IFBvaW50KGxpbmUuc3RhcnQueCAtIHRoaXMuc3RhcnQueCwgbGluZS5zdGFydC55IC0gdGhpcy5zdGFydC55KTtcbiAgICAgICAgdmFyIGFscGhhID0gKGRlbHRhUHQueCAqIHB0MkRpci55KSAtIChkZWx0YVB0LnkgKiBwdDJEaXIueCk7XG4gICAgICAgIHZhciBiZXRhID0gKGRlbHRhUHQueCAqIHB0MURpci55KSAtIChkZWx0YVB0LnkgKiBwdDFEaXIueCk7XG5cbiAgICAgICAgaWYgKGRldCA9PT0gMCB8fCBhbHBoYSAqIGRldCA8IDAgfHwgYmV0YSAqIGRldCA8IDApIHtcbiAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvbiBmb3VuZC5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhbHBoYSA+IGRldCB8fCBiZXRhID4gZGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbHBoYSA8IGRldCB8fCBiZXRhIDwgZGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW25ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueCArIChhbHBoYSAqIHB0MURpci54IC8gZGV0KSxcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueSArIChhbHBoYSAqIHB0MURpci55IC8gZGV0KVxuICAgICAgICApXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXJ0LmVxdWFscyh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge2RvdWJsZX0gbGVuZ3RoIG9mIHRoZSBsaW5lXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3BvaW50fSBteSBtaWRwb2ludFxuICAgIG1pZHBvaW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgKHRoaXMuc3RhcnQueCArIHRoaXMuZW5kLngpIC8gMixcbiAgICAgICAgICAgICh0aGlzLnN0YXJ0LnkgKyB0aGlzLmVuZC55KSAvIDJcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgcGFyYWxsZWw6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBsO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGw7XG4gICAgICAgIGNvbnN0IGVSZWYgPSBzdGFydC5jbG9uZSgpLnJvdGF0ZShlbmQsIDI3MCk7XG4gICAgICAgIGNvbnN0IHNSZWYgPSBlbmQuY2xvbmUoKS5yb3RhdGUoc3RhcnQsIDkwKTtcbiAgICAgICAgc3RhcnQubW92ZShzUmVmLCBkaXN0YW5jZSk7XG4gICAgICAgIGVuZC5tb3ZlKGVSZWYsIGRpc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3BvaW50fSBteSBwb2ludCBhdCAndCcgPDAsMT5cbiAgICBwb2ludEF0OiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiBzdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAodCA+PSAxKSByZXR1cm4gZW5kLmNsb25lKCk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXJ0LmxlcnAoZW5kLCB0KTtcbiAgICB9LFxuXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbmd0aCA+PSBsaW5lTGVuZ3RoKSByZXR1cm4gKGZyb21TdGFydCA/IGVuZC5jbG9uZSgpIDogc3RhcnQuY2xvbmUoKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdCgoZnJvbVN0YXJ0ID8gKGxlbmd0aCkgOiAobGluZUxlbmd0aCAtIGxlbmd0aCkpIC8gbGluZUxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge251bWJlcn0gdGhlIG9mZnNldCBvZiB0aGUgcG9pbnQgYHBgIGZyb20gdGhlIGxpbmUuICsgaWYgdGhlIHBvaW50IGBwYCBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGluZSwgLSBpZiBvbiB0aGUgbGVmdCBhbmQgMCBpZiBvbiB0aGUgbGluZS5cbiAgICBwb2ludE9mZnNldDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHNpZ24gb2YgdGhlIGRldGVybWluYW50IG9mIHZlY3RvcnMgKHN0YXJ0LGVuZCksIHdoZXJlIHAgaXMgdGhlIHF1ZXJ5IHBvaW50LlxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgICAgIHZhciBkZXRlcm1pbmFudCA9ICgoZW5kLnggLSBzdGFydC54KSAqIChwLnkgLSBzdGFydC55KSAtIChlbmQueSAtIHN0YXJ0LnkpICogKHAueCAtIHN0YXJ0LngpKTtcblxuICAgICAgICByZXR1cm4gZGV0ZXJtaW5hbnQgLyB0aGlzLmxlbmd0aCgpO1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKG9yaWdpbiwgYW5nbGUpIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnJvdGF0ZShvcmlnaW4sIGFuZ2xlKTtcbiAgICAgICAgdGhpcy5lbmQucm90YXRlKG9yaWdpbiwgYW5nbGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuc3RhcnQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuc3RhcnQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtudW1iZXJ9IHNjYWxlIHRoZSBsaW5lIHNvIHRoYXQgaXQgaGFzIHRoZSByZXF1ZXN0ZWQgbGVuZ3RoXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGlmICghY3VycmVudExlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gbGVuZ3RoIC8gY3VycmVudExlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoc2NhbGVGYWN0b3IsIHNjYWxlRmFjdG9yLCB0aGlzLnN0YXJ0KTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7aW50ZWdlcn0gbGVuZ3RoIHdpdGhvdXQgc3FydFxuICAgIC8vIEBub3RlIGZvciBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGV4YWN0IGxlbmd0aCBpcyBub3QgbmVjZXNzYXJ5IChlLmcuIGNvbXBhcmUgb25seSlcbiAgICBzcXVhcmVkTGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNxdWFyZWRMZW5ndGgodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgdmFyIHRhbmdlbnRTdGFydCA9IHRoaXMucG9pbnRBdCh0KTsgLy8gY29uc3RyYWlucyBgdGAgYmV0d2VlbiAwIGFuZCAxXG5cbiAgICAgICAgdmFyIHRhbmdlbnRMaW5lID0gbmV3IExpbmUoc3RhcnQsIGVuZCk7XG4gICAgICAgIHRhbmdlbnRMaW5lLnRyYW5zbGF0ZSh0YW5nZW50U3RhcnQueCAtIHN0YXJ0LngsIHRhbmdlbnRTdGFydC55IC0gc3RhcnQueSk7IC8vIG1vdmUgc28gdGhhdCB0YW5nZW50IGxpbmUgc3RhcnRzIGF0IHRoZSBwb2ludCByZXF1ZXN0ZWRcblxuICAgICAgICByZXR1cm4gdGFuZ2VudExpbmU7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHZhciB0YW5nZW50U3RhcnQgPSB0aGlzLnBvaW50QXRMZW5ndGgobGVuZ3RoKTtcblxuICAgICAgICB2YXIgdGFuZ2VudExpbmUgPSBuZXcgTGluZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGFuZ2VudExpbmUudHJhbnNsYXRlKHRhbmdlbnRTdGFydC54IC0gc3RhcnQueCwgdGFuZ2VudFN0YXJ0LnkgLSBzdGFydC55KTsgLy8gbW92ZSBzbyB0aGF0IHRhbmdlbnQgbGluZSBzdGFydHMgYXQgdGhlIHBvaW50IHJlcXVlc3RlZFxuXG4gICAgICAgIHJldHVybiB0YW5nZW50TGluZTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnRvU3RyaW5nKCkgKyAnICcgKyB0aGlzLmVuZC50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnNlcmlhbGl6ZSgpICsgJyAnICsgdGhpcy5lbmQuc2VyaWFsaXplKCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHZlY3RvciB7cG9pbnR9IG9mIHRoZSBsaW5lXG4gICAgdmVjdG9yOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0LngsIHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0LnkpO1xuICAgIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbkxpbmUucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IExpbmUucHJvdG90eXBlLmludGVyc2VjdDtcblxuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG5leHBvcnQgY29uc3QgbGluZSA9IExpbmU7XG4iXSwibmFtZXMiOlsiUG9pbnQiLCJSZWN0IiwiYmVhcmluZyIsInNxdWFyZWRMZW5ndGgiLCJsZW5ndGgiLCJ0eXBlcyIsIm1heCIsIm1pbiIsIk1hdGgiLCJMaW5lIiwicDEiLCJwMiIsInN0YXJ0IiwiZW5kIiwicHJvdG90eXBlIiwidHlwZSIsImFuZ2xlIiwiaG9yaXpvbnRhbFBvaW50IiwieCIsInkiLCJhbmdsZUJldHdlZW4iLCJiYm94IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY2xvbmUiLCJjbG9zZXN0UG9pbnQiLCJwIiwicG9pbnRBdCIsImNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgiLCJjbG9zZXN0UG9pbnRMZW5ndGgiLCJwcm9kdWN0IiwidmVjdG9yIiwiZG90IiwiY3BOb3JtYWxpemVkTGVuZ3RoIiwiY2xvc2VzdFBvaW50VGFuZ2VudCIsInRhbmdlbnRBdCIsImNvbnRhaW5zUG9pbnQiLCJjcm9zcyIsImRpdmlkZUF0IiwicmF0aW8iLCJkaXZpZGVyUG9pbnQiLCJkaXZpZGVBdExlbmd0aCIsInBvaW50QXRMZW5ndGgiLCJlcXVhbHMiLCJsIiwiaW50ZXJzZWN0Iiwic2hhcGUiLCJvcHQiLCJpbnRlcnNlY3Rpb25XaXRoTGluZSIsImludGVyc2VjdGlvbiIsImxpbmUiLCJwdDFEaXIiLCJwdDJEaXIiLCJkZXQiLCJkZWx0YVB0IiwiYWxwaGEiLCJiZXRhIiwiaXNEaWZmZXJlbnRpYWJsZSIsIm1pZHBvaW50IiwicGFyYWxsZWwiLCJkaXN0YW5jZSIsImVSZWYiLCJyb3RhdGUiLCJzUmVmIiwibW92ZSIsInQiLCJsZXJwIiwiZnJvbVN0YXJ0IiwibGluZUxlbmd0aCIsInBvaW50T2Zmc2V0IiwiZGV0ZXJtaW5hbnQiLCJvcmlnaW4iLCJyb3VuZCIsInByZWNpc2lvbiIsInNjYWxlIiwic3giLCJzeSIsInNldExlbmd0aCIsImN1cnJlbnRMZW5ndGgiLCJzY2FsZUZhY3RvciIsInRhbmdlbnRTdGFydCIsInRhbmdlbnRMaW5lIiwidHJhbnNsYXRlIiwidGFuZ2VudEF0TGVuZ3RoIiwidG9TdHJpbmciLCJzZXJpYWxpemUiLCJ0eCIsInR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/line.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/line.squaredLength.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/jointjs/src/g/line.squaredLength.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredLength: () => (/* binding */ squaredLength)\n/* harmony export */ });\n// @return {integer} length without sqrt\n// @note for applications where the exact length is not necessary (e.g. compare only)\nconst squaredLength = function(start, end) {\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = end.x;\n    var y1 = end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9saW5lLnNxdWFyZWRMZW5ndGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3Q0FBd0M7QUFDeEMscUZBQXFGO0FBQzlFLE1BQU1BLGdCQUFnQixTQUFTQyxLQUFLLEVBQUVDLEdBQUc7SUFFNUMsSUFBSUMsS0FBS0YsTUFBTUcsQ0FBQztJQUNoQixJQUFJQyxLQUFLSixNQUFNSyxDQUFDO0lBQ2hCLElBQUlDLEtBQUtMLElBQUlFLENBQUM7SUFDZCxJQUFJSSxLQUFLTixJQUFJSSxDQUFDO0lBQ2QsT0FBTyxDQUFDSCxNQUFNSSxFQUFDLElBQUtKLEtBQUssQ0FBQ0UsTUFBTUcsRUFBQyxJQUFLSDtBQUMxQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9saW5lLnNxdWFyZWRMZW5ndGgubWpzPzlkMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHJldHVybiB7aW50ZWdlcn0gbGVuZ3RoIHdpdGhvdXQgc3FydFxuLy8gQG5vdGUgZm9yIGFwcGxpY2F0aW9ucyB3aGVyZSB0aGUgZXhhY3QgbGVuZ3RoIGlzIG5vdCBuZWNlc3NhcnkgKGUuZy4gY29tcGFyZSBvbmx5KVxuZXhwb3J0IGNvbnN0IHNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cbiAgICB2YXIgeDAgPSBzdGFydC54O1xuICAgIHZhciB5MCA9IHN0YXJ0Lnk7XG4gICAgdmFyIHgxID0gZW5kLng7XG4gICAgdmFyIHkxID0gZW5kLnk7XG4gICAgcmV0dXJuICh4MCAtPSB4MSkgKiB4MCArICh5MCAtPSB5MSkgKiB5MDtcbn07XG4iXSwibmFtZXMiOlsic3F1YXJlZExlbmd0aCIsInN0YXJ0IiwiZW5kIiwieDAiLCJ4IiwieTAiLCJ5IiwieDEiLCJ5MSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/line.squaredLength.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/path.mjs":
/*!*********************************************!*\
  !*** ./node_modules/jointjs/src/g/path.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Path: () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/jointjs/src/g/curve.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extend.mjs */ \"(ssr)/./node_modules/jointjs/src/g/extend.mjs\");\n// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\n\n\n\n\n\n\nconst Path = function(arg) {\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n    if (typeof arg === \"string\") {\n        return new Path.parse(arg);\n    }\n    this.segments = [];\n    var i;\n    var n;\n    if (!arg) {\n    // don't do anything\n    } else if (Array.isArray(arg) && arg.length !== 0) {\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n        n = arg.length;\n        if (arg[0].isSegment) {\n            for(i = 0; i < n; i++){\n                var segment = arg[i];\n                this.appendSegment(segment);\n            }\n        } else {\n            var previousObj = null;\n            for(i = 0; i < n; i++){\n                var obj = arg[i];\n                if (!(obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line || obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve)) {\n                    throw new Error(\"Cannot construct a path segment from the provided object.\");\n                }\n                if (i === 0) this.appendSegment(Path.createSegment(\"M\", obj.start));\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment(\"M\", obj.start));\n                if (obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n                    this.appendSegment(Path.createSegment(\"L\", obj.end));\n                } else if (obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n                    this.appendSegment(Path.createSegment(\"C\", obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n                previousObj = obj;\n            }\n        }\n    } else if (arg.isSegment) {\n        this.appendSegment(arg);\n    } else if (arg instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n        this.appendSegment(Path.createSegment(\"M\", arg.start));\n        this.appendSegment(Path.createSegment(\"L\", arg.end));\n    } else if (arg instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n        this.appendSegment(Path.createSegment(\"M\", arg.start));\n        this.appendSegment(Path.createSegment(\"C\", arg.controlPoint1, arg.controlPoint2, arg.end));\n    } else if (arg instanceof _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline) {\n        if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n        n = arg.points.length;\n        for(i = 0; i < n; i++){\n            var point = arg.points[i];\n            if (i === 0) this.appendSegment(Path.createSegment(\"M\", point));\n            else this.appendSegment(Path.createSegment(\"L\", point));\n        }\n    } else {\n        throw new Error(\"Cannot construct a path from the provided object.\");\n    }\n};\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n    if (!pathData) return new Path();\n    var path = new Path();\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n    var numCommands = commands.length;\n    for(var i = 0; i < numCommands; i++){\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n    return path;\n};\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n    if (!type) throw new Error(\"Type must be provided.\");\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + \" is not a recognized path segment type.\");\n    var args = [];\n    var n = arguments.length;\n    for(var i = 1; i < n; i++){\n        args.push(arguments[i]);\n    }\n    return applyToNew(segmentConstructor, args);\n};\nPath.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_3__.types.Path,\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n        var currentSegment;\n        var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n            if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n            var n = arg.length;\n            for(var i = 0; i < n; i++){\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var bbox;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n        if (bbox) return bbox;\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n        var path = new Path();\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n        return path;\n    },\n    closestPoint: function(p, opt) {\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n        return this.pointAtT(t);\n    },\n    closestPointLength: function(p, opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n        return this.lengthAtT(t, localOpt);\n    },\n    closestPointNormalizedLength: function(p, opt) {\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n        return cpLength / length;\n    },\n    // Private function.\n    closestPointT: function(p, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p).squaredLength();\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = {\n                        segmentIndex: i,\n                        value: segmentClosestPointT\n                    };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointT) return closestPointT;\n        // if no visible segment, return end of last segment\n        return {\n            segmentIndex: numSegments - 1,\n            value: 1\n        };\n    },\n    closestPointTangent: function(p, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p).squaredLength();\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointTangent) return closestPointTangent;\n        // if no valid segment, return null\n        return null;\n    },\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n        var numPolylines = polylines.length;\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for(var i = 0; i < numPolylines; i++){\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return numIntersections % 2 === 1;\n    },\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n        return this.divideAtLength(length, localOpt);\n    },\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var i;\n        var segment;\n        // identify the segment to divide:\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for(i = 0; i < numSegments; i++){\n            var index = fromStart ? i : numSegments - 1 - i;\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({\n                precision: precision,\n                subdivisions: subdivisions\n            });\n            if (segment.isDifferentiable()) {\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n                if (length <= l + d) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n            l += d;\n        }\n        if (!lastValidSegment) {\n            return null;\n        }\n        // else: the path contains at least one valid segment\n        if (!divided) {\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = fromStart ? 1 : 0;\n            divided = lastValidSegment.divideAtT(t);\n        }\n        // create a copy of this path and replace the identified segment with its two divided parts:\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment(\"M\", movetoEnd));\n        divisionEndIndex += 1;\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for(i = divisionEndIndex; i < pathCopy.segments.length; i++){\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n            if (segment.type === \"Z\" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment(\"L\", originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n        // distribute pathCopy segments into two paths and return those:\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n        return [\n            firstPath,\n            secondPath\n        ];\n    },\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n        if (!p) return false;\n        var segments = this.segments;\n        var otherSegments = p.segments;\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n            // as soon as an inequality is found in segments, return false\n            if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n        }\n        // if no inequality found in segments, return true\n        return true;\n    },\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error(\"Path has no segments.\");\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n        return segments[index];\n    },\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n        var segmentSubdivisions = [];\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({\n                precision: precision\n            });\n            segmentSubdivisions.push(subdivisions);\n        }\n        return segmentSubdivisions;\n    },\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n        const validatedPath = this.clone().validate();\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n        const subpaths = [];\n        for(let i = 0; i < numSegments; i++){\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n        return subpaths;\n    },\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error(\"Index out of range.\");\n        var currentSegment;\n        var previousSegment = null;\n        var nextSegment = null;\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n            } else {\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n            if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n            var n = arg.length;\n            for(var i = 0; i < n; i++){\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n    intersectionWithLine: function(line, opt) {\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for(var i = 0, n = polylines.length; i < n; i++){\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n        return intersection;\n    },\n    isDifferentiable: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n        var segments = this.segments;\n        var isValid = segments.length === 0 || segments[0].type === \"M\"; // either empty or first segment is a Moveto\n        return isValid;\n    },\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var length = 0;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({\n                subdivisions: subdivisions\n            });\n        }\n        return length;\n    },\n    // Private function.\n    lengthAtT: function(t, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var subdivisions;\n        var length = 0;\n        for(var i = 0; i < segmentIndex; i++){\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({\n                precisison: precision,\n                subdivisions: subdivisions\n            });\n        }\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, {\n            precisison: precision,\n            subdivisions: subdivisions\n        });\n        return length;\n    },\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n        return this.pointAtLength(length, localOpt);\n    },\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        if (length === 0) return this.start.clone();\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for(var i = 0; i < numSegments; i++){\n            var index = fromStart ? i : numSegments - 1 - i;\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({\n                precision: precision,\n                subdivisions: subdivisions\n            });\n            if (segment.isVisible) {\n                if (length <= l + d) {\n                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n                lastVisibleSegment = segment;\n            }\n            l += d;\n        }\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n    // Private function.\n    pointAtT: function(t) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n    // Default precision\n    PRECISION: 3,\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n        return segment;\n    },\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error(\"Path has no segments.\");\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error(\"Path has no segments.\");\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n        var currentSegment;\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n            if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n            segments.splice(index, 1);\n            var n = arg.length;\n            for(var i = 0; i < n; i++){\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n    round: function(precision) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            segment.round(precision);\n        }\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n        return this;\n    },\n    segmentAt: function(ratio, opt) {\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n        return this.getSegment(index);\n    },\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n        return this.getSegment(index);\n    },\n    segmentIndexAt: function(ratio, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for(var i = 0; i < numSegments; i++){\n            var index = fromStart ? i : numSegments - 1 - i;\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({\n                precision: precision,\n                subdivisions: subdivisions\n            });\n            if (segment.isVisible) {\n                if (length <= l + d) return index;\n                lastVisibleSegmentIndex = index;\n            }\n            l += d;\n        }\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n        if (!this.isValid()) throw new Error(\"Invalid path segments.\");\n        return this.toString();\n    },\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var localOpt = {\n            precision: precision,\n            segmentSubdivisions: segmentSubdivisions\n        };\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n        return this.tangentAtLength(length, localOpt);\n    },\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        // not using localOpt\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for(var i = 0; i < numSegments; i++){\n            var index = fromStart ? i : numSegments - 1 - i;\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({\n                precision: precision,\n                subdivisions: subdivisions\n            });\n            if (segment.isDifferentiable()) {\n                if (length <= l + d) {\n                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n                lastValidSegment = segment;\n            }\n            l += d;\n        }\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = fromStart ? 1 : 0;\n            return lastValidSegment.tangentAtT(t);\n        }\n        // if no valid segment, return null\n        return null;\n    },\n    // Private function.\n    tangentAtT: function(t) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n    toPoints: function(opt) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n        opt = opt || {};\n        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n            precision: precision\n        }) : opt.segmentSubdivisions;\n        var points = [];\n        var partialPoints = [];\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n    toPolylines: function(opt) {\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for(var i = 0, n = points.length; i < n; i++){\n            polylines.push(new _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline(points[i]));\n        }\n        return polylines;\n    },\n    toString: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        var pathData = \"\";\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            pathData += segment.serialize() + \" \";\n        }\n        return pathData.trim();\n    },\n    translate: function(tx, ty) {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n        return this;\n    },\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n        var previousSegment = segment.previousSegment; // may be null\n        while(segment && !segment.isSubpathStart){\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment(\"M\", 0, 0));\n        return this;\n    }\n};\nObject.defineProperty(Path.prototype, \"start\", {\n    // Getter for the first visible endpoint of the path.\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n        for(var i = 0; i < numSegments; i++){\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\nObject.defineProperty(Path.prototype, \"end\", {\n    // Getter for the last visible endpoint of the path.\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n        for(var i = numSegments - 1; i >= 0; i--){\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n// Path segment interface:\nvar segmentPrototype = {\n    // virtual\n    bbox: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    clone: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    closestPoint: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    closestPointLength: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    closestPointNormalizedLength: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n        throw new Error(\"Neither closestPointT() nor closestPointNormalizedLength() function is implemented.\");\n    },\n    // virtual\n    closestPointTangent: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    divideAt: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    divideAtLength: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n        if (this.divideAt) return this.divideAt(t);\n        throw new Error(\"Neither divideAtT() nor divideAt() function is implemented.\");\n    },\n    // virtual\n    equals: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    getSubdivisions: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    isDifferentiable: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    isSegment: true,\n    isSubpathStart: false,\n    isVisible: true,\n    // virtual\n    length: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n        if (t <= 0) return 0;\n        var length = this.length();\n        if (t >= 1) return length;\n        return length * t;\n    },\n    nextSegment: null,\n    // virtual\n    pointAt: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    pointAtLength: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n        if (this.pointAt) return this.pointAt(t);\n        throw new Error(\"Neither pointAtT() nor pointAt() function is implemented.\");\n    },\n    previousSegment: null,\n    // virtual\n    round: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    subpathStartSegment: null,\n    // virtual\n    scale: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    serialize: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    tangentAt: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    tangentAtLength: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n        if (this.tangentAt) return this.tangentAt(t);\n        throw new Error(\"Neither tangentAtT() nor tangentAt() function is implemented.\");\n    },\n    // virtual\n    toString: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    },\n    // virtual\n    translate: function() {\n        throw new Error(\"Declaration missing for virtual function.\");\n    }\n};\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, \"end\", {\n    configurable: true,\n    enumerable: true,\n    writable: true\n});\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, \"start\", {\n    // get a reference to the end point of previous segment\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.previousSegment) throw new Error(\"Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)\");\n        return this.previousSegment.end;\n    }\n});\n// virtual\nObject.defineProperty(segmentPrototype, \"type\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        throw new Error(\"Bad segment declaration. No type specified.\");\n    }\n});\n// Path segment implementations:\nvar Lineto = function() {\n    var args = [];\n    var n = arguments.length;\n    for(var i = 0; i < n; i++){\n        args.push(arguments[i]);\n    }\n    if (!(this instanceof Lineto)) {\n        return applyToNew(Lineto, args);\n    }\n    if (n === 0) {\n        throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).\");\n    }\n    var outputArray;\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n        } else {\n            throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (\" + n + \" lines provided).\");\n        }\n    } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n        } else if (n < 2) {\n            throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (\" + n + \" coordinates provided).\");\n        } else {\n            var segmentCoords;\n            outputArray = [];\n            for(i = 0; i < n; i += 2){\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n    } else {\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n        } else {\n            var segmentPoint;\n            outputArray = [];\n            for(i = 0; i < n; i += 1){\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\nvar linetoPrototype = {\n    clone: function() {\n        return new Lineto(this.end);\n    },\n    divideAt: function(ratio) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n    divideAtLength: function(length) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n    getSubdivisions: function() {\n        return [];\n    },\n    isDifferentiable: function() {\n        if (!this.previousSegment) return false;\n        return !this.start.equals(this.end);\n    },\n    round: function(precision) {\n        this.end.round(precision);\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n    serialize: function() {\n        var end = this.end;\n        return this.type + \" \" + end.x + \" \" + end.y;\n    },\n    toString: function() {\n        return this.type + \" \" + this.start + \" \" + this.end;\n    },\n    translate: function(tx, ty) {\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\nObject.defineProperty(linetoPrototype, \"type\", {\n    configurable: true,\n    enumerable: true,\n    value: \"L\"\n});\nLineto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, linetoPrototype);\nvar Curveto = function() {\n    var args = [];\n    var n = arguments.length;\n    for(var i = 0; i < n; i++){\n        args.push(arguments[i]);\n    }\n    if (!(this instanceof Curveto)) {\n        return applyToNew(Curveto, args);\n    }\n    if (n === 0) {\n        throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).\");\n    }\n    var outputArray;\n    if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n        } else {\n            throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" curves provided).\");\n        }\n    } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n        if (n === 6) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[2], +args[3]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[4], +args[5]);\n            return this;\n        } else if (n < 6) {\n            throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" coordinates provided).\");\n        } else {\n            var segmentCoords;\n            outputArray = [];\n            for(i = 0; i < n; i += 6){\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n    } else {\n        if (n === 3) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[1]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[2]);\n            return this;\n        } else if (n < 3) {\n            throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" points provided).\");\n        } else {\n            var segmentPoints;\n            outputArray = [];\n            for(i = 0; i < n; i += 3){\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\nvar curvetoPrototype = {\n    clone: function() {\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n    divideAt: function(ratio, opt) {\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n    divideAtLength: function(length, opt) {\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n    divideAtT: function(t) {\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n    isDifferentiable: function() {\n        if (!this.previousSegment) return false;\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n    round: function(precision) {\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n    serialize: function() {\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + \" \" + c1.x + \" \" + c1.y + \" \" + c2.x + \" \" + c2.y + \" \" + end.x + \" \" + end.y;\n    },\n    toString: function() {\n        return this.type + \" \" + this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n    },\n    translate: function(tx, ty) {\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\nObject.defineProperty(curvetoPrototype, \"type\", {\n    configurable: true,\n    enumerable: true,\n    value: \"C\"\n});\nCurveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.prototype, curvetoPrototype);\nvar Moveto = function() {\n    var args = [];\n    var n = arguments.length;\n    for(var i = 0; i < n; i++){\n        args.push(arguments[i]);\n    }\n    if (!(this instanceof Moveto)) {\n        return applyToNew(Moveto, args);\n    }\n    if (n === 0) {\n        throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).\");\n    }\n    var outputArray;\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n        } else {\n            throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" lines provided).\");\n        }\n    } else if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n        } else {\n            throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" curves provided).\");\n        }\n    } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n        } else if (n < 2) {\n            throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" coordinates provided).\");\n        } else {\n            var segmentCoords;\n            outputArray = [];\n            for(i = 0; i < n; i += 2){\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n    } else {\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n        } else {\n            var segmentPoint;\n            outputArray = [];\n            for(i = 0; i < n; i += 1){\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\nvar movetoPrototype = {\n    bbox: function() {\n        return null;\n    },\n    clone: function() {\n        return new Moveto(this.end);\n    },\n    closestPoint: function() {\n        return this.end.clone();\n    },\n    closestPointNormalizedLength: function() {\n        return 0;\n    },\n    closestPointLength: function() {\n        return 0;\n    },\n    closestPointT: function() {\n        return 1;\n    },\n    closestPointTangent: function() {\n        return null;\n    },\n    divideAt: function() {\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n    divideAtLength: function() {\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n    equals: function(m) {\n        return this.end.equals(m.end);\n    },\n    getSubdivisions: function() {\n        return [];\n    },\n    isDifferentiable: function() {\n        return false;\n    },\n    isSubpathStart: true,\n    isVisible: false,\n    length: function() {\n        return 0;\n    },\n    lengthAtT: function() {\n        return 0;\n    },\n    pointAt: function() {\n        return this.end.clone();\n    },\n    pointAtLength: function() {\n        return this.end.clone();\n    },\n    pointAtT: function() {\n        return this.end.clone();\n    },\n    round: function(precision) {\n        this.end.round(precision);\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n    serialize: function() {\n        var end = this.end;\n        return this.type + \" \" + end.x + \" \" + end.y;\n    },\n    tangentAt: function() {\n        return null;\n    },\n    tangentAtLength: function() {\n        return null;\n    },\n    tangentAtT: function() {\n        return null;\n    },\n    toString: function() {\n        return this.type + \" \" + this.end;\n    },\n    translate: function(tx, ty) {\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\nObject.defineProperty(movetoPrototype, \"start\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        throw new Error(\"Illegal access. Moveto segments should not need a start property.\");\n    }\n});\nObject.defineProperty(movetoPrototype, \"type\", {\n    configurable: true,\n    enumerable: true,\n    value: \"M\"\n});\nMoveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\nvar Closepath = function() {\n    var args = [];\n    var n = arguments.length;\n    for(var i = 0; i < n; i++){\n        args.push(arguments[i]);\n    }\n    if (!(this instanceof Closepath)) {\n        return applyToNew(Closepath, args);\n    }\n    if (n > 0) {\n        throw new Error(\"Closepath constructor expects no arguments.\");\n    }\n    return this;\n};\nvar closepathPrototype = {\n    clone: function() {\n        return new Closepath();\n    },\n    divideAt: function(ratio) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),\n            new Lineto(divided[1])\n        ];\n    },\n    divideAtLength: function(length) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),\n            new Lineto(divided[1])\n        ];\n    },\n    getSubdivisions: function() {\n        return [];\n    },\n    isDifferentiable: function() {\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n        return !this.start.equals(this.end);\n    },\n    round: function() {\n        return this;\n    },\n    scale: function() {\n        return this;\n    },\n    serialize: function() {\n        return this.type;\n    },\n    toString: function() {\n        return this.type + \" \" + this.start + \" \" + this.end;\n    },\n    translate: function() {\n        return this;\n    }\n};\nObject.defineProperty(closepathPrototype, \"end\", {\n    // get a reference to the end point of subpath start segment\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.subpathStartSegment) throw new Error(\"Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)\");\n        return this.subpathStartSegment.end;\n    }\n});\nObject.defineProperty(closepathPrototype, \"type\", {\n    configurable: true,\n    enumerable: true,\n    value: \"Z\"\n});\nClosepath.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, closepathPrototype);\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\nPath.regexSupportedData = new RegExp(\"^[\\\\s\\\\d\" + Object.keys(segmentTypes).join(\"\") + \",.]*$\");\nPath.isDataSupported = function(data) {\n    if (typeof data !== \"string\") return false;\n    return this.regexSupportedData.test(data);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wYXRoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDRGQUE0RjtBQUM1RixnR0FBZ0c7QUFDdEQ7QUFDUjtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDL0IsTUFBTU8sT0FBTyxTQUFTQyxHQUFHO0lBRTVCLElBQUksQ0FBRSxLQUFJLFlBQVlELElBQUcsR0FBSTtRQUN6QixPQUFPLElBQUlBLEtBQUtDO0lBQ3BCO0lBRUEsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDekIsT0FBTyxJQUFJRCxLQUFLRSxLQUFLLENBQUNEO0lBQzFCO0lBRUEsSUFBSSxDQUFDRSxRQUFRLEdBQUcsRUFBRTtJQUVsQixJQUFJQztJQUNKLElBQUlDO0lBRUosSUFBSSxDQUFDSixLQUFLO0lBQ04sb0JBQW9CO0lBRXhCLE9BQU8sSUFBSUssTUFBTUMsT0FBTyxDQUFDTixRQUFRQSxJQUFJTyxNQUFNLEtBQUssR0FBRztRQUMvQyx5QkFBeUI7UUFDekIsdURBQXVEO1FBQ3ZEUCxNQUFNQSxJQUFJUSxNQUFNLENBQUMsU0FBU0MsR0FBRyxFQUFFQyxHQUFHO1lBQzlCLE9BQU9ELElBQUlFLE1BQU0sQ0FBQ0Q7UUFDdEIsR0FBRyxFQUFFO1FBRUxOLElBQUlKLElBQUlPLE1BQU07UUFDZCxJQUFJUCxHQUFHLENBQUMsRUFBRSxDQUFDWSxTQUFTLEVBQUU7WUFDbEIsSUFBS1QsSUFBSSxHQUFHQSxJQUFJQyxHQUFHRCxJQUFLO2dCQUVwQixJQUFJVSxVQUFVYixHQUFHLENBQUNHLEVBQUU7Z0JBRXBCLElBQUksQ0FBQ1csYUFBYSxDQUFDRDtZQUN2QjtRQUVKLE9BQU87WUFDSCxJQUFJRSxjQUFjO1lBQ2xCLElBQUtaLElBQUksR0FBR0EsSUFBSUMsR0FBR0QsSUFBSztnQkFFcEIsSUFBSWEsTUFBTWhCLEdBQUcsQ0FBQ0csRUFBRTtnQkFFaEIsSUFBSSxDQUFFLGdCQUFnQlIsMkNBQUlBLElBQU1xQixlQUFl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SixTQUFTLEdBQUc1QyxtREFBTUEsQ0FBQ29MLGtCQUFrQnZMLDJDQUFJQSxDQUFDK0MsU0FBUyxFQUFFMEo7QUFFL0QsSUFBSTlKLGVBQWV2QyxLQUFLdUMsWUFBWSxHQUFHO0lBQ25DK0osR0FBR2pCO0lBQ0hrQixHQUFHYjtJQUNIYyxHQUFHUDtJQUNIUSxHQUFHTDtJQUNITSxHQUFHTjtBQUNQO0FBRUFwTSxLQUFLMk0sa0JBQWtCLEdBQUcsSUFBSUMsT0FBTyxhQUFhbkMsT0FBT29DLElBQUksQ0FBQ3RLLGNBQWN1SyxJQUFJLENBQUMsTUFBTTtBQUV2RjlNLEtBQUsrTSxlQUFlLEdBQUcsU0FBU0MsSUFBSTtJQUVoQyxJQUFJLE9BQU9BLFNBQVMsVUFBVSxPQUFPO0lBQ3JDLE9BQU8sSUFBSSxDQUFDTCxrQkFBa0IsQ0FBQ00sSUFBSSxDQUFDRDtBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2cvcGF0aC5tanM/NzMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBY2NlcHRzIHBhdGggZGF0YSBzdHJpbmcsIGFycmF5IG9mIHNlZ21lbnRzLCBhcnJheSBvZiBDdXJ2ZXMgYW5kL29yIExpbmVzLCBvciBhIFBvbHlsaW5lLlxuLy8gUGF0aCBjcmVhdGVkIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgdmFsaWQgKHNlcmlhbGl6YWJsZSkgcGF0aCAobWlnaHQgbm90IHN0YXJ0IHdpdGggYW4gTSkuXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuL2N1cnZlLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vZXh0ZW5kLm1qcyc7XG5leHBvcnQgY29uc3QgUGF0aCA9IGZ1bmN0aW9uKGFyZykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChhcmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykgeyAvLyBjcmVhdGUgZnJvbSBhIHBhdGggZGF0YSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoLnBhcnNlKGFyZyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIG47XG5cbiAgICBpZiAoIWFyZykge1xuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCAhPT0gMCkgeyAvLyBpZiBhcmcgaXMgYSBub24tZW1wdHkgYXJyYXlcbiAgICAgICAgLy8gZmxhdHRlbiBvbmUgbGV2ZWwgZGVlcFxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgIGFyZyA9IGFyZy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBuID0gYXJnLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1swXS5pc1NlZ21lbnQpIHsgLy8gY3JlYXRlIGZyb20gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gYXJnW2ldO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGNyZWF0ZSBmcm9tIGFuIGFycmF5IG9mIEN1cnZlcyBhbmQvb3IgTGluZXNcbiAgICAgICAgICAgIHZhciBwcmV2aW91c09iaiA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gYXJnW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoKG9iaiBpbnN0YW5jZW9mIExpbmUpIHx8IChvYmogaW5zdGFuY2VvZiBDdXJ2ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIHBhdGggc2VnbWVudCBmcm9tIHRoZSBwcm92aWRlZCBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBvYmouc3RhcnQpKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG9iamVjdHMgZG8gbm90IGxpbmsgdXAsIG1vdmV0byBzZWdtZW50cyBhcmUgaW5zZXJ0ZWQgdG8gY292ZXIgdGhlIGdhcHNcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNPYmogJiYgIXByZXZpb3VzT2JqLmVuZC5lcXVhbHMob2JqLnN0YXJ0KSkgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTScsIG9iai5zdGFydCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIG9iai5lbmQpKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnQycsIG9iai5jb250cm9sUG9pbnQxLCBvYmouY29udHJvbFBvaW50Miwgb2JqLmVuZCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZpb3VzT2JqID0gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGFyZy5pc1NlZ21lbnQpIHsgLy8gY3JlYXRlIGZyb20gYSBzaW5nbGUgc2VnbWVudFxuICAgICAgICB0aGlzLmFwcGVuZFNlZ21lbnQoYXJnKTtcblxuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTGluZSkgeyAvLyBjcmVhdGUgZnJvbSBhIHNpbmdsZSBMaW5lXG4gICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBhcmcuc3RhcnQpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIGFyZy5lbmQpKTtcblxuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQ3VydmUpIHsgLy8gY3JlYXRlIGZyb20gYSBzaW5nbGUgQ3VydmVcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTScsIGFyZy5zdGFydCkpO1xuICAgICAgICB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgYXJnLmNvbnRyb2xQb2ludDEsIGFyZy5jb250cm9sUG9pbnQyLCBhcmcuZW5kKSk7XG5cbiAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFBvbHlsaW5lKSB7IC8vIGNyZWF0ZSBmcm9tIGEgUG9seWxpbmVcbiAgICAgICAgaWYgKCEoYXJnLnBvaW50cyAmJiAoYXJnLnBvaW50cy5sZW5ndGggIT09IDApKSkgcmV0dXJuOyAvLyBpZiBQb2x5bGluZSBoYXMgbm8gcG9pbnRzLCBsZWF2ZSBQYXRoIGVtcHR5XG5cbiAgICAgICAgbiA9IGFyZy5wb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IGFyZy5wb2ludHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgcG9pbnQpKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIHBvaW50KSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIHVua25vd24gb2JqZWN0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIHBhdGggZnJvbSB0aGUgcHJvdmlkZWQgb2JqZWN0LicpO1xuICAgIH1cbn07XG5cbi8vIE1vcmUgcGVybWlzc2l2ZSB0aGFuIFYubm9ybWFsaXplUGF0aERhdGEgYW5kIFBhdGgucHJvdG90eXBlLnNlcmlhbGl6ZS5cbi8vIEFsbG93cyBwYXRoIGRhdGEgc3RyaW5ncyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGEgTW92ZXRvIGNvbW1hbmQgKHVubGlrZSBTVkcgc3BlY2lmaWNhdGlvbikuXG4vLyBEb2VzIG5vdCByZXF1aXJlIHNwYWNlcyBiZXR3ZWVuIGVsZW1lbnRzOyBjb21tYXMgYXJlIGFsbG93ZWQsIHNlcGFyYXRvcnMgbWF5IGJlIG9taXR0ZWQgd2hlbiB1bmFtYmlndW91cyAoZS5nLiAnWk0xMCwxMCcsICdMMS42LjgnLCAnTTEwMC0yMDAnKS5cbi8vIEFsbG93cyBmb3IgY29tbWFuZCBhcmd1bWVudCBjaGFpbmluZy5cbi8vIFRocm93cyBhbiBlcnJvciBpZiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGlzIHByb3ZpZGVkIHdpdGggYSBjb21tYW5kLlxuLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIHVucmVjb2duaXplZCBwYXRoIGNvbW1hbmQgaXMgcHJvdmlkZWQgKGFjY29yZGluZyB0byBQYXRoLnNlZ21lbnRUeXBlcykuIE9ubHkgYSBzdWJzZXQgb2YgU1ZHIGNvbW1hbmRzIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQgKEwsIEMsIE0sIFopLlxuUGF0aC5wYXJzZSA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG5cbiAgICBpZiAoIXBhdGhEYXRhKSByZXR1cm4gbmV3IFBhdGgoKTtcblxuICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcblxuICAgIHZhciBjb21tYW5kUmUgPSAvKD86W2EtekEtWl0gKikoPzooPzotP1xcZCsoPzpcXC5cXGQrKT8oPzplWy0rXT9cXGQrKT8gKiw/ICopfCg/Oi0/XFwuXFxkKyAqLD8gKikpK3woPzpbYS16QS1aXSAqKSg/ISB8XFxkfC18XFwuKS9nO1xuICAgIHZhciBjb21tYW5kcyA9IHBhdGhEYXRhLm1hdGNoKGNvbW1hbmRSZSk7XG5cbiAgICB2YXIgbnVtQ29tbWFuZHMgPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db21tYW5kczsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgdmFyIGFyZ1JlID0gLyg/OlthLXpBLVpdKXwoPzooPzotP1xcZCsoPzpcXC5cXGQrKT8oPzplWy0rXT9cXGQrKT8pKXwoPzooPzotP1xcLlxcZCspKS9nO1xuICAgICAgICB2YXIgYXJncyA9IGNvbW1hbmQubWF0Y2goYXJnUmUpO1xuXG4gICAgICAgIHZhciBzZWdtZW50ID0gUGF0aC5jcmVhdGVTZWdtZW50LmFwcGx5KHRoaXMsIGFyZ3MpOyAvLyBhcmdzID0gW3R5cGUsIGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMi4uLl1cbiAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLy8gQ3JlYXRlIGEgc2VnbWVudCBvciBhbiBhcnJheSBvZiBzZWdtZW50cy5cbi8vIEFjY2VwdHMgdW5saW1pdGVkIHBvaW50cy9jb29yZHMgYXJndW1lbnRzIGFmdGVyIGB0eXBlYC5cblBhdGguY3JlYXRlU2VnbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblxuICAgIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgcHJvdmlkZWQuJyk7XG5cbiAgICB2YXIgc2VnbWVudENvbnN0cnVjdG9yID0gUGF0aC5zZWdtZW50VHlwZXNbdHlwZV07XG4gICAgaWYgKCFzZWdtZW50Q29uc3RydWN0b3IpIHRocm93IG5ldyBFcnJvcih0eXBlICsgJyBpcyBub3QgYSByZWNvZ25pemVkIHBhdGggc2VnbWVudCB0eXBlLicpO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHsgLy8gZG8gbm90IGFkZCBmaXJzdCBlbGVtZW50IChgdHlwZWApIHRvIGFyZ3MgYXJyYXlcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5VG9OZXcoc2VnbWVudENvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cblBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuUGF0aCxcblxuICAgIC8vIEFjY2VwdHMgb25lIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYXMgYXJndW1lbnQuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgYXBwZW5kU2VnbWVudDogZnVuY3Rpb24oYXJnKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAvLyB3b3JrcyBldmVuIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzXG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50O1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSAoKG51bVNlZ21lbnRzICE9PSAwKSA/IHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0gOiBudWxsKTsgLy8gaWYgd2UgYXJlIGFwcGVuZGluZyB0byBhbiBlbXB0eSBwYXRoLCBwcmV2aW91c1NlZ21lbnQgaXMgbnVsbFxuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7IC8vIGFyZyBpcyBhIHNlZ21lbnRcbiAgICAgICAgICAgIGlmICghYXJnIHx8ICFhcmcuaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnQgcmVxdWlyZWQuJyk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gdGhpcy5wcmVwYXJlU2VnbWVudChhcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChjdXJyZW50U2VnbWVudCk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gYXJnIGlzIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VycmVudFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VnbWVudCA9IGN1cnJlbnRTZWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGJib3ggb2YgdGhlIHBhdGguXG4gICAgLy8gSWYgcGF0aCBoYXMgbm8gc2VnbWVudHMsIHJldHVybnMgbnVsbC5cbiAgICAvLyBJZiBwYXRoIGhhcyBvbmx5IGludmlzaWJsZSBzZWdtZW50cywgcmV0dXJucyBiYm94IG9mIHRoZSBlbmQgcG9pbnQgb2YgbGFzdCBzZWdtZW50LlxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudEJCb3ggPSBzZWdtZW50LmJib3goKTtcbiAgICAgICAgICAgICAgICBiYm94ID0gYmJveCA/IGJib3gudW5pb24oc2VnbWVudEJCb3gpIDogc2VnbWVudEJCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmJveCkgcmV0dXJuIGJib3g7XG5cbiAgICAgICAgLy8gaWYgdGhlIHBhdGggaGFzIG9ubHkgaW52aXNpYmxlIGVsZW1lbnRzLCByZXR1cm4gZW5kIHBvaW50IG9mIGxhc3Qgc2VnbWVudFxuICAgICAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGFzdFNlZ21lbnQuZW5kLngsIGxhc3RTZWdtZW50LmVuZC55LCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIG5ldyBwYXRoIHRoYXQgaXMgYSBjbG9uZSBvZiB0aGlzIHBhdGguXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0uY2xvbmUoKTtcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUKHAsIG9wdCk7XG4gICAgICAgIGlmICghdCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdFQodCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUKHAsIGxvY2FsT3B0KTtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gMDtcblxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhBdFQodCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCwgbG9jYWxPcHQpO1xuICAgICAgICBpZiAoY3BMZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBzaG9ydGN1dFxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBwcmV2ZW50cyBkaXZpc2lvbiBieSB6ZXJvXG5cbiAgICAgICAgcmV0dXJuIGNwTGVuZ3RoIC8gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIGZ1bmN0aW9uLlxuICAgIGNsb3Nlc3RQb2ludFQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgY2xvc2VzdFBvaW50VDtcbiAgICAgICAgdmFyIG1pblNxdWFyZWREaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2ldO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudENsb3Nlc3RQb2ludFQgPSBzZWdtZW50LmNsb3Nlc3RQb2ludFQocCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudENsb3Nlc3RQb2ludCA9IHNlZ21lbnQucG9pbnRBdFQoc2VnbWVudENsb3Nlc3RQb2ludFQpO1xuICAgICAgICAgICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSAobmV3IExpbmUoc2VnbWVudENsb3Nlc3RQb2ludCwgcCkpLnNxdWFyZWRMZW5ndGgoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50VCA9IHsgc2VnbWVudEluZGV4OiBpLCB2YWx1ZTogc2VnbWVudENsb3Nlc3RQb2ludFQgfTtcbiAgICAgICAgICAgICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZXN0UG9pbnRUKSByZXR1cm4gY2xvc2VzdFBvaW50VDtcblxuICAgICAgICAvLyBpZiBubyB2aXNpYmxlIHNlZ21lbnQsIHJldHVybiBlbmQgb2YgbGFzdCBzZWdtZW50XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRJbmRleDogbnVtU2VnbWVudHMgLSAxLCB2YWx1ZTogMSB9O1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUYW5nZW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludFRhbmdlbnQ7XG4gICAgICAgIHZhciBtaW5TcXVhcmVkRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnRUID0gc2VnbWVudC5jbG9zZXN0UG9pbnRUKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnQgPSBzZWdtZW50LnBvaW50QXRUKHNlZ21lbnRDbG9zZXN0UG9pbnRUKTtcbiAgICAgICAgICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gKG5ldyBMaW5lKHNlZ21lbnRDbG9zZXN0UG9pbnQsIHApKS5zcXVhcmVkTGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQgPSBzZWdtZW50LnRhbmdlbnRBdFQoc2VnbWVudENsb3Nlc3RQb2ludFQpO1xuICAgICAgICAgICAgICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb3Nlc3RQb2ludFRhbmdlbnQpIHJldHVybiBjbG9zZXN0UG9pbnRUYW5nZW50O1xuXG4gICAgICAgIC8vIGlmIG5vIHZhbGlkIHNlZ21lbnQsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJlYSBzdXJyb3VuZGVkIGJ5IHRoZSBwYXRoIGNvbnRhaW5zIHRoZSBwb2ludCBgcGAuXG4gICAgLy8gSW1wbGVtZW50cyB0aGUgZXZlbi1vZGQgYWxnb3JpdGhtIChzZWxmLWludGVyc2VjdGlvbnMgYXJlIFwib3V0c2lkZVwiKS5cbiAgICAvLyBDbG9zZXMgb3BlbiBwYXRocyAoYWx3YXlzIGltYWdpbmVzIGEgZmluYWwgY2xvc2luZyBzZWdtZW50KS5cbiAgICAvLyBQcmVjaXNpb24gbWF5IGJlIGFkanVzdGVkIGJ5IHBhc3NpbmcgYW4gYG9wdGAgb2JqZWN0LlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciBwb2x5bGluZXMgPSB0aGlzLnRvUG9seWxpbmVzKG9wdCk7XG4gICAgICAgIGlmICghcG9seWxpbmVzKSByZXR1cm4gZmFsc2U7IC8vIHNob3J0Y3V0ICh0aGlzIHBhdGggaGFzIG5vIHBvbHlsaW5lcylcblxuICAgICAgICB2YXIgbnVtUG9seWxpbmVzID0gcG9seWxpbmVzLmxlbmd0aDtcblxuICAgICAgICAvLyBob3cgbWFueSBjb21wb25lbnQgcG9seWxpbmVzIGRvZXMgYHBgIGxpZSB3aXRoaW4/XG4gICAgICAgIHZhciBudW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2x5bGluZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gcG9seWxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHBvbHlsaW5lLmNvbnRhaW5zUG9pbnQocCkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcGAgbGllcyB3aXRoaW4gdGhpcyBwb2x5bGluZVxuICAgICAgICAgICAgICAgIG51bUludGVyc2VjdGlvbnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgYHRydWVgIGZvciBvZGQgbnVtYmVycyBvZiBpbnRlcnNlY3Rpb25zIChldmVuLW9kZCBhbGdvcml0aG0pXG4gICAgICAgIHJldHVybiAoKG51bUludGVyc2VjdGlvbnMgJSAyKSA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIHBhdGggaW50byB0d28gYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMCkgcmF0aW8gPSAwO1xuICAgICAgICBpZiAocmF0aW8gPiAxKSByYXRpbyA9IDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBwYXRoIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgICAgLy8gaWRlbnRpZnkgdGhlIHNlZ21lbnQgdG8gZGl2aWRlOlxuXG4gICAgICAgIHZhciBsID0gMDsgLy8gbGVuZ3RoIHNvIGZhclxuICAgICAgICB2YXIgZGl2aWRlZDtcbiAgICAgICAgdmFyIGRpdmlkZWRTZWdtZW50SW5kZXg7XG4gICAgICAgIHZhciBsYXN0VmFsaWRTZWdtZW50OyAvLyB2aXNpYmxlIEFORCBkaWZmZXJlbnRpYWJsZVxuICAgICAgICB2YXIgbGFzdFZhbGlkU2VnbWVudEluZGV4O1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG51bVNlZ21lbnRzIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgc2VnbWVudCA9IHRoaXMuZ2V0U2VnbWVudChpbmRleCk7XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQubGVuZ3RoKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc0RpZmZlcmVudGlhYmxlKCkpIHsgLy8gc2VnbWVudCBpcyBub3QganVzdCBhIHBvaW50XG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlZFNlZ21lbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBkaXZpZGVkID0gc2VnbWVudC5kaXZpZGVBdExlbmd0aCgoKGZyb21TdGFydCA/IDEgOiAtMSkgKiAobGVuZ3RoIC0gbCkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGFzdFZhbGlkU2VnbWVudCkgeyAvLyBubyB2YWxpZCBzZWdtZW50IGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2U6IHRoZSBwYXRoIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSB2YWxpZCBzZWdtZW50XG5cbiAgICAgICAgaWYgKCFkaXZpZGVkKSB7IC8vIHRoZSBkZXNpcmVkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgZGl2aWRlZFNlZ21lbnRJbmRleCA9IGxhc3RWYWxpZFNlZ21lbnRJbmRleDtcbiAgICAgICAgICAgIHQgPSAoZnJvbVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICAgICAgZGl2aWRlZCA9IGxhc3RWYWxpZFNlZ21lbnQuZGl2aWRlQXRUKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY29weSBvZiB0aGlzIHBhdGggYW5kIHJlcGxhY2UgdGhlIGlkZW50aWZpZWQgc2VnbWVudCB3aXRoIGl0cyB0d28gZGl2aWRlZCBwYXJ0czpcblxuICAgICAgICB2YXIgcGF0aENvcHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHBhdGhDb3B5LnJlcGxhY2VTZWdtZW50KGRpdmlkZWRTZWdtZW50SW5kZXgsIGRpdmlkZWQpO1xuXG4gICAgICAgIHZhciBkaXZpc2lvblN0YXJ0SW5kZXggPSBkaXZpZGVkU2VnbWVudEluZGV4O1xuICAgICAgICB2YXIgZGl2aXNpb25NaWRJbmRleCA9IGRpdmlkZWRTZWdtZW50SW5kZXggKyAxO1xuICAgICAgICB2YXIgZGl2aXNpb25FbmRJbmRleCA9IGRpdmlkZWRTZWdtZW50SW5kZXggKyAyO1xuXG4gICAgICAgIC8vIGRvIG5vdCBpbnNlcnQgdGhlIHBhcnQgaWYgaXQgbG9va3MgbGlrZSBhIHBvaW50XG4gICAgICAgIGlmICghZGl2aWRlZFswXS5pc0RpZmZlcmVudGlhYmxlKCkpIHtcbiAgICAgICAgICAgIHBhdGhDb3B5LnJlbW92ZVNlZ21lbnQoZGl2aXNpb25TdGFydEluZGV4KTtcbiAgICAgICAgICAgIGRpdmlzaW9uTWlkSW5kZXggLT0gMTtcbiAgICAgICAgICAgIGRpdmlzaW9uRW5kSW5kZXggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCBhIE1vdmV0byBzZWdtZW50IHRvIGVuc3VyZSBzZWNvbmRQYXRoIHdpbGwgYmUgdmFsaWQ6XG4gICAgICAgIHZhciBtb3ZldG9FbmQgPSBwYXRoQ29weS5nZXRTZWdtZW50KGRpdmlzaW9uTWlkSW5kZXgpLnN0YXJ0O1xuICAgICAgICBwYXRoQ29weS5pbnNlcnRTZWdtZW50KGRpdmlzaW9uTWlkSW5kZXgsIFBhdGguY3JlYXRlU2VnbWVudCgnTScsIG1vdmV0b0VuZCkpO1xuICAgICAgICBkaXZpc2lvbkVuZEluZGV4ICs9IDE7XG5cbiAgICAgICAgLy8gZG8gbm90IGluc2VydCB0aGUgcGFydCBpZiBpdCBsb29rcyBsaWtlIGEgcG9pbnRcbiAgICAgICAgaWYgKCFkaXZpZGVkWzFdLmlzRGlmZmVyZW50aWFibGUoKSkge1xuICAgICAgICAgICAgcGF0aENvcHkucmVtb3ZlU2VnbWVudChkaXZpc2lvbkVuZEluZGV4IC0gMSk7XG4gICAgICAgICAgICBkaXZpc2lvbkVuZEluZGV4IC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCBDbG9zZXBhdGggc2VnbWVudHMgaW4gc2Vjb25kUGF0aCB3aWxsIGJlIGFzc2lnbmVkIGNvcnJlY3Qgc3VicGF0aFN0YXJ0U2VnbWVudDpcblxuICAgICAgICB2YXIgc2Vjb25kUGF0aFNlZ21lbnRJbmRleENvbnZlcnNpb24gPSBkaXZpc2lvbkVuZEluZGV4IC0gZGl2aXNpb25TdGFydEluZGV4IC0gMTtcbiAgICAgICAgZm9yIChpID0gZGl2aXNpb25FbmRJbmRleDsgaSA8IHBhdGhDb3B5LnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNlZ21lbnQgPSB0aGlzLmdldFNlZ21lbnQoaSAtIHNlY29uZFBhdGhTZWdtZW50SW5kZXhDb252ZXJzaW9uKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBwYXRoQ29weS5nZXRTZWdtZW50KGkpO1xuXG4gICAgICAgICAgICBpZiAoKHNlZ21lbnQudHlwZSA9PT0gJ1onKSAmJiAhb3JpZ2luYWxTZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQuZW5kLmVxdWFscyhzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQuZW5kKSkge1xuICAgICAgICAgICAgICAgIC8vIHBhdGhDb3B5IHNlZ21lbnQncyBzdWJwYXRoU3RhcnRTZWdtZW50IGlzIGRpZmZlcmVudCBmcm9tIG9yaWdpbmFsIHNlZ21lbnQncyBvbmVcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoaXMgQ2xvc2VwYXRoIHNlZ21lbnQgdG8gYSBMaW5ldG8gYW5kIHJlcGxhY2UgaXQgaW4gcGF0aENvcHlcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkU2VnbWVudCA9IFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIG9yaWdpbmFsU2VnbWVudC5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGhDb3B5LnJlcGxhY2VTZWdtZW50KGksIGNvbnZlcnRlZFNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzdHJpYnV0ZSBwYXRoQ29weSBzZWdtZW50cyBpbnRvIHR3byBwYXRocyBhbmQgcmV0dXJuIHRob3NlOlxuXG4gICAgICAgIHZhciBmaXJzdFBhdGggPSBuZXcgUGF0aChwYXRoQ29weS5zZWdtZW50cy5zbGljZSgwLCBkaXZpc2lvbk1pZEluZGV4KSk7XG4gICAgICAgIHZhciBzZWNvbmRQYXRoID0gbmV3IFBhdGgocGF0aENvcHkuc2VnbWVudHMuc2xpY2UoZGl2aXNpb25NaWRJbmRleCkpO1xuXG4gICAgICAgIHJldHVybiBbZmlyc3RQYXRoLCBzZWNvbmRQYXRoXTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIHBhdGhzIGFyZSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIC8vIElmIGBwYCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgcmV0dXJucyBmYWxzZS5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgb3RoZXJTZWdtZW50cyA9IHAuc2VnbWVudHM7XG5cbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAob3RoZXJTZWdtZW50cy5sZW5ndGggIT09IG51bVNlZ21lbnRzKSByZXR1cm4gZmFsc2U7IC8vIGlmIHRoZSB0d28gcGF0aHMgaGF2ZSBkaWZmZXJlbnQgbnVtYmVyIG9mIHNlZ21lbnRzLCB0aGV5IGNhbm5vdCBiZSBlcXVhbFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyU2VnbWVudCA9IG90aGVyU2VnbWVudHNbaV07XG5cbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYW4gaW5lcXVhbGl0eSBpcyBmb3VuZCBpbiBzZWdtZW50cywgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAoKHNlZ21lbnQudHlwZSAhPT0gb3RoZXJTZWdtZW50LnR5cGUpIHx8ICghc2VnbWVudC5lcXVhbHMob3RoZXJTZWdtZW50KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGluZXF1YWxpdHkgZm91bmQgaW4gc2VnbWVudHMsIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGluZGljZXMuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgZ2V0U2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGhhcyBubyBzZWdtZW50cy4nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IG51bVNlZ21lbnRzICsgaW5kZXg7IC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlcyB0byBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5kZXggPj0gbnVtU2VnbWVudHMgfHwgaW5kZXggPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZS4nKTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHNlZ21lbnQgc3ViZGl2aXNpb25zLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gLlxuICAgIGdldFNlZ21lbnRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICAvLyBub3QgdXNpbmcgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudC5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcbiAgICAgICAgICAgIHNlZ21lbnRTdWJkaXZpc2lvbnMucHVzaChzdWJkaXZpc2lvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2Ygc3VicGF0aHMgb2YgdGhpcyBwYXRoLlxuICAgIC8vIEludmFsaWQgcGF0aHMgYXJlIHZhbGlkYXRlZCBmaXJzdC5cbiAgICAvLyBSZXR1cm5zIGBbXWAgaWYgcGF0aCBoYXMgbm8gc2VnbWVudHMuXG4gICAgZ2V0U3VicGF0aHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFBhdGggPSB0aGlzLmNsb25lKCkudmFsaWRhdGUoKTtcblxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHZhbGlkYXRlZFBhdGguc2VnbWVudHM7XG4gICAgICAgIGNvbnN0IG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IHN1YnBhdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1N1YnBhdGhTdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGVuY291bnRlcmVkIGEgc3VicGF0aCBzdGFydCBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHBhdGggZm9yIHNlZ21lbnQsIGFuZCBwdXNoIGl0IHRvIGxpc3Qgb2Ygc3VicGF0aHNcbiAgICAgICAgICAgICAgICBzdWJwYXRocy5wdXNoKG5ldyBQYXRoKHNlZ21lbnQpKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgY3VycmVudCBzZWdtZW50IHRvIHRoZSBsYXN0IHN1YnBhdGhcbiAgICAgICAgICAgICAgICBzdWJwYXRoc1tzdWJwYXRocy5sZW5ndGggLSAxXS5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnBhdGhzO1xuICAgIH0sXG5cbiAgICAvLyBJbnNlcnQgYGFyZ2AgYXQgZ2l2ZW4gYGluZGV4YC5cbiAgICAvLyBgaW5kZXggPSAwYCBtZWFucyBpbnNlcnQgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAvLyBgaW5kZXggPSBzZWdtZW50cy5sZW5ndGhgIG1lYW5zIGluc2VydCBhdCB0aGUgZW5kLlxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgaW5kaWNlcywgZnJvbSBgLTFgIHRvIGAtKHNlZ21lbnRzLmxlbmd0aCArIDEpYC5cbiAgICAvLyBBY2NlcHRzIG9uZSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFzIGFyZ3VtZW50LlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgaW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXgsIGFyZykge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0aGVzZSBhcmUgaW5jcmVtZW50ZWQgY29tcGFyZWQgdG8gZ2V0U2VnbWVudHMoKVxuICAgICAgICAvLyB3ZSBjYW4gaW5zZXJ0IGFmdGVyIGxhc3QgZWxlbWVudCAobm90ZSB0aGF0IHRoaXMgY2hhbmdlcyB0aGUgbWVhbmluZyBvZiBpbmRleCAtMSlcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4ICsgMTsgLy8gY29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIHRvIHBvc2l0aXZlXG4gICAgICAgIGlmIChpbmRleCA+IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50O1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSBudWxsO1xuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChudW1TZWdtZW50cyAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDEpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50c1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gcHJldmlvdXNTZWdtZW50Lm5leHRTZWdtZW50OyAvLyBpZiB3ZSBhcmUgaW5zZXJ0aW5nIGF0IGVuZCwgbmV4dFNlZ21lbnQgaXMgbnVsbFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZiBpbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzU2VnbWVudCBpcyBudWxsXG4gICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoIWFyZyB8fCAhYXJnLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50IHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHRoaXMucHJlcGFyZVNlZ21lbnQoYXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZShpbmRleCwgMCwgY3VycmVudFNlZ21lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZSgoaW5kZXggKyBpKSwgMCwgY3VycmVudFNlZ21lbnQpOyAvLyBpbmNyZW1lbnRpbmcgaW5kZXggdG8gaW5zZXJ0IHN1YnNlcXVlbnQgc2VnbWVudHMgYWZ0ZXIgaW5zZXJ0ZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBjdXJyZW50U2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBwb2x5bGluZXMgPSB0aGlzLnRvUG9seWxpbmVzKG9wdCk7XG4gICAgICAgIGlmICghcG9seWxpbmVzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5bGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSBwb2x5bGluZXNbaV07XG4gICAgICAgICAgICB2YXIgcG9seWxpbmVJbnRlcnNlY3Rpb24gPSBsaW5lLmludGVyc2VjdChwb2x5bGluZSk7XG4gICAgICAgICAgICBpZiAocG9seWxpbmVJbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gfHwgKGludGVyc2VjdGlvbiA9IFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2x5bGluZUludGVyc2VjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uLCBwb2x5bGluZUludGVyc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnB1c2gocG9seWxpbmVJbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYSBkaWZmZXJlbnRpYWJsZSBzZWdtZW50IGlzIGZvdW5kIGluIHNlZ21lbnRzLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGRpZmZlcmVudGlhYmxlIHNlZ21lbnQgaXMgZm91bmQgaW4gc2VnbWVudHMsIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGN1cnJlbnQgcGF0aCBzZWdtZW50cyBhcmUgdmFsaWQuXG4gICAgLy8gTm90ZSB0aGF0IGQgaXMgYWxsb3dlZCB0byBiZSBlbXB0eSAtIHNob3VsZCBkaXNhYmxlIHJlbmRlcmluZyBvZiB0aGUgcGF0aC5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IChzZWdtZW50cy5sZW5ndGggPT09IDApIHx8IChzZWdtZW50c1swXS50eXBlID09PSAnTScpOyAvLyBlaXRoZXIgZW1wdHkgb3IgZmlyc3Qgc2VnbWVudCBpcyBhIE1vdmV0b1xuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBsZW5ndGggb2YgdGhlIHBhdGgsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gSWYgcGF0aCBoYXMgbm8gc2VnbWVudHMsIHJldHVybnMgMC5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjsgLy8gb3B0LnByZWNpc2lvbiBvbmx5IHVzZWQgaW4gZ2V0U2VnbWVudFN1YmRpdmlzaW9ucygpIGNhbGxcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWdtZW50Lmxlbmd0aCh7IHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbi5cbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKHQsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gMDsgLy8gcmVnYXJkbGVzcyBvZiB0LnZhbHVlXG5cbiAgICAgICAgdmFyIHRWYWx1ZSA9IHQudmFsdWU7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPj0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IG51bVNlZ21lbnRzIC0gMTtcbiAgICAgICAgICAgIHRWYWx1ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodFZhbHVlIDwgMCkgdFZhbHVlID0gMDtcbiAgICAgICAgZWxzZSBpZiAodFZhbHVlID4gMSkgdFZhbHVlID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50SW5kZXg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lzb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tzZWdtZW50SW5kZXhdO1xuICAgICAgICBsZW5ndGggKz0gc2VnbWVudC5sZW5ndGhBdFQodFZhbHVlLCB7IHByZWNpc2lzb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBwb2ludCBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zZWdtZW50U3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBwb2ludEF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAocmF0aW8gPj0gMSkgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRMZW5ndGgobGVuZ3RoLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcG9pbnQgYXQgcmVxdWVzdGVkIGBsZW5ndGhgLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBsZW5ndGguXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3RhcnQuY2xvbmUoKTtcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGFzdFZpc2libGVTZWdtZW50O1xuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnBvaW50QXRMZW5ndGgoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZVNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZW5ndGggcmVxdWVzdGVkIGlzIGhpZ2hlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHJldHVybiBsYXN0IHZpc2libGUgc2VnbWVudCBlbmRwb2ludFxuICAgICAgICBpZiAobGFzdFZpc2libGVTZWdtZW50KSByZXR1cm4gKGZyb21TdGFydCA/IGxhc3RWaXNpYmxlU2VnbWVudC5lbmQgOiBsYXN0VmlzaWJsZVNlZ21lbnQuc3RhcnQpO1xuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnQgKG5vIG1hdHRlciBpZiBmcm9tU3RhcnQgb3Igbm8pXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV07XG4gICAgICAgIHJldHVybiBsYXN0U2VnbWVudC5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbi5cbiAgICBwb2ludEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gc2VnbWVudHNbMF0ucG9pbnRBdFQoMCk7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPj0gbnVtU2VnbWVudHMpIHJldHVybiBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLnBvaW50QXRUKDEpO1xuXG4gICAgICAgIHZhciB0VmFsdWUgPSB0LnZhbHVlO1xuICAgICAgICBpZiAodFZhbHVlIDwgMCkgdFZhbHVlID0gMDtcbiAgICAgICAgZWxzZSBpZiAodFZhbHVlID4gMSkgdFZhbHVlID0gMTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudHNbc2VnbWVudEluZGV4XS5wb2ludEF0VCh0VmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIFBSRUNJU0lPTjogMyxcblxuICAgIC8vIEhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBzZWdtZW50cy5cbiAgICBwcmVwYXJlU2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCwgcHJldmlvdXNTZWdtZW50LCBuZXh0U2VnbWVudCkge1xuXG4gICAgICAgIC8vIGluc2VydCBhZnRlciBwcmV2aW91cyBzZWdtZW50IGFuZCBiZWZvcmUgcHJldmlvdXMgc2VnbWVudCdzIG5leHQgc2VnbWVudFxuICAgICAgICBzZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHByZXZpb3VzU2VnbWVudDtcbiAgICAgICAgc2VnbWVudC5uZXh0U2VnbWVudCA9IG5leHRTZWdtZW50O1xuICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50KSBwcmV2aW91c1NlZ21lbnQubmV4dFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICBpZiAobmV4dFNlZ21lbnQpIG5leHRTZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHNlZ21lbnQ7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVN1YnBhdGhTdGFydCA9IHNlZ21lbnQ7XG4gICAgICAgIGlmIChzZWdtZW50LmlzU3VicGF0aFN0YXJ0KSB7XG4gICAgICAgICAgICBzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQgPSBzZWdtZW50OyAvLyBhc3NpZ24gc2VsZiBhcyBzdWJwYXRoIHN0YXJ0IHNlZ21lbnRcbiAgICAgICAgICAgIHVwZGF0ZVN1YnBhdGhTdGFydCA9IG5leHRTZWdtZW50OyAvLyBzdGFydCB1cGRhdGluZyBmcm9tIG5leHQgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzaWduIHByZXZpb3VzIHNlZ21lbnQncyBzdWJwYXRoIHN0YXJ0IChvciBzZWxmIGlmIGl0IGlzIGEgc3VicGF0aCBzdGFydCkgdG8gc3Vic2VxdWVudCBzZWdtZW50c1xuICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0KSB0aGlzLnVwZGF0ZVN1YnBhdGhTdGFydFNlZ21lbnQodXBkYXRlU3VicGF0aFN0YXJ0KTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBzZWdtZW50IGF0IGBpbmRleGAuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLCBmcm9tIGAtMWAgdG8gYC1zZWdtZW50cy5sZW5ndGhgLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBwYXRoIGhhcyBubyBzZWdtZW50cy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgIHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHRocm93IG5ldyBFcnJvcignUGF0aCBoYXMgbm8gc2VnbWVudHMuJyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4OyAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXMgdG8gcG9zaXRpdmVcbiAgICAgICAgaWYgKGluZGV4ID49IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgdmFyIHJlbW92ZWRTZWdtZW50ID0gc2VnbWVudHMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VnbWVudCA9IHJlbW92ZWRTZWdtZW50LnByZXZpb3VzU2VnbWVudDtcbiAgICAgICAgdmFyIG5leHRTZWdtZW50ID0gcmVtb3ZlZFNlZ21lbnQubmV4dFNlZ21lbnQ7XG5cbiAgICAgICAgLy8gbGluayB0aGUgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudHMgdG9nZXRoZXIgKGlmIHByZXNlbnQpXG4gICAgICAgIGlmIChwcmV2aW91c1NlZ21lbnQpIHByZXZpb3VzU2VnbWVudC5uZXh0U2VnbWVudCA9IG5leHRTZWdtZW50OyAvLyBtYXkgYmUgbnVsbFxuICAgICAgICBpZiAobmV4dFNlZ21lbnQpIG5leHRTZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHByZXZpb3VzU2VnbWVudDsgLy8gbWF5IGJlIG51bGxcblxuICAgICAgICAvLyBpZiByZW1vdmVkIHNlZ21lbnQgdXNlZCB0byBzdGFydCBhIHN1YnBhdGgsIHVwZGF0ZSBhbGwgc3Vic2VxdWVudCBzZWdtZW50cyB1bnRpbCBhbm90aGVyIHN1YnBhdGggc3RhcnQgc2VnbWVudCBpcyByZWFjaGVkXG4gICAgICAgIGlmIChyZW1vdmVkU2VnbWVudC5pc1N1YnBhdGhTdGFydCAmJiBuZXh0U2VnbWVudCkgdGhpcy51cGRhdGVTdWJwYXRoU3RhcnRTZWdtZW50KG5leHRTZWdtZW50KTtcbiAgICB9LFxuXG4gICAgLy8gUmVwbGFjZSB0aGUgc2VnbWVudCBhdCBgaW5kZXhgIHdpdGggYGFyZ2AuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLCBmcm9tIGAtMWAgdG8gYC1zZWdtZW50cy5sZW5ndGhgLlxuICAgIC8vIEFjY2VwdHMgb25lIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYXMgYXJndW1lbnQuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgcmVwbGFjZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4LCBhcmcpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGhhcyBubyBzZWdtZW50cy4nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IG51bVNlZ21lbnRzICsgaW5kZXg7IC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlcyB0byBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5kZXggPj0gbnVtU2VnbWVudHMgfHwgaW5kZXggPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZS4nKTtcblxuICAgICAgICB2YXIgY3VycmVudFNlZ21lbnQ7XG5cbiAgICAgICAgdmFyIHJlcGxhY2VkU2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VnbWVudCA9IHJlcGxhY2VkU2VnbWVudC5wcmV2aW91c1NlZ21lbnQ7XG4gICAgICAgIHZhciBuZXh0U2VnbWVudCA9IHJlcGxhY2VkU2VnbWVudC5uZXh0U2VnbWVudDtcblxuICAgICAgICB2YXIgdXBkYXRlU3VicGF0aFN0YXJ0ID0gcmVwbGFjZWRTZWdtZW50LmlzU3VicGF0aFN0YXJ0OyAvLyBib29sZWFuOiBpcyBhbiB1cGRhdGUgb2Ygc3VicGF0aCBzdGFydHMgbmVjZXNzYXJ5P1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoIWFyZyB8fCAhYXJnLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50IHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHRoaXMucHJlcGFyZVNlZ21lbnQoYXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZShpbmRleCwgMSwgY3VycmVudFNlZ21lbnQpOyAvLyBkaXJlY3RseSByZXBsYWNlXG5cbiAgICAgICAgICAgIGlmICh1cGRhdGVTdWJwYXRoU3RhcnQgJiYgY3VycmVudFNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHVwZGF0ZVN1YnBhdGhTdGFydCA9IGZhbHNlOyAvLyBhbHJlYWR5IHVwZGF0ZWQgYnkgYHByZXBhcmVTZWdtZW50YFxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZSgoaW5kZXggKyBpKSwgMCwgY3VycmVudFNlZ21lbnQpOyAvLyBpbmNyZW1lbnRpbmcgaW5kZXggdG8gaW5zZXJ0IHN1YnNlcXVlbnQgc2VnbWVudHMgYWZ0ZXIgaW5zZXJ0ZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBjdXJyZW50U2VnbWVudDtcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdWJwYXRoU3RhcnQgJiYgY3VycmVudFNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHVwZGF0ZVN1YnBhdGhTdGFydCA9IGZhbHNlOyAvLyBhbHJlYWR5IHVwZGF0ZWQgYnkgYHByZXBhcmVTZWdtZW50YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVwbGFjZWQgc2VnbWVudCB1c2VkIHRvIHN0YXJ0IGEgc3VicGF0aCBhbmQgbm8gbmV3IHN1YnBhdGggc3RhcnQgd2FzIGFkZGVkLCB1cGRhdGUgYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMgdW50aWwgYW5vdGhlciBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgaXMgcmVhY2hlZFxuICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0ICYmIG5leHRTZWdtZW50KSB0aGlzLnVwZGF0ZVN1YnBhdGhTdGFydFNlZ21lbnQobmV4dFNlZ21lbnQpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHNlZ21lbnQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlZ21lbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4QXQocmF0aW8sIG9wdCk7XG4gICAgICAgIGlmICghaW5kZXgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlZ21lbnQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGxlbmd0aC5cbiAgICBzZWdtZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXhBdExlbmd0aChsZW5ndGgsIG9wdCk7XG4gICAgICAgIGlmICghaW5kZXgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlZ21lbnQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICBzZWdtZW50SW5kZXhBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEluZGV4QXRMZW5ndGgobGVuZ3RoLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgbGVuZ3RoLlxuICAgIHNlZ21lbnRJbmRleEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGFzdFZpc2libGVTZWdtZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVTZWdtZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoLCByZXR1cm4gbGFzdCB2aXNpYmxlIHNlZ21lbnQgaW5kZXhcbiAgICAgICAgLy8gaWYgbm8gdmlzaWJsZSBzZWdtZW50LCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbGFzdFZpc2libGVTZWdtZW50SW5kZXg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgcGF0aC5cbiAgICAvLyBBZGRpdGlvbmFsIGVycm9yIGNoZWNraW5nIGNvbXBhcmVkIHRvIHRvU3RyaW5nIChtdXN0IHN0YXJ0IHdpdGggTSBzZWdtZW50KS5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRoIHNlZ21lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGFuZ2VudCBsaW5lIGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMSwgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zZWdtZW50U3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGxlbmd0aC5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBsYXN0VmFsaWRTZWdtZW50OyAvLyB2aXNpYmxlIEFORCBkaWZmZXJlbnRpYWJsZSAod2l0aCBhIHRhbmdlbnQpXG4gICAgICAgIHZhciBsID0gMDsgLy8gbGVuZ3RoIHNvIGZhclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG51bVNlZ21lbnRzIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQubGVuZ3RoKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc0RpZmZlcmVudGlhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQudGFuZ2VudEF0TGVuZ3RoKCgoZnJvbVN0YXJ0ID8gMSA6IC0xKSAqIChsZW5ndGggLSBsKSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCByZXF1ZXN0ZWQgaXMgaGlnaGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgcmV0dXJuIHRhbmdlbnQgb2YgZW5kcG9pbnQgb2YgbGFzdCB2YWxpZCBzZWdtZW50XG4gICAgICAgIGlmIChsYXN0VmFsaWRTZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IChmcm9tU3RhcnQgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbGlkU2VnbWVudC50YW5nZW50QXRUKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gdmFsaWQgc2VnbWVudCwgcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb24uXG4gICAgdGFuZ2VudEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gc2VnbWVudHNbMF0udGFuZ2VudEF0VCgwKTtcbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA+PSBudW1TZWdtZW50cykgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0udGFuZ2VudEF0VCgxKTtcblxuICAgICAgICB2YXIgdFZhbHVlID0gdC52YWx1ZTtcbiAgICAgICAgaWYgKHRWYWx1ZSA8IDApIHRWYWx1ZSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRWYWx1ZSA+IDEpIHRWYWx1ZSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRJbmRleF0udGFuZ2VudEF0VCh0VmFsdWUpO1xuICAgIH0sXG5cbiAgICB0b1BvaW50czogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgcGFydGlhbFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRTdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VnbWVudFN1YmRpdmlzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvblBvaW50cyA9IGN1cnJlbnRTZWdtZW50U3ViZGl2aXNpb25zLm1hcChmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnZlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocGFydGlhbFBvaW50cywgc3ViZGl2aXNpb25Qb2ludHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxQb2ludHMucHVzaChzZWdtZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRpYWxQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxQb2ludHMucHVzaChzZWdtZW50c1tpIC0gMV0uZW5kKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwYXJ0aWFsUG9pbnRzKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsUG9pbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0aWFsUG9pbnRzLnB1c2godGhpcy5lbmQpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocGFydGlhbFBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgdG9Qb2x5bGluZXM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBwb2x5bGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMudG9Qb2ludHMob3B0KTtcbiAgICAgICAgaWYgKCFwb2ludHMpIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlsaW5lcy5wdXNoKG5ldyBQb2x5bGluZShwb2ludHNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bGluZXM7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgcGF0aERhdGEgKz0gc2VnbWVudC5zZXJpYWxpemUoKSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoRGF0YS50cmltKCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kIGZvciB1cGRhdGluZyBzdWJwYXRoIHN0YXJ0IG9mIHNlZ21lbnRzLCBzdGFydGluZyB3aXRoIHRoZSBvbmUgcHJvdmlkZWQuXG4gICAgdXBkYXRlU3VicGF0aFN0YXJ0U2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCkge1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50LnByZXZpb3VzU2VnbWVudDsgLy8gbWF5IGJlIG51bGxcbiAgICAgICAgd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHtcblxuICAgICAgICAgICAgLy8gYXNzaWduIHByZXZpb3VzIHNlZ21lbnQncyBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgdG8gdGhpcyBzZWdtZW50XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50KSBzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQgPSBwcmV2aW91c1NlZ21lbnQuc3VicGF0aFN0YXJ0U2VnbWVudDsgLy8gbWF5IGJlIG51bGxcbiAgICAgICAgICAgIGVsc2Ugc2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50ID0gbnVsbDsgLy8gaWYgc2VnbWVudCBoYWQgbm8gcHJldmlvdXMgc2VnbWVudCwgYXNzaWduIG51bGwgLSBjcmVhdGVzIGFuIGludmFsaWQgcGF0aCFcblxuICAgICAgICAgICAgcHJldmlvdXNTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50Lm5leHRTZWdtZW50OyAvLyBtb3ZlIG9uIHRvIHRoZSBzZWdtZW50IGFmdGVyIGV0Yy5cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBub3QgdmFsaWQsIGluc2VydCBNIDAgMCBhdCB0aGUgYmVnaW5uaW5nLlxuICAgIC8vIFBhdGggd2l0aCBubyBzZWdtZW50cyBpcyBjb25zaWRlcmVkIHZhbGlkLCBzbyBub3RoaW5nIGlzIGluc2VydGVkLlxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB0aGlzLmluc2VydFNlZ21lbnQoMCwgUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgMCwgMCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0aC5wcm90b3R5cGUsICdzdGFydCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBmaXJzdCB2aXNpYmxlIGVuZHBvaW50IG9mIHRoZSBwYXRoLlxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSByZXR1cm4gc2VnbWVudC5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnRcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0uZW5kO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0aC5wcm90b3R5cGUsICdlbmQnLCB7XG4gICAgLy8gR2V0dGVyIGZvciB0aGUgbGFzdCB2aXNpYmxlIGVuZHBvaW50IG9mIHRoZSBwYXRoLlxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBudW1TZWdtZW50cyAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHJldHVybiBzZWdtZW50LmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnRcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0uZW5kO1xuICAgIH1cbn0pO1xuXG5cbi8vIExvY2FsIGhlbHBlciBmdW5jdGlvbi5cbi8vIFVzZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCBhIGNvbnN0cnVjdG9yIChmdW5jdGlvbiBjYWxsZWQgd2l0aCBgbmV3YCkuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4NDMxODEvMjI2MzU5NVxuLy8gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byB1c2UgdGhpcyBmdW5jdGlvbiBpZiB0aGUgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgc2VwYXJhdGVseSAoaS5lLiBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBsaW1pdGVkKS5cbi8vIC0gSWYgdGhhdCBpcyB0aGUgY2FzZSwgdXNlIGBuZXcgY29uc3RydWN0b3IoYXJnMSwgYXJnMilgLCBmb3IgZXhhbXBsZS5cbi8vIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gdXNlIHRoaXMgZnVuY3Rpb24gaWYgdGhlIGZ1bmN0aW9uIHRoYXQgbmVlZHMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3IuXG4vLyAtIElmIHRoYXQgaXMgdGhlIGNhc2UsIHVzZSBgZi5hcHBseSh0aGlzQXJnLCBbYXJnMSwgYXJnMi4uLl0pYCwgZm9yIGV4YW1wbGUuXG5mdW5jdGlvbiBhcHBseVRvTmV3KGNvbnN0cnVjdG9yLCBhcmdzQXJyYXkpIHtcbiAgICAvLyBUaGUgYG5ld2Aga2V5d29yZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBsaW1pdGVkIG51bWJlciBvZiBhcmd1bWVudHMuXG4gICAgLy8gLSBXZSBjYW4gZmFrZSB0aGF0IHdpdGggLmJpbmQoKS5cbiAgICAvLyAtIEl0IGNhbGxzIGEgZnVuY3Rpb24gKGBjb25zdHJ1Y3RvcmAsIGhlcmUpIHdpdGggdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcHJvdmlkZWQgdG8gaXQgLSBlZmZlY3RpdmVseSB0cmFuc2Zvcm1pbmcgYW4gdW5saW1pdGVkIG51bWJlciBvZiBhcmd1bWVudHMgaW50byBsaW1pdGVkLlxuICAgIC8vIC0gU28gYG5ldyAoY29uc3RydWN0b3IuYmluZCh0aGlzQXJnLCBhcmcxLCBhcmcyLi4uKSlgXG4gICAgLy8gLSBgdGhpc0FyZ2AgY2FuIGJlIGFueXRoaW5nIChlLmcuIG51bGwpIGJlY2F1c2UgYG5ld2Aga2V5d29yZCByZXNldHMgY29udGV4dCB0byB0aGUgY29uc3RydWN0b3Igb2JqZWN0LlxuICAgIC8vIFdlIG5lZWQgdG8gcGFzcyBpbiBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gdGhlIGJpbmQoKSBjYWxsLlxuICAgIC8vIC0gV2UgY2FuIHVzZSAuYXBwbHkoKS5cbiAgICAvLyAtIFNvIGBuZXcgKGNvbnN0cnVjdG9yLmJpbmQuYXBwbHkoY29uc3RydWN0b3IsIFt0aGlzQXJnLCBhcmcxLCBhcmcyLi4uXSkpYFxuICAgIC8vIC0gYHRoaXNBcmdgIGNhbiBzdGlsbCBiZSBhbnl0aGluZyBiZWNhdXNlIGBuZXdgIG92ZXJ3cml0ZXMgaXQuXG4gICAgLy8gRmluYWxseSwgdG8gbWFrZSBzdXJlIHRoYXQgY29uc3RydWN0b3IuYmluZCBvdmVyd3JpdGluZyBpcyBub3QgYSBwcm9ibGVtLCB3ZSBzd2l0Y2ggdG8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYC5cbiAgICAvLyAtIFNvLCB0aGUgZmluYWwgdmVyc2lvbiBpcyBgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShjb25zdHJ1Y3RvciwgW3RoaXNBcmcsIGFyZzEsIGFyZzIuLi5dKSlgXG5cbiAgICAvLyBUaGUgZnVuY3Rpb24gZXhwZWN0cyBgYXJnc0FycmF5WzBdYCB0byBiZSBgdGhpc0FyZ2AuXG4gICAgLy8gLSBUaGlzIG1lYW5zIHRoYXQgd2hhdGV2ZXIgaXMgc2VudCBhcyB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgLy8gLSBUaGUgY29uc3RydWN0b3Igd2lsbCBvbmx5IHNlZSBhcmd1bWVudHMgc3RhcnRpbmcgZnJvbSBhcmdzQXJyYXlbMV0uXG4gICAgLy8gLSBTbywgYSBuZXcgZHVtbXkgZWxlbWVudCBpcyBpbnNlcnRlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIGFycmF5LlxuICAgIGFyZ3NBcnJheS51bnNoaWZ0KG51bGwpO1xuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoY29uc3RydWN0b3IsIGFyZ3NBcnJheSkpO1xufVxuXG4vLyBQYXRoIHNlZ21lbnQgaW50ZXJmYWNlOlxudmFyIHNlZ21lbnRQcm90b3R5cGUgPSB7XG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJlZGlyZWN0IGNhbGxzIHRvIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgoKSBmdW5jdGlvbiBpZiBjbG9zZXN0UG9pbnRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgY2xvc2VzdFBvaW50VDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIGlmICh0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgpIHJldHVybiB0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIGNsb3Nlc3RQb2ludFQoKSBub3IgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aCgpIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJlZGlyZWN0IGNhbGxzIHRvIGRpdmlkZUF0KCkgZnVuY3Rpb24gaWYgZGl2aWRlQXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgZGl2aWRlQXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGl2aWRlQXQpIHJldHVybiB0aGlzLmRpdmlkZUF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBkaXZpZGVBdFQoKSBub3IgZGl2aWRlQXQoKSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZC4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGVxdWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIGlzU2VnbWVudDogdHJ1ZSxcblxuICAgIGlzU3VicGF0aFN0YXJ0OiBmYWxzZSwgLy8gdHJ1ZSBmb3IgTW92ZXRvIHNlZ21lbnRzXG5cbiAgICBpc1Zpc2libGU6IHRydWUsIC8vIGZhbHNlIGZvciBNb3ZldG8gc2VnbWVudHNcblxuICAgIC8vIHZpcnR1YWxcbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGEgZnJhY3Rpb24gb2YgcmVzdWx0IG9mIGxlbmd0aCgpIGZ1bmN0aW9uIGlmIGxlbmd0aEF0VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIGxlbmd0aEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICh0ID49IDEpIHJldHVybiBsZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAqIHQ7XG4gICAgfSxcblxuICAgIG5leHRTZWdtZW50OiBudWxsLCAvLyBuZWVkZWQgZm9yIHN1YnBhdGggc3RhcnQgc2VnbWVudCB1cGRhdGluZ1xuXG4gICAgLy8gdmlydHVhbFxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmVkaXJlY3QgY2FsbHMgdG8gcG9pbnRBdCgpIGZ1bmN0aW9uIGlmIHBvaW50QXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgcG9pbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAodGhpcy5wb2ludEF0KSByZXR1cm4gdGhpcy5wb2ludEF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBwb2ludEF0VCgpIG5vciBwb2ludEF0KCkgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQuJyk7XG4gICAgfSxcblxuICAgIHByZXZpb3VzU2VnbWVudDogbnVsbCwgLy8gbmVlZGVkIHRvIGdldCBzZWdtZW50IHN0YXJ0IHByb3BlcnR5XG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgc3VicGF0aFN0YXJ0U2VnbWVudDogbnVsbCwgLy8gbmVlZGVkIHRvIGdldCBDbG9zZXBhdGggc2VnbWVudCBlbmQgcHJvcGVydHlcblxuICAgIC8vIHZpcnR1YWxcbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyBSZWRpcmVjdCBjYWxscyB0byB0YW5nZW50QXQoKSBmdW5jdGlvbiBpZiB0YW5nZW50QXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgdGFuZ2VudEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0aGlzLnRhbmdlbnRBdCkgcmV0dXJuIHRoaXMudGFuZ2VudEF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciB0YW5nZW50QXRUKCkgbm9yIHRhbmdlbnRBdCgpIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH1cbn07XG5cbi8vIHVzdWFsbHkgZGlyZWN0bHkgYXNzaWduZWRcbi8vIGdldHRlciBmb3IgQ2xvc2VwYXRoXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2VnbWVudFByb3RvdHlwZSwgJ2VuZCcsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8vIGFsd2F5cyBhIGdldHRlclxuLy8gYWx3YXlzIHRocm93cyBlcnJvciBmb3IgTW92ZXRvXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2VnbWVudFByb3RvdHlwZSwgJ3N0YXJ0Jywge1xuICAgIC8vIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgZW5kIHBvaW50IG9mIHByZXZpb3VzIHNlZ21lbnRcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c1NlZ21lbnQpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcmV2aW91cyBzZWdtZW50LiAoVGhpcyBzZWdtZW50IGNhbm5vdCBiZSB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIHBhdGg7IE9SIHNlZ21lbnQgaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byBhIHBhdGguKScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzU2VnbWVudC5lbmQ7XG4gICAgfVxufSk7XG5cbi8vIHZpcnR1YWxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWdtZW50UHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHNlZ21lbnQgZGVjbGFyYXRpb24uIE5vIHR5cGUgc3BlY2lmaWVkLicpO1xuICAgIH1cbn0pO1xuXG4vLyBQYXRoIHNlZ21lbnQgaW1wbGVtZW50YXRpb25zOlxudmFyIExpbmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmV0bykpIHsgLy8gc3dpdGNoaW5nIGNvbnRleHQgb2YgYHRoaXNgIHRvIExpbmV0byB3aGVuIGNhbGxlZCB3aXRob3V0IGBuZXdgXG4gICAgICAgIHJldHVybiBhcHBseVRvTmV3KExpbmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5ldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgTGluZSkgeyAvLyBsaW5lcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGluZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgbGluZXMgcHJvdmlkZWQpLicpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHsgLy8gY29vcmRpbmF0ZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KCthcmdzWzBdLCArYXJnc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgaWYgKG4gPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGNvb3JkaW5hdGVzIHByb3ZpZGVkKS4nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgcG9seS1saW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBzZWdtZW50Q29vcmRzO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IDIpIHsgLy8gY29vcmRzIGNvbWUgaW4gZ3JvdXBzIG9mIHR3b1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudENvb3JkcyA9IGFyZ3Muc2xpY2UoaSwgaSArIDIpOyAvLyB3aWxsIHNlbmQgb25lIGNvb3JkIGlmIGFyZ3MubGVuZ3RoIG5vdCBkaXZpc2libGUgYnkgMlxuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goYXBwbHlUb05ldyhMaW5ldG8sIHNlZ21lbnRDb29yZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gcG9pbnRzIHByb3ZpZGVkIChuZWVkcyB0byBiZSBsYXN0IHRvIGFsc28gY292ZXIgcGxhaW4gb2JqZWN0cyB3aXRoIHggYW5kIHkpXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChhcmdzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgdmFyIHNlZ21lbnRQb2ludDtcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50UG9pbnQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gobmV3IExpbmV0byhzZWdtZW50UG9pbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsaW5ldG9Qcm90b3R5cGUgPSB7XG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5ldG8odGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBsaW5lLmRpdmlkZUF0KHJhdGlvKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFswXSksXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBsaW5lLmRpdmlkZUF0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydC5lcXVhbHModGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyAnICsgZW5kLnggKyAnICcgKyBlbmQueTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyB0aGlzLnN0YXJ0ICsgJyAnICsgdGhpcy5lbmQ7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaW5ldG9Qcm90b3R5cGUsICd0eXBlJywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIHZhbHVlOiAnTCdcbn0pO1xuXG5MaW5ldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIExpbmUucHJvdG90eXBlLCBsaW5ldG9Qcm90b3R5cGUpO1xuXG52YXIgQ3VydmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1cnZldG8pKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBDdXJ2ZXRvIHdoZW4gY2FsbGVkIHdpdGhvdXQgYG5ld2BcbiAgICAgICAgcmV0dXJuIGFwcGx5VG9OZXcoQ3VydmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBjdXJ2ZSwgMyBwb2ludHMsIG9yIDYgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgQ3VydmUpIHsgLy8gY3VydmVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBhcmdzWzBdLmNvbnRyb2xQb2ludDEuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IGFyZ3NbMF0uY29udHJvbFBvaW50Mi5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzICgnICsgbiArICcgY3VydmVzIHByb3ZpZGVkKS4nKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInKSB7IC8vIGNvb3JkaW5hdGVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSA2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBuZXcgUG9pbnQoK2FyZ3NbMF0sICthcmdzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IG5ldyBQb2ludCgrYXJnc1syXSwgK2FyZ3NbM10pO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQoK2FyZ3NbNF0sICthcmdzWzVdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzICgnICsgbiArICcgY29vcmRpbmF0ZXMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWJlemllciBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudENvb3JkcztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSA2KSB7IC8vIGNvb3JkcyBjb21lIGluIGdyb3VwcyBvZiBzaXhcblxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb29yZHMgPSBhcmdzLnNsaWNlKGksIGkgKyA2KTsgLy8gd2lsbCBzZW5kIGZld2VyIHRoYW4gc2l4IGNvb3JkcyBpZiBhcmdzLmxlbmd0aCBub3QgZGl2aXNpYmxlIGJ5IDZcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKGFwcGx5VG9OZXcoQ3VydmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBwb2ludHMgcHJvdmlkZWQgKG5lZWRzIHRvIGJlIGxhc3QgdG8gYWxzbyBjb3ZlciBwbGFpbiBvYmplY3RzIHdpdGggeCBhbmQgeSlcbiAgICAgICAgaWYgKG4gPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MSA9IG5ldyBQb2ludChhcmdzWzBdKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IG5ldyBQb2ludChhcmdzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBjdXJ2ZSwgMyBwb2ludHMsIG9yIDYgY29vcmRpbmF0ZXMgKCcgKyBuICsgJyBwb2ludHMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWJlemllciBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudFBvaW50cztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAzKSB7IC8vIHBvaW50cyBjb21lIGluIGdyb3VwcyBvZiB0aHJlZVxuXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvaW50cyA9IGFyZ3Muc2xpY2UoaSwgaSArIDMpOyAvLyB3aWxsIHNlbmQgZmV3ZXIgdGhhbiB0aHJlZSBwb2ludHMgaWYgYXJncy5sZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSAzXG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KEN1cnZldG8sIHNlZ21lbnRQb2ludHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBjdXJ2ZXRvUHJvdG90eXBlID0ge1xuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ3VydmV0byh0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZSh0aGlzLnN0YXJ0LCB0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGN1cnZlLmRpdmlkZUF0KHJhdGlvLCBvcHQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFswXSksXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUodGhpcy5zdGFydCwgdGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJ2ZS5kaXZpZGVBdExlbmd0aChsZW5ndGgsIG9wdCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzBdKSxcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZSh0aGlzLnN0YXJ0LCB0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGN1cnZlLmRpdmlkZUF0VCh0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2wyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgcmV0dXJuICEoc3RhcnQuZXF1YWxzKGNvbnRyb2wxKSAmJiBjb250cm9sMS5lcXVhbHMoY29udHJvbDIpICYmIGNvbnRyb2wyLmVxdWFscyhlbmQpKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGMxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgYzIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIGMxLnggKyAnICcgKyBjMS55ICsgJyAnICsgYzIueCArICcgJyArIGMyLnkgKyAnICcgKyBlbmQueCArICcgJyArIGVuZC55O1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIHRoaXMuc3RhcnQgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDEgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDIgKyAnICcgKyB0aGlzLmVuZDtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXRvUHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB2YWx1ZTogJ0MnXG59KTtcblxuQ3VydmV0by5wcm90b3R5cGUgPSBleHRlbmQoc2VnbWVudFByb3RvdHlwZSwgQ3VydmUucHJvdG90eXBlLCBjdXJ2ZXRvUHJvdG90eXBlKTtcblxudmFyIE1vdmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdmV0bykpIHsgLy8gc3dpdGNoaW5nIGNvbnRleHQgb2YgYHRoaXNgIHRvIE1vdmV0byB3aGVuIGNhbGxlZCB3aXRob3V0IGBuZXdgXG4gICAgICAgIHJldHVybiBhcHBseVRvTmV3KE1vdmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb3ZldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIGEgY3VydmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgTGluZSkgeyAvLyBsaW5lcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW92ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCBhIGN1cnZlLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgbGluZXMgcHJvdmlkZWQpLicpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBDdXJ2ZSkgeyAvLyBjdXJ2ZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYXJnc1swXS5lbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vdmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgYSBjdXJ2ZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGN1cnZlcyBwcm92aWRlZCkuJyk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJykgeyAvLyBjb29yZGluYXRlcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQoK2FyZ3NbMF0sICthcmdzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW92ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCBhIGN1cnZlLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgY29vcmRpbmF0ZXMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBtb3ZldG8td2l0aC1zdWJzZXF1ZW50LXBvbHktbGluZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudENvb3JkcztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAyKSB7IC8vIGNvb3JkcyBjb21lIGluIGdyb3VwcyBvZiB0d29cblxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb29yZHMgPSBhcmdzLnNsaWNlKGksIGkgKyAyKTsgLy8gd2lsbCBzZW5kIG9uZSBjb29yZCBpZiBhcmdzLmxlbmd0aCBub3QgZGl2aXNpYmxlIGJ5IDJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KE1vdmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgICAgIGVsc2Ugb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KExpbmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBwb2ludHMgcHJvdmlkZWQgKG5lZWRzIHRvIGJlIGxhc3QgdG8gYWxzbyBjb3ZlciBwbGFpbiBvYmplY3RzIHdpdGggeCBhbmQgeSlcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KGFyZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhpcyBpcyBhIG1vdmV0by13aXRoLXN1YnNlcXVlbnQtcG9seS1saW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBzZWdtZW50UG9pbnQ7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gMSkgeyAvLyBwb2ludHMgY29tZSBvbmUgYnkgb25lXG5cbiAgICAgICAgICAgICAgICBzZWdtZW50UG9pbnQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSBvdXRwdXRBcnJheS5wdXNoKG5ldyBNb3ZldG8oc2VnbWVudFBvaW50KSk7XG4gICAgICAgICAgICAgICAgZWxzZSBvdXRwdXRBcnJheS5wdXNoKG5ldyBMaW5ldG8oc2VnbWVudFBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbW92ZXRvUHJvdG90eXBlID0ge1xuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IE1vdmV0byh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5jbG9uZSgpLFxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5jbG9uZSgpLFxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24obSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5lcXVhbHMobS5lbmQpO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBpc1N1YnBhdGhTdGFydDogdHJ1ZSxcblxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBwb2ludEF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHBvaW50QXRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIGVuZC54ICsgJyAnICsgZW5kLnk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdFQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW92ZXRvUHJvdG90eXBlLCAnc3RhcnQnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYWNjZXNzLiBNb3ZldG8gc2VnbWVudHMgc2hvdWxkIG5vdCBuZWVkIGEgc3RhcnQgcHJvcGVydHkuJyk7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb3ZldG9Qcm90b3R5cGUsICd0eXBlJywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIHZhbHVlOiAnTSdcbn0pO1xuXG5Nb3ZldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIG1vdmV0b1Byb3RvdHlwZSk7IC8vIGRvZXMgbm90IGluaGVyaXQgZnJvbSBhbnkgb3RoZXIgZ2VvbWV0cnkgb2JqZWN0XG5cbnZhciBDbG9zZXBhdGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbG9zZXBhdGgpKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBDbG9zZXBhdGggd2hlbiBjYWxsZWQgd2l0aG91dCBgbmV3YFxuICAgICAgICByZXR1cm4gYXBwbHlUb05ldyhDbG9zZXBhdGgsIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChuID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlcGF0aCBjb25zdHJ1Y3RvciBleHBlY3RzIG5vIGFyZ3VtZW50cy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBjbG9zZXBhdGhQcm90b3R5cGUgPSB7XG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDbG9zZXBhdGgoKTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIHZhciBkaXZpZGVkID0gbGluZS5kaXZpZGVBdChyYXRpbyk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgYWN0dWFsbHkgY3V0IGludG8gdGhlIHNlZ21lbnQsIGZpcnN0IGRpdmlkZWQgcGFydCBjYW4gc3RheSBhcyBaXG4gICAgICAgICAgICAoZGl2aWRlZFsxXS5pc0RpZmZlcmVudGlhYmxlKCkgPyBuZXcgTGluZXRvKGRpdmlkZWRbMF0pIDogdGhpcy5jbG9uZSgpKSxcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGxpbmUuZGl2aWRlQXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBhY3R1YWxseSBjdXQgaW50byB0aGUgc2VnbWVudCwgZmlyc3QgZGl2aWRlZCBwYXJ0IGNhbiBzdGF5IGFzIFpcbiAgICAgICAgICAgIChkaXZpZGVkWzFdLmlzRGlmZmVyZW50aWFibGUoKSA/IG5ldyBMaW5ldG8oZGl2aWRlZFswXSkgOiB0aGlzLmNsb25lKCkpLFxuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCB8fCAhdGhpcy5zdWJwYXRoU3RhcnRTZWdtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXJ0LmVxdWFscyh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyAnICsgdGhpcy5zdGFydCArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZXBhdGhQcm90b3R5cGUsICdlbmQnLCB7XG4gICAgLy8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBlbmQgcG9pbnQgb2Ygc3VicGF0aCBzdGFydCBzZWdtZW50XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3VicGF0aFN0YXJ0U2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHN1YnBhdGggc3RhcnQgc2VnbWVudC4gKFRoaXMgc2VnbWVudCBuZWVkcyBhIHN1YnBhdGggc3RhcnQgc2VnbWVudCAoZS5nLiBNb3ZldG8pOyBPUiBzZWdtZW50IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gYSBwYXRoLiknKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdWJwYXRoU3RhcnRTZWdtZW50LmVuZDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlcGF0aFByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgdmFsdWU6ICdaJ1xufSk7XG5cbkNsb3NlcGF0aC5wcm90b3R5cGUgPSBleHRlbmQoc2VnbWVudFByb3RvdHlwZSwgTGluZS5wcm90b3R5cGUsIGNsb3NlcGF0aFByb3RvdHlwZSk7XG5cbnZhciBzZWdtZW50VHlwZXMgPSBQYXRoLnNlZ21lbnRUeXBlcyA9IHtcbiAgICBMOiBMaW5ldG8sXG4gICAgQzogQ3VydmV0byxcbiAgICBNOiBNb3ZldG8sXG4gICAgWjogQ2xvc2VwYXRoLFxuICAgIHo6IENsb3NlcGF0aFxufTtcblxuUGF0aC5yZWdleFN1cHBvcnRlZERhdGEgPSBuZXcgUmVnRXhwKCdeW1xcXFxzXFxcXGQnICsgT2JqZWN0LmtleXMoc2VnbWVudFR5cGVzKS5qb2luKCcnKSArICcsLl0qJCcpO1xuXG5QYXRoLmlzRGF0YVN1cHBvcnRlZCA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5yZWdleFN1cHBvcnRlZERhdGEudGVzdChkYXRhKTtcbn07XG4iXSwibmFtZXMiOlsiUG9seWxpbmUiLCJSZWN0IiwiUG9pbnQiLCJMaW5lIiwiQ3VydmUiLCJ0eXBlcyIsImV4dGVuZCIsIlBhdGgiLCJhcmciLCJwYXJzZSIsInNlZ21lbnRzIiwiaSIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJjb25jYXQiLCJpc1NlZ21lbnQiLCJzZWdtZW50IiwiYXBwZW5kU2VnbWVudCIsInByZXZpb3VzT2JqIiwib2JqIiwiRXJyb3IiLCJjcmVhdGVTZWdtZW50Iiwic3RhcnQiLCJlbmQiLCJlcXVhbHMiLCJjb250cm9sUG9pbnQxIiwiY29udHJvbFBvaW50MiIsInBvaW50cyIsInBvaW50IiwicGF0aERhdGEiLCJwYXRoIiwiY29tbWFuZFJlIiwiY29tbWFuZHMiLCJtYXRjaCIsIm51bUNvbW1hbmRzIiwiY29tbWFuZCIsImFyZ1JlIiwiYXJncyIsImFwcGx5IiwidHlwZSIsInNlZ21lbnRDb25zdHJ1Y3RvciIsInNlZ21lbnRUeXBlcyIsImFyZ3VtZW50cyIsInB1c2giLCJhcHBseVRvTmV3IiwicHJvdG90eXBlIiwibnVtU2VnbWVudHMiLCJjdXJyZW50U2VnbWVudCIsInByZXZpb3VzU2VnbWVudCIsIm5leHRTZWdtZW50IiwicHJlcGFyZVNlZ21lbnQiLCJjdXJyZW50QXJnIiwiYmJveCIsImlzVmlzaWJsZSIsInNlZ21lbnRCQm94IiwidW5pb24iLCJsYXN0U2VnbWVudCIsIngiLCJ5IiwiY2xvbmUiLCJjbG9zZXN0UG9pbnQiLCJwIiwib3B0IiwidCIsImNsb3Nlc3RQb2ludFQiLCJwb2ludEF0VCIsImNsb3Nlc3RQb2ludExlbmd0aCIsInByZWNpc2lvbiIsInVuZGVmaW5lZCIsIlBSRUNJU0lPTiIsInNlZ21lbnRTdWJkaXZpc2lvbnMiLCJnZXRTZWdtZW50U3ViZGl2aXNpb25zIiwibG9jYWxPcHQiLCJsZW5ndGhBdFQiLCJjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoIiwiY3BMZW5ndGgiLCJtaW5TcXVhcmVkRGlzdGFuY2UiLCJJbmZpbml0eSIsInN1YmRpdmlzaW9ucyIsInNlZ21lbnRDbG9zZXN0UG9pbnRUIiwic2VnbWVudENsb3Nlc3RQb2ludCIsInNxdWFyZWREaXN0YW5jZSIsInNxdWFyZWRMZW5ndGgiLCJzZWdtZW50SW5kZXgiLCJ2YWx1ZSIsImNsb3Nlc3RQb2ludFRhbmdlbnQiLCJpc0RpZmZlcmVudGlhYmxlIiwidGFuZ2VudEF0VCIsImNvbnRhaW5zUG9pbnQiLCJwb2x5bGluZXMiLCJ0b1BvbHlsaW5lcyIsIm51bVBvbHlsaW5lcyIsIm51bUludGVyc2VjdGlvbnMiLCJwb2x5bGluZSIsImRpdmlkZUF0IiwicmF0aW8iLCJwYXRoTGVuZ3RoIiwiZGl2aWRlQXRMZW5ndGgiLCJmcm9tU3RhcnQiLCJsIiwiZGl2aWRlZCIsImRpdmlkZWRTZWdtZW50SW5kZXgiLCJsYXN0VmFsaWRTZWdtZW50IiwibGFzdFZhbGlkU2VnbWVudEluZGV4IiwiaW5kZXgiLCJnZXRTZWdtZW50IiwiZCIsImRpdmlkZUF0VCIsInBhdGhDb3B5IiwicmVwbGFjZVNlZ21lbnQiLCJkaXZpc2lvblN0YXJ0SW5kZXgiLCJkaXZpc2lvbk1pZEluZGV4IiwiZGl2aXNpb25FbmRJbmRleCIsInJlbW92ZVNlZ21lbnQiLCJtb3ZldG9FbmQiLCJpbnNlcnRTZWdtZW50Iiwic2Vjb25kUGF0aFNlZ21lbnRJbmRleENvbnZlcnNpb24iLCJvcmlnaW5hbFNlZ21lbnQiLCJzdWJwYXRoU3RhcnRTZWdtZW50IiwiY29udmVydGVkU2VnbWVudCIsImZpcnN0UGF0aCIsInNsaWNlIiwic2Vjb25kUGF0aCIsIm90aGVyU2VnbWVudHMiLCJvdGhlclNlZ21lbnQiLCJnZXRTdWJkaXZpc2lvbnMiLCJnZXRTdWJwYXRocyIsInZhbGlkYXRlZFBhdGgiLCJ2YWxpZGF0ZSIsInN1YnBhdGhzIiwiaXNTdWJwYXRoU3RhcnQiLCJzcGxpY2UiLCJpbnRlcnNlY3Rpb25XaXRoTGluZSIsImxpbmUiLCJpbnRlcnNlY3Rpb24iLCJwb2x5bGluZUludGVyc2VjdGlvbiIsImludGVyc2VjdCIsImlzVmFsaWQiLCJ0VmFsdWUiLCJwcmVjaXNpc29uIiwicG9pbnRBdCIsInBvaW50QXRMZW5ndGgiLCJsYXN0VmlzaWJsZVNlZ21lbnQiLCJ1cGRhdGVTdWJwYXRoU3RhcnQiLCJ1cGRhdGVTdWJwYXRoU3RhcnRTZWdtZW50IiwicmVtb3ZlZFNlZ21lbnQiLCJyZXBsYWNlZFNlZ21lbnQiLCJyb3VuZCIsInNjYWxlIiwic3giLCJzeSIsIm9yaWdpbiIsInNlZ21lbnRBdCIsInNlZ21lbnRJbmRleEF0Iiwic2VnbWVudEF0TGVuZ3RoIiwic2VnbWVudEluZGV4QXRMZW5ndGgiLCJsYXN0VmlzaWJsZVNlZ21lbnRJbmRleCIsInNlcmlhbGl6ZSIsInRvU3RyaW5nIiwidGFuZ2VudEF0IiwidGFuZ2VudEF0TGVuZ3RoIiwidG9Qb2ludHMiLCJwYXJ0aWFsUG9pbnRzIiwiY3VycmVudFNlZ21lbnRTdWJkaXZpc2lvbnMiLCJzdWJkaXZpc2lvblBvaW50cyIsIm1hcCIsImN1cnZlIiwidHJpbSIsInRyYW5zbGF0ZSIsInR4IiwidHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJjb25zdHJ1Y3RvciIsImFyZ3NBcnJheSIsInVuc2hpZnQiLCJGdW5jdGlvbiIsImJpbmQiLCJzZWdtZW50UHJvdG90eXBlIiwid3JpdGFibGUiLCJMaW5ldG8iLCJvdXRwdXRBcnJheSIsInNlZ21lbnRDb29yZHMiLCJzZWdtZW50UG9pbnQiLCJsaW5ldG9Qcm90b3R5cGUiLCJDdXJ2ZXRvIiwic2VnbWVudFBvaW50cyIsImN1cnZldG9Qcm90b3R5cGUiLCJjb250cm9sMSIsImNvbnRyb2wyIiwiYzEiLCJjMiIsIk1vdmV0byIsIm1vdmV0b1Byb3RvdHlwZSIsIm0iLCJDbG9zZXBhdGgiLCJjbG9zZXBhdGhQcm90b3R5cGUiLCJMIiwiQyIsIk0iLCJaIiwieiIsInJlZ2V4U3VwcG9ydGVkRGF0YSIsIlJlZ0V4cCIsImtleXMiLCJqb2luIiwiaXNEYXRhU3VwcG9ydGVkIiwiZGF0YSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/path.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/point.mjs":
/*!**********************************************!*\
  !*** ./node_modules/jointjs/src/g/point.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   point: () => (/* binding */ point)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.length.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/ \n\n\n\n\nconst { abs, cos, sin, sqrt, min, max, atan2, round, pow, PI } = Math;\nconst Point = function(x, y) {\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n    if (typeof x === \"string\") {\n        var xy = x.split(x.indexOf(\"@\") === -1 ? \" \" : \"@\");\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(angle));\n    if (deg < 90) {\n        y = -y;\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n    } else if (deg < 270) {\n        x = -x;\n    }\n    return new Point(origin.x + x, origin.y + y);\n};\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n    return new Point((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(x1, x2), (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(y1, y2));\n};\nPoint.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Point,\n    chooseClosest: function(points) {\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for(var i = 0; i < n; i++){\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n        if (r.containsPoint(this)) {\n            return this;\n        }\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n        var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n        return angleBetween;\n    },\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__.bearing)(this, point);\n    },\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n    clone: function() {\n        return new Point(this);\n    },\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n        return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n    },\n    difference: function(dx, dy) {\n        if (Object(dx) === dx) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_3__.length)(this, p);\n    },\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n        return p ? this.x * p.x + this.y * p.y : NaN;\n    },\n    equals: function(p) {\n        return !!p && this.x === p.x && this.y === p.y;\n    },\n    // Linear interpolation\n    lerp: function(p, t) {\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n    magnitude: function() {\n        return sqrt(this.x * this.x + this.y * this.y) || 0.01;\n    },\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n        var theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(new Point(ref).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n        if (Object(dx) === dx) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n        return new Point(ref).move(this, this.distance(ref));\n    },\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n        if (angle === 0) return this;\n        origin = origin || new Point(0, 0);\n        angle = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n        var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n        var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n    round: function(precision) {\n        let f = 1; // case 0\n        if (precision) {\n            switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow(10, precision);\n                    break;\n            }\n        }\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n        origin = origin && new Point(origin) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n    snapToGrid: function(gx, gy) {\n        this.x = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.x, gx);\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.y, gy || gx);\n        return this;\n    },\n    squaredDistance: function(p) {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__.squaredLength)(this, p);\n    },\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n        p = new Point(p);\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n        return 180 * rad / PI;\n    },\n    toJSON: function() {\n        return {\n            x: this.x,\n            y: this.y\n        };\n    },\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n        o = o && new Point(o) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(o.theta(new Point(x, y)));\n        return this;\n    },\n    toString: function() {\n        return this.x + \"@\" + this.y;\n    },\n    serialize: function() {\n        return this.x + \",\" + this.y;\n    },\n    update: function(x, y) {\n        if (Object(x) === x) {\n            y = x.y;\n            x = x.x;\n        }\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\nPoint.prototype.translate = Point.prototype.offset;\n// For backwards compatibility:\nconst point = Point;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2ludC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBQzBGO0FBQzdDO0FBQ1k7QUFDZDtBQUNQO0FBRXBDLE1BQU0sRUFDRlMsR0FBRyxFQUNIQyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsSUFBSSxFQUNKQyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxLQUFLLEVBQ0xDLEdBQUcsRUFDSEMsRUFBRSxFQUNMLEdBQUdDO0FBRUcsTUFBTUMsUUFBUSxTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFFOUIsSUFBSSxDQUFFLEtBQUksWUFBWUYsS0FBSSxHQUFJO1FBQzFCLE9BQU8sSUFBSUEsTUFBTUMsR0FBR0M7SUFDeEI7SUFFQSxJQUFJLE9BQU9ELE1BQU0sVUFBVTtRQUN2QixJQUFJRSxLQUFLRixFQUFFRyxLQUFLLENBQUNILEVBQUVJLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNO1FBQy9DSixJQUFJSyxXQUFXSCxFQUFFLENBQUMsRUFBRTtRQUNwQkQsSUFBSUksV0FBV0gsRUFBRSxDQUFDLEVBQUU7SUFFeEIsT0FBTyxJQUFJSSxPQUFPTixPQUFPQSxHQUFHO1FBQ3hCQyxJQUFJRCxFQUFFQyxDQUFDO1FBQ1BELElBQUlBLEVBQUVBLENBQUM7SUFDWDtJQUVBLElBQUksQ0FBQ0EsQ0FBQyxHQUFHQSxNQUFNTyxZQUFZLElBQUlQO0lBQy9CLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxNQUFNTSxZQUFZLElBQUlOO0FBQ25DLEVBQUU7QUFFRixtREFBbUQ7QUFDbkQsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcENGLE1BQU1TLFNBQVMsR0FBRyxTQUFTQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUU5Q0EsU0FBUyxJQUFJWixNQUFNWTtJQUNuQixJQUFJWCxJQUFJWixJQUFJcUIsV0FBV3BCLElBQUlxQjtJQUMz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LElBQUl4QyxNQUFNQyxHQUFHQztRQUNwQyxPQUFPLElBQUk7SUFDZjtJQUVBc0UsVUFBVTtRQUVOLE9BQU8sSUFBSSxDQUFDdkUsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDQyxDQUFDO0lBQ2hDO0lBRUF1RSxXQUFXO1FBRVAsT0FBTyxJQUFJLENBQUN4RSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUNDLENBQUM7SUFDaEM7SUFFQXdFLFFBQVEsU0FBU3pFLENBQUMsRUFBRUMsQ0FBQztRQUVqQixJQUFLSyxPQUFPTixPQUFPQSxHQUFJO1lBQ25CQyxJQUFJRCxFQUFFQyxDQUFDO1lBQ1BELElBQUlBLEVBQUVBLENBQUM7UUFDWDtRQUVBLElBQUksQ0FBQ0EsQ0FBQyxHQUFHQSxLQUFLO1FBQ2QsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLEtBQUs7UUFDZCxPQUFPLElBQUk7SUFDZjtJQUVBLG9GQUFvRjtJQUNwRiw4QkFBOEI7SUFDOUJ5RSxhQUFhLFNBQVNoRCxDQUFDO1FBRW5CLElBQUlpRCxPQUFPLElBQUk1RSxNQUFNLEdBQUc7UUFDeEIsT0FBTzRFLEtBQUt6QyxZQUFZLENBQUMsSUFBSSxFQUFFUjtJQUNuQztBQUNKO0FBRUEzQixNQUFNa0IsU0FBUyxDQUFDMkQsU0FBUyxHQUFHN0UsTUFBTWtCLFNBQVMsQ0FBQzZCLE1BQU07QUFFbEQsK0JBQStCO0FBQ3hCLE1BQU1OLFFBQVF6QyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2ludC5tanM/NTVmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFBvaW50IGlzIHRoZSBtb3N0IGJhc2ljIG9iamVjdCBjb25zaXN0aW5nIG9mIHgveSBjb29yZGluYXRlLlxuXG4gICAgUG9zc2libGUgaW5zdGFudGlhdGlvbnMgYXJlOlxuICAgICogYFBvaW50KDEwLCAyMClgXG4gICAgKiBgbmV3IFBvaW50KDEwLCAyMClgXG4gICAgKiBgUG9pbnQoJzEwIDIwJylgXG4gICAgKiBgUG9pbnQoUG9pbnQoMTAsIDIwKSlgXG4qL1xuaW1wb3J0IHsgbm9ybWFsaXplQW5nbGUsIHJhbmRvbSwgc25hcFRvR3JpZCwgdG9EZWcsIHRvUmFkIH0gZnJvbSAnLi9nZW9tZXRyeS5oZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBiZWFyaW5nIH0gZnJvbSAnLi9saW5lLmJlYXJpbmcubWpzJztcbmltcG9ydCB7IHNxdWFyZWRMZW5ndGggfSBmcm9tICcuL2xpbmUuc3F1YXJlZExlbmd0aC5tanMnO1xuaW1wb3J0IHsgbGVuZ3RoIH0gZnJvbSAnLi9saW5lLmxlbmd0aC5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBhYnMsXG4gICAgY29zLFxuICAgIHNpbixcbiAgICBzcXJ0LFxuICAgIG1pbixcbiAgICBtYXgsXG4gICAgYXRhbjIsXG4gICAgcm91bmQsXG4gICAgcG93LFxuICAgIFBJXG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHh5ID0geC5zcGxpdCh4LmluZGV4T2YoJ0AnKSA9PT0gLTEgPyAnICcgOiAnQCcpO1xuICAgICAgICB4ID0gcGFyc2VGbG9hdCh4eVswXSk7XG4gICAgICAgIHkgPSBwYXJzZUZsb2F0KHh5WzFdKTtcblxuICAgIH0gZWxzZSBpZiAoT2JqZWN0KHgpID09PSB4KSB7XG4gICAgICAgIHkgPSB4Lnk7XG4gICAgICAgIHggPSB4Lng7XG4gICAgfVxuXG4gICAgdGhpcy54ID0geCA9PT0gdW5kZWZpbmVkID8gMCA6IHg7XG4gICAgdGhpcy55ID0geSA9PT0gdW5kZWZpbmVkID8gMCA6IHk7XG59O1xuXG4vLyBBbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciwgZnJvbSBwb2xhciBjb29yZGluYXRlcy5cbi8vIEBwYXJhbSB7bnVtYmVyfSBEaXN0YW5jZS5cbi8vIEBwYXJhbSB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuLy8gQHBhcmFtIHtwb2ludH0gW29wdGlvbmFsXSBPcmlnaW4uXG5Qb2ludC5mcm9tUG9sYXIgPSBmdW5jdGlvbihkaXN0YW5jZSwgYW5nbGUsIG9yaWdpbikge1xuXG4gICAgb3JpZ2luID0gbmV3IFBvaW50KG9yaWdpbik7XG4gICAgdmFyIHggPSBhYnMoZGlzdGFuY2UgKiBjb3MoYW5nbGUpKTtcbiAgICB2YXIgeSA9IGFicyhkaXN0YW5jZSAqIHNpbihhbmdsZSkpO1xuICAgIHZhciBkZWcgPSBub3JtYWxpemVBbmdsZSh0b0RlZyhhbmdsZSkpO1xuXG4gICAgaWYgKGRlZyA8IDkwKSB7XG4gICAgICAgIHkgPSAteTtcblxuICAgIH0gZWxzZSBpZiAoZGVnIDwgMTgwKSB7XG4gICAgICAgIHggPSAteDtcbiAgICAgICAgeSA9IC15O1xuXG4gICAgfSBlbHNlIGlmIChkZWcgPCAyNzApIHtcbiAgICAgICAgeCA9IC14O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9pbnQob3JpZ2luLnggKyB4LCBvcmlnaW4ueSArIHkpO1xufTtcblxuLy8gQ3JlYXRlIGEgcG9pbnQgd2l0aCByYW5kb20gY29vcmRpbmF0ZXMgdGhhdCBmYWxsIGludG8gdGhlIHJhbmdlIGBbeDEsIHgyXWAgYW5kIGBbeTEsIHkyXWAuXG5Qb2ludC5yYW5kb20gPSBmdW5jdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuXG4gICAgcmV0dXJuIG5ldyBQb2ludChyYW5kb20oeDEsIHgyKSwgcmFuZG9tKHkxLCB5MikpO1xufTtcblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuUG9pbnQsXG5cbiAgICBjaG9vc2VDbG9zZXN0OiBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAxKSByZXR1cm4gbmV3IFBvaW50KHBvaW50c1swXSk7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIG1pblNxckRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQb2ludChwb2ludHNbaV0pO1xuICAgICAgICAgICAgdmFyIHNxckRpc3RhbmNlID0gdGhpcy5zcXVhcmVkRGlzdGFuY2UocCk7XG4gICAgICAgICAgICBpZiAoc3FyRGlzdGFuY2UgPCBtaW5TcXJEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBwO1xuICAgICAgICAgICAgICAgIG1pblNxckRpc3RhbmNlID0gc3FyRGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfSxcblxuICAgIC8vIElmIHBvaW50IGxpZXMgb3V0c2lkZSByZWN0YW5nbGUgYHJgLCByZXR1cm4gdGhlIG5lYXJlc3QgcG9pbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHJlY3QgYHJgLFxuICAgIC8vIG90aGVyd2lzZSByZXR1cm4gcG9pbnQgaXRzZWxmLlxuICAgIC8vIChzZWUgU3F1ZWFrIFNtYWxsdGFsaywgUG9pbnQ+PmFkaGVyZVRvOilcbiAgICBhZGhlcmVUb1JlY3Q6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgICBpZiAoci5jb250YWluc1BvaW50KHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IG1pbihtYXgodGhpcy54LCByLngpLCByLnggKyByLndpZHRoKTtcbiAgICAgICAgdGhpcy55ID0gbWluKG1heCh0aGlzLnksIHIueSksIHIueSArIHIuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENvbXB1dGUgdGhlIGFuZ2xlIGJldHdlZW4gdmVjdG9yIGZyb20gbWUgdG8gcDEgYW5kIHRoZSB2ZWN0b3IgZnJvbSBtZSB0byBwMi5cbiAgICAvLyBvcmRlcmluZyBvZiBwb2ludHMgcDEgYW5kIHAyIGlzIGltcG9ydGFudCFcbiAgICAvLyB0aGV0YSBmdW5jdGlvbidzIGFuZ2xlIGNvbnZlbnRpb246XG4gICAgLy8gcmV0dXJucyBhbmdsZXMgYmV0d2VlbiAwIGFuZCAxODAgd2hlbiB0aGUgYW5nbGUgaXMgY291bnRlcmNsb2Nrd2lzZVxuICAgIC8vIHJldHVybnMgYW5nbGVzIGJldHdlZW4gMTgwIGFuZCAzNjAgdG8gY29udmVydCBjbG9ja3dpc2UgYW5nbGVzIGludG8gY291bnRlcmNsb2Nrd2lzZSBvbmVzXG4gICAgLy8gcmV0dXJucyBOYU4gaWYgYW55IG9mIHRoZSBwb2ludHMgcDEsIHAyIGlzIGNvaW5jaWRlbnQgd2l0aCB0aGlzIHBvaW50XG4gICAgYW5nbGVCZXR3ZWVuOiBmdW5jdGlvbihwMSwgcDIpIHtcblxuICAgICAgICB2YXIgYW5nbGVCZXR3ZWVuID0gKHRoaXMuZXF1YWxzKHAxKSB8fCB0aGlzLmVxdWFscyhwMikpID8gTmFOIDogKHRoaXMudGhldGEocDIpIC0gdGhpcy50aGV0YShwMSkpO1xuXG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPCAwKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMzYwOyAvLyBjb3JyZWN0aW9uIHRvIGtlZXAgYW5nbGVCZXR3ZWVuIGJldHdlZW4gMCBhbmQgMzYwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5nbGVCZXR3ZWVuO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGJlYXJpbmcgYmV0d2VlbiBtZSBhbmQgdGhlIGdpdmVuIHBvaW50LlxuICAgIGJlYXJpbmc6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBiZWFyaW5nKHRoaXMsIHBvaW50KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBjaGFuZ2UgaW4gYW5nbGUgZnJvbSBteSBwcmV2aW91cyBwb3NpdGlvbiAoLWR4LCAtZHkpIHRvIG15IG5ldyBwb3NpdGlvblxuICAgIC8vIHJlbGF0aXZlIHRvIHJlZiBwb2ludC5cbiAgICBjaGFuZ2VJbkFuZ2xlOiBmdW5jdGlvbihkeCwgZHksIHJlZikge1xuXG4gICAgICAgIC8vIFJldmVydCB0aGUgdHJhbnNsYXRpb24gYW5kIG1lYXN1cmUgdGhlIGNoYW5nZSBpbiBhbmdsZSBhcm91bmQgeC1heGlzLlxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm9mZnNldCgtZHgsIC1keSkudGhldGEocmVmKSAtIHRoaXMudGhldGEocmVmKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyBwb2ludCByZWxhdGl2ZSB0byB0d28gb3RoZXIgcG9pbnRzXG4gICAgLy8gdGhpcyBwb2ludCBpcyB0aGUgY29tbW9uIHBvaW50XG4gICAgLy8gcG9pbnQgcDEgbGllcyBvbiB0aGUgZmlyc3QgdmVjdG9yLCBwb2ludCBwMiBsaWVzIG9uIHRoZSBzZWNvbmQgdmVjdG9yXG4gICAgLy8gd2F0Y2ggb3V0IGZvciB0aGUgb3JkZXJpbmcgb2YgcG9pbnRzIHAxIGFuZCBwMiFcbiAgICAvLyBwb3NpdGl2ZSByZXN1bHQgaW5kaWNhdGVzIGEgY2xvY2t3aXNlIChcInJpZ2h0XCIpIHR1cm4gZnJvbSBmaXJzdCB0byBzZWNvbmQgdmVjdG9yXG4gICAgLy8gbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyBhIGNvdW50ZXJjbG9ja3dpc2UgKFwibGVmdFwiKSB0dXJuIGZyb20gZmlyc3QgdG8gc2Vjb25kIHZlY3RvclxuICAgIC8vIHplcm8gaW5kaWNhdGVzIHRoYXQgdGhlIGZpcnN0IGFuZCBzZWNvbmQgdmVjdG9yIGFyZSBjb2xsaW5lYXJcbiAgICAvLyBub3RlIHRoYXQgdGhlIGFib3ZlIGRpcmVjdGlvbnMgYXJlIHJldmVyc2VkIGZyb20gdGhlIHVzdWFsIGFuc3dlciBvbiB0aGUgSW50ZXJuZXRcbiAgICAvLyB0aGF0IGlzIGJlY2F1c2Ugd2UgYXJlIGluIGEgbGVmdC1oYW5kZWQgY29vcmQgc3lzdGVtIChiZWNhdXNlIHRoZSB5LWF4aXMgcG9pbnRzIGRvd253YXJkKVxuICAgIGNyb3NzOiBmdW5jdGlvbihwMSwgcDIpIHtcblxuICAgICAgICByZXR1cm4gKHAxICYmIHAyKSA/ICgoKHAyLnggLSB0aGlzLngpICogKHAxLnkgLSB0aGlzLnkpKSAtICgocDIueSAtIHRoaXMueSkgKiAocDEueCAtIHRoaXMueCkpKSA6IE5hTjtcbiAgICB9LFxuXG4gICAgZGlmZmVyZW5jZTogZnVuY3Rpb24oZHgsIGR5KSB7XG5cbiAgICAgICAgaWYgKChPYmplY3QoZHgpID09PSBkeCkpIHtcbiAgICAgICAgICAgIGR5ID0gZHgueTtcbiAgICAgICAgICAgIGR4ID0gZHgueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gKGR4IHx8IDApLCB0aGlzLnkgLSAoZHkgfHwgMCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gbWUgYW5kIHBvaW50IGBwYC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHRoaXMsIHApO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHBvaW50IHdpdGggZ2l2ZW4gb3RoZXIgcG9pbnRcbiAgICBkb3Q6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gcCA/ICh0aGlzLnggKiBwLnggKyB0aGlzLnkgKiBwLnkpIDogTmFOO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gISFwICYmXG4gICAgICAgICAgICB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgbGVycDogZnVuY3Rpb24ocCwgdCkge1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgoMSAtIHQpICogeCArIHQgKiBwLngsICgxIC0gdCkgKiB5ICsgdCAqIHAueSk7XG4gICAgfSxcblxuICAgIG1hZ25pdHVkZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHNxcnQoKHRoaXMueCAqIHRoaXMueCkgKyAodGhpcy55ICogdGhpcy55KSkgfHwgMC4wMTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIG1hbmhhdHRhbiAodGF4aS1jYWIpIGRpc3RhbmNlIGJldHdlZW4gbWUgYW5kIHBvaW50IGBwYC5cbiAgICBtYW5oYXR0YW5EaXN0YW5jZTogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiBhYnMocC54IC0gdGhpcy54KSArIGFicyhwLnkgLSB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlIHBvaW50IG9uIGxpbmUgc3RhcnRpbmcgZnJvbSByZWYgZW5kaW5nIGF0IG1lIGJ5XG4gICAgLy8gZGlzdGFuY2UgZGlzdGFuY2UuXG4gICAgbW92ZTogZnVuY3Rpb24ocmVmLCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB0aGV0YSA9IHRvUmFkKChuZXcgUG9pbnQocmVmKSkudGhldGEodGhpcykpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY29zKHRoZXRhKSAqIGRpc3RhbmNlLCAtc2luKHRoZXRhKSAqIGRpc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLy8gU2NhbGVzIHggYW5kIHkgc3VjaCB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCBhbmQgdGhlIG9yaWdpbiAoMCwwKSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gKGxlbmd0aCB8fCAxKSAvIHRoaXMubWFnbml0dWRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgfSxcblxuICAgIC8vIE9mZnNldCBtZSBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC5cbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGR4LCBkeSkge1xuXG4gICAgICAgIGlmICgoT2JqZWN0KGR4KSA9PT0gZHgpKSB7XG4gICAgICAgICAgICBkeSA9IGR4Lnk7XG4gICAgICAgICAgICBkeCA9IGR4Lng7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggKz0gZHggfHwgMDtcbiAgICAgICAgdGhpcy55ICs9IGR5IHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgcmVmbGVjdGlvbiBvZiBtZSB3aXRoXG4gICAgLy8gdGhlIGNlbnRlciBvZiBpbnZlcnNpb24gaW4gcmVmIHBvaW50LlxuICAgIHJlZmxlY3Rpb246IGZ1bmN0aW9uKHJlZikge1xuXG4gICAgICAgIHJldHVybiAobmV3IFBvaW50KHJlZikpLm1vdmUodGhpcywgdGhpcy5kaXN0YW5jZShyZWYpKTtcbiAgICB9LFxuXG4gICAgLy8gUm90YXRlIHBvaW50IGJ5IGFuZ2xlIGFyb3VuZCBvcmlnaW4uXG4gICAgLy8gQW5nbGUgaXMgZmxpcHBlZCBiZWNhdXNlIHRoaXMgaXMgYSBsZWZ0LWhhbmRlZCBjb29yZCBzeXN0ZW0gKHktYXhpcyBwb2ludHMgZG93bndhcmQpLlxuICAgIHJvdGF0ZTogZnVuY3Rpb24ob3JpZ2luLCBhbmdsZSkge1xuXG4gICAgICAgIGlmIChhbmdsZSA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgb3JpZ2luID0gb3JpZ2luIHx8IG5ldyBQb2ludCgwLCAwKTtcblxuICAgICAgICBhbmdsZSA9IHRvUmFkKG5vcm1hbGl6ZUFuZ2xlKC1hbmdsZSkpO1xuICAgICAgICB2YXIgY29zQW5nbGUgPSBjb3MoYW5nbGUpO1xuICAgICAgICB2YXIgc2luQW5nbGUgPSBzaW4oYW5nbGUpO1xuXG4gICAgICAgIHZhciB4ID0gKGNvc0FuZ2xlICogKHRoaXMueCAtIG9yaWdpbi54KSkgLSAoc2luQW5nbGUgKiAodGhpcy55IC0gb3JpZ2luLnkpKSArIG9yaWdpbi54O1xuICAgICAgICB2YXIgeSA9IChzaW5BbmdsZSAqICh0aGlzLnggLSBvcmlnaW4ueCkpICsgKGNvc0FuZ2xlICogKHRoaXMueSAtIG9yaWdpbi55KSkgKyBvcmlnaW4ueTtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIGxldCBmID0gMTsgLy8gY2FzZSAwXG4gICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiBmID0gMTA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogZiA9IDEwMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiBmID0gMTAwMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZiA9IHBvdygxMCwgcHJlY2lzaW9uKTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggPSByb3VuZCh0aGlzLnggKiBmKSAvIGY7XG4gICAgICAgIHRoaXMueSA9IHJvdW5kKHRoaXMueSAqIGYpIC8gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNjYWxlIHBvaW50IHdpdGggb3JpZ2luLlxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIG9yaWdpbiA9IChvcmlnaW4gJiYgbmV3IFBvaW50KG9yaWdpbikpIHx8IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy54ID0gb3JpZ2luLnggKyBzeCAqICh0aGlzLnggLSBvcmlnaW4ueCk7XG4gICAgICAgIHRoaXMueSA9IG9yaWdpbi55ICsgc3kgKiAodGhpcy55IC0gb3JpZ2luLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc25hcFRvR3JpZDogZnVuY3Rpb24oZ3gsIGd5KSB7XG5cbiAgICAgICAgdGhpcy54ID0gc25hcFRvR3JpZCh0aGlzLngsIGd4KTtcbiAgICAgICAgdGhpcy55ID0gc25hcFRvR3JpZCh0aGlzLnksIGd5IHx8IGd4KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNxdWFyZWREaXN0YW5jZTogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gc3F1YXJlZExlbmd0aCh0aGlzLCBwKTtcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYW5nbGUgYmV0d2VlbiBtZSBhbmQgYHBgIGFuZCB0aGUgeCBheGlzLlxuICAgIC8vIChjYXJ0ZXNpYW4tdG8tcG9sYXIgY29vcmRpbmF0ZXMgY29udmVyc2lvbilcbiAgICAvLyBSZXR1cm4gdGhldGEgYW5nbGUgaW4gZGVncmVlcy5cbiAgICB0aGV0YTogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHAgPSBuZXcgUG9pbnQocCk7XG5cbiAgICAgICAgLy8gSW52ZXJ0IHRoZSB5LWF4aXMuXG4gICAgICAgIHZhciB5ID0gLShwLnkgLSB0aGlzLnkpO1xuICAgICAgICB2YXIgeCA9IHAueCAtIHRoaXMueDtcbiAgICAgICAgdmFyIHJhZCA9IGF0YW4yKHksIHgpOyAvLyBkZWZpbmVkIGZvciBhbGwgMCBjb3JuZXIgY2FzZXNcblxuICAgICAgICAvLyBDb3JyZWN0aW9uIGZvciBJSUkuIGFuZCBJVi4gcXVhZHJhbnQuXG4gICAgICAgIGlmIChyYWQgPCAwKSB7XG4gICAgICAgICAgICByYWQgPSAyICogUEkgKyByYWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTgwICogcmFkIC8gUEk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydHMgcmVjdGFuZ3VsYXIgdG8gcG9sYXIgY29vcmRpbmF0ZXMuXG4gICAgLy8gQW4gb3JpZ2luIGNhbiBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSBpdCdzIDBAMC5cbiAgICB0b1BvbGFyOiBmdW5jdGlvbihvKSB7XG5cbiAgICAgICAgbyA9IChvICYmIG5ldyBQb2ludChvKSkgfHwgbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHNxcnQoKHggLSBvLngpICogKHggLSBvLngpICsgKHkgLSBvLnkpICogKHkgLSBvLnkpKTsgLy8gclxuICAgICAgICB0aGlzLnkgPSB0b1JhZChvLnRoZXRhKG5ldyBQb2ludCh4LCB5KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKyAnQCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCArICcsJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgaWYgKChPYmplY3QoeCkgPT09IHgpKSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICAgICAgdGhpcy55ID0geSB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGZyb20gMCwwIHRvIG1lIGFuZCB0aGUgdmVjdG9yIGZyb20gMCwwIHRvIHAuXG4gICAgLy8gUmV0dXJucyBOYU4gaWYgcCBpcyBhdCAwLDAuXG4gICAgdmVjdG9yQW5nbGU6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgemVybyA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHplcm8uYW5nbGVCZXR3ZWVuKHRoaXMsIHApO1xuICAgIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS50cmFuc2xhdGUgPSBQb2ludC5wcm90b3R5cGUub2Zmc2V0O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG5leHBvcnQgY29uc3QgcG9pbnQgPSBQb2ludDtcbiJdLCJuYW1lcyI6WyJub3JtYWxpemVBbmdsZSIsInJhbmRvbSIsInNuYXBUb0dyaWQiLCJ0b0RlZyIsInRvUmFkIiwiYmVhcmluZyIsInNxdWFyZWRMZW5ndGgiLCJsZW5ndGgiLCJ0eXBlcyIsImFicyIsImNvcyIsInNpbiIsInNxcnQiLCJtaW4iLCJtYXgiLCJhdGFuMiIsInJvdW5kIiwicG93IiwiUEkiLCJNYXRoIiwiUG9pbnQiLCJ4IiwieSIsInh5Iiwic3BsaXQiLCJpbmRleE9mIiwicGFyc2VGbG9hdCIsIk9iamVjdCIsInVuZGVmaW5lZCIsImZyb21Qb2xhciIsImRpc3RhbmNlIiwiYW5nbGUiLCJvcmlnaW4iLCJkZWciLCJ4MSIsIngyIiwieTEiLCJ5MiIsInByb3RvdHlwZSIsInR5cGUiLCJjaG9vc2VDbG9zZXN0IiwicG9pbnRzIiwibiIsImNsb3Nlc3QiLCJtaW5TcXJEaXN0YW5jZSIsIkluZmluaXR5IiwiaSIsInAiLCJzcXJEaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsImFkaGVyZVRvUmVjdCIsInIiLCJjb250YWluc1BvaW50Iiwid2lkdGgiLCJoZWlnaHQiLCJhbmdsZUJldHdlZW4iLCJwMSIsInAyIiwiZXF1YWxzIiwiTmFOIiwidGhldGEiLCJwb2ludCIsImNoYW5nZUluQW5nbGUiLCJkeCIsImR5IiwicmVmIiwiY2xvbmUiLCJvZmZzZXQiLCJjcm9zcyIsImRpZmZlcmVuY2UiLCJkb3QiLCJsZXJwIiwidCIsIm1hZ25pdHVkZSIsIm1hbmhhdHRhbkRpc3RhbmNlIiwibW92ZSIsIm5vcm1hbGl6ZSIsInNjYWxlIiwicmVmbGVjdGlvbiIsInJvdGF0ZSIsImNvc0FuZ2xlIiwic2luQW5nbGUiLCJwcmVjaXNpb24iLCJmIiwic3giLCJzeSIsImd4IiwiZ3kiLCJyYWQiLCJ0b0pTT04iLCJ0b1BvbGFyIiwibyIsInRvU3RyaW5nIiwic2VyaWFsaXplIiwidXBkYXRlIiwidmVjdG9yQW5nbGUiLCJ6ZXJvIiwidHJhbnNsYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/point.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/points.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/g/points.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clonePoints: () => (/* binding */ clonePoints),\n/* harmony export */   convexHull: () => (/* binding */ convexHull),\n/* harmony export */   parsePoints: () => (/* binding */ parsePoints)\n/* harmony export */ });\nfunction parsePoints(svgString) {\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === \"\") return [];\n    const points = [];\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n    const numCoords = coords.length;\n    for(let i = 0; i < numCoords; i += 2){\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({\n            x: +coords[i],\n            y: +coords[i + 1]\n        });\n    }\n    return points;\n}\nfunction clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for(let i = 0; i < numPoints; i++){\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nfunction convexHull(points) {\n    const { abs } = Math;\n    var i;\n    var n;\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for(i = 0; i < numPoints; i++){\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n        } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for(i = 0; i < numPoints; i++){\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n        // the start point will end up at end of sorted list\n        // the start point will end up at beginning of hull points list\n        }\n        var entry = [\n            points[i],\n            i,\n            angle\n        ];\n        sortedPointRecords.push(entry);\n    }\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n        var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n        // coincident points will be sorted in reverse-numerical order\n        // so the coincident points with lower original index will be considered first\n        }\n        return sortOutput;\n    });\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while(sortedPointRecords.length !== 0){\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + \"@@\" + currentPointRecord[1])) {\n            continue;\n        }\n        var correctTurnFound = false;\n        while(!correctTurnFound){\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) {\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                    } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                    // we are switching the order of the 0deg and 180deg points\n                    // correct turn not found\n                    }\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                // do not do anything with current point\n                // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for(i = 0; i < n; i++){\n        var currentHullIndex = hullPointRecords[i][1];\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for(i = 0; i < n; i++){\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n    return hullPoints;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2ludHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLFNBQVNBLFlBQVlDLFNBQVM7SUFFakMscUNBQXFDO0lBQ3JDLE1BQU1DLGdCQUFnQkQsVUFBVUUsSUFBSTtJQUNwQyxJQUFJRCxrQkFBa0IsSUFBSSxPQUFPLEVBQUU7SUFFbkMsTUFBTUUsU0FBUyxFQUFFO0lBRWpCLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsNEVBQTRFO0lBQzVFLGdFQUFnRTtJQUNoRSxNQUFNQyxTQUFTSCxjQUFjSSxLQUFLLENBQUM7SUFFbkMsTUFBTUMsWUFBWUYsT0FBT0csTUFBTTtJQUMvQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsV0FBV0UsS0FBSyxFQUFHO1FBQ25DLHVDQUF1QztRQUN2Qyx1RUFBdUU7UUFDdkUseUVBQXlFO1FBQ3pFLCtGQUErRjtRQUMvRkwsT0FBT00sSUFBSSxDQUFDO1lBQUVDLEdBQUcsQ0FBQ04sTUFBTSxDQUFDSSxFQUFFO1lBQUVHLEdBQUcsQ0FBQ1AsTUFBTSxDQUFDSSxJQUFJLEVBQUU7UUFBQztJQUNuRDtJQUNBLE9BQU9MO0FBQ1g7QUFFTyxTQUFTUyxZQUFZVCxNQUFNO0lBQzlCLE1BQU1VLFlBQVlWLE9BQU9JLE1BQU07SUFDL0IsSUFBSU0sY0FBYyxHQUFHLE9BQU8sRUFBRTtJQUM5QixNQUFNQyxZQUFZLEVBQUU7SUFDcEIsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlLLFdBQVdMLElBQUs7UUFDaEMsTUFBTU8sUUFBUVosTUFBTSxDQUFDSyxFQUFFLENBQUNRLEtBQUs7UUFDN0JGLFVBQVVMLElBQUksQ0FBQ007SUFDbkI7SUFDQSxPQUFPRDtBQUNYO0FBRUEscURBQXFEO0FBQ3JELDBFQUEwRTtBQUMxRSxzSEFBc0g7QUFDdEgsMkZBQTJGO0FBQ3BGLFNBQVNHLFdBQVdkLE1BQU07SUFFN0IsTUFBTSxFQUFFZSxHQUFHLEVBQUUsR0FBR0M7SUFFaEIsSUFBSVg7SUFDSixJQUFJWTtJQUVKLElBQUlQLFlBQVlWLE9BQU9JLE1BQU07SUFDN0IsSUFBSU0sY0FBYyxHQUFHLE9BQU8sRUFBRSxFQUFFLDJCQUEyQjtJQUUzRCxxRkFBcUY7SUFDckYsSUFBSVE7SUFDSixJQUFLYixJQUFJLEdBQUdBLElBQUlLLFdBQVdMLElBQUs7UUFDNUIsSUFBSWEsZUFBZUMsV0FBVztZQUMxQiwyREFBMkQ7WUFDM0RELGFBQWFsQixNQUFNLENBQUNLLEVBQUU7UUFFMUIsT0FBTyxJQUFJTCxNQUFNLENBQUNLLEVBQUUsQ0FBQ0csQ0FBQyxHQUFHVSxXQUFXVixDQUFDLEVBQUU7WUFDbkMsbURBQW1EO1lBQ25EVSxhQUFhbEIsTUFBTSxDQUFDSyxFQUFFO1FBRTFCLE9BQU8sSUFBSSxNQUFPLENBQUNBLEVBQUUsQ0FBQ0csQ0FBQyxLQUFLVSxXQUFXVixDQUFDLElBQU1SLE1BQU0sQ0FBQ0ssRUFBRSxDQUFDRSxDQUFDLEdBQUdXLFdBQVdYLENBQUMsRUFBRztZQUN2RSxxRUFBcUU7WUFDckUsOEVBQThFO1lBQzlFLGdGQUFnRjtZQUNoRlcsYUFBYWxCLE1BQU0sQ0FBQ0ssRUFBRTtRQUMxQjtJQUNKO0lBRUEsa0NBQWtDO0lBQ2xDLGdGQUFnRjtJQUVoRixvRUFBb0U7SUFDcEUsSUFBSWUscUJBQXFCLEVBQUU7SUFDM0IsSUFBS2YsSUFBSSxHQUFHQSxJQUFJSyxXQUFXTCxJQUFLO1FBRTVCLElBQUlnQixRQUFRSCxXQUFXSSxLQUFLLENBQUN0QixNQUFNLENBQUNLLEVBQUU7UUFDdEMsSUFBSWdCLFVBQVUsR0FBRztZQUNiQSxRQUFRLEtBQUssb0NBQW9DO1FBQ2pELG9EQUFvRDtRQUNwRCwrREFBK0Q7UUFDbkU7UUFFQSxJQUFJRSxRQUFRO1lBQUN2QixNQUFNLENBQUNLLEVBQUU7WUFBRUE7WUFBR2dCO1NBQU07UUFDakNELG1CQUFtQmQsSUFBSSxDQUFDaUI7SUFDNUI7SUFFQSxrQ0FBa0M7SUFDbENILG1CQUFtQkksSUFBSSxDQUFDLFNBQVNDLE9BQU8sRUFBRUMsT0FBTztRQUM3QyxnRUFBZ0U7UUFDaEUsK0VBQStFO1FBRS9FLElBQUlDLGFBQWFGLE9BQU8sQ0FBQyxFQUFFLEdBQUdDLE9BQU8sQ0FBQyxFQUFFLEVBQUcsa0NBQWtDO1FBQzdFLElBQUlDLGVBQWUsR0FBRztZQUNsQixxREFBcUQ7WUFDckRBLGFBQWFELE9BQU8sQ0FBQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxFQUFFLEVBQUUsaUNBQWlDO1FBQ3ZFLDhEQUE4RDtRQUM5RCw4RUFBOEU7UUFDbEY7UUFFQSxPQUFPRTtJQUNYO0lBRUEsdUZBQXVGO0lBQ3ZGLElBQUlQLG1CQUFtQmhCLE1BQU0sR0FBRyxHQUFHO1FBQy9CLElBQUl3QixtQkFBbUJSLGtCQUFrQixDQUFDQSxtQkFBbUJoQixNQUFNLEdBQUcsRUFBRTtRQUN4RWdCLG1CQUFtQlMsT0FBTyxDQUFDRDtJQUMvQjtJQUVBLDZFQUE2RTtJQUM3RSxnREFBZ0Q7SUFDaEQsSUFBSUUsZUFBZSxDQUFDLEdBQUcsK0RBQStEO0lBQ3RGLElBQUlDLG1CQUFtQixFQUFFLEVBQUUsNERBQTREO0lBRXZGLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU9qQixtQkFBbUJoQixNQUFNLEtBQUssRUFBRztRQUVwQzRCLHFCQUFxQlosbUJBQW1Ca0IsR0FBRztRQUMzQ0wsZUFBZUQsa0JBQWtCLENBQUMsRUFBRTtRQUVwQyw0Q0FBNEM7UUFDNUMsZ0ZBQWdGO1FBQ2hGLElBQUlGLGFBQWFTLGNBQWMsQ0FBQ1Asa0JBQWtCLENBQUMsRUFBRSxHQUFHLE9BQU9BLGtCQUFrQixDQUFDLEVBQUUsR0FBRztZQUduRjtRQUNKO1FBRUEsSUFBSVEsbUJBQW1CO1FBQ3ZCLE1BQU8sQ0FBQ0EsaUJBQWtCO1lBRXRCLElBQUlULGlCQUFpQjNCLE1BQU0sR0FBRyxHQUFHO2dCQUM3QiwyREFBMkQ7Z0JBQzNEMkIsaUJBQWlCekIsSUFBSSxDQUFDMEI7Z0JBQ3RCUSxtQkFBbUI7WUFFdkIsT0FBTztnQkFDSE4sc0JBQXNCSCxpQkFBaUJPLEdBQUc7Z0JBQzFDSCxnQkFBZ0JELG1CQUFtQixDQUFDLEVBQUU7Z0JBQ3RDRSw0QkFBNEJMLGlCQUFpQk8sR0FBRztnQkFDaERELHNCQUFzQkQseUJBQXlCLENBQUMsRUFBRTtnQkFFbEQsSUFBSUssZUFBZUosb0JBQW9CSyxLQUFLLENBQUNQLGVBQWVGO2dCQUU1RCxJQUFJUSxlQUFlLEdBQUc7b0JBQ2xCLHFCQUFxQjtvQkFDckJWLGlCQUFpQnpCLElBQUksQ0FBQzhCO29CQUN0QkwsaUJBQWlCekIsSUFBSSxDQUFDNEI7b0JBQ3RCSCxpQkFBaUJ6QixJQUFJLENBQUMwQjtvQkFDdEJRLG1CQUFtQjtnQkFFdkIsT0FBTyxJQUFJQyxpQkFBaUIsR0FBRztvQkFDM0IsaUNBQWlDO29CQUNqQyxpQkFBaUI7b0JBQ2pCLHdEQUF3RDtvQkFDeEQsNENBQTRDO29CQUM1QyxJQUFJRSxZQUFZLE9BQU8sK0NBQStDO29CQUN0RSxJQUFJQyxlQUFlVCxjQUFjUyxZQUFZLENBQUNQLHFCQUFxQko7b0JBQ25FLElBQUlsQixJQUFJNkIsZUFBZSxPQUFPRCxXQUFXO3dCQUNyQyw2REFBNkQ7d0JBQzdELGdEQUFnRDt3QkFDaEQsc0NBQXNDO3dCQUN0Q2IsWUFBWSxDQUFDSSxtQkFBbUIsQ0FBQyxFQUFFLEdBQUcsT0FBT0EsbUJBQW1CLENBQUMsRUFBRSxDQUFDLEdBQUdDO3dCQUN2RSxnRUFBZ0U7d0JBQ2hFSixpQkFBaUJ6QixJQUFJLENBQUM4QjtvQkFDdEIsd0NBQXdDO29CQUN4Qyx5QkFBeUI7b0JBRTdCLE9BQU8sSUFBSUQsY0FBY1UsTUFBTSxDQUFDWixpQkFBaUJJLG9CQUFvQlEsTUFBTSxDQUFDVixnQkFBZ0I7d0JBQ3hGLDREQUE0RDt3QkFDNUQsZ0RBQWdEO3dCQUNoRCxzQ0FBc0M7d0JBQ3RDTCxZQUFZLENBQUNJLG1CQUFtQixDQUFDLEVBQUUsR0FBRyxPQUFPQSxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsR0FBR0M7d0JBQ3ZFLGdFQUFnRTt3QkFDaEVKLGlCQUFpQnpCLElBQUksQ0FBQzhCO29CQUN0Qix3Q0FBd0M7b0JBQ3hDLHlCQUF5QjtvQkFFN0IsT0FBTyxJQUFJckIsSUFBSSxDQUFFNkIsZUFBZSxLQUFLLE1BQU8sS0FBS0QsV0FBVzt3QkFDeEQsMkRBQTJEO3dCQUMzRCx5REFBeUQ7d0JBQ3pELGdFQUFnRTt3QkFDaEVaLGlCQUFpQnpCLElBQUksQ0FBQzhCO3dCQUN0Qiw4REFBOEQ7d0JBQzlEaEIsbUJBQW1CZCxJQUFJLENBQUM0QjtvQkFDeEIsMkRBQTJEO29CQUMzRCx5QkFBeUI7b0JBQzdCO2dCQUVKLE9BQU87b0JBQ0gsb0JBQW9CO29CQUNwQixnREFBZ0Q7b0JBQ2hELHNDQUFzQztvQkFDdENKLFlBQVksQ0FBQ0ksbUJBQW1CLENBQUMsRUFBRSxHQUFHLE9BQU9BLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxHQUFHQztvQkFDdkUsd0VBQXdFO29CQUN4RUosaUJBQWlCekIsSUFBSSxDQUFDOEI7Z0JBQ3RCLHdDQUF3QztnQkFDeEMseUJBQXlCO2dCQUM3QjtZQUNKO1FBQ0o7SUFDSjtJQUNBLGdGQUFnRjtJQUNoRixpRkFBaUY7SUFFakYsd0VBQXdFO0lBQ3hFLElBQUlMLGlCQUFpQjNCLE1BQU0sR0FBRyxHQUFHO1FBQzdCMkIsaUJBQWlCTyxHQUFHO0lBQ3hCO0lBRUEsbUZBQW1GO0lBQ25GLElBQUlRLGlCQUFpQix1Q0FBdUM7SUFDNUQsSUFBSUMsK0JBQStCLENBQUMsR0FBRywrQ0FBK0M7SUFDdEY5QixJQUFJYyxpQkFBaUIzQixNQUFNO0lBQzNCLElBQUtDLElBQUksR0FBR0EsSUFBSVksR0FBR1osSUFBSztRQUVwQixJQUFJMkMsbUJBQW1CakIsZ0JBQWdCLENBQUMxQixFQUFFLENBQUMsRUFBRTtRQUU3QyxJQUFJeUMsb0JBQW9CM0IsYUFBYTZCLG1CQUFtQkYsaUJBQWlCO1lBQ3JFQSxrQkFBa0JFO1lBQ2xCRCwrQkFBK0IxQztRQUNuQztJQUNKO0lBRUEsSUFBSTRDLDRCQUE0QixFQUFFO0lBQ2xDLElBQUlGLCtCQUErQixHQUFHO1FBQ2xDLElBQUlHLGdCQUFnQm5CLGlCQUFpQm9CLEtBQUssQ0FBQ0o7UUFDM0MsSUFBSUssaUJBQWlCckIsaUJBQWlCb0IsS0FBSyxDQUFDLEdBQUdKO1FBQy9DRSw0QkFBNEJDLGNBQWNHLE1BQU0sQ0FBQ0Q7SUFFckQsT0FBTztRQUNISCw0QkFBNEJsQjtJQUNoQztJQUVBLElBQUl1QixhQUFhLEVBQUU7SUFDbkJyQyxJQUFJZ0MsMEJBQTBCN0MsTUFBTTtJQUNwQyxJQUFLQyxJQUFJLEdBQUdBLElBQUlZLEdBQUdaLElBQUs7UUFDcEJpRCxXQUFXaEQsSUFBSSxDQUFDMkMseUJBQXlCLENBQUM1QyxFQUFFLENBQUMsRUFBRTtJQUNuRDtJQUVBLE9BQU9pRDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2ludHMubWpzPzM3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUG9pbnRzKHN2Z1N0cmluZykge1xuXG4gICAgLy8gU3RlcCAxOiBEaXNjYXJkIHN1cnJvdW5kaW5nIHNwYWNlc1xuICAgIGNvbnN0IHRyaW1tZWRTdHJpbmcgPSBzdmdTdHJpbmcudHJpbSgpO1xuICAgIGlmICh0cmltbWVkU3RyaW5nID09PSAnJykgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgcG9pbnRzID0gW107XG5cbiAgICAvLyBTdGVwIDI6IFNwbGl0IGF0IGNvbW1hcyAoKyB0aGVpciBzdXJyb3VuZGluZyBzcGFjZXMpIG9yIGF0IG11bHRpcGxlIHNwYWNlc1xuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IEhhdmUgYW4gYW5jaG9yIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBhbHRlcm5hdGlvblxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBzaW1wbGlmeSBkb3VibGUgKG9yIG1vcmUpIGNvbW1hcyAtIGNhdXNlcyBlbXB0eSBjb29yZHNcbiAgICAvLyBUaGlzIHJlZ2V4IGlzIHVzZWQgYnkgYHNwbGl0KClgLCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gdXNlIC9nXG4gICAgY29uc3QgY29vcmRzID0gdHJpbW1lZFN0cmluZy5zcGxpdCgvXFxiXFxzKixcXHMqfCxcXHMqfFxccysvKTtcblxuICAgIGNvbnN0IG51bUNvb3JkcyA9IGNvb3Jkcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db29yZHM7IGkgKz0gMikge1xuICAgICAgICAvLyBTdGVwIDM6IENvbnZlcnQgZWFjaCBjb29yZCB0byBudW1iZXJcbiAgICAgICAgLy8gTm90ZTogSWYgdGhlIGNvb3JkIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIsIGl0IHdpbGwgYmUgYE5hTmBcbiAgICAgICAgLy8gTm90ZTogSWYgdGhlIGNvb3JkIGlzIGVtcHR5IChcIlwiLCBlLmcuIGZyb20gXCIsLFwiIGlucHV0KSwgaXQgd2lsbCBiZSBgMGBcbiAgICAgICAgLy8gTm90ZTogSWYgd2UgZW5kIHVwIHdpdGggYW4gb2RkIG51bWJlciBvZiBjb29yZHMsIHRoZSBsYXN0IHBvaW50J3Mgc2Vjb25kIGNvb3JkIHdpbGwgYmUgYE5hTmBcbiAgICAgICAgcG9pbnRzLnB1c2goeyB4OiArY29vcmRzW2ldLCB5OiArY29vcmRzW2kgKyAxXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV0uY2xvbmUoKTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG4vLyBSZXR1cm5zIGEgY29udmV4LWh1bGwgcG9seWxpbmUgZnJvbSB0aGlzIHBvbHlsaW5lLlxuLy8gSW1wbGVtZW50cyB0aGUgR3JhaGFtIHNjYW4gKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYWhhbV9zY2FuKS5cbi8vIE91dHB1dCBwb2x5bGluZSBzdGFydHMgYXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIG9yaWdpbmFsIHBvbHlsaW5lIHRoYXQgaXMgb24gdGhlIGh1bGwsIHRoZW4gY29udGludWVzIGNsb2Nrd2lzZS5cbi8vIE1pbmltYWwgcG9seWxpbmUgaXMgZm91bmQgKG9ubHkgdmVydGljZXMgb2YgdGhlIGh1bGwgYXJlIHJlcG9ydGVkLCBubyBjb2xsaW5lYXIgcG9pbnRzKS5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhIdWxsKHBvaW50cykge1xuXG4gICAgY29uc3QgeyBhYnMgfSA9IE1hdGg7XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbjtcblxuICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBbXTsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAvLyBzdGVwIDE6IGZpbmQgdGhlIHN0YXJ0aW5nIHBvaW50IC0gcG9pbnQgd2l0aCB0aGUgbG93ZXN0IHkgKGlmIGVxdWFsaXR5LCBoaWdoZXN0IHgpXG4gICAgdmFyIHN0YXJ0UG9pbnQ7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIGlmIChzdGFydFBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IHdlIHNlZSwgc2V0IGl0IGFzIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICBzdGFydFBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzW2ldLnkgPCBzdGFydFBvaW50LnkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBvaW50IHNob3VsZCBoYXZlIGxvd2VzdCB5IGZyb20gYWxsIHBvaW50c1xuICAgICAgICAgICAgc3RhcnRQb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICB9IGVsc2UgaWYgKChwb2ludHNbaV0ueSA9PT0gc3RhcnRQb2ludC55KSAmJiAocG9pbnRzW2ldLnggPiBzdGFydFBvaW50LngpKSB7XG4gICAgICAgICAgICAvLyBpZiB0d28gcG9pbnRzIGhhdmUgdGhlIGxvd2VzdCB5LCBjaG9vc2UgdGhlIG9uZSB0aGF0IGhhcyBoaWdoZXN0IHhcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBwb2ludHMgdG8gdGhlIHJpZ2h0IG9mIHN0YXJ0UG9pbnQgLSBubyBhbWJpZ3VpdHkgYWJvdXQgdGhldGEgMFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHNldmVyYWwgY29pbmNpZGVudCBzdGFydCBwb2ludCBjYW5kaWRhdGVzLCBmaXJzdCBvbmUgaXMgcmVwb3J0ZWRcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdGVwIDI6IHNvcnQgdGhlIGxpc3Qgb2YgcG9pbnRzXG4gICAgLy8gc29ydGluZyBieSBhbmdsZSBiZXR3ZWVuIGxpbmUgZnJvbSBzdGFydFBvaW50IHRvIHBvaW50IGFuZCB0aGUgeC1heGlzICh0aGV0YSlcblxuICAgIC8vIHN0ZXAgMmE6IGNyZWF0ZSB0aGUgcG9pbnQgcmVjb3JkcyA9IFtwb2ludCwgb3JpZ2luYWxJbmRleCwgYW5nbGVdXG4gICAgdmFyIHNvcnRlZFBvaW50UmVjb3JkcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgIHZhciBhbmdsZSA9IHN0YXJ0UG9pbnQudGhldGEocG9pbnRzW2ldKTtcbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgICAgICBhbmdsZSA9IDM2MDsgLy8gZ2l2ZSBoaWdoZXN0IGFuZ2xlIHRvIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgcG9pbnQgd2lsbCBlbmQgdXAgYXQgZW5kIG9mIHNvcnRlZCBsaXN0XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgcG9pbnQgd2lsbCBlbmQgdXAgYXQgYmVnaW5uaW5nIG9mIGh1bGwgcG9pbnRzIGxpc3RcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyeSA9IFtwb2ludHNbaV0sIGksIGFuZ2xlXTtcbiAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIC8vIHN0ZXAgMmI6IHNvcnQgdGhlIGxpc3QgaW4gcGxhY2VcbiAgICBzb3J0ZWRQb2ludFJlY29yZHMuc29ydChmdW5jdGlvbihyZWNvcmQxLCByZWNvcmQyKSB7XG4gICAgICAgIC8vIHJldHVybmluZyBhIG5lZ2F0aXZlIG51bWJlciBoZXJlIHNvcnRzIHJlY29yZDEgYmVmb3JlIHJlY29yZDJcbiAgICAgICAgLy8gaWYgZmlyc3QgYW5nbGUgaXMgc21hbGxlciB0aGFuIHNlY29uZCwgZmlyc3QgYW5nbGUgc2hvdWxkIGNvbWUgYmVmb3JlIHNlY29uZFxuXG4gICAgICAgIHZhciBzb3J0T3V0cHV0ID0gcmVjb3JkMVsyXSAtIHJlY29yZDJbMl07ICAvLyBuZWdhdGl2ZSBpZiBmaXJzdCBhbmdsZSBzbWFsbGVyXG4gICAgICAgIGlmIChzb3J0T3V0cHV0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHdvIGFuZ2xlcyBhcmUgZXF1YWwsIHNvcnQgYnkgb3JpZ2luYWxJbmRleFxuICAgICAgICAgICAgc29ydE91dHB1dCA9IHJlY29yZDJbMV0gLSByZWNvcmQxWzFdOyAvLyBuZWdhdGl2ZSBpZiBmaXJzdCBpbmRleCBsYXJnZXJcbiAgICAgICAgICAgIC8vIGNvaW5jaWRlbnQgcG9pbnRzIHdpbGwgYmUgc29ydGVkIGluIHJldmVyc2UtbnVtZXJpY2FsIG9yZGVyXG4gICAgICAgICAgICAvLyBzbyB0aGUgY29pbmNpZGVudCBwb2ludHMgd2l0aCBsb3dlciBvcmlnaW5hbCBpbmRleCB3aWxsIGJlIGNvbnNpZGVyZWQgZmlyc3RcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3J0T3V0cHV0O1xuICAgIH0pO1xuXG4gICAgLy8gc3RlcCAyYzogZHVwbGljYXRlIHN0YXJ0IHJlY29yZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrXG4gICAgaWYgKHNvcnRlZFBvaW50UmVjb3Jkcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBzdGFydFBvaW50UmVjb3JkID0gc29ydGVkUG9pbnRSZWNvcmRzW3NvcnRlZFBvaW50UmVjb3Jkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnVuc2hpZnQoc3RhcnRQb2ludFJlY29yZCk7XG4gICAgfVxuXG4gICAgLy8gc3RlcCAzYTogZ28gdGhyb3VnaCBzb3J0ZWQgcG9pbnRzIGluIG9yZGVyIGFuZCBmaW5kIHRob3NlIHdpdGggcmlnaHQgdHVybnNcbiAgICAvLyB3ZSB3YW50IHRvIGdldCBvdXIgcmVzdWx0cyBpbiBjbG9ja3dpc2Ugb3JkZXJcbiAgICB2YXIgaW5zaWRlUG9pbnRzID0ge307IC8vIGRpY3Rpb25hcnkgb2YgcG9pbnRzIHdpdGggbGVmdCB0dXJucyAtIGNhbm5vdCBiZSBvbiB0aGUgaHVsbFxuICAgIHZhciBodWxsUG9pbnRSZWNvcmRzID0gW107IC8vIHN0YWNrIG9mIHJlY29yZHMgd2l0aCByaWdodCB0dXJucyAtIGh1bGwgcG9pbnQgY2FuZGlkYXRlc1xuXG4gICAgdmFyIGN1cnJlbnRQb2ludFJlY29yZDtcbiAgICB2YXIgY3VycmVudFBvaW50O1xuICAgIHZhciBsYXN0SHVsbFBvaW50UmVjb3JkO1xuICAgIHZhciBsYXN0SHVsbFBvaW50O1xuICAgIHZhciBzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkO1xuICAgIHZhciBzZWNvbmRMYXN0SHVsbFBvaW50O1xuICAgIHdoaWxlIChzb3J0ZWRQb2ludFJlY29yZHMubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAgICAgY3VycmVudFBvaW50UmVjb3JkID0gc29ydGVkUG9pbnRSZWNvcmRzLnBvcCgpO1xuICAgICAgICBjdXJyZW50UG9pbnQgPSBjdXJyZW50UG9pbnRSZWNvcmRbMF07XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgcG9pbnQgaGFzIGFscmVhZHkgYmVlbiBkaXNjYXJkZWRcbiAgICAgICAgLy8ga2V5cyBmb3IgaW5zaWRlUG9pbnRzIGFyZSBzdG9yZWQgaW4gdGhlIGZvcm0gJ3BvaW50LnhAcG9pbnQueUBAb3JpZ2luYWxJbmRleCdcbiAgICAgICAgaWYgKGluc2lkZVBvaW50cy5oYXNPd25Qcm9wZXJ0eShjdXJyZW50UG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgY3VycmVudFBvaW50UmVjb3JkWzFdKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBwb2ludCBoYWQgYW4gaW5jb3JyZWN0IHR1cm4gYXQgc29tZSBwcmV2aW91cyBpdGVyYXRpb24gb2YgdGhpcyBsb29wXG4gICAgICAgICAgICAvLyB0aGlzIGRpc3F1YWxpZmllcyBpdCBmcm9tIHBvc3NpYmx5IGJlaW5nIG9uIHRoZSBodWxsXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3JyZWN0VHVybkZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghY29ycmVjdFR1cm5Gb3VuZCkge1xuXG4gICAgICAgICAgICBpZiAoaHVsbFBvaW50UmVjb3Jkcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBwb2ludHMgZm9yIGNvbXBhcmlzb24sIGp1c3QgYWRkIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goY3VycmVudFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICBjb3JyZWN0VHVybkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0SHVsbFBvaW50UmVjb3JkID0gaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0SHVsbFBvaW50ID0gbGFzdEh1bGxQb2ludFJlY29yZFswXTtcbiAgICAgICAgICAgICAgICBzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkID0gaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBzZWNvbmRMYXN0SHVsbFBvaW50ID0gc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZFswXTtcblxuICAgICAgICAgICAgICAgIHZhciBjcm9zc1Byb2R1Y3QgPSBzZWNvbmRMYXN0SHVsbFBvaW50LmNyb3NzKGxhc3RIdWxsUG9pbnQsIGN1cnJlbnRQb2ludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NQcm9kdWN0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIHJpZ2h0IHR1cm5cbiAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2gobGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChjdXJyZW50UG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0VHVybkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NQcm9kdWN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJlZSBvcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtYXkgYmUgYSAxODAgb3IgMCBkZWdyZWUgYW5nbGUgYXQgbGFzdEh1bGxQb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0d28gb2YgdGhlIHRocmVlIHBvaW50cyBhcmUgY29pbmNpZGVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgVEhSRVNIT0xEID0gMWUtMTA7IC8vIHdlIGhhdmUgdG8gdGFrZSByb3VuZGluZyBlcnJvcnMgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZUJldHdlZW4gPSBsYXN0SHVsbFBvaW50LmFuZ2xlQmV0d2VlbihzZWNvbmRMYXN0SHVsbFBvaW50LCBjdXJyZW50UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzKGFuZ2xlQmV0d2VlbiAtIDE4MCkgPCBUSFJFU0hPTEQpIHsgLy8gcm91bmRpbmcgYXJvdW5kIDE4MCB0byAxODBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjcm9zcyBwcm9kdWN0IGlzIDAgYmVjYXVzZSB0aGUgYW5nbGUgaXMgMTgwIGRlZ3JlZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgbGFzdCBodWxsIHBvaW50IChhZGQgdG8gaW5zaWRlUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnNpZGVQb2ludHMudW5zaGlmdChsYXN0SHVsbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVBvaW50c1tsYXN0SHVsbFBvaW50UmVjb3JkWzBdICsgJ0BAJyArIGxhc3RIdWxsUG9pbnRSZWNvcmRbMV1dID0gbGFzdEh1bGxQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZW50ZXIgc2Vjb25kLXRvLWxhc3QgaHVsbCBwb2ludCAod2lsbCBiZSBsYXN0IGF0IG5leHQgaXRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkbyBhbnl0aGluZyB3aXRoIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RIdWxsUG9pbnQuZXF1YWxzKGN1cnJlbnRQb2ludCkgfHwgc2Vjb25kTGFzdEh1bGxQb2ludC5lcXVhbHMobGFzdEh1bGxQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjcm9zcyBwcm9kdWN0IGlzIDAgYmVjYXVzZSB0d28gcG9pbnRzIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBsYXN0IGh1bGwgcG9pbnQgKGFkZCB0byBpbnNpZGVQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2luc2lkZVBvaW50cy51bnNoaWZ0KGxhc3RIdWxsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlUG9pbnRzW2xhc3RIdWxsUG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgbGFzdEh1bGxQb2ludFJlY29yZFsxXV0gPSBsYXN0SHVsbFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVlbnRlciBzZWNvbmQtdG8tbGFzdCBodWxsIHBvaW50ICh3aWxsIGJlIGxhc3QgYXQgbmV4dCBpdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRvIGFueXRoaW5nIHdpdGggY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB0dXJuIG5vdCBmb3VuZFxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzKCgoYW5nbGVCZXR3ZWVuICsgMSkgJSAzNjApIC0gMSkgPCBUSFJFU0hPTEQpIHsgLy8gcm91bmRpbmcgYXJvdW5kIDAgYW5kIDM2MCB0byAwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Jvc3MgcHJvZHVjdCBpcyAwIGJlY2F1c2UgdGhlIGFuZ2xlIGlzIDAgZGVncmVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxhc3QgaHVsbCBwb2ludCBmcm9tIGh1bGwgQlVUIGRvIG5vdCBkaXNjYXJkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWVudGVyIHNlY29uZC10by1sYXN0IGh1bGwgcG9pbnQgKHdpbGwgYmUgbGFzdCBhdCBuZXh0IGl0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXQgbGFzdCBodWxsIHBvaW50IGJhY2sgaW50byB0aGUgc29ydGVkIHBvaW50IHJlY29yZHMgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnB1c2gobGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgc3dpdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgMGRlZyBhbmQgMTgwZGVnIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB0dXJuIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGxlZnQgdHVyblxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGxhc3QgaHVsbCBwb2ludCAoYWRkIHRvIGluc2lkZVBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgLy9pbnNpZGVQb2ludHMudW5zaGlmdChsYXN0SHVsbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlUG9pbnRzW2xhc3RIdWxsUG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgbGFzdEh1bGxQb2ludFJlY29yZFsxXV0gPSBsYXN0SHVsbFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAvLyByZWVudGVyIHNlY29uZC10by1sYXN0IGh1bGwgcG9pbnQgKHdpbGwgYmUgbGFzdCBhdCBuZXh0IGl0ZXIgb2YgbG9vcClcbiAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZG8gYW55dGhpbmcgd2l0aCBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaHVsbFBvaW50UmVjb3JkcyBjb250YWlucyB0aGUgb3V0cHV0IHBvaW50cyBpbiBjbG9ja3dpc2Ugb3JkZXJcbiAgICAvLyB0aGUgcG9pbnRzIHN0YXJ0IHdpdGggbG93ZXN0LXksaGlnaGVzdC14IHN0YXJ0UG9pbnQsIGFuZCBlbmQgYXQgdGhlIHNhbWUgcG9pbnRcblxuICAgIC8vIHN0ZXAgM2I6IHJlbW92ZSBkdXBsaWNhdGVkIHN0YXJ0UG9pbnRSZWNvcmQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgIGlmIChodWxsUG9pbnRSZWNvcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyBzdGVwIDQ6IGZpbmQgdGhlIGxvd2VzdCBvcmlnaW5hbEluZGV4IHJlY29yZCBhbmQgcHV0IGl0IGF0IHRoZSBiZWdpbm5pbmcgb2YgaHVsbFxuICAgIHZhciBsb3dlc3RIdWxsSW5kZXg7IC8vIHRoZSBsb3dlc3Qgb3JpZ2luYWxJbmRleCBvbiB0aGUgaHVsbFxuICAgIHZhciBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkID0gLTE7IC8vIHRoZSBpbmRleCBvZiB0aGUgcmVjb3JkIHdpdGggbG93ZXN0SHVsbEluZGV4XG4gICAgbiA9IGh1bGxQb2ludFJlY29yZHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICB2YXIgY3VycmVudEh1bGxJbmRleCA9IGh1bGxQb2ludFJlY29yZHNbaV1bMV07XG5cbiAgICAgICAgaWYgKGxvd2VzdEh1bGxJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRIdWxsSW5kZXggPCBsb3dlc3RIdWxsSW5kZXgpIHtcbiAgICAgICAgICAgIGxvd2VzdEh1bGxJbmRleCA9IGN1cnJlbnRIdWxsSW5kZXg7XG4gICAgICAgICAgICBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBodWxsUG9pbnRSZWNvcmRzUmVvcmRlcmVkID0gW107XG4gICAgaWYgKGluZGV4T2ZMb3dlc3RIdWxsSW5kZXhSZWNvcmQgPiAwKSB7XG4gICAgICAgIHZhciBuZXdGaXJzdENodW5rID0gaHVsbFBvaW50UmVjb3Jkcy5zbGljZShpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkKTtcbiAgICAgICAgdmFyIG5ld1NlY29uZENodW5rID0gaHVsbFBvaW50UmVjb3Jkcy5zbGljZSgwLCBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkKTtcbiAgICAgICAgaHVsbFBvaW50UmVjb3Jkc1Jlb3JkZXJlZCA9IG5ld0ZpcnN0Q2h1bmsuY29uY2F0KG5ld1NlY29uZENodW5rKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWQgPSBodWxsUG9pbnRSZWNvcmRzO1xuICAgIH1cblxuICAgIHZhciBodWxsUG9pbnRzID0gW107XG4gICAgbiA9IGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWQubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaHVsbFBvaW50cy5wdXNoKGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWRbaV1bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBodWxsUG9pbnRzO1xufVxuIl0sIm5hbWVzIjpbInBhcnNlUG9pbnRzIiwic3ZnU3RyaW5nIiwidHJpbW1lZFN0cmluZyIsInRyaW0iLCJwb2ludHMiLCJjb29yZHMiLCJzcGxpdCIsIm51bUNvb3JkcyIsImxlbmd0aCIsImkiLCJwdXNoIiwieCIsInkiLCJjbG9uZVBvaW50cyIsIm51bVBvaW50cyIsIm5ld1BvaW50cyIsInBvaW50IiwiY2xvbmUiLCJjb252ZXhIdWxsIiwiYWJzIiwiTWF0aCIsIm4iLCJzdGFydFBvaW50IiwidW5kZWZpbmVkIiwic29ydGVkUG9pbnRSZWNvcmRzIiwiYW5nbGUiLCJ0aGV0YSIsImVudHJ5Iiwic29ydCIsInJlY29yZDEiLCJyZWNvcmQyIiwic29ydE91dHB1dCIsInN0YXJ0UG9pbnRSZWNvcmQiLCJ1bnNoaWZ0IiwiaW5zaWRlUG9pbnRzIiwiaHVsbFBvaW50UmVjb3JkcyIsImN1cnJlbnRQb2ludFJlY29yZCIsImN1cnJlbnRQb2ludCIsImxhc3RIdWxsUG9pbnRSZWNvcmQiLCJsYXN0SHVsbFBvaW50Iiwic2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZCIsInNlY29uZExhc3RIdWxsUG9pbnQiLCJwb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImNvcnJlY3RUdXJuRm91bmQiLCJjcm9zc1Byb2R1Y3QiLCJjcm9zcyIsIlRIUkVTSE9MRCIsImFuZ2xlQmV0d2VlbiIsImVxdWFscyIsImxvd2VzdEh1bGxJbmRleCIsImluZGV4T2ZMb3dlc3RIdWxsSW5kZXhSZWNvcmQiLCJjdXJyZW50SHVsbEluZGV4IiwiaHVsbFBvaW50UmVjb3Jkc1Jlb3JkZXJlZCIsIm5ld0ZpcnN0Q2h1bmsiLCJzbGljZSIsIm5ld1NlY29uZENodW5rIiwiY29uY2F0IiwiaHVsbFBvaW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/points.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/polygon.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/g/polygon.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.mjs */ \"(ssr)/./node_modules/jointjs/src/g/extend.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(ssr)/./node_modules/jointjs/src/g/points.mjs\");\n\n\n\n\n\nconst Polygon = function(points) {\n    if (!(this instanceof Polygon)) {\n        return new Polygon(points);\n    }\n    if (typeof points === \"string\") {\n        return new Polygon.parse(points);\n    }\n    this.points = Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : [];\n};\nPolygon.parse = function(svgString) {\n    return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\nPolygon.fromRect = function(rect) {\n    return new Polygon([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft()\n    ]);\n};\nPolygon.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_2__.extend)(_polyline_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline.prototype, {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_4__.types.Polygon,\n    clone: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n    convexHull: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n    lengthPoints: function() {\n        const { start, end, points } = this;\n        if (points.length <= 1 || start.equals(end)) return points;\n        return [\n            ...points,\n            start.clone()\n        ];\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2x5Z29uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDTTtBQUNKO0FBQ0Y7QUFDZ0M7QUFFN0QsTUFBTU8sVUFBVSxTQUFTQyxNQUFNO0lBRWxDLElBQUksQ0FBRSxLQUFJLFlBQVlELE9BQU0sR0FBSTtRQUM1QixPQUFPLElBQUlBLFFBQVFDO0lBQ3ZCO0lBRUEsSUFBSSxPQUFPQSxXQUFXLFVBQVU7UUFDNUIsT0FBTyxJQUFJRCxRQUFRRSxLQUFLLENBQUNEO0lBQzdCO0lBRUEsSUFBSSxDQUFDQSxNQUFNLEdBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVUEsT0FBT0ksR0FBRyxDQUFDWiw2Q0FBS0EsSUFBSSxFQUFFO0FBQ2pFLEVBQUU7QUFFRk8sUUFBUUUsS0FBSyxHQUFHLFNBQVNJLFNBQVM7SUFDOUIsT0FBTyxJQUFJTixRQUFRRix3REFBV0EsQ0FBQ1E7QUFDbkM7QUFFQU4sUUFBUU8sUUFBUSxHQUFHLFNBQVNDLElBQUk7SUFDNUIsT0FBTyxJQUFJUixRQUFRO1FBQ2ZRLEtBQUtDLE9BQU87UUFDWkQsS0FBS0UsUUFBUTtRQUNiRixLQUFLRyxXQUFXO1FBQ2hCSCxLQUFLSSxVQUFVO0tBQ2xCO0FBQ0w7QUFFQVosUUFBUWEsU0FBUyxHQUFHbEIsbURBQU1BLENBQUNELG1EQUFRQSxDQUFDbUIsU0FBUyxFQUFFO0lBRTNDQyxNQUFNbEIsNkNBQUtBLENBQUNJLE9BQU87SUFFbkJlLE9BQU87UUFDSCxPQUFPLElBQUlmLFFBQVFILHdEQUFXQSxDQUFDLElBQUksQ0FBQ0ksTUFBTTtJQUM5QztJQUVBRixZQUFZO1FBQ1IsT0FBTyxJQUFJQyxRQUFRRCx1REFBVUEsQ0FBQyxJQUFJLENBQUNFLE1BQU07SUFDN0M7SUFFQWUsY0FBYztRQUNWLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxHQUFHLEVBQUVqQixNQUFNLEVBQUUsR0FBRyxJQUFJO1FBQ25DLElBQUlBLE9BQU9rQixNQUFNLElBQUksS0FBS0YsTUFBTUcsTUFBTSxDQUFDRixNQUFNLE9BQU9qQjtRQUNwRCxPQUFPO2VBQUlBO1lBQVFnQixNQUFNRixLQUFLO1NBQUc7SUFDckM7QUFFSiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2cvcG9seWdvbi5tanM/ZjkyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi9wb2x5bGluZS5tanMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi9leHRlbmQubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuaW1wb3J0IHsgY2xvbmVQb2ludHMsIHBhcnNlUG9pbnRzLCBjb252ZXhIdWxsIH0gZnJvbSAnLi9wb2ludHMubWpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBvaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uLnBhcnNlKHBvaW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wb2ludHMgPSAoQXJyYXkuaXNBcnJheShwb2ludHMpID8gcG9pbnRzLm1hcChQb2ludCkgOiBbXSk7XG59O1xuXG5Qb2x5Z29uLnBhcnNlID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBhcnNlUG9pbnRzKHN2Z1N0cmluZykpO1xufTtcblxuUG9seWdvbi5mcm9tUmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oW1xuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICAgICAgcmVjdC50b3BSaWdodCgpLFxuICAgICAgICByZWN0LmJvdHRvbVJpZ2h0KCksXG4gICAgICAgIHJlY3QuYm90dG9tTGVmdCgpXG4gICAgXSk7XG59O1xuXG5Qb2x5Z29uLnByb3RvdHlwZSA9IGV4dGVuZChQb2x5bGluZS5wcm90b3R5cGUsIHtcblxuICAgIHR5cGU6IHR5cGVzLlBvbHlnb24sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbihjbG9uZVBvaW50cyh0aGlzLnBvaW50cykpO1xuICAgIH0sXG5cbiAgICBjb252ZXhIdWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKGNvbnZleEh1bGwodGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgbGVuZ3RoUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCBwb2ludHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDEgfHwgc3RhcnQuZXF1YWxzKGVuZCkpIHJldHVybiBwb2ludHM7XG4gICAgICAgIHJldHVybiBbLi4ucG9pbnRzLCBzdGFydC5jbG9uZSgpXTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbIlBvaW50IiwiUG9seWxpbmUiLCJleHRlbmQiLCJ0eXBlcyIsImNsb25lUG9pbnRzIiwicGFyc2VQb2ludHMiLCJjb252ZXhIdWxsIiwiUG9seWdvbiIsInBvaW50cyIsInBhcnNlIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwic3ZnU3RyaW5nIiwiZnJvbVJlY3QiLCJyZWN0IiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tUmlnaHQiLCJib3R0b21MZWZ0IiwicHJvdG90eXBlIiwidHlwZSIsImNsb25lIiwibGVuZ3RoUG9pbnRzIiwic3RhcnQiLCJlbmQiLCJsZW5ndGgiLCJlcXVhbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/polygon.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/polyline.mjs":
/*!*************************************************!*\
  !*** ./node_modules/jointjs/src/g/polyline.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polyline: () => (/* binding */ Polyline)\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(ssr)/./node_modules/jointjs/src/g/points.mjs\");\n\n\n\n\n\nconst Polyline = function(points) {\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n    if (typeof points === \"string\") {\n        return new Polyline.parse(points);\n    }\n    this.points = Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : [];\n};\nPolyline.parse = function(svgString) {\n    return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft()\n    ]);\n};\nPolyline.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Polyline,\n    bbox: function() {\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        for(var i = 0; i < numPoints; i++){\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n    clone: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n    closestPoint: function(p) {\n        var cpLength = this.closestPointLength(p);\n        return this.pointAtLength(cpLength);\n    },\n    closestPointLength: function(p) {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for(var i = 0; i < n; i++){\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + cpNormalizedLength * lineLength;\n            }\n            length += lineLength;\n        }\n        return cpLength;\n    },\n    closestPointNormalizedLength: function(p) {\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n        return cpLength / length;\n    },\n    closestPointTangent: function(p) {\n        var cpLength = this.closestPointLength(p);\n        return this.tangentAtLength(cpLength);\n    },\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n        var x = p.x;\n        var y = p.y;\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var ray = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var rayEnd = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n        for(; endIndex < numPoints; endIndex++){\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n            // do we have an intersection?\n            if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n                var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return numIntersections % 2 === 1;\n    },\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n    lengthPoints: function() {\n        return this.points;\n    },\n    convexHull: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n        if (!p) return false;\n        var points = this.points;\n        var otherPoints = p.points;\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n        for(var i = 0; i < numPoints; i++){\n            var point = points[i];\n            var otherPoint = p.points[i];\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n        // if no inequality found in points, return true\n        return true;\n    },\n    intersectionWithLine: function(l) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        for(var i = 0, n = points.length - 1; i < n; i++){\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return intersections.length > 0 ? intersections : null;\n    },\n    isDifferentiable: function() {\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var n = numPoints - 1;\n        for(var i = 0; i < n; i++){\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n    length: function() {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        var length = 0;\n        var n = numPoints - 1;\n        for(var i = 0; i < n; i++){\n            length += points[i].distance(points[i + 1]);\n        }\n        return length;\n    },\n    pointAt: function(ratio) {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n        return this.pointAtLength(length);\n    },\n    pointAtLength: function(length) {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        var l = 0;\n        var n = numPoints - 1;\n        for(var i = 0; i < n; i++){\n            var index = fromStart ? i : n - 1 - i;\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n            if (length <= l + d) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n            l += d;\n        }\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n        return lastPoint.clone();\n    },\n    round: function(precision) {\n        var points = this.points;\n        var numPoints = points.length;\n        for(var i = 0; i < numPoints; i++){\n            points[i].round(precision);\n        }\n        return this;\n    },\n    scale: function(sx, sy, origin) {\n        var points = this.points;\n        var numPoints = points.length;\n        for(var i = 0; i < numPoints; i++){\n            points[i].scale(sx, sy, origin);\n        }\n        return this;\n    },\n    simplify: function(opt = {}) {\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while(points[currentIndex + 2]){\n            const firstIndex = currentIndex;\n            const middleIndex = currentIndex + 1;\n            const lastIndex = currentIndex + 2;\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n            const chord = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n            // 2) in next iteration, investigate the newly-created triplet of points\n            //    - do not change `currentIndex`\n            //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n            //    = (point after first point becomes first point)\n            }\n        }\n        // `points` array was modified in-place\n        return this;\n    },\n    tangentAt: function(ratio) {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n        return this.tangentAtLength(length);\n    },\n    tangentAtLength: function(length) {\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for(var i = 0; i < n; i++){\n            var index = fromStart ? i : n - 1 - i;\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n            if (line.isDifferentiable()) {\n                if (length <= l + d) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n                lastValidLine = line;\n            }\n            l += d;\n        }\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = fromStart ? 1 : 0;\n            return lastValidLine.tangentAt(ratio);\n        }\n        // if no valid line, return null\n        return null;\n    },\n    toString: function() {\n        return this.points + \"\";\n    },\n    translate: function(tx, ty) {\n        var points = this.points;\n        var numPoints = points.length;\n        for(var i = 0; i < numPoints; i++){\n            points[i].translate(tx, ty);\n        }\n        return this;\n    },\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return \"\"; // if points array is empty\n        var output = \"\";\n        for(var i = 0; i < numPoints; i++){\n            var point = points[i];\n            output += point.x + \",\" + point.y + \" \";\n        }\n        return output.trim();\n    }\n};\nObject.defineProperty(Polyline.prototype, \"start\", {\n    // Getter for the first point of the polyline.\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        return this.points[0];\n    }\n});\nObject.defineProperty(Polyline.prototype, \"end\", {\n    // Getter for the last point of the polyline.\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        return this.points[numPoints - 1];\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9wb2x5bGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0U7QUFDRjtBQUNFO0FBQ2dDO0FBRzdELE1BQU1PLFdBQVcsU0FBU0MsTUFBTTtJQUVuQyxJQUFJLENBQUUsS0FBSSxZQUFZRCxRQUFPLEdBQUk7UUFDN0IsT0FBTyxJQUFJQSxTQUFTQztJQUN4QjtJQUVBLElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQzVCLE9BQU8sSUFBSUQsU0FBU0UsS0FBSyxDQUFDRDtJQUM5QjtJQUVBLElBQUksQ0FBQ0EsTUFBTSxHQUFJRSxNQUFNQyxPQUFPLENBQUNILFVBQVVBLE9BQU9JLEdBQUcsQ0FBQ1gsNkNBQUtBLElBQUksRUFBRTtBQUNqRSxFQUFFO0FBRUZNLFNBQVNFLEtBQUssR0FBRyxTQUFTSSxTQUFTO0lBQy9CLE9BQU8sSUFBSU4sU0FBU0Ysd0RBQVdBLENBQUNRO0FBQ3BDO0FBRUFOLFNBQVNPLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzdCLE9BQU8sSUFBSVIsU0FBUztRQUNoQlEsS0FBS0MsT0FBTztRQUNaRCxLQUFLRSxRQUFRO1FBQ2JGLEtBQUtHLFdBQVc7UUFDaEJILEtBQUtJLFVBQVU7UUFDZkosS0FBS0MsT0FBTztLQUNmO0FBQ0w7QUFFQVQsU0FBU2EsU0FBUyxHQUFHO0lBRWpCQyxNQUFNbEIsNkNBQUtBLENBQUNJLFFBQVE7SUFFcEJlLE1BQU07UUFFRixJQUFJQyxLQUFLQztRQUNULElBQUlDLEtBQUssQ0FBQ0Q7UUFDVixJQUFJRSxLQUFLRjtRQUNULElBQUlHLEtBQUssQ0FBQ0g7UUFFVixJQUFJaEIsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDeEIsSUFBSW9CLFlBQVlwQixPQUFPcUIsTUFBTTtRQUM3QixJQUFJRCxjQUFjLEdBQUcsT0FBTyxNQUFNLDJCQUEyQjtRQUU3RCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsV0FBV0UsSUFBSztZQUVoQyxJQUFJQyxRQUFRdkIsTUFBTSxDQUFDc0IsRUFBRTtZQUNyQixJQUFJRSxJQUFJRCxNQUFNQyxDQUFDO1lBQ2YsSUFBSUMsSUFBSUYsTUFBTUUsQ0FBQztZQUVmLElBQUlELElBQUlULElBQUlBLEtBQUtTO1lBQ2pCLElBQUlBLElBQUlQLElBQUlBLEtBQUtPO1lBQ2pCLElBQUlDLElBQUlQLElBQUlBLEtBQUtPO1lBQ2pCLElBQUlBLElBQUlOLElBQUlBLEtBQUtNO1FBQ3JCO1FBRUEsT0FBTyxJQUFJakMsMkNBQUlBLENBQUN1QixJQUFJRyxJQUFJRCxLQUFLRixJQUFJSSxLQUFLRDtJQUMxQztJQUVBUSxPQUFPO1FBQ0gsT0FBTyxJQUFJM0IsU0FBU0gsd0RBQVdBLENBQUMsSUFBSSxDQUFDSSxNQUFNO0lBQy9DO0lBRUEyQixjQUFjLFNBQVNDLENBQUM7UUFFcEIsSUFBSUMsV0FBVyxJQUFJLENBQUNDLGtCQUFrQixDQUFDRjtRQUV2QyxPQUFPLElBQUksQ0FBQ0csYUFBYSxDQUFDRjtJQUM5QjtJQUVBQyxvQkFBb0IsU0FBU0YsQ0FBQztRQUUxQixJQUFJNUIsU0FBUyxJQUFJLENBQUNnQyxZQUFZO1FBQzlCLElBQUlaLFlBQVlwQixPQUFPcUIsTUFBTTtRQUM3QixJQUFJRCxjQUFjLEdBQUcsT0FBTyxHQUFHLDJCQUEyQjtRQUMxRCxJQUFJQSxjQUFjLEdBQUcsT0FBTyxHQUFHLDZCQUE2QjtRQUU1RCxJQUFJUztRQUNKLElBQUlJLGlCQUFpQmpCO1FBQ3JCLElBQUlLLFNBQVM7UUFDYixJQUFJYSxJQUFJZCxZQUFZO1FBQ3BCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJWSxHQUFHWixJQUFLO1lBRXhCLElBQUlhLE9BQU8sSUFBSXpDLDJDQUFJQSxDQUFDTSxNQUFNLENBQUNzQixFQUFFLEVBQUV0QixNQUFNLENBQUNzQixJQUFJLEVBQUU7WUFDNUMsSUFBSWMsYUFBYUQsS0FBS2QsTUFBTTtZQUU1QixJQUFJZ0IscUJBQXFCRixLQUFLRyw0QkFBNEIsQ0FBQ1Y7WUFDM0QsSUFBSVcsS0FBS0osS0FBS0ssT0FBTyxDQUFDSDtZQUV0QixJQUFJSSxjQUFjRixHQUFHRyxlQUFlLENBQUNkO1lBQ3JDLElBQUlhLGNBQWNSLGdCQUFnQjtnQkFDOUJBLGlCQUFpQlE7Z0JBQ2pCWixXQUFXUixTQUFVZ0IscUJBQXFCRDtZQUM5QztZQUVBZixVQUFVZTtRQUNkO1FBRUEsT0FBT1A7SUFDWDtJQUVBUyw4QkFBOEIsU0FBU1YsQ0FBQztRQUVwQyxJQUFJQyxXQUFXLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNGO1FBQ3ZDLElBQUlDLGFBQWEsR0FBRyxPQUFPLEdBQUcsV0FBVztRQUV6QyxJQUFJUixTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJQSxXQUFXLEdBQUcsT0FBTyxHQUFHLDRCQUE0QjtRQUV4RCxPQUFPUSxXQUFXUjtJQUN0QjtJQUVBc0IscUJBQXFCLFNBQVNmLENBQUM7UUFFM0IsSUFBSUMsV0FBVyxJQUFJLENBQUNDLGtCQUFrQixDQUFDRjtRQUV2QyxPQUFPLElBQUksQ0FBQ2dCLGVBQWUsQ0FBQ2Y7SUFDaEM7SUFFQSxnRkFBZ0Y7SUFDaEYsNEVBQTRFO0lBQzVFLHdFQUF3RTtJQUN4RSxtRUFBbUU7SUFDbkVnQixlQUFlLFNBQVNqQixDQUFDO1FBRXJCLElBQUk1QixTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJb0IsWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLE9BQU8seUNBQXlDO1FBRTVFLElBQUlJLElBQUlJLEVBQUVKLENBQUM7UUFDWCxJQUFJQyxJQUFJRyxFQUFFSCxDQUFDO1FBRVgsd0ZBQXdGO1FBQ3hGLElBQUlxQixhQUFhMUIsWUFBWSxHQUFHLG9DQUFvQztRQUNwRSxJQUFJMkIsV0FBVyxHQUFHLGtDQUFrQztRQUNwRCxJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsVUFBVSxJQUFJdkQsMkNBQUlBO1FBQ3RCLElBQUl3RCxNQUFNLElBQUl4RCwyQ0FBSUE7UUFDbEIsSUFBSXlELFNBQVMsSUFBSTFELDZDQUFLQTtRQUN0QixNQUFPc0QsV0FBVzNCLFdBQVcyQixXQUFZO1lBQ3JDLElBQUlLLFFBQVFwRCxNQUFNLENBQUM4QyxXQUFXO1lBQzlCLElBQUlPLE1BQU1yRCxNQUFNLENBQUMrQyxTQUFTO1lBQzFCLElBQUluQixFQUFFMEIsTUFBTSxDQUFDRixRQUFRLE9BQU8sTUFBTSx3Q0FBd0M7WUFDMUUsMkJBQTJCO1lBQzNCSCxRQUFRRyxLQUFLLEdBQUdBO1lBQ2hCSCxRQUFRSSxHQUFHLEdBQUdBO1lBQ2QsSUFBSUosUUFBUUosYUFBYSxDQUFDakIsSUFBSSxPQUFPLE1BQU0sNENBQTRDO1lBRXZGLDhCQUE4QjtZQUM5QixJQUFJLEtBQU93QixNQUFNM0IsQ0FBQyxJQUFNQSxJQUFJNEIsSUFBSTVCLENBQUMsSUFBTyxJQUFLMkIsTUFBTTNCLENBQUMsSUFBTUEsS0FBSzRCLElBQUk1QixDQUFDLEVBQUk7Z0JBQ3BFLDJGQUEyRjtnQkFDM0YsbUNBQW1DO2dCQUNuQyxvRkFBb0Y7Z0JBQ3BGLHdDQUF3QztnQkFDeEMsMkZBQTJGO2dCQUUzRixJQUFJOEIsY0FBZSxNQUFRL0IsQ0FBQyxHQUFHQSxJQUFNNkIsSUFBSTdCLENBQUMsR0FBR0EsSUFBTzRCLE1BQU01QixDQUFDLEdBQUdBLElBQU02QixJQUFJN0IsQ0FBQyxHQUFHQTtnQkFDNUUsSUFBSStCLGVBQWUsR0FBRztvQkFDbEIsc0RBQXNEO29CQUN0REosT0FBTzNCLENBQUMsR0FBR0EsSUFBSStCO29CQUNmSixPQUFPMUIsQ0FBQyxHQUFHQSxHQUFHLFFBQVE7b0JBQ3RCeUIsSUFBSUUsS0FBSyxHQUFHeEI7b0JBQ1pzQixJQUFJRyxHQUFHLEdBQUdGO29CQUNWLElBQUlGLFFBQVFPLFNBQVMsQ0FBQ04sTUFBTTt3QkFDeEIsbURBQW1EO3dCQUNuREY7b0JBQ0o7Z0JBQ0osRUFBRSx5RkFBeUY7WUFDL0Y7WUFFQSwwQ0FBMEM7WUFDMUNGLGFBQWFDO1FBQ2pCO1FBRUEsdUVBQXVFO1FBQ3ZFLE9BQVEsbUJBQW9CLE1BQU87SUFDdkM7SUFFQVUsT0FBTztRQUNILE1BQU0sRUFBRUwsS0FBSyxFQUFFQyxHQUFHLEVBQUVyRCxNQUFNLEVBQUUsR0FBRyxJQUFJO1FBQ25DLElBQUlvRCxTQUFTQyxPQUFPLENBQUNELE1BQU1FLE1BQU0sQ0FBQ0QsTUFBTTtZQUNwQ3JELE9BQU8wRCxJQUFJLENBQUNOLE1BQU0xQixLQUFLO1FBQzNCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFFQU0sY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDaEMsTUFBTTtJQUN0QjtJQUVBRixZQUFZO1FBQ1IsT0FBTyxJQUFJQyxTQUFTRCx1REFBVUEsQ0FBQyxJQUFJLENBQUNFLE1BQU07SUFDOUM7SUFFQSxxREFBcUQ7SUFDckQsOENBQThDO0lBQzlDc0QsUUFBUSxTQUFTMUIsQ0FBQztRQUVkLElBQUksQ0FBQ0EsR0FBRyxPQUFPO1FBRWYsSUFBSTVCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLElBQUkyRCxjQUFjL0IsRUFBRTVCLE1BQU07UUFFMUIsSUFBSW9CLFlBQVlwQixPQUFPcUIsTUFBTTtRQUM3QixJQUFJc0MsWUFBWXRDLE1BQU0sS0FBS0QsV0FBVyxPQUFPLE9BQU8sNkVBQTZFO1FBRWpJLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixXQUFXRSxJQUFLO1lBRWhDLElBQUlDLFFBQVF2QixNQUFNLENBQUNzQixFQUFFO1lBQ3JCLElBQUlzQyxhQUFhaEMsRUFBRTVCLE1BQU0sQ0FBQ3NCLEVBQUU7WUFFNUIsNERBQTREO1lBQzVELElBQUksQ0FBQ0MsTUFBTStCLE1BQU0sQ0FBQ00sYUFBYSxPQUFPO1FBQzFDO1FBRUEsZ0RBQWdEO1FBQ2hELE9BQU87SUFDWDtJQUVBQyxzQkFBc0IsU0FBU0MsQ0FBQztRQUM1QixJQUFJM0IsT0FBTyxJQUFJekMsMkNBQUlBLENBQUNvRTtRQUNwQixJQUFJQyxnQkFBZ0IsRUFBRTtRQUN0QixJQUFJL0QsU0FBUyxJQUFJLENBQUNnQyxZQUFZO1FBQzlCLElBQUlnQyxLQUFLLElBQUl0RSwyQ0FBSUE7UUFDakIsSUFBSyxJQUFJNEIsSUFBSSxHQUFHWSxJQUFJbEMsT0FBT3FCLE1BQU0sR0FBRyxHQUFHQyxJQUFJWSxHQUFHWixJQUFLO1lBQy9DMEMsR0FBR1osS0FBSyxHQUFHcEQsTUFBTSxDQUFDc0IsRUFBRTtZQUNwQjBDLEdBQUdYLEdBQUcsR0FBR3JELE1BQU0sQ0FBQ3NCLElBQUksRUFBRTtZQUN0QixJQUFJMkMsTUFBTTlCLEtBQUswQixvQkFBb0IsQ0FBQ0c7WUFDcEMsSUFBSUMsS0FBS0YsY0FBY0wsSUFBSSxDQUFDTyxHQUFHLENBQUMsRUFBRTtRQUN0QztRQUNBLE9BQU8sY0FBZTVDLE1BQU0sR0FBRyxJQUFLMEMsZ0JBQWdCO0lBQ3hEO0lBRUFHLGtCQUFrQjtRQUVkLElBQUlsRSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJb0IsWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPO1FBRTVCLElBQUllLE9BQU8sSUFBSXpDLDJDQUFJQTtRQUNuQixJQUFJd0MsSUFBSWQsWUFBWTtRQUNwQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSVksR0FBR1osSUFBSztZQUN4QmEsS0FBS2lCLEtBQUssR0FBR3BELE1BQU0sQ0FBQ3NCLEVBQUU7WUFDdEJhLEtBQUtrQixHQUFHLEdBQUdyRCxNQUFNLENBQUNzQixJQUFJLEVBQUU7WUFDeEIsNEVBQTRFO1lBQzVFLElBQUlhLEtBQUsrQixnQkFBZ0IsSUFBSSxPQUFPO1FBQ3hDO1FBRUEsMkVBQTJFO1FBQzNFLE9BQU87SUFDWDtJQUVBN0MsUUFBUTtRQUVKLElBQUlyQixTQUFTLElBQUksQ0FBQ2dDLFlBQVk7UUFDOUIsSUFBSVosWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLEdBQUcsMkJBQTJCO1FBRTFELElBQUlDLFNBQVM7UUFDYixJQUFJYSxJQUFJZCxZQUFZO1FBQ3BCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJWSxHQUFHWixJQUFLO1lBQ3hCRCxVQUFVckIsTUFBTSxDQUFDc0IsRUFBRSxDQUFDNkMsUUFBUSxDQUFDbkUsTUFBTSxDQUFDc0IsSUFBSSxFQUFFO1FBQzlDO1FBRUEsT0FBT0Q7SUFDWDtJQUVBbUIsU0FBUyxTQUFTNEIsS0FBSztRQUVuQixJQUFJcEUsU0FBUyxJQUFJLENBQUNnQyxZQUFZO1FBQzlCLElBQUlaLFlBQVlwQixPQUFPcUIsTUFBTTtRQUM3QixJQUFJRCxjQUFjLEdBQUcsT0FBTyxNQUFNLDJCQUEyQjtRQUM3RCxJQUFJQSxjQUFjLEdBQUcsT0FBT3BCLE1BQU0sQ0FBQyxFQUFFLENBQUMwQixLQUFLLElBQUksNkJBQTZCO1FBRTVFLElBQUkwQyxTQUFTLEdBQUcsT0FBT3BFLE1BQU0sQ0FBQyxFQUFFLENBQUMwQixLQUFLO1FBQ3RDLElBQUkwQyxTQUFTLEdBQUcsT0FBT3BFLE1BQU0sQ0FBQ29CLFlBQVksRUFBRSxDQUFDTSxLQUFLO1FBRWxELElBQUkyQyxpQkFBaUIsSUFBSSxDQUFDaEQsTUFBTTtRQUNoQyxJQUFJQSxTQUFTZ0QsaUJBQWlCRDtRQUU5QixPQUFPLElBQUksQ0FBQ3JDLGFBQWEsQ0FBQ1Y7SUFDOUI7SUFFQVUsZUFBZSxTQUFTVixNQUFNO1FBRTFCLElBQUlyQixTQUFTLElBQUksQ0FBQ2dDLFlBQVk7UUFDOUIsSUFBSVosWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLE1BQU0sMkJBQTJCO1FBQzdELElBQUlBLGNBQWMsR0FBRyxPQUFPcEIsTUFBTSxDQUFDLEVBQUUsQ0FBQzBCLEtBQUssSUFBSSw2QkFBNkI7UUFFNUUsSUFBSTRDLFlBQVk7UUFDaEIsSUFBSWpELFNBQVMsR0FBRztZQUNaaUQsWUFBWSxPQUFPLHlEQUF5RDtZQUM1RWpELFNBQVMsQ0FBQ0EsUUFBUSxpQkFBaUI7UUFDdkM7UUFFQSxJQUFJeUMsSUFBSTtRQUNSLElBQUk1QixJQUFJZCxZQUFZO1FBQ3BCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJWSxHQUFHWixJQUFLO1lBQ3hCLElBQUlpRCxRQUFTRCxZQUFZaEQsSUFBS1ksSUFBSSxJQUFJWjtZQUV0QyxJQUFJa0QsSUFBSXhFLE1BQU0sQ0FBQ3VFLE1BQU07WUFDckIsSUFBSUUsSUFBSXpFLE1BQU0sQ0FBQ3VFLFFBQVEsRUFBRTtZQUN6QixJQUFJcEMsT0FBTyxJQUFJekMsMkNBQUlBLENBQUM4RSxHQUFHQztZQUN2QixJQUFJQyxJQUFJRixFQUFFTCxRQUFRLENBQUNNO1lBRW5CLElBQUlwRCxVQUFXeUMsSUFBSVksR0FBSTtnQkFDbkIsT0FBT3ZDLEtBQUtKLGFBQWEsQ0FBQyxDQUFDdUMsWUFBWSxJQUFJLENBQUMsS0FBTWpELENBQUFBLFNBQVN5QyxDQUFBQTtZQUMvRDtZQUVBQSxLQUFLWTtRQUNUO1FBRUEsc0ZBQXNGO1FBQ3RGLElBQUlDLFlBQWFMLFlBQVl0RSxNQUFNLENBQUNvQixZQUFZLEVBQUUsR0FBR3BCLE1BQU0sQ0FBQyxFQUFFO1FBQzlELE9BQU8yRSxVQUFVakQsS0FBSztJQUMxQjtJQUVBa0QsT0FBTyxTQUFTQyxTQUFTO1FBRXJCLElBQUk3RSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJb0IsWUFBWXBCLE9BQU9xQixNQUFNO1FBRTdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixXQUFXRSxJQUFLO1lBQ2hDdEIsTUFBTSxDQUFDc0IsRUFBRSxDQUFDc0QsS0FBSyxDQUFDQztRQUNwQjtRQUVBLE9BQU8sSUFBSTtJQUNmO0lBRUFDLE9BQU8sU0FBU0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07UUFFMUIsSUFBSWpGLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLElBQUlvQixZQUFZcEIsT0FBT3FCLE1BQU07UUFFN0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFdBQVdFLElBQUs7WUFDaEN0QixNQUFNLENBQUNzQixFQUFFLENBQUN3RCxLQUFLLENBQUNDLElBQUlDLElBQUlDO1FBQzVCO1FBRUEsT0FBTyxJQUFJO0lBQ2Y7SUFFQUMsVUFBVSxTQUFTQyxNQUFNLENBQUMsQ0FBQztRQUV2QixNQUFNbkYsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsSUFBSUEsT0FBT3FCLE1BQU0sR0FBRyxHQUFHLE9BQU8sSUFBSSxFQUFFLDRCQUE0QjtRQUVoRSxvR0FBb0c7UUFFcEcsMkZBQTJGO1FBQzNGLDBFQUEwRTtRQUMxRSxNQUFNK0QsWUFBWUQsSUFBSUMsU0FBUyxJQUFJLE9BQU8sNkRBQTZEO1FBRXZHLHdEQUF3RDtRQUN4RCxJQUFJQyxlQUFlO1FBQ25CLHdFQUF3RTtRQUN4RSwrRUFBK0U7UUFDL0UsTUFBT3JGLE1BQU0sQ0FBQ3FGLGVBQWUsRUFBRSxDQUFFO1lBQzdCLE1BQU1DLGFBQWFEO1lBQ25CLE1BQU1FLGNBQWVGLGVBQWU7WUFDcEMsTUFBTUcsWUFBYUgsZUFBZTtZQUVsQyxNQUFNSSxhQUFhekYsTUFBTSxDQUFDc0YsV0FBVztZQUNyQyxNQUFNSSxjQUFjMUYsTUFBTSxDQUFDdUYsWUFBWTtZQUN2QyxNQUFNWixZQUFZM0UsTUFBTSxDQUFDd0YsVUFBVTtZQUVuQyxNQUFNRyxRQUFRLElBQUlqRywyQ0FBSUEsQ0FBQytGLFlBQVlkLFlBQVksNENBQTRDO1lBQzNGLE1BQU1oRCxlQUFlZ0UsTUFBTWhFLFlBQVksQ0FBQytELGNBQWMsNkNBQTZDO1lBQ25HLE1BQU1FLHVCQUF1QmpFLGFBQWF3QyxRQUFRLENBQUN1QjtZQUNuRCxJQUFJRSx3QkFBd0JSLFdBQVc7Z0JBQ25DLHVEQUF1RDtnQkFDdkQsMEJBQTBCO2dCQUMxQnBGLE9BQU82RixNQUFNLENBQUNOLGFBQWE7WUFDM0Isd0VBQXdFO1lBQ3hFLG9DQUFvQztZQUNwQywyRUFBMkU7WUFDL0UsT0FBTztnQkFDSCxxQ0FBcUM7Z0JBQ3JDLDJCQUEyQjtnQkFDM0IseURBQXlEO2dCQUN6REYsZ0JBQWdCO1lBQ2hCLHFEQUFxRDtZQUN6RDtRQUNKO1FBRUEsdUNBQXVDO1FBQ3ZDLE9BQU8sSUFBSTtJQUNmO0lBRUFTLFdBQVcsU0FBUzFCLEtBQUs7UUFFckIsSUFBSXBFLFNBQVMsSUFBSSxDQUFDZ0MsWUFBWTtRQUM5QixJQUFJWixZQUFZcEIsT0FBT3FCLE1BQU07UUFDN0IsSUFBSUQsY0FBYyxHQUFHLE9BQU8sTUFBTSwyQkFBMkI7UUFDN0QsSUFBSUEsY0FBYyxHQUFHLE9BQU8sTUFBTSw2QkFBNkI7UUFFL0QsSUFBSWdELFFBQVEsR0FBR0EsUUFBUTtRQUN2QixJQUFJQSxRQUFRLEdBQUdBLFFBQVE7UUFFdkIsSUFBSUMsaUJBQWlCLElBQUksQ0FBQ2hELE1BQU07UUFDaEMsSUFBSUEsU0FBU2dELGlCQUFpQkQ7UUFFOUIsT0FBTyxJQUFJLENBQUN4QixlQUFlLENBQUN2QjtJQUNoQztJQUVBdUIsaUJBQWlCLFNBQVN2QixNQUFNO1FBRTVCLElBQUlyQixTQUFTLElBQUksQ0FBQ2dDLFlBQVk7UUFDOUIsSUFBSVosWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLE1BQU0sMkJBQTJCO1FBQzdELElBQUlBLGNBQWMsR0FBRyxPQUFPLE1BQU0sNkJBQTZCO1FBRS9ELElBQUlrRCxZQUFZO1FBQ2hCLElBQUlqRCxTQUFTLEdBQUc7WUFDWmlELFlBQVksT0FBTyx5REFBeUQ7WUFDNUVqRCxTQUFTLENBQUNBLFFBQVEsaUJBQWlCO1FBQ3ZDO1FBRUEsSUFBSTBFLGVBQWUsa0NBQWtDO1FBQ3JELElBQUlqQyxJQUFJLEdBQUcsZ0JBQWdCO1FBQzNCLElBQUk1QixJQUFJZCxZQUFZO1FBQ3BCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJWSxHQUFHWixJQUFLO1lBQ3hCLElBQUlpRCxRQUFTRCxZQUFZaEQsSUFBS1ksSUFBSSxJQUFJWjtZQUV0QyxJQUFJa0QsSUFBSXhFLE1BQU0sQ0FBQ3VFLE1BQU07WUFDckIsSUFBSUUsSUFBSXpFLE1BQU0sQ0FBQ3VFLFFBQVEsRUFBRTtZQUN6QixJQUFJcEMsT0FBTyxJQUFJekMsMkNBQUlBLENBQUM4RSxHQUFHQztZQUN2QixJQUFJQyxJQUFJRixFQUFFTCxRQUFRLENBQUNNO1lBRW5CLElBQUl0QyxLQUFLK0IsZ0JBQWdCLElBQUk7Z0JBQ3pCLElBQUk3QyxVQUFXeUMsSUFBSVksR0FBSTtvQkFDbkIsT0FBT3ZDLEtBQUtTLGVBQWUsQ0FBQyxDQUFDMEIsWUFBWSxJQUFJLENBQUMsS0FBTWpELENBQUFBLFNBQVN5QyxDQUFBQTtnQkFDakU7Z0JBRUFpQyxnQkFBZ0I1RDtZQUNwQjtZQUVBMkIsS0FBS1k7UUFDVDtRQUVBLDRGQUE0RjtRQUM1RixJQUFJcUIsZUFBZTtZQUNmLElBQUkzQixRQUFTRSxZQUFZLElBQUk7WUFDN0IsT0FBT3lCLGNBQWNELFNBQVMsQ0FBQzFCO1FBQ25DO1FBRUEsZ0NBQWdDO1FBQ2hDLE9BQU87SUFDWDtJQUVBNEIsVUFBVTtRQUVOLE9BQU8sSUFBSSxDQUFDaEcsTUFBTSxHQUFHO0lBQ3pCO0lBRUFpRyxXQUFXLFNBQVNDLEVBQUUsRUFBRUMsRUFBRTtRQUV0QixJQUFJbkcsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDeEIsSUFBSW9CLFlBQVlwQixPQUFPcUIsTUFBTTtRQUU3QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsV0FBV0UsSUFBSztZQUNoQ3RCLE1BQU0sQ0FBQ3NCLEVBQUUsQ0FBQzJFLFNBQVMsQ0FBQ0MsSUFBSUM7UUFDNUI7UUFFQSxPQUFPLElBQUk7SUFDZjtJQUVBLDJEQUEyRDtJQUMzREMsV0FBVztRQUVQLElBQUlwRyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJb0IsWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLElBQUksMkJBQTJCO1FBRTNELElBQUlpRixTQUFTO1FBQ2IsSUFBSyxJQUFJL0UsSUFBSSxHQUFHQSxJQUFJRixXQUFXRSxJQUFLO1lBRWhDLElBQUlDLFFBQVF2QixNQUFNLENBQUNzQixFQUFFO1lBQ3JCK0UsVUFBVTlFLE1BQU1DLENBQUMsR0FBRyxNQUFNRCxNQUFNRSxDQUFDLEdBQUc7UUFDeEM7UUFFQSxPQUFPNEUsT0FBT0MsSUFBSTtJQUN0QjtBQUNKO0FBRUFDLE9BQU9DLGNBQWMsQ0FBQ3pHLFNBQVNhLFNBQVMsRUFBRSxTQUFTO0lBQy9DLDhDQUE4QztJQUU5QzZGLGNBQWM7SUFFZEMsWUFBWTtJQUVaQyxLQUFLO1FBRUQsSUFBSTNHLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLElBQUlvQixZQUFZcEIsT0FBT3FCLE1BQU07UUFDN0IsSUFBSUQsY0FBYyxHQUFHLE9BQU8sTUFBTSwyQkFBMkI7UUFFN0QsT0FBTyxJQUFJLENBQUNwQixNQUFNLENBQUMsRUFBRTtJQUN6QjtBQUNKO0FBRUF1RyxPQUFPQyxjQUFjLENBQUN6RyxTQUFTYSxTQUFTLEVBQUUsT0FBTztJQUM3Qyw2Q0FBNkM7SUFFN0M2RixjQUFjO0lBRWRDLFlBQVk7SUFFWkMsS0FBSztRQUVELElBQUkzRyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJb0IsWUFBWXBCLE9BQU9xQixNQUFNO1FBQzdCLElBQUlELGNBQWMsR0FBRyxPQUFPLE1BQU0sMkJBQTJCO1FBRTdELE9BQU8sSUFBSSxDQUFDcEIsTUFBTSxDQUFDb0IsWUFBWSxFQUFFO0lBQ3JDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL3BvbHlsaW5lLm1qcz83MTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBjbG9uZVBvaW50cywgcGFyc2VQb2ludHMsIGNvbnZleEh1bGwgfSBmcm9tICcuL3BvaW50cy5tanMnO1xuXG5cbmV4cG9ydCBjb25zdCBQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvbHlsaW5lKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwb2ludHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUucGFyc2UocG9pbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvaW50cyA9IChBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHMubWFwKFBvaW50KSA6IFtdKTtcbn07XG5cblBvbHlsaW5lLnBhcnNlID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bGluZShwYXJzZVBvaW50cyhzdmdTdHJpbmcpKTtcbn07XG5cblBvbHlsaW5lLmZyb21SZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIHJldHVybiBuZXcgUG9seWxpbmUoW1xuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICAgICAgcmVjdC50b3BSaWdodCgpLFxuICAgICAgICByZWN0LmJvdHRvbVJpZ2h0KCksXG4gICAgICAgIHJlY3QuYm90dG9tTGVmdCgpLFxuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICBdKTtcbn07XG5cblBvbHlsaW5lLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLlBvbHlsaW5lLFxuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB4MiA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHkxID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICB2YXIgeCA9IHBvaW50Lng7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUoY2xvbmVQb2ludHModGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdExlbmd0aChjcExlbmd0aCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gMDsgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnRcblxuICAgICAgICB2YXIgY3BMZW5ndGg7XG4gICAgICAgIHZhciBtaW5TcXJEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIHZhciBjcE5vcm1hbGl6ZWRMZW5ndGggPSBsaW5lLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCk7XG4gICAgICAgICAgICB2YXIgY3AgPSBsaW5lLnBvaW50QXQoY3BOb3JtYWxpemVkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHNxckRpc3RhbmNlID0gY3Auc3F1YXJlZERpc3RhbmNlKHApO1xuICAgICAgICAgICAgaWYgKHNxckRpc3RhbmNlIDwgbWluU3FyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtaW5TcXJEaXN0YW5jZSA9IHNxckRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNwTGVuZ3RoID0gbGVuZ3RoICsgKGNwTm9ybWFsaXplZExlbmd0aCAqIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW5ndGggKz0gbGluZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcExlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHApO1xuICAgICAgICBpZiAoY3BMZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBzaG9ydGN1dFxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDsgLy8gcHJldmVudHMgZGl2aXNpb24gYnkgemVyb1xuXG4gICAgICAgIHJldHVybiBjcExlbmd0aCAvIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdExlbmd0aChjcExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmVhIHN1cnJvdW5kZWQgYnkgdGhlIHBvbHlsaW5lIGNvbnRhaW5zIHRoZSBwb2ludCBgcGAuXG4gICAgLy8gSW1wbGVtZW50cyB0aGUgZXZlbi1vZGQgU1ZHIGFsZ29yaXRobSAoc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBcIm91dHNpZGVcIikuXG4gICAgLy8gKFVzZXMgaG9yaXpvbnRhbCByYXlzIHRvIHRoZSByaWdodCBvZiBgcGAgdG8gbG9vayBmb3IgaW50ZXJzZWN0aW9ucy4pXG4gICAgLy8gQ2xvc2VzIG9wZW4gcG9seWxpbmVzIChhbHdheXMgaW1hZ2luZXMgYSBmaW5hbCBjbG9zaW5nIHNlZ21lbnQpLlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gZmFsc2U7IC8vIHNob3J0Y3V0ICh0aGlzIHBvbHlsaW5lIGhhcyBubyBwb2ludHMpXG5cbiAgICAgICAgdmFyIHggPSBwLng7XG4gICAgICAgIHZhciB5ID0gcC55O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgYSBmaW5hbCBjbG9zaW5nIHNlZ21lbnQgYnkgY3JlYXRpbmcgb25lIGZyb20gbGFzdC1maXJzdCBwb2ludHMgb24gcG9seWxpbmVcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBudW1Qb2ludHMgLSAxOyAvLyBzdGFydCBvZiBjdXJyZW50IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gMDsgLy8gZW5kIG9mIGN1cnJlbnQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICB2YXIgbnVtSW50ZXJzZWN0aW9ucyA9IDA7XG4gICAgICAgIHZhciBzZWdtZW50ID0gbmV3IExpbmUoKTtcbiAgICAgICAgdmFyIHJheSA9IG5ldyBMaW5lKCk7XG4gICAgICAgIHZhciByYXlFbmQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgZm9yICg7IGVuZEluZGV4IDwgbnVtUG9pbnRzOyBlbmRJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbc3RhcnRJbmRleF07XG4gICAgICAgICAgICB2YXIgZW5kID0gcG9pbnRzW2VuZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwLmVxdWFscyhzdGFydCkpIHJldHVybiB0cnVlOyAvLyBzaG9ydGN1dCAoYHBgIGlzIGEgcG9pbnQgb24gcG9seWxpbmUpXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHNlZ21lbnQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHNlZ21lbnQuZW5kID0gZW5kO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuY29udGFpbnNQb2ludChwKSkgcmV0dXJuIHRydWU7IC8vIHNob3J0Y3V0IChgcGAgbGllcyBvbiBhIHBvbHlsaW5lIHNlZ21lbnQpXG5cbiAgICAgICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gaW50ZXJzZWN0aW9uP1xuICAgICAgICAgICAgaWYgKCgoeSA8PSBzdGFydC55KSAmJiAoeSA+IGVuZC55KSkgfHwgKCh5ID4gc3RhcnQueSkgJiYgKHkgPD0gZW5kLnkpKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uYWwgYnJhbmNoIElTIE5PVCBlbnRlcmVkIHdoZW4gYHNlZ21lbnRgIGlzIGNvbGxpbmVhci9jb2luY2lkZW50IHdpdGggYHJheWBcbiAgICAgICAgICAgICAgICAvLyAod2hlbiBgeSA9PT0gc3RhcnQueSA9PT0gZW5kLnlgKVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uYWwgYnJhbmNoIElTIGVudGVyZWQgd2hlbiBgc2VnbWVudGAgdG91Y2hlcyBgcmF5YCBhdCBvbmx5IG9uZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIChlLmcuIHdoZW4gYHkgPT09IHN0YXJ0LnkgIT09IGVuZC55YClcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGlzIGJyYW5jaCBpcyBlbnRlcmVkIGFnYWluIGZvciB0aGUgZm9sbG93aW5nIHNlZ21lbnQsIHRoZSB0d28gdG91Y2hlcyBjYW5jZWwgb3V0XG5cbiAgICAgICAgICAgICAgICB2YXIgeERpZmZlcmVuY2UgPSAoKChzdGFydC54IC0geCkgPiAoZW5kLnggLSB4KSkgPyAoc3RhcnQueCAtIHgpIDogKGVuZC54IC0geCkpO1xuICAgICAgICAgICAgICAgIGlmICh4RGlmZmVyZW5jZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgbGllcyBhdCBsZWFzdCBwYXJ0aWFsbHkgdG8gdGhlIHJpZ2h0IG9mIGBwYFxuICAgICAgICAgICAgICAgICAgICByYXlFbmQueCA9IHggKyB4RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgcmF5RW5kLnkgPSB5OyAvLyByaWdodFxuICAgICAgICAgICAgICAgICAgICByYXkuc3RhcnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICByYXkuZW5kID0gcmF5RW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5pbnRlcnNlY3QocmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW50ZXJzZWN0aW9uIHdhcyBkZXRlY3RlZCB0byB0aGUgcmlnaHQgb2YgYHBgXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1JbnRlcnNlY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVsc2U6IGBzZWdtZW50YCBsaWVzIGNvbXBsZXRlbHkgdG8gdGhlIGxlZnQgb2YgYHBgIChpLmUuIG5vIGludGVyc2VjdGlvbiB0byB0aGUgcmlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdG8gY2hlY2sgdGhlIG5leHQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyBgdHJ1ZWAgZm9yIG9kZCBudW1iZXJzIG9mIGludGVyc2VjdGlvbnMgKGV2ZW4tb2RkIGFsZ29yaXRobSlcbiAgICAgICAgcmV0dXJuICgobnVtSW50ZXJzZWN0aW9ucyAlIDIpID09PSAxKTtcbiAgICB9LFxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHBvaW50cyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiAhc3RhcnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0LmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsZW5ndGhQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgfSxcblxuICAgIGNvbnZleEh1bGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKGNvbnZleEh1bGwodGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIHBvbHlsaW5lcyBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICAvLyBJZiBgcGAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybnMgZmFsc2UuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgb3RoZXJQb2ludHMgPSBwLnBvaW50cztcblxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG90aGVyUG9pbnRzLmxlbmd0aCAhPT0gbnVtUG9pbnRzKSByZXR1cm4gZmFsc2U7IC8vIGlmIHRoZSB0d28gcG9seWxpbmVzIGhhdmUgZGlmZmVyZW50IG51bWJlciBvZiBwb2ludHMsIHRoZXkgY2Fubm90IGJlIGVxdWFsXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICB2YXIgb3RoZXJQb2ludCA9IHAucG9pbnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBhcyBzb29uIGFzIGFuIGluZXF1YWxpdHkgaXMgZm91bmQgaW4gcG9pbnRzLCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGlmICghcG9pbnQuZXF1YWxzKG90aGVyUG9pbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBpbmVxdWFsaXR5IGZvdW5kIGluIHBvaW50cywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUobCk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbDIgPSBuZXcgTGluZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGggLSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsMi5zdGFydCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGwyLmVuZCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB2YXIgaW50ID0gbGluZS5pbnRlcnNlY3Rpb25XaXRoTGluZShsMik7XG4gICAgICAgICAgICBpZiAoaW50KSBpbnRlcnNlY3Rpb25zLnB1c2goaW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkgPyBpbnRlcnNlY3Rpb25zIDogbnVsbDtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGluZS5zdGFydCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxpbmUuZW5kID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYSBkaWZmZXJlbnRpYWJsZSBsaW5lIGlzIGZvdW5kIGJldHdlZW4gdHdvIHBvaW50cywgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIGlmIChsaW5lLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBkaWZmZXJlbnRpYWJsZSBsaW5lIGlzIGZvdW5kIGJldHdlZW4gcGFpcnMgb2YgcG9pbnRzLCByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgbiA9IG51bVBvaW50cyAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gcG9pbnRzW2ldLmRpc3RhbmNlKHBvaW50c1tpICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgcG9pbnRBdDogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIHBvaW50c1swXS5jbG9uZSgpOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gcG9pbnRzWzBdLmNsb25lKCk7XG4gICAgICAgIGlmIChyYXRpbyA+PSAxKSByZXR1cm4gcG9pbnRzW251bVBvaW50cyAtIDFdLmNsb25lKCk7XG5cbiAgICAgICAgdmFyIHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBvbHlsaW5lTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICAgIH0sXG5cbiAgICBwb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIHBvaW50c1swXS5jbG9uZSgpOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobiAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBhID0gcG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBiID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKGEsIGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhLmRpc3RhbmNlKGIpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5wb2ludEF0TGVuZ3RoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZSwgcmV0dXJuIGxhc3QgZW5kcG9pbnRcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IChmcm9tU3RhcnQgPyBwb2ludHNbbnVtUG9pbnRzIC0gMV0gOiBwb2ludHNbMF0pO1xuICAgICAgICByZXR1cm4gbGFzdFBvaW50LmNsb25lKCk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50c1tpXS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaW1wbGlmeTogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gdGhpczsgLy8gd2UgbmVlZCBhdCBsZWFzdCAzIHBvaW50c1xuXG4gICAgICAgIC8vIFRPRE86IHdlIG1heSBhbHNvIGFjY2VwdCBzdGFydEluZGV4IGFuZCBlbmRJbmRleCB0byBzcGVjaWZ5IHdoZXJlIHRvIHN0YXJ0IGFuZCBlbmQgc2ltcGxpZmljYXRpb25cblxuICAgICAgICAvLyBEdWUgdG8gdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtLCB3ZSBkbyBub3QgdXNlIDAgYXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGB0aHJlc2hvbGRgXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIHJvdW5kaW5nIGVycm9ycyB0aGF0IGNhbiBvY2N1ciB3aGVuIGNvbXBhcmluZyBkaXN0YW5jZXMuXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdC50aHJlc2hvbGQgfHwgMWUtMTA7IC8vID0gbWF4IGRpc3RhbmNlIG9mIG1pZGRsZSBwb2ludCBmcm9tIGNob3JkIHRvIGJlIHNpbXBsaWZpZWRcblxuICAgICAgICAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwb2x5bGluZSBhbmQgZ28gZm9yd2FyZFxuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgLy8gd2UgbmVlZCBhdCBsZWFzdCBvbmUgaW50ZXJtZWRpYXRlIHBvaW50ICgzIHBvaW50cykgaW4gZXZlcnkgaXRlcmF0aW9uXG4gICAgICAgIC8vIGFzIHNvb24gYXMgdGhhdCBzdG9wcyBiZWluZyB0cnVlLCB3ZSBrbm93IHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcG9seWxpbmVcbiAgICAgICAgd2hpbGUgKHBvaW50c1tjdXJyZW50SW5kZXggKyAyXSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDIpO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW2ZpcnN0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlUG9pbnQgPSBwb2ludHNbbWlkZGxlSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW2xhc3RJbmRleF07XG5cbiAgICAgICAgICAgIGNvbnN0IGNob3JkID0gbmV3IExpbmUoZmlyc3RQb2ludCwgbGFzdFBvaW50KTsgLy8gPSBjb25uZWN0aW9uIGJldHdlZW4gZmlyc3QgYW5kIGxhc3QgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IGNob3JkLmNsb3Nlc3RQb2ludChtaWRkbGVQb2ludCk7IC8vID0gY2xvc2VzdCBwb2ludCBvbiBjaG9yZCBmcm9tIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50RGlzdGFuY2UgPSBjbG9zZXN0UG9pbnQuZGlzdGFuY2UobWlkZGxlUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RQb2ludERpc3RhbmNlIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIC8vIG1pZGRsZSBwb2ludCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIGNob3JkID0gc2ltcGxpZnlcbiAgICAgICAgICAgICAgICAvLyAxKSByZW1vdmUgbWlkZGxlIHBvaW50OlxuICAgICAgICAgICAgICAgIHBvaW50cy5zcGxpY2UobWlkZGxlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIC8vIDIpIGluIG5leHQgaXRlcmF0aW9uLCBpbnZlc3RpZ2F0ZSB0aGUgbmV3bHktY3JlYXRlZCB0cmlwbGV0IG9mIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vICAgIC0gZG8gbm90IGNoYW5nZSBgY3VycmVudEluZGV4YFxuICAgICAgICAgICAgICAgIC8vICAgID0gKGZpcnN0IHBvaW50IHN0YXlzLCBwb2ludCBhZnRlciByZW1vdmVkIHBvaW50IGJlY29tZXMgbWlkZGxlIHBvaW50KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGUgcG9pbnQgaXMgZmFyIGZyb20gdGhlIGNob3JkXG4gICAgICAgICAgICAgICAgLy8gMSkgcHJlc2VydmUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gMikgaW4gbmV4dCBpdGVyYXRpb24sIG1vdmUgYGN1cnJlbnRJbmRleGAgYnkgb25lIHN0ZXA6XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gICAgPSAocG9pbnQgYWZ0ZXIgZmlyc3QgcG9pbnQgYmVjb21lcyBmaXJzdCBwb2ludClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBwb2ludHNgIGFycmF5IHdhcyBtb2RpZmllZCBpbi1wbGFjZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0OiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gbnVsbDsgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnRcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICB2YXIgcG9seWxpbmVMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcG9seWxpbmVMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIG51bGw7IC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBvaW50XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RWYWxpZExpbmU7IC8vIGRpZmZlcmVudGlhYmxlICh3aXRoIGEgdGFuZ2VudClcbiAgICAgICAgdmFyIGwgPSAwOyAvLyBsZW5ndGggc28gZmFyXG4gICAgICAgIHZhciBuID0gbnVtUG9pbnRzIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG4gLSAxIC0gaSkpO1xuXG4gICAgICAgICAgICB2YXIgYSA9IHBvaW50c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgYiA9IHBvaW50c1tpbmRleCArIDFdO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZShhLCBiKTtcbiAgICAgICAgICAgIHZhciBkID0gYS5kaXN0YW5jZShiKTtcblxuICAgICAgICAgICAgaWYgKGxpbmUuaXNEaWZmZXJlbnRpYWJsZSgpKSB7IC8vIGhhcyBhIHRhbmdlbnQgbGluZSAobGluZSBsZW5ndGggaXMgbm90IDApXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnRhbmdlbnRBdExlbmd0aCgoZnJvbVN0YXJ0ID8gMSA6IC0xKSAqIChsZW5ndGggLSBsKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkTGluZSA9IGxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCByZXF1ZXN0ZWQgaXMgaGlnaGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcG9seWxpbmUsIHJldHVybiBsYXN0IHZhbGlkIGVuZHBvaW50XG4gICAgICAgIGlmIChsYXN0VmFsaWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSAoZnJvbVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWYWxpZExpbmUudGFuZ2VudEF0KHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZhbGlkIGxpbmUsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzICsgJyc7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0udHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHN2Z1N0cmluZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlY3JlYXRlIHRoaXMgbGluZS5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiAnJzsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIG91dHB1dCArPSBwb2ludC54ICsgJywnICsgcG9pbnQueSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQudHJpbSgpO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bGluZS5wcm90b3R5cGUsICdzdGFydCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgcG9seWxpbmUuXG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzWzBdO1xuICAgIH0sXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHlsaW5lLnByb3RvdHlwZSwgJ2VuZCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBsYXN0IHBvaW50IG9mIHRoZSBwb2x5bGluZS5cblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHNbbnVtUG9pbnRzIC0gMV07XG4gICAgfSxcbn0pO1xuIl0sIm5hbWVzIjpbIlJlY3QiLCJQb2ludCIsIkxpbmUiLCJ0eXBlcyIsImNsb25lUG9pbnRzIiwicGFyc2VQb2ludHMiLCJjb252ZXhIdWxsIiwiUG9seWxpbmUiLCJwb2ludHMiLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInN2Z1N0cmluZyIsImZyb21SZWN0IiwicmVjdCIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbVJpZ2h0IiwiYm90dG9tTGVmdCIsInByb3RvdHlwZSIsInR5cGUiLCJiYm94IiwieDEiLCJJbmZpbml0eSIsIngyIiwieTEiLCJ5MiIsIm51bVBvaW50cyIsImxlbmd0aCIsImkiLCJwb2ludCIsIngiLCJ5IiwiY2xvbmUiLCJjbG9zZXN0UG9pbnQiLCJwIiwiY3BMZW5ndGgiLCJjbG9zZXN0UG9pbnRMZW5ndGgiLCJwb2ludEF0TGVuZ3RoIiwibGVuZ3RoUG9pbnRzIiwibWluU3FyRGlzdGFuY2UiLCJuIiwibGluZSIsImxpbmVMZW5ndGgiLCJjcE5vcm1hbGl6ZWRMZW5ndGgiLCJjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoIiwiY3AiLCJwb2ludEF0Iiwic3FyRGlzdGFuY2UiLCJzcXVhcmVkRGlzdGFuY2UiLCJjbG9zZXN0UG9pbnRUYW5nZW50IiwidGFuZ2VudEF0TGVuZ3RoIiwiY29udGFpbnNQb2ludCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIm51bUludGVyc2VjdGlvbnMiLCJzZWdtZW50IiwicmF5IiwicmF5RW5kIiwic3RhcnQiLCJlbmQiLCJlcXVhbHMiLCJ4RGlmZmVyZW5jZSIsImludGVyc2VjdCIsImNsb3NlIiwicHVzaCIsIm90aGVyUG9pbnRzIiwib3RoZXJQb2ludCIsImludGVyc2VjdGlvbldpdGhMaW5lIiwibCIsImludGVyc2VjdGlvbnMiLCJsMiIsImludCIsImlzRGlmZmVyZW50aWFibGUiLCJkaXN0YW5jZSIsInJhdGlvIiwicG9seWxpbmVMZW5ndGgiLCJmcm9tU3RhcnQiLCJpbmRleCIsImEiLCJiIiwiZCIsImxhc3RQb2ludCIsInJvdW5kIiwicHJlY2lzaW9uIiwic2NhbGUiLCJzeCIsInN5Iiwib3JpZ2luIiwic2ltcGxpZnkiLCJvcHQiLCJ0aHJlc2hvbGQiLCJjdXJyZW50SW5kZXgiLCJmaXJzdEluZGV4IiwibWlkZGxlSW5kZXgiLCJsYXN0SW5kZXgiLCJmaXJzdFBvaW50IiwibWlkZGxlUG9pbnQiLCJjaG9yZCIsImNsb3Nlc3RQb2ludERpc3RhbmNlIiwic3BsaWNlIiwidGFuZ2VudEF0IiwibGFzdFZhbGlkTGluZSIsInRvU3RyaW5nIiwidHJhbnNsYXRlIiwidHgiLCJ0eSIsInNlcmlhbGl6ZSIsIm91dHB1dCIsInRyaW0iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/polyline.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/rect.mjs":
/*!*********************************************!*\
  !*** ./node_modules/jointjs/src/g/rect.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   rect: () => (/* binding */ rect)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ellipse.mjs */ \"(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/jointjs/src/g/types.mjs\");\n\n\n\n\n\nconst { abs, cos, sin, min, max, round, pow } = Math;\nconst Rect = function(x, y, w, h) {\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n    if (Object(x) === x) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\nRect.fromEllipse = function(e) {\n    e = new _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__.Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\nRect.fromPointUnion = function(...points) {\n    if (points.length === 0) return null;\n    const p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n    for(let i = 0; i < points.length; i++){\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\nRect.fromRectUnion = function(...rects) {\n    if (rects.length === 0) return null;\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n    for(let i = 0; i < rects.length; i++){\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\nRect.prototype = {\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Rect,\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toRad)(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n    bottomLeft: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height);\n    },\n    bottomLine: function() {\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.bottomLeft(), this.bottomRight());\n    },\n    bottomMiddle: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height);\n    },\n    center: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n    clone: function() {\n        return new Rect(this);\n    },\n    // @return {bool} true if point p is inside me.\n    containsPoint: function(p) {\n        if (!(p instanceof _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point)) {\n            p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p);\n        }\n        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n    },\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n    corner: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height);\n    },\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n        var mr = new Rect(this).normalize();\n        var nr = new Rect(r).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n        if (dy === undefined) {\n            dy = dx;\n        }\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n        return this;\n    },\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n        // No intersection found\n        if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n    intersectionWithLine: function(line) {\n        var r = this;\n        var rectLines = [\n            r.topLine(),\n            r.rightLine(),\n            r.bottomLine(),\n            r.leftLine()\n        ];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n        var n = rectLines.length;\n        for(i = 0; i < n; i++){\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n        return points.length > 0 ? points : null;\n    },\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p);\n        var center = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n        if (angle) p.rotate(center, angle);\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(center, p);\n        for(var i = sides.length - 1; i >= 0; --i){\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n    leftLine: function() {\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.bottomLeft());\n    },\n    leftMiddle: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height / 2);\n    },\n    maxRectScaleToFit: function(rect, origin) {\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n    maxRectUniformScaleToFit: function(rect, origin) {\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.prototype.offset.call(this, dx, dy);\n    },\n    origin: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y);\n    },\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch(side){\n                case \"right\":\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, point.y);\n                case \"left\":\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, point.y);\n                case \"bottom\":\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y + this.height);\n                case \"top\":\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n    rightLine: function() {\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topRight(), this.bottomRight());\n    },\n    rightMiddle: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height / 2);\n    },\n    round: function(precision) {\n        let f = 1; // case 0\n        if (precision) {\n            switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow(10, precision);\n                    break;\n            }\n        }\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = this.x + this.width - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = this.y + this.height - point.y;\n        var closest = distToLeft;\n        var side = \"left\";\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = \"right\";\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = \"top\";\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = \"bottom\";\n        }\n        return side;\n    },\n    snapToGrid: function(gx, gy) {\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n    toJSON: function() {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height\n        };\n    },\n    topLine: function() {\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.topRight());\n    },\n    topMiddle: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y);\n    },\n    topRight: function() {\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y);\n    },\n    toString: function() {\n        return this.origin().toString() + \" \" + this.corner().toString();\n    },\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n        return Rect.fromRectUnion(this, rect);\n    },\n    update: function(x, y, w, h) {\n        if (Object(x) === x) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\nRect.prototype.bottomRight = Rect.prototype.corner;\nRect.prototype.topLeft = Rect.prototype.origin;\nRect.prototype.translate = Rect.prototype.offset;\n// For backwards compatibility:\nconst rect = Rect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy9yZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStDO0FBQ2I7QUFDRTtBQUNJO0FBQ0o7QUFFcEMsTUFBTSxFQUNGSyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsR0FBRyxFQUNIQyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxHQUFHLEVBQ04sR0FBR0M7QUFFRyxNQUFNQyxPQUFPLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFFbkMsSUFBSSxDQUFFLEtBQUksWUFBWUosSUFBRyxHQUFJO1FBQ3pCLE9BQU8sSUFBSUEsS0FBS0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDN0I7SUFFQSxJQUFLQyxPQUFPSixPQUFPQSxHQUFJO1FBQ25CQyxJQUFJRCxFQUFFQyxDQUFDO1FBQ1BDLElBQUlGLEVBQUVLLEtBQUs7UUFDWEYsSUFBSUgsRUFBRU0sTUFBTTtRQUNaTixJQUFJQSxFQUFFQSxDQUFDO0lBQ1g7SUFFQSxJQUFJLENBQUNBLENBQUMsR0FBR0EsTUFBTU8sWUFBWSxJQUFJUDtJQUMvQixJQUFJLENBQUNDLENBQUMsR0FBR0EsTUFBTU0sWUFBWSxJQUFJTjtJQUMvQixJQUFJLENBQUNJLEtBQUssR0FBR0gsTUFBTUssWUFBWSxJQUFJTDtJQUNuQyxJQUFJLENBQUNJLE1BQU0sR0FBR0gsTUFBTUksWUFBWSxJQUFJSjtBQUN4QyxFQUFFO0FBRUZKLEtBQUtTLFdBQVcsR0FBRyxTQUFTQyxDQUFDO0lBRXpCQSxJQUFJLElBQUlwQixpREFBT0EsQ0FBQ29CO0lBQ2hCLE9BQU8sSUFBSVYsS0FBS1UsRUFBRVQsQ0FBQyxHQUFHUyxFQUFFQyxDQUFDLEVBQUVELEVBQUVSLENBQUMsR0FBR1EsRUFBRUUsQ0FBQyxFQUFFLElBQUlGLEVBQUVDLENBQUMsRUFBRSxJQUFJRCxFQUFFRSxDQUFDO0FBQzFEO0FBRUFaLEtBQUthLGNBQWMsR0FBRyxTQUFT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QVE7SUFDbEU7SUFFQSw0REFBNEQ7SUFDNUR3RCxPQUFPLFNBQVM3QyxJQUFJO1FBRWhCLE9BQU8xRixLQUFLd0IsYUFBYSxDQUFDLElBQUksRUFBRWtFO0lBQ3BDO0lBRUFuRSxRQUFRLFNBQVN0QixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO1FBRXZCLElBQUtDLE9BQU9KLE9BQU9BLEdBQUk7WUFDbkJDLElBQUlELEVBQUVDLENBQUM7WUFDUEMsSUFBSUYsRUFBRUssS0FBSztZQUNYRixJQUFJSCxFQUFFTSxNQUFNO1lBQ1pOLElBQUlBLEVBQUVBLENBQUM7UUFDWDtRQUVBLElBQUksQ0FBQ0EsQ0FBQyxHQUFHQSxLQUFLO1FBQ2QsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLEtBQUs7UUFDZCxJQUFJLENBQUNJLEtBQUssR0FBR0gsS0FBSztRQUNsQixJQUFJLENBQUNJLE1BQU0sR0FBR0gsS0FBSztRQUNuQixPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUFKLEtBQUs2QixTQUFTLENBQUNXLFdBQVcsR0FBR3hDLEtBQUs2QixTQUFTLENBQUMyQixNQUFNO0FBRWxEeEQsS0FBSzZCLFNBQVMsQ0FBQzBELE9BQU8sR0FBR3ZGLEtBQUs2QixTQUFTLENBQUNvQyxNQUFNO0FBRTlDakUsS0FBSzZCLFNBQVMsQ0FBQzJHLFNBQVMsR0FBR3hJLEtBQUs2QixTQUFTLENBQUNzRixNQUFNO0FBRWhELCtCQUErQjtBQUN4QixNQUFNekIsT0FBTzFGLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL3JlY3QubWpzPzc0NTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9SYWQgfSBmcm9tICcuL2dlb21ldHJ5LmhlbHBlcnMubWpzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICcuL2xpbmUubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgRWxsaXBzZSB9IGZyb20gJy4vZWxsaXBzZS5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBhYnMsXG4gICAgY29zLFxuICAgIHNpbixcbiAgICBtaW4sXG4gICAgbWF4LFxuICAgIHJvdW5kLFxuICAgIHBvd1xufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiAoKE9iamVjdCh4KSA9PT0geCkpIHtcbiAgICAgICAgeSA9IHgueTtcbiAgICAgICAgdyA9IHgud2lkdGg7XG4gICAgICAgIGggPSB4LmhlaWdodDtcbiAgICAgICAgeCA9IHgueDtcbiAgICB9XG5cbiAgICB0aGlzLnggPSB4ID09PSB1bmRlZmluZWQgPyAwIDogeDtcbiAgICB0aGlzLnkgPSB5ID09PSB1bmRlZmluZWQgPyAwIDogeTtcbiAgICB0aGlzLndpZHRoID0gdyA9PT0gdW5kZWZpbmVkID8gMCA6IHc7XG4gICAgdGhpcy5oZWlnaHQgPSBoID09PSB1bmRlZmluZWQgPyAwIDogaDtcbn07XG5cblJlY3QuZnJvbUVsbGlwc2UgPSBmdW5jdGlvbihlKSB7XG5cbiAgICBlID0gbmV3IEVsbGlwc2UoZSk7XG4gICAgcmV0dXJuIG5ldyBSZWN0KGUueCAtIGUuYSwgZS55IC0gZS5iLCAyICogZS5hLCAyICogZS5iKTtcbn07XG5cblJlY3QuZnJvbVBvaW50VW5pb24gPSBmdW5jdGlvbiguLi5wb2ludHMpIHtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoKTtcbiAgICBsZXQgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICBtaW5YID0gbWluWSA9IEluZmluaXR5O1xuICAgIG1heFggPSBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcC51cGRhdGUocG9pbnRzW2ldKTtcbiAgICAgICAgY29uc3QgeCA9IHAueDtcbiAgICAgICAgY29uc3QgeSA9IHAueTtcblxuICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xufTtcblxuUmVjdC5mcm9tUmVjdFVuaW9uID0gZnVuY3Rpb24oLi4ucmVjdHMpIHtcblxuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgciA9IG5ldyBSZWN0KCk7XG4gICAgbGV0IG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgbWluWCA9IG1pblkgPSBJbmZpbml0eTtcbiAgICBtYXhYID0gbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgci51cGRhdGUocmVjdHNbaV0pO1xuICAgICAgICBjb25zdCB4ID0gci54O1xuICAgICAgICBjb25zdCB5ID0gci55O1xuICAgICAgICBjb25zdCBtWCA9IHggKyByLndpZHRoO1xuICAgICAgICBjb25zdCBtWSA9IHkgKyByLmhlaWdodDtcblxuICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICBpZiAobVggPiBtYXhYKSBtYXhYID0gbVg7XG4gICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgIGlmIChtWSA+IG1heFkpIG1heFkgPSBtWTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlY3QobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbn07XG5cblJlY3QucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuUmVjdCxcblxuICAgIC8vIEZpbmQgbXkgYm91bmRpbmcgYm94IHdoZW4gSSdtIHJvdGF0ZWQgd2l0aCB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIGluIHRoZSBjZW50ZXIgb2YgbWUuXG4gICAgLy8gQHJldHVybiByIHtyZWN0YW5nbGV9IHJlcHJlc2VudGluZyBhIGJvdW5kaW5nIGJveFxuICAgIGJib3g6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucm90YXRlQXJvdW5kQ2VudGVyKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgcm90YXRlQXJvdW5kQ2VudGVyOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICBpZiAoIWFuZ2xlKSByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0aGV0YSA9IHRvUmFkKGFuZ2xlKTtcbiAgICAgICAgY29uc3Qgc3QgPSBhYnMoc2luKHRoZXRhKSk7XG4gICAgICAgIGNvbnN0IGN0ID0gYWJzKGNvcyh0aGV0YSkpO1xuICAgICAgICBjb25zdCB3ID0gd2lkdGggKiBjdCArIGhlaWdodCAqIHN0O1xuICAgICAgICBjb25zdCBoID0gd2lkdGggKiBzdCArIGhlaWdodCAqIGN0O1xuICAgICAgICB0aGlzLnggKz0gKHdpZHRoIC0gdykgLyAyO1xuICAgICAgICB0aGlzLnkgKz0gKGhlaWdodCAtIGgpIC8gMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJvdHRvbUxlZnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGJvdHRvbUxpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLmJvdHRvbUxlZnQoKSwgdGhpcy5ib3R0b21SaWdodCgpKTtcbiAgICB9LFxuXG4gICAgYm90dG9tTWlkZGxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBwb2ludCBwIGlzIGluc2lkZSBtZS5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwLnggPj0gdGhpcy54ICYmIHAueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHAueSA+PSB0aGlzLnkgJiYgcC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtib29sfSB0cnVlIGlmIHJlY3RhbmdsZSBgcmAgaXMgaW5zaWRlIG1lLlxuICAgIGNvbnRhaW5zUmVjdDogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHZhciByMCA9IG5ldyBSZWN0KHRoaXMpLm5vcm1hbGl6ZSgpO1xuICAgICAgICB2YXIgcjEgPSBuZXcgUmVjdChyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIHcwID0gcjAud2lkdGg7XG4gICAgICAgIHZhciBoMCA9IHIwLmhlaWdodDtcbiAgICAgICAgdmFyIHcxID0gcjEud2lkdGg7XG4gICAgICAgIHZhciBoMSA9IHIxLmhlaWdodDtcblxuICAgICAgICBpZiAoIXcwIHx8ICFoMCB8fCAhdzEgfHwgIWgxKSB7XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgMFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgwID0gcjAueDtcbiAgICAgICAgdmFyIHkwID0gcjAueTtcbiAgICAgICAgdmFyIHgxID0gcjEueDtcbiAgICAgICAgdmFyIHkxID0gcjEueTtcblxuICAgICAgICB3MSArPSB4MTtcbiAgICAgICAgdzAgKz0geDA7XG4gICAgICAgIGgxICs9IHkxO1xuICAgICAgICBoMCArPSB5MDtcblxuICAgICAgICByZXR1cm4geDAgPD0geDEgJiYgdzEgPD0gdzAgJiYgeTAgPD0geTEgJiYgaDEgPD0gaDA7XG4gICAgfSxcblxuICAgIGNvcm5lcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcmVjdGFuZ2xlcyBhcmUgZXF1YWwuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgdmFyIG1yID0gKG5ldyBSZWN0KHRoaXMpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIG5yID0gKG5ldyBSZWN0KHIpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1yLnggPT09IG5yLnggJiYgbXIueSA9PT0gbnIueSAmJiBtci53aWR0aCA9PT0gbnIud2lkdGggJiYgbXIuaGVpZ2h0ID09PSBuci5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8vIGluZmxhdGUgYnkgZHggYW5kIGR5LCByZWNvbXB1dGUgb3JpZ2luIFt4LCB5XVxuICAgIC8vIEBwYXJhbSBkeCB7ZGVsdGFfeH0gcmVwcmVzZW50aW5nIGFkZGl0aW9uYWwgc2l6ZSB0byB4XG4gICAgLy8gQHBhcmFtIGR5IHtkZWx0YV95fSByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBzaXplIHRvIHkgLVxuICAgIC8vIGR5IHBhcmFtIGlzIG5vdCByZXF1aXJlZCAtPiBpbiB0aGF0IGNhc2UgeSBpcyBzaXplZCBieSBkeFxuICAgIGluZmxhdGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xuXG4gICAgICAgIGlmIChkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAtPSBkeDtcbiAgICAgICAgdGhpcy55IC09IGR5O1xuICAgICAgICB0aGlzLndpZHRoICs9IDIgKiBkeDtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gMiAqIGR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtyZWN0fSBpZiByZWN0YW5nbGVzIGludGVyc2VjdCwge251bGx9IGlmIG5vdC5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgICB2YXIgbXlPcmlnaW4gPSB0aGlzLm9yaWdpbigpO1xuICAgICAgICB2YXIgbXlDb3JuZXIgPSB0aGlzLmNvcm5lcigpO1xuICAgICAgICB2YXIgck9yaWdpbiA9IHIub3JpZ2luKCk7XG4gICAgICAgIHZhciByQ29ybmVyID0gci5jb3JuZXIoKTtcblxuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb24gZm91bmRcbiAgICAgICAgaWYgKHJDb3JuZXIueCA8PSBteU9yaWdpbi54IHx8XG4gICAgICAgICAgICByQ29ybmVyLnkgPD0gbXlPcmlnaW4ueSB8fFxuICAgICAgICAgICAgck9yaWdpbi54ID49IG15Q29ybmVyLnggfHxcbiAgICAgICAgICAgIHJPcmlnaW4ueSA+PSBteUNvcm5lci55KSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgeCA9IG1heChteU9yaWdpbi54LCByT3JpZ2luLngpO1xuICAgICAgICB2YXIgeSA9IG1heChteU9yaWdpbi55LCByT3JpZ2luLnkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCBtaW4obXlDb3JuZXIueCwgckNvcm5lci54KSAtIHgsIG1pbihteUNvcm5lci55LCByQ29ybmVyLnkpIC0geSk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgICB2YXIgcmVjdExpbmVzID0gW3IudG9wTGluZSgpLCByLnJpZ2h0TGluZSgpLCByLmJvdHRvbUxpbmUoKSwgci5sZWZ0TGluZSgpXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgZGVkdXBlQXJyID0gW107XG4gICAgICAgIHZhciBwdCwgaTtcblxuICAgICAgICB2YXIgbiA9IHJlY3RMaW5lcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgcHQgPSBsaW5lLmludGVyc2VjdChyZWN0TGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHB0ICE9PSBudWxsICYmIGRlZHVwZUFyci5pbmRleE9mKHB0LnRvU3RyaW5nKCkpIDwgMCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHB0KTtcbiAgICAgICAgICAgICAgICBkZWR1cGVBcnIucHVzaChwdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludHMubGVuZ3RoID4gMCA/IHBvaW50cyA6IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgcG9pbnQgb24gbXkgYm91bmRhcnkgd2hlcmUgbGluZSBzdGFydGluZ1xuICAgIC8vIGZyb20gbXkgY2VudGVyIGVuZGluZyBpbiBwb2ludCBwIGludGVyc2VjdHMgbWUuXG4gICAgLy8gQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIElmIGFuZ2xlIGlzIHNwZWNpZmllZCwgaW50ZXJzZWN0aW9uIHdpdGggcm90YXRlZCByZWN0YW5nbGUgaXMgY29tcHV0ZWQuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludDogZnVuY3Rpb24ocCwgYW5nbGUpIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmIChhbmdsZSkgcC5yb3RhdGUoY2VudGVyLCBhbmdsZSk7XG5cbiAgICAgICAgLy8gKGNsb2Nrd2lzZSwgc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHNpZGUpXG4gICAgICAgIHZhciBzaWRlcyA9IFtcbiAgICAgICAgICAgIHRoaXMudG9wTGluZSgpLFxuICAgICAgICAgICAgdGhpcy5yaWdodExpbmUoKSxcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGluZSgpLFxuICAgICAgICAgICAgdGhpcy5sZWZ0TGluZSgpXG4gICAgICAgIF07XG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgTGluZShjZW50ZXIsIHApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHNpZGVzW2ldLmludGVyc2VjdGlvbihjb25uZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGFuZ2xlKSByZXN1bHQucm90YXRlKGNlbnRlciwgLWFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgbGVmdExpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLnRvcExlZnQoKSwgdGhpcy5ib3R0b21MZWZ0KCkpO1xuICAgIH0sXG5cbiAgICBsZWZ0TWlkZGxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICB9LFxuXG4gICAgbWF4UmVjdFNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHJlY3QsIG9yaWdpbikge1xuXG4gICAgICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0KTtcbiAgICAgICAgb3JpZ2luIHx8IChvcmlnaW4gPSByZWN0LmNlbnRlcigpKTtcblxuICAgICAgICB2YXIgc3gxLCBzeDIsIHN4Mywgc3g0LCBzeTEsIHN5Miwgc3kzLCBzeTQ7XG4gICAgICAgIHZhciBveCA9IG9yaWdpbi54O1xuICAgICAgICB2YXIgb3kgPSBvcmlnaW4ueTtcblxuICAgICAgICAvLyBIZXJlIHdlIGZpbmQgdGhlIG1heGltYWwgcG9zc2libGUgc2NhbGUgZm9yIGFsbCBjb3JuZXIgcG9pbnRzIChmb3IgeCBhbmQgeSBheGlzKSBvZiB0aGUgcmVjdGFuZ2xlLFxuICAgICAgICAvLyBzbyB3aGVuIHRoZSBzY2FsZSBpcyBhcHBsaWVkIHRoZSBwb2ludCBpcyBzdGlsbCBpbnNpZGUgdGhlIHJlY3RhbmdsZS5cblxuICAgICAgICBzeDEgPSBzeDIgPSBzeDMgPSBzeDQgPSBzeTEgPSBzeTIgPSBzeTMgPSBzeTQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBUb3AgTGVmdFxuICAgICAgICB2YXIgcDEgPSByZWN0LnRvcExlZnQoKTtcbiAgICAgICAgaWYgKHAxLnggPCBveCkge1xuICAgICAgICAgICAgc3gxID0gKHRoaXMueCAtIG94KSAvIChwMS54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMS55IDwgb3kpIHtcbiAgICAgICAgICAgIHN5MSA9ICh0aGlzLnkgLSBveSkgLyAocDEueSAtIG95KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb3R0b20gUmlnaHRcbiAgICAgICAgdmFyIHAyID0gcmVjdC5ib3R0b21SaWdodCgpO1xuICAgICAgICBpZiAocDIueCA+IG94KSB7XG4gICAgICAgICAgICBzeDIgPSAodGhpcy54ICsgdGhpcy53aWR0aCAtIG94KSAvIChwMi54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMi55ID4gb3kpIHtcbiAgICAgICAgICAgIHN5MiA9ICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIG95KSAvIChwMi55IC0gb3kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcCBSaWdodFxuICAgICAgICB2YXIgcDMgPSByZWN0LnRvcFJpZ2h0KCk7XG4gICAgICAgIGlmIChwMy54ID4gb3gpIHtcbiAgICAgICAgICAgIHN4MyA9ICh0aGlzLnggKyB0aGlzLndpZHRoIC0gb3gpIC8gKHAzLnggLSBveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAzLnkgPCBveSkge1xuICAgICAgICAgICAgc3kzID0gKHRoaXMueSAtIG95KSAvIChwMy55IC0gb3kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAgICAgIHZhciBwNCA9IHJlY3QuYm90dG9tTGVmdCgpO1xuICAgICAgICBpZiAocDQueCA8IG94KSB7XG4gICAgICAgICAgICBzeDQgPSAodGhpcy54IC0gb3gpIC8gKHA0LnggLSBveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHA0LnkgPiBveSkge1xuICAgICAgICAgICAgc3k0ID0gKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gb3kpIC8gKHA0LnkgLSBveSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3g6IG1pbihzeDEsIHN4Miwgc3gzLCBzeDQpLFxuICAgICAgICAgICAgc3k6IG1pbihzeTEsIHN5Miwgc3kzLCBzeTQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG1heFJlY3RVbmlmb3JtU2NhbGVUb0ZpdDogZnVuY3Rpb24ocmVjdCwgb3JpZ2luKSB7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5tYXhSZWN0U2NhbGVUb0ZpdChyZWN0LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gbWluKHNjYWxlLnN4LCBzY2FsZS5zeSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmUgYW5kIGV4cGFuZCBtZS5cbiAgICAvLyBAcGFyYW0gciB7cmVjdGFuZ2xlfSByZXByZXNlbnRpbmcgZGVsdGFzXG4gICAgbW92ZUFuZEV4cGFuZDogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHRoaXMueCArPSByLnggfHwgMDtcbiAgICAgICAgdGhpcy55ICs9IHIueSB8fCAwO1xuICAgICAgICB0aGlzLndpZHRoICs9IHIud2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gci5oZWlnaHQgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcmVjdGFuZ2xlOyBpLmUuLCBtYWtlIGl0IHNvIHRoYXQgaXQgaGFzIGEgbm9uLW5lZ2F0aXZlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgLy8gSWYgd2lkdGggPCAwIHRoZSBmdW5jdGlvbiBzd2FwcyB0aGUgbGVmdCBhbmQgcmlnaHQgY29ybmVycyxcbiAgICAvLyBhbmQgaXQgc3dhcHMgdGhlIHRvcCBhbmQgYm90dG9tIGNvcm5lcnMgaWYgaGVpZ2h0IDwgMFxuICAgIC8vIGxpa2UgaW4gaHR0cDovL3F0LXByb2plY3Qub3JnL2RvYy9xdC00LjgvcXJlY3RmLmh0bWwjbm9ybWFsaXplZFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG5ld3ggPSB0aGlzLng7XG4gICAgICAgIHZhciBuZXd5ID0gdGhpcy55O1xuICAgICAgICB2YXIgbmV3d2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB2YXIgbmV3aGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIDwgMCkge1xuICAgICAgICAgICAgbmV3eCA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICBuZXd3aWR0aCA9IC10aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG5ld3kgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIG5ld2hlaWdodCA9IC10aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSBuZXd4O1xuICAgICAgICB0aGlzLnkgPSBuZXd5O1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3d2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3aGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gT2Zmc2V0IG1lIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LlxuICAgIG9mZnNldDogZnVuY3Rpb24oZHgsIGR5KSB7XG5cbiAgICAgICAgLy8gcHJldGVuZCB0aGF0IHRoaXMgaXMgYSBwb2ludCBhbmQgY2FsbCBvZmZzZXQoKVxuICAgICAgICAvLyByZXdyaXRlcyB4IGFuZCB5IGFjY29yZGluZyB0byBkeCBhbmQgZHlcbiAgICAgICAgcmV0dXJuIFBvaW50LnByb3RvdHlwZS5vZmZzZXQuY2FsbCh0aGlzLCBkeCwgZHkpO1xuICAgIH0sXG5cbiAgICBvcmlnaW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gYSBwb2ludCBvbiBteSBib3VuZGFyeSBuZWFyZXN0IHRvIHRoZSBnaXZlbiBwb2ludC5cbiAgICAvLyBAc2VlIFNxdWVhayBTbWFsbHRhbGssIFJlY3RhbmdsZT4+cG9pbnROZWFyZXN0VG86XG4gICAgcG9pbnROZWFyZXN0VG9Qb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICBwb2ludCA9IG5ldyBQb2ludChwb2ludCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICB2YXIgc2lkZSA9IHRoaXMuc2lkZU5lYXJlc3RUb1BvaW50KHBvaW50KTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgdGhpcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQuYWRoZXJlVG9SZWN0KHRoaXMpO1xuICAgIH0sXG5cbiAgICByaWdodExpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLnRvcFJpZ2h0KCksIHRoaXMuYm90dG9tUmlnaHQoKSk7XG4gICAgfSxcblxuICAgIHJpZ2h0TWlkZGxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICBsZXQgZiA9IDE7IC8vIGNhc2UgMFxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZiA9IDEwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IGYgPSAxMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZiA9IDEwMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGYgPSBwb3coMTAsIHByZWNpc2lvbik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0gcm91bmQodGhpcy54ICogZikgLyBmO1xuICAgICAgICB0aGlzLnkgPSByb3VuZCh0aGlzLnkgKiBmKSAvIGY7XG4gICAgICAgIHRoaXMud2lkdGggPSByb3VuZCh0aGlzLndpZHRoICogZikgLyBmO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHJvdW5kKHRoaXMuaGVpZ2h0ICogZikgLyBmO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2NhbGUgcmVjdGFuZ2xlIHdpdGggb3JpZ2luLlxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luKCkuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLnggPSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy55ID0gb3JpZ2luLnk7XG4gICAgICAgIHRoaXMud2lkdGggKj0gc3g7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICo9IHN5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7c3RyaW5nfSAobGVmdHxyaWdodHx0b3B8Ym90dG9tKSBzaWRlIHdoaWNoIGlzIG5lYXJlc3QgdG8gcG9pbnRcbiAgICAvLyBAc2VlIFNxdWVhayBTbWFsbHRhbGssIFJlY3RhbmdsZT4+c2lkZU5lYXJlc3RUbzpcbiAgICBzaWRlTmVhcmVzdFRvUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgZGlzdFRvTGVmdCA9IHBvaW50LnggLSB0aGlzLng7XG4gICAgICAgIHZhciBkaXN0VG9SaWdodCA9ICh0aGlzLnggKyB0aGlzLndpZHRoKSAtIHBvaW50Lng7XG4gICAgICAgIHZhciBkaXN0VG9Ub3AgPSBwb2ludC55IC0gdGhpcy55O1xuICAgICAgICB2YXIgZGlzdFRvQm90dG9tID0gKHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHBvaW50Lnk7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gZGlzdFRvTGVmdDtcbiAgICAgICAgdmFyIHNpZGUgPSAnbGVmdCc7XG5cbiAgICAgICAgaWYgKGRpc3RUb1JpZ2h0IDwgY2xvc2VzdCkge1xuICAgICAgICAgICAgY2xvc2VzdCA9IGRpc3RUb1JpZ2h0O1xuICAgICAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RUb1RvcCA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBkaXN0VG9Ub3A7XG4gICAgICAgICAgICBzaWRlID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RUb0JvdHRvbSA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgPSBkaXN0VG9Cb3R0b207XG4gICAgICAgICAgICBzaWRlID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZGU7XG4gICAgfSxcblxuICAgIHNuYXBUb0dyaWQ6IGZ1bmN0aW9uKGd4LCBneSkge1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbigpLnNuYXBUb0dyaWQoZ3gsIGd5KTtcbiAgICAgICAgdmFyIGNvcm5lciA9IHRoaXMuY29ybmVyKCkuc25hcFRvR3JpZChneCwgZ3kpO1xuICAgICAgICB0aGlzLnggPSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy55ID0gb3JpZ2luLnk7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb3JuZXIueCAtIG9yaWdpbi54O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGNvcm5lci55IC0gb3JpZ2luLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55LCB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9O1xuICAgIH0sXG5cbiAgICB0b3BMaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy50b3BMZWZ0KCksIHRoaXMudG9wUmlnaHQoKSk7XG4gICAgfSxcblxuICAgIHRvcE1pZGRsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgdG9wUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbigpLnRvU3RyaW5nKCkgKyAnICcgKyB0aGlzLmNvcm5lcigpLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3JlY3R9IHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgYm90aCByZWN0YW5nbGVzLlxuICAgIHVuaW9uOiBmdW5jdGlvbihyZWN0KSB7XG5cbiAgICAgICAgcmV0dXJuIFJlY3QuZnJvbVJlY3RVbmlvbih0aGlzLCByZWN0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cbiAgICAgICAgaWYgKChPYmplY3QoeCkgPT09IHgpKSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgdyA9IHgud2lkdGg7XG4gICAgICAgICAgICBoID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSB3IHx8IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaCB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5SZWN0LnByb3RvdHlwZS5ib3R0b21SaWdodCA9IFJlY3QucHJvdG90eXBlLmNvcm5lcjtcblxuUmVjdC5wcm90b3R5cGUudG9wTGVmdCA9IFJlY3QucHJvdG90eXBlLm9yaWdpbjtcblxuUmVjdC5wcm90b3R5cGUudHJhbnNsYXRlID0gUmVjdC5wcm90b3R5cGUub2Zmc2V0O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG5leHBvcnQgY29uc3QgcmVjdCA9IFJlY3Q7XG4iXSwibmFtZXMiOlsidG9SYWQiLCJMaW5lIiwiUG9pbnQiLCJFbGxpcHNlIiwidHlwZXMiLCJhYnMiLCJjb3MiLCJzaW4iLCJtaW4iLCJtYXgiLCJyb3VuZCIsInBvdyIsIk1hdGgiLCJSZWN0IiwieCIsInkiLCJ3IiwiaCIsIk9iamVjdCIsIndpZHRoIiwiaGVpZ2h0IiwidW5kZWZpbmVkIiwiZnJvbUVsbGlwc2UiLCJlIiwiYSIsImIiLCJmcm9tUG9pbnRVbmlvbiIsInBvaW50cyIsImxlbmd0aCIsInAiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiSW5maW5pdHkiLCJpIiwidXBkYXRlIiwiZnJvbVJlY3RVbmlvbiIsInJlY3RzIiwiciIsIm1YIiwibVkiLCJwcm90b3R5cGUiLCJ0eXBlIiwiYmJveCIsImFuZ2xlIiwiY2xvbmUiLCJyb3RhdGVBcm91bmRDZW50ZXIiLCJ0aGV0YSIsInN0IiwiY3QiLCJib3R0b21MZWZ0IiwiYm90dG9tTGluZSIsImJvdHRvbVJpZ2h0IiwiYm90dG9tTWlkZGxlIiwiY2VudGVyIiwiY29udGFpbnNQb2ludCIsImNvbnRhaW5zUmVjdCIsInIwIiwibm9ybWFsaXplIiwicjEiLCJ3MCIsImgwIiwidzEiLCJoMSIsIngwIiwieTAiLCJ4MSIsInkxIiwiY29ybmVyIiwiZXF1YWxzIiwibXIiLCJuciIsImluZmxhdGUiLCJkeCIsImR5IiwiaW50ZXJzZWN0IiwibXlPcmlnaW4iLCJvcmlnaW4iLCJteUNvcm5lciIsInJPcmlnaW4iLCJyQ29ybmVyIiwiaW50ZXJzZWN0aW9uV2l0aExpbmUiLCJsaW5lIiwicmVjdExpbmVzIiwidG9wTGluZSIsInJpZ2h0TGluZSIsImxlZnRMaW5lIiwiZGVkdXBlQXJyIiwicHQiLCJuIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwicHVzaCIsImludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQiLCJyZXN1bHQiLCJyb3RhdGUiLCJzaWRlcyIsImNvbm5lY3RvciIsImludGVyc2VjdGlvbiIsInRvcExlZnQiLCJsZWZ0TWlkZGxlIiwibWF4UmVjdFNjYWxlVG9GaXQiLCJyZWN0Iiwic3gxIiwic3gyIiwic3gzIiwic3g0Iiwic3kxIiwic3kyIiwic3kzIiwic3k0Iiwib3giLCJveSIsInAxIiwicDIiLCJwMyIsInRvcFJpZ2h0IiwicDQiLCJzeCIsInN5IiwibWF4UmVjdFVuaWZvcm1TY2FsZVRvRml0Iiwic2NhbGUiLCJtb3ZlQW5kRXhwYW5kIiwibmV3eCIsIm5ld3kiLCJuZXd3aWR0aCIsIm5ld2hlaWdodCIsIm9mZnNldCIsImNhbGwiLCJwb2ludE5lYXJlc3RUb1BvaW50IiwicG9pbnQiLCJzaWRlIiwic2lkZU5lYXJlc3RUb1BvaW50IiwiYWRoZXJlVG9SZWN0IiwicmlnaHRNaWRkbGUiLCJwcmVjaXNpb24iLCJmIiwiZGlzdFRvTGVmdCIsImRpc3RUb1JpZ2h0IiwiZGlzdFRvVG9wIiwiZGlzdFRvQm90dG9tIiwiY2xvc2VzdCIsInNuYXBUb0dyaWQiLCJneCIsImd5IiwidG9KU09OIiwidG9wTWlkZGxlIiwidW5pb24iLCJ0cmFuc2xhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/rect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/g/types.mjs":
/*!**********************************************!*\
  !*** ./node_modules/jointjs/src/g/types.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\nconst types = {\n    Point: 1,\n    Line: 2,\n    Ellipse: 3,\n    Rect: 4,\n    Polyline: 5,\n    Polygon: 6,\n    Curve: 7,\n    Path: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvZy90eXBlcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFFBQVE7SUFDakJDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsTUFBTTtBQUNWLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9nL3R5cGVzLm1qcz8yYTA4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB0eXBlcyA9IHtcbiAgICBQb2ludDogMSxcbiAgICBMaW5lOiAyLFxuICAgIEVsbGlwc2U6IDMsXG4gICAgUmVjdDogNCxcbiAgICBQb2x5bGluZTogNSxcbiAgICBQb2x5Z29uOiA2LFxuICAgIEN1cnZlOiA3LFxuICAgIFBhdGg6IDhcbn07XG4iXSwibmFtZXMiOlsidHlwZXMiLCJQb2ludCIsIkxpbmUiLCJFbGxpcHNlIiwiUmVjdCIsIlBvbHlsaW5lIiwiUG9seWdvbiIsIkN1cnZlIiwiUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/g/types.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/addClass.mjs":
/*!************************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/addClass.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* binding */ addClass)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n\n\n\nconst className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.addClassNamePrefix(\"highlighted\");\nconst addClass = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__.HighlighterView.extend({\n    UPDATABLE: false,\n    MOUNTABLE: false,\n    options: {\n        className\n    },\n    highlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).addClass(this.options.className);\n    },\n    unhighlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).removeClass(this.options.className);\n    }\n}, {\n    // Backwards Compatibility\n    className\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL2FkZENsYXNzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ1g7QUFDOEI7QUFFN0QsTUFBTUcsWUFBWUgsK0RBQXVCLENBQUM7QUFFbkMsTUFBTUssV0FBV0gscUVBQWVBLENBQUNJLE1BQU0sQ0FBQztJQUUzQ0MsV0FBVztJQUNYQyxXQUFXO0lBRVhDLFNBQVM7UUFDTE47SUFDSjtJQUVBTyxXQUFXLFNBQVNDLFNBQVMsRUFBRUMsSUFBSTtRQUMvQlgsd0RBQUNBLENBQUNXLE1BQU1QLFFBQVEsQ0FBQyxJQUFJLENBQUNJLE9BQU8sQ0FBQ04sU0FBUztJQUMzQztJQUVBVSxhQUFhLFNBQVNGLFNBQVMsRUFBRUMsSUFBSTtRQUNqQ1gsd0RBQUNBLENBQUNXLE1BQU1FLFdBQVcsQ0FBQyxJQUFJLENBQUNMLE9BQU8sQ0FBQ04sU0FBUztJQUM5QztBQUVKLEdBQUc7SUFDQywwQkFBMEI7SUFDMUJBO0FBQ0osR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2hpZ2hsaWdodGVycy9hZGRDbGFzcy5tanM/YTY1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcblxuY29uc3QgY2xhc3NOYW1lID0gdXRpbC5hZGRDbGFzc05hbWVQcmVmaXgoJ2hpZ2hsaWdodGVkJyk7XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzcyA9IEhpZ2hsaWdodGVyVmlldy5leHRlbmQoe1xuXG4gICAgVVBEQVRBQkxFOiBmYWxzZSxcbiAgICBNT1VOVEFCTEU6IGZhbHNlLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbGFzc05hbWVcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihfY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgVihub2RlKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbm9kZSkge1xuICAgICAgICBWKG5vZGUpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpO1xuICAgIH1cblxufSwge1xuICAgIC8vIEJhY2t3YXJkcyBDb21wYXRpYmlsaXR5XG4gICAgY2xhc3NOYW1lXG59KTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwiViIsIkhpZ2hsaWdodGVyVmlldyIsImNsYXNzTmFtZSIsImFkZENsYXNzTmFtZVByZWZpeCIsImFkZENsYXNzIiwiZXh0ZW5kIiwiVVBEQVRBQkxFIiwiTU9VTlRBQkxFIiwib3B0aW9ucyIsImhpZ2hsaWdodCIsIl9jZWxsVmlldyIsIm5vZGUiLCJ1bmhpZ2hsaWdodCIsInJlbW92ZUNsYXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/addClass.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* reexport safe */ _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__.addClass),\n/* harmony export */   list: () => (/* reexport safe */ _list_mjs__WEBPACK_IMPORTED_MODULE_4__.list),\n/* harmony export */   mask: () => (/* reexport safe */ _mask_mjs__WEBPACK_IMPORTED_MODULE_1__.mask),\n/* harmony export */   opacity: () => (/* reexport safe */ _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__.opacity),\n/* harmony export */   stroke: () => (/* reexport safe */ _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__.stroke)\n/* harmony export */ });\n/* harmony import */ var _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stroke.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/stroke.mjs\");\n/* harmony import */ var _mask_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mask.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/mask.mjs\");\n/* harmony import */ var _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opacity.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/opacity.mjs\");\n/* harmony import */ var _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addClass.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/addClass.mjs\");\n/* harmony import */ var _list_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.mjs */ \"(ssr)/./node_modules/jointjs/src/highlighters/list.mjs\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0Y7QUFDRztBQUNDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9oaWdobGlnaHRlcnMvaW5kZXgubWpzP2JjZGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9zdHJva2UubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vbWFzay5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vcGFjaXR5Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FkZENsYXNzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpc3QubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/list.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/list.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   list: () => (/* binding */ list)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/getRectPoint.mjs */ \"(ssr)/./node_modules/jointjs/src/util/getRectPoint.mjs\");\n\n\n\n\nconst Directions = {\n    ROW: \"row\",\n    COLUMN: \"column\"\n};\nconst list = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n    tagName: \"g\",\n    MOUNTABLE: true,\n    UPDATE_ATTRIBUTES: function() {\n        return [\n            this.options.attribute\n        ];\n    },\n    _prevItems: null,\n    highlight (elementView, node) {\n        const element = elementView.model;\n        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;\n        if (!attribute) throw new Error(\"List: attribute is required\");\n        const normalizedSize = typeof size === \"number\" ? {\n            width: size,\n            height: size\n        } : size;\n        const isRowDirection = direction === Directions.ROW;\n        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n        let items = element.get(attribute);\n        if (!Array.isArray(items)) items = [];\n        const prevItems = this._prevItems || [];\n        const comparison = items.map((item, index)=>(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(prevItems[index], items[index]));\n        if (prevItems.length !== items.length || comparison.some((unchanged)=>!unchanged)) {\n            const prevEls = this.vel.children();\n            const itemsEls = items.map((item, index)=>{\n                const prevEl = index in prevEls ? prevEls[index].node : null;\n                if (comparison[index]) return prevEl;\n                const itemEl = this.createListItem(item, normalizedSize, prevEl);\n                if (!itemEl) return null;\n                if (!(itemEl instanceof SVGElement)) throw new Error(\"List: item must be an SVGElement\");\n                itemEl.dataset.index = index;\n                itemEl.dataset.attribute = attribute;\n                const offset = index * (itemWidth + gap);\n                itemEl.setAttribute(\"transform\", isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);\n                return itemEl;\n            });\n            this.vel.empty().append(itemsEls);\n            this._prevItems = items;\n        }\n        const itemsCount = items.length;\n        const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;\n        const listSize = isRowDirection ? {\n            width: length,\n            height: normalizedSize.height\n        } : {\n            width: normalizedSize.width,\n            height: length\n        };\n        this.position(element, listSize);\n    },\n    position (element, listSize) {\n        const { vel, options } = this;\n        const { margin = 5, position = \"top-left\" } = options;\n        const { width, height } = element.size();\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides)(margin);\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(left, top, width - (left + right), height - (top + bottom));\n        let { x, y } = (0,_util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.getRectPoint)(bbox, position);\n        // x\n        switch(position){\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM:\n                {\n                    x -= listSize.width / 2;\n                    break;\n                }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP_RIGHT:\n                {\n                    x -= listSize.width;\n                    break;\n                }\n        }\n        // y\n        switch(position){\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.LEFT:\n                {\n                    y -= listSize.height / 2;\n                    break;\n                }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_LEFT:\n                {\n                    y -= listSize.height;\n                    break;\n                }\n        }\n        vel.attr(\"transform\", `translate(${x}, ${y})`);\n    }\n}, {\n    Directions,\n    Positions: _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL2xpc3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzQztBQUN1QjtBQUlsQztBQUlPO0FBRWxDLE1BQU1NLGFBQWE7SUFDZkMsS0FBSztJQUNMQyxRQUFRO0FBQ1o7QUFFTyxNQUFNQyxPQUFPUixxRUFBZUEsQ0FBQ1MsTUFBTSxDQUFDO0lBRXZDQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsbUJBQW1CO1FBQ2YsT0FBTztZQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxTQUFTO1NBQUM7SUFDbkM7SUFFQUMsWUFBWTtJQUVaQyxXQUFVQyxXQUFXLEVBQUVDLElBQUk7UUFDdkIsTUFBTUMsVUFBVUYsWUFBWUcsS0FBSztRQUNqQyxNQUFNLEVBQUVOLFNBQVMsRUFBRU8sT0FBTyxFQUFFLEVBQUVDLE1BQU0sQ0FBQyxFQUFFQyxZQUFZbEIsV0FBV0MsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDTyxPQUFPO1FBQ2xGLElBQUksQ0FBQ0MsV0FBVyxNQUFNLElBQUlVLE1BQU07UUFDaEMsTUFBTUMsaUJBQWlCLE9BQVFKLFNBQVMsV0FBWTtZQUFFSyxPQUFPTDtZQUFNTSxRQUFRTjtRQUFLLElBQUlBO1FBQ3BGLE1BQU1PLGlCQUFrQkwsY0FBY2xCLFdBQVdDLEdBQUc7UUFDcEQsTUFBTXVCLFlBQVlELGlCQUFpQkgsZUFBZUMsS0FBSyxHQUFHRCxlQUFlRSxNQUFNO1FBQy9FLElBQUlHLFFBQVFYLFFBQVFZLEdBQUcsQ0FBQ2pCO1FBQ3hCLElBQUksQ0FBQ2tCLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUUEsUUFBUSxFQUFFO1FBQ3JDLE1BQU1JLFlBQVksSUFBSSxDQUFDbkIsVUFBVSxJQUFJLEVBQUU7UUFDdkMsTUFBTW9CLGFBQWFMLE1BQU1NLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxRQUFVcEMsd0RBQU9BLENBQUNnQyxTQUFTLENBQUNJLE1BQU0sRUFBRVIsS0FBSyxDQUFDUSxN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K0QsTUFBTTtZQUNyQixLQUFLL0QsNkRBQVNBLENBQUNrRSxLQUFLO1lBQ3BCLEtBQUtsRSw2REFBU0EsQ0FBQ3FFLElBQUk7Z0JBQUU7b0JBQ2pCUCxLQUFLVCxTQUFTN0IsTUFBTSxHQUFHO29CQUN2QjtnQkFDSjtZQUNBLEtBQUt4Qiw2REFBU0EsQ0FBQ2lFLE1BQU07WUFDckIsS0FBS2pFLDZEQUFTQSxDQUFDbUUsWUFBWTtZQUMzQixLQUFLbkUsNkRBQVNBLENBQUNzRSxXQUFXO2dCQUFFO29CQUN4QlIsS0FBS1QsU0FBUzdCLE1BQU07b0JBQ3BCO2dCQUNKO1FBQ0o7UUFDQWdCLElBQUkrQixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRVYsRUFBRSxFQUFFLEVBQUVDLEVBQUUsQ0FBQyxDQUFDO0lBQ2pEO0FBQ0osR0FBRztJQUNDNUQ7SUFDQUYsU0FBU0EsK0RBQUFBO0FBQ2IsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2hpZ2hsaWdodGVycy9saXN0Lm1qcz83M2I0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5pbXBvcnQge1xuICAgIG5vcm1hbGl6ZVNpZGVzLFxuICAgIGlzRXF1YWwsXG59IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7XG4gICAgUG9zaXRpb25zLFxuICAgIGdldFJlY3RQb2ludCxcbn0gZnJvbSAnLi4vdXRpbC9nZXRSZWN0UG9pbnQubWpzJztcblxuY29uc3QgRGlyZWN0aW9ucyA9IHtcbiAgICBST1c6ICdyb3cnLFxuICAgIENPTFVNTjogJ2NvbHVtbidcbn07XG5cbmV4cG9ydCBjb25zdCBsaXN0ID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAnZycsXG4gICAgTU9VTlRBQkxFOiB0cnVlLFxuICAgIFVQREFURV9BVFRSSUJVVEVTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9wdGlvbnMuYXR0cmlidXRlXTtcbiAgICB9LFxuXG4gICAgX3ByZXZJdGVtczogbnVsbCxcblxuICAgIGhpZ2hsaWdodChlbGVtZW50Vmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFZpZXcubW9kZWw7XG4gICAgICAgIGNvbnN0IHsgYXR0cmlidXRlLCBzaXplID0gMjAsIGdhcCA9IDUsIGRpcmVjdGlvbiA9IERpcmVjdGlvbnMuUk9XIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghYXR0cmlidXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0xpc3Q6IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkU2l6ZSA9ICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpID8geyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplIH0gOiBzaXplO1xuICAgICAgICBjb25zdCBpc1Jvd0RpcmVjdGlvbiA9IChkaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuUk9XKTtcbiAgICAgICAgY29uc3QgaXRlbVdpZHRoID0gaXNSb3dEaXJlY3Rpb24gPyBub3JtYWxpemVkU2l6ZS53aWR0aCA6IG5vcm1hbGl6ZWRTaXplLmhlaWdodDtcbiAgICAgICAgbGV0IGl0ZW1zID0gZWxlbWVudC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkgaXRlbXMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJldkl0ZW1zID0gdGhpcy5fcHJldkl0ZW1zIHx8IFtdO1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gaXNFcXVhbChwcmV2SXRlbXNbaW5kZXhdLCBpdGVtc1tpbmRleF0pKTtcbiAgICAgICAgaWYgKHByZXZJdGVtcy5sZW5ndGggIT09IGl0ZW1zLmxlbmd0aCB8fCBjb21wYXJpc29uLnNvbWUodW5jaGFuZ2VkID0+ICF1bmNoYW5nZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2RWxzID0gdGhpcy52ZWwuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zRWxzID0gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZFbCA9IChpbmRleCBpbiBwcmV2RWxzKSA/IHByZXZFbHNbaW5kZXhdLm5vZGUgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJpc29uW2luZGV4XSkgcmV0dXJuIHByZXZFbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtRWwgPSB0aGlzLmNyZWF0ZUxpc3RJdGVtKGl0ZW0sIG5vcm1hbGl6ZWRTaXplLCBwcmV2RWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbUVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIShpdGVtRWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKCdMaXN0OiBpdGVtIG11c3QgYmUgYW4gU1ZHRWxlbWVudCcpO1xuICAgICAgICAgICAgICAgIGl0ZW1FbC5kYXRhc2V0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaXRlbUVsLmRhdGFzZXQuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogKGl0ZW1XaWR0aCArIGdhcCk7XG4gICAgICAgICAgICAgICAgaXRlbUVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgKGlzUm93RGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IGB0cmFuc2xhdGUoJHtvZmZzZXR9LCAwKWBcbiAgICAgICAgICAgICAgICAgICAgOiBgdHJhbnNsYXRlKDAsICR7b2Zmc2V0fSlgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbUVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZlbC5lbXB0eSgpLmFwcGVuZChpdGVtc0Vscyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2SXRlbXMgPSBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtc0NvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoaXRlbXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiAoaXRlbXNDb3VudCAqIGl0ZW1XaWR0aCArIChpdGVtc0NvdW50IC0gMSkgKiBnYXApO1xuICAgICAgICBjb25zdCBsaXN0U2l6ZSA9IChpc1Jvd0RpcmVjdGlvbilcbiAgICAgICAgICAgID8geyB3aWR0aDogbGVuZ3RoLCBoZWlnaHQ6IG5vcm1hbGl6ZWRTaXplLmhlaWdodCB9XG4gICAgICAgICAgICA6IHsgd2lkdGg6IG5vcm1hbGl6ZWRTaXplLndpZHRoLCBoZWlnaHQ6IGxlbmd0aCB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24oZWxlbWVudCwgbGlzdFNpemUpO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbihlbGVtZW50LCBsaXN0U2l6ZSkge1xuICAgICAgICBjb25zdCB7IHZlbCwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBtYXJnaW4gPSA1LCBwb3NpdGlvbiA9ICd0b3AtbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZWxlbWVudC5zaXplKCk7XG4gICAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBub3JtYWxpemVTaWRlcyhtYXJnaW4pO1xuICAgICAgICBjb25zdCBiYm94ID0gbmV3IFJlY3QobGVmdCwgdG9wLCB3aWR0aCAtIChsZWZ0ICsgcmlnaHQpLCBoZWlnaHQgLSAodG9wICsgYm90dG9tKSk7XG4gICAgICAgIGxldCB7IHgsIHkgfSA9IGdldFJlY3RQb2ludChiYm94LCBwb3NpdGlvbik7XG4gICAgICAgIC8vIHhcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQ0VOVEVSOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuVE9QOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NOiB7XG4gICAgICAgICAgICAgICAgeCAtPSBsaXN0U2l6ZS53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUF9SSUdIVDoge1xuICAgICAgICAgICAgICAgIHggLT0gbGlzdFNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geVxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5DRU5URVI6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkxFRlQ6IHtcbiAgICAgICAgICAgICAgICB5IC09IGxpc3RTaXplLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT006XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT01fUklHSFQ6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT01fTEVGVDoge1xuICAgICAgICAgICAgICAgIHkgLT0gbGlzdFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZlbC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYCk7XG4gICAgfVxufSwge1xuICAgIERpcmVjdGlvbnMsXG4gICAgUG9zaXRpb25zXG59KTtcbiJdLCJuYW1lcyI6WyJSZWN0IiwiSGlnaGxpZ2h0ZXJWaWV3Iiwibm9ybWFsaXplU2lkZXMiLCJpc0VxdWFsIiwiUG9zaXRpb25zIiwiZ2V0UmVjdFBvaW50IiwiRGlyZWN0aW9ucyIsIlJPVyIsIkNPTFVNTiIsImxpc3QiLCJleHRlbmQiLCJ0YWdOYW1lIiwiTU9VTlRBQkxFIiwiVVBEQVRFX0FUVFJJQlVURVMiLCJvcHRpb25zIiwiYXR0cmlidXRlIiwiX3ByZXZJdGVtcyIsImhpZ2hsaWdodCIsImVsZW1lbnRWaWV3Iiwibm9kZSIsImVsZW1lbnQiLCJtb2RlbCIsInNpemUiLCJnYXAiLCJkaXJlY3Rpb24iLCJFcnJvciIsIm5vcm1hbGl6ZWRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJpc1Jvd0RpcmVjdGlvbiIsIml0ZW1XaWR0aCIsIml0ZW1zIiwiZ2V0IiwiQXJyYXkiLCJpc0FycmF5IiwicHJldkl0ZW1zIiwiY29tcGFyaXNvbiIsIm1hcCIsIml0ZW0iLCJpbmRleCIsImxlbmd0aCIsInNvbWUiLCJ1bmNoYW5nZWQiLCJwcmV2RWxzIiwidmVsIiwiY2hpbGRyZW4iLCJpdGVtc0VscyIsInByZXZFbCIsIml0ZW1FbCIsImNyZWF0ZUxpc3RJdGVtIiwiU1ZHRWxlbWVudCIsImRhdGFzZXQiLCJvZmZzZXQiLCJzZXRBdHRyaWJ1dGUiLCJlbXB0eSIsImFwcGVuZCIsIml0ZW1zQ291bnQiLCJsaXN0U2l6ZSIsInBvc2l0aW9uIiwibWFyZ2luIiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiYmJveCIsIngiLCJ5IiwiQ0VOVEVSIiwiVE9QIiwiQk9UVE9NIiwiUklHSFQiLCJCT1RUT01fUklHSFQiLCJUT1BfUklHSFQiLCJMRUZUIiwiQk9UVE9NX0xFRlQiLCJhdHRyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/list.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/mask.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/mask.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mask: () => (/* binding */ mask)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n\n\nconst MASK_CLIP = 20;\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while(descendants.length > 0){\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\nconst mask = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n    tagName: \"rect\",\n    className: \"highlight-mask\",\n    attributes: {\n        \"pointer-events\": \"none\"\n    },\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            \"stroke\": \"#FEB663\",\n            \"stroke-width\": 3,\n            \"stroke-linecap\": \"butt\",\n            \"stroke-linejoin\": \"miter\"\n        }\n    },\n    VISIBLE: \"white\",\n    INVISIBLE: \"black\",\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        \"marker-start\",\n        \"marker-end\",\n        \"marker-mid\",\n        \"transform\",\n        \"stroke-dasharray\",\n        \"class\"\n    ],\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        \"stroke\",\n        \"fill\",\n        \"stroke-width\",\n        \"stroke-opacity\",\n        \"stroke-dasharray\",\n        \"fill-opacity\",\n        \"marker-start\",\n        \"marker-end\",\n        \"marker-mid\",\n        \"class\"\n    ],\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        \"FOREIGNOBJECT\",\n        \"IMAGE\",\n        \"USE\",\n        \"TEXT\",\n        \"TSPAN\",\n        \"TEXTPATH\"\n    ],\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        \"TEXT\",\n        \"TSPAN\",\n        \"TEXTPATH\"\n    ],\n    transformMaskChild (cellView, childEl) {\n        const { MASK_CHILD_ATTRIBUTE_BLACKLIST, MASK_REPLACE_TAGS, MASK_REMOVE_TAGS } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"rect\", childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{\n            if (attrName === \"fill\" && childEl.attr(\"fill\") === \"none\") return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n    transformMaskRoot (_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{\n            rootEl.removeAttr(attrName);\n        });\n    },\n    getMaskShape (cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === \"G\") {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, (maskChild)=>this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n    getMaskId () {\n        return `highlight-mask-${this.cid}`;\n    },\n    getMask (cellView, vNode) {\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        const strokeWidth = \"stroke-width\" in attrs ? attrs[\"stroke-width\"] : 1;\n        const hasNodeFill = vNode.attr(\"fill\") !== \"none\";\n        let magnetStrokeWidth = parseFloat(vNode.attr(\"stroke-width\"));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"rect\", nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"mask\", {\n            \"id\": this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                \"fill\": hasNodeFill ? VISIBLE : \"none\",\n                \"stroke\": VISIBLE,\n                \"stroke-width\": maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                \"fill\": hasNodeFill ? INVISIBLE : \"none\",\n                \"stroke\": INVISIBLE,\n                \"stroke-width\": minStrokeWidth\n            })\n        ]);\n    },\n    removeMask (paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n    addMask (paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n    highlight (cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = \"stroke\" in attrs ? attrs[\"stroke\"] : \"#000000\";\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            \"transform\": _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix),\n            \"mask\": `url(#${maskEl.id})`,\n            \"fill\": color\n        });\n    },\n    unhighlight (cellView) {\n        this.removeMask(cellView.paper);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL21hc2subWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUM4QjtBQUU3RCxNQUFNRSxZQUFZO0FBRWxCLFNBQVNDLGtCQUFrQkMsR0FBRyxFQUFFQyxFQUFFO0lBQzlCLE1BQU1DLGNBQWNGLElBQUlHLFFBQVE7SUFDaEMsTUFBT0QsWUFBWUUsTUFBTSxHQUFHLEVBQUc7UUFDM0IsTUFBTUMsYUFBYUgsWUFBWUksS0FBSztRQUNwQyxJQUFJTCxHQUFHSSxhQUFhO1lBQ2hCSCxZQUFZSyxJQUFJLElBQUlGLFdBQVdGLFFBQVE7UUFDM0M7SUFDSjtBQUNKO0FBRU8sTUFBTUssT0FBT1gscUVBQWVBLENBQUNZLE1BQU0sQ0FBQztJQUV2Q0MsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFlBQVk7UUFDUixrQkFBa0I7SUFDdEI7SUFFQUMsU0FBUztRQUNMQyxTQUFTO1FBQ1RDLFVBQVVqQjtRQUNWa0IsTUFBTTtRQUNOQyxPQUFPO1lBQ0gsVUFBVTtZQUNWLGdCQUFnQjtZQUNoQixrQkFBa0I7WUFDbEIsbUJBQW1CO1FBQ3ZCO0lBQ0o7SUFFQUMsU0FBUztJQUNUQyxXQUFXO0lBRVhDLCtCQUErQjtRQUMzQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUVEQyxnQ0FBZ0M7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUVELCtDQUErQztJQUMvQ0MsbUJBQW1CO1FBQ2Y7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFFRCwrQ0FBK0M7SUFDL0NDLGtCQUFrQjtRQUNkO1FBQ0E7UUFDQTtLQUNIO0lBRURDLG9CQUFtQkMsUUFBUSxFQUFFQyxPQUFPO1FBQ2hDLE1BQU0sRUFDRkwsOEJBQThCLEVBQzlCQyxpQkFBaUIsRUFDakJDLGdCQUFnQixFQUNuQixHQUFHLElBQUk7UUFDUixNQUFNSSxlQUFlRCxRQUFRaEIsT0FBTztRQUNwQyxpREFBaUQ7UUFDakQsSUFBSSxDQUFDZCxvREFBQ0EsQ0FBQ2dDLG9CQUFvQixDQUFDRixZQUFZSCxpQkFBaUJNLFFBQVEsQ0FBQ0YsZUFBZTtZQUM3RUQsUUFBUUksTUFBTTtZQUNkLE9BQU87UUFDWDtRQUNBLHVDQUF1QztRQUN2QyxJQUFJUixrQkFBa0JPLFFBQVEsQ0FBQ0YsZUFBZTtZQUMxQyx3REFBd0Q7WUFDeEQsTUFBTUksZ0JBQWdCTixTQUFTekIsR0FBRyxDQUFDZ0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFTixRQUFRTyxFQUFFLENBQUMsQ0FBQztZQUMzRCxJQUFJRixlQUFlO2dCQUNmLE1BQU0sRUFBRUcsTUFBTUMsWUFBWSxFQUFFLEdBQUdKO2dCQUMvQixJQUFJSyxZQUFZWCxTQUFTWSxtQkFBbUIsQ0FBQ0Y7Z0JBQzdDLElBQUlWLFNBQVNhLEtBQUssQ0FBQ0MsU0FBUyxJQUFJO29CQUM1QkgsWUFBWXhDLG9EQUFDQSxDQUFDNEMsYUFBYSxDQUFDSixXQUFXWCxTQUFTZ0IsYUFBYSxDQUFDTjtnQkFDbEU7Z0JBQ0EsTUFBTU8sY0FBYzlDLHdEQUFDQSxDQUFDLFFBQVF3QyxVQUFVTyxNQUFNO2dCQUM5QyxNQUFNLEVBQUVDLEdBQUdDLEVBQUUsRUFBRUMsR0FBR0MsRUFBRSxFQUFFLEdBQUdYLFVBQVVZLE1BQU07Z0JBQ3pDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLTCxFQUFFLEVBQUVNLEtBQUtKLEVBQUUsRUFBRSxHQUFHaEIsY0FBY3FCLE1BQU07Z0JBQ3hELElBQUlILE9BQU9QLFlBQVlVLE1BQU0sQ0FBQ0gsT0FBT0MsSUFBSUM7Z0JBQ3pDLHdGQUF3RjtnQkFDeEZ6QixRQUFRMkIsTUFBTSxHQUFHQyxNQUFNLENBQUNaO1lBQzVCO1lBQ0FoQixRQUFRSSxNQUFNO1lBQ2QsT0FBTztRQUNYO1FBQ0EseURBQXlEO1FBQ3pEVCwrQkFBK0JrQyxPQUFPLENBQUNDLENBQUFBO1lBQ25DLElBQUlBLGFBQWEsVUFBVTlCLFFBQVErQixJQUFJLENBQUMsWUFBWSxRQUFRO1lBQzVEL0IsUUFBUWdDLFVBQVUsQ0FBQ0Y7UUFDdkI7UUFDQSxPQUFPO0lBQ1g7SUFFQUcsbUJBQWtCQyxTQUFTLEVBQUVDLE1BQU07UUFDL0IsTUFBTSxFQUFFekMsNkJBQTZCLEVBQUUsR0FBRyxJQUFJO1FBQzlDQSw4QkFBOEJtQyxPQUFPLENBQUNDLENBQUFBO1lBQ2xDSyxPQUFPSCxVQUFVLENBQUNGO1FBQ3RCO0lBQ0o7SUFFQU0sY0FBYXJDLFFBQVEsRUFBRXpCLEdBQUc7UUFDdEIsTUFBTSxFQUFFYSxPQUFPLEVBQUVTLGlCQUFpQixFQUFFLEdBQUcsSUFBSTtRQUMzQyxNQUFNLEVBQUVOLElBQUksRUFBRSxHQUFHSDtRQUNqQixNQUFNSCxVQUFVVixJQUFJVSxPQUFPO1FBQzNCLElBQUlxRDtRQUNKLElBQUlyRCxZQUFZLEtBQUs7WUFDakIsSUFBSSxDQUFDTSxNQUFNLE9BQU87WUFDbEIrQyxXQUFXL0QsSUFBSWdFLEtBQUs7WUFDcEJqRSxrQkFBa0JnRSxVQUFVRSxDQUFBQSxZQUFhLElBQUksQ0FBQ3pDLGtCQUFrQixDQUFDQyxVQUFVd0M7UUFDL0UsT0FBTztZQUNILElBQUkzQyxrQkFBa0JPLFFBQVEsQ0FBQ25CLFVBQVUsT0FBTztZQUNoRHFELFdBQVcvRCxJQUFJZ0UsS0FBSztRQUN4QjtRQUNBLElBQUksQ0FBQ0wsaUJBQWlCLENBQUNsQyxVQUFVc0M7UUFDakMsT0FBT0E7SUFDWDtJQUVBRztRQUNJLE9BQU8sQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQztJQUN2QztJQUVBQyxTQUFRM0MsUUFBUSxFQUFFNEMsS0FBSztRQUVuQixNQUFNLEVBQUVuRCxPQUFPLEVBQUVDLFNBQVMsRUFBRU4sT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUM1QyxNQUFNLEVBQUVDLE9BQU8sRUFBRUcsS0FBSyxFQUFFLEdBQUdKO1FBRTNCLE1BQU15RCxjQUFjLGtCQUFtQnJELFFBQVNBLEtBQUssQ0FBQyxlQUFlLEdBQUc7UUFDeEUsTUFBTXNELGNBQWNGLE1BQU1aLElBQUksQ0FBQyxZQUFZO1FBQzNDLElBQUllLG9CQUFvQkMsV0FBV0osTUFBTVosSUFBSSxDQUFDO1FBQzlDLElBQUlpQixNQUFNRixvQkFBb0JBLG9CQUFvQjtRQUNsRCxnQ0FBZ0M7UUFDaEMsTUFBTUcsaUJBQWlCSCxvQkFBb0IxRCxVQUFVO1FBQ3JELDhCQUE4QjtRQUM5QixNQUFNOEQsaUJBQWlCRCxpQkFBaUJMLGNBQWM7UUFDdEQsSUFBSU8sU0FBUyxJQUFJLENBQUNmLFlBQVksQ0FBQ3JDLFVBQVU0QztRQUN6QyxJQUFJLENBQUNRLFFBQVE7WUFDVCxNQUFNQyxXQUFXckQsU0FBU1ksbUJBQW1CLENBQUNnQyxNQUFNbkMsSUFBSTtZQUN4RCxnQ0FBZ0M7WUFDaEM0QyxTQUFTQyxPQUFPLENBQUNELFNBQVNFLEtBQUssR0FBRyxJQUFJLEtBQUtGLFNBQVNHLE1BQU0sR0FBRyxJQUFJO1lBQ2pFSixTQUFVakYsd0RBQUNBLENBQUMsUUFBUWtGLFNBQVNuQyxNQUFNO1FBQ3ZDO1FBQ0FrQyxPQUFPcEIsSUFBSSxDQUFDeEM7UUFDWixPQUFPckIsd0RBQUNBLENBQUMsUUFBUTtZQUNiLE1BQU0sSUFBSSxDQUFDc0UsU0FBUztRQUN4QixHQUFHWixNQUFNLENBQUM7WUFDTnVCLE9BQU9iLEtBQUssR0FBR1AsSUFBSSxDQUFDO2dCQUNoQixRQUFRYyxjQUFjckQsVUFBVTtnQkFDaEMsVUFBVUE7Z0JBQ1YsZ0JBQWdCMEQ7WUFDcEI7WUFDQUMsT0FBT2IsS0FBSyxHQUFHUCxJQUFJLENBQUM7Z0JBQ2hCLFFBQVFjLGNBQWNwRCxZQUFZO2dCQUNsQyxVQUFVQTtnQkFDVixnQkFBZ0J3RDtZQUNwQjtTQUNIO0lBQ0w7SUFFQU8sWUFBV0MsS0FBSztRQUNaLE1BQU1DLFdBQVdELE1BQU1FLEdBQUcsQ0FBQ0MsY0FBYyxDQUFDLElBQUksQ0FBQ3BCLFNBQVM7UUFDeEQsSUFBSWtCLFVBQVU7WUFDVkQsTUFBTUksSUFBSSxDQUFDQyxXQUFXLENBQUNKO1FBQzNCO0lBQ0o7SUFFQUssU0FBUU4sS0FBSyxFQUFFTixNQUFNO1FBQ2pCTSxNQUFNSSxJQUFJLENBQUNHLFdBQVcsQ0FBQ2IsT0FBTzNDLElBQUk7SUFDdEM7SUFFQXlELFdBQVVsRSxRQUFRLEVBQUVTLElBQUk7UUFDcEIsTUFBTSxFQUFFckIsT0FBTyxFQUFFYixHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQzdCLE1BQU0sRUFBRWMsT0FBTyxFQUFFRyxLQUFLLEVBQUVGLFdBQVdqQixTQUFTLEVBQUU4RixLQUFLLEVBQUUsR0FBRy9FO1FBQ3hELE1BQU1nRixRQUFRLFlBQWE1RSxRQUFTQSxLQUFLLENBQUMsU0FBUyxHQUFHO1FBQ3RELElBQUksQ0FBQzJFLFNBQVMxRCxTQUFTVCxTQUFTcUUsRUFBRSxFQUFFO1lBQ2hDLGlEQUFpRDtZQUNqRCx5REFBeUQ7WUFDekQsaURBQWlEO1lBQ2pEOUYsSUFBSThCLE1BQU07UUFDZDtRQUNBLE1BQU1pRSxrQkFBa0J0RSxTQUFTWSxtQkFBbUIsQ0FBQ0gsTUFBTTZDLE9BQU8sQ0FBQ2pFLFVBQVVDO1FBQzdFLE1BQU1pRixrQkFBa0IsSUFBSSxDQUFDdkQsYUFBYSxDQUFDaEIsVUFBVVM7UUFDckQsTUFBTTJDLFNBQVMsSUFBSSxDQUFDVCxPQUFPLENBQUMzQyxVQUFVN0Isd0RBQUNBLENBQUNzQztRQUN4QyxJQUFJLENBQUN1RCxPQUFPLENBQUNoRSxTQUFTMEQsS0FBSyxFQUFFTjtRQUM3QjdFLElBQUl5RCxJQUFJLENBQUNzQyxnQkFBZ0JwRCxNQUFNO1FBQy9CM0MsSUFBSXlELElBQUksQ0FBQztZQUNMLGFBQWE3RCxvREFBQ0EsQ0FBQ3FHLHVCQUF1QixDQUFDRDtZQUN2QyxRQUFRLENBQUMsS0FBSyxFQUFFbkIsT0FBTzVDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDNUIsUUFBUTREO1FBQ1o7SUFDSjtJQUVBSyxhQUFZekUsUUFBUTtRQUNoQixJQUFJLENBQUN5RCxVQUFVLENBQUN6RCxTQUFTMEQsS0FBSztJQUNsQztBQUVKLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9oaWdobGlnaHRlcnMvbWFzay5tanM/MzJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmNvbnN0IE1BU0tfQ0xJUCA9IDIwO1xuXG5mdW5jdGlvbiBmb3JFYWNoRGVzY2VuZGFudCh2ZWwsIGZuKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSB2ZWwuY2hpbGRyZW4oKTtcbiAgICB3aGlsZSAoZGVzY2VuZGFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gZGVzY2VuZGFudHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGZuKGRlc2NlbmRhbnQpKSB7XG4gICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKC4uLmRlc2NlbmRhbnQuY2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBtYXNrID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgY2xhc3NOYW1lOiAnaGlnaGxpZ2h0LW1hc2snLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgbWFza0NsaXA6IE1BU0tfQ0xJUCxcbiAgICAgICAgZGVlcDogZmFsc2UsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnc3Ryb2tlJzogJyNGRUI2NjMnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDMsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAnYnV0dCcsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBWSVNJQkxFOiAnd2hpdGUnLFxuICAgIElOVklTSUJMRTogJ2JsYWNrJyxcblxuICAgIE1BU0tfUk9PVF9BVFRSSUJVVEVfQkxBQ0tMSVNUOiBbXG4gICAgICAgICdtYXJrZXItc3RhcnQnLFxuICAgICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAgICdtYXJrZXItbWlkJyxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgJ2NsYXNzJyxcbiAgICBdLFxuXG4gICAgTUFTS19DSElMRF9BVFRSSUJVVEVfQkxBQ0tMSVNUOiBbXG4gICAgICAgICdzdHJva2UnLFxuICAgICAgICAnZmlsbCcsXG4gICAgICAgICdzdHJva2Utd2lkdGgnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgICAgICdmaWxsLW9wYWNpdHknLFxuICAgICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICAgJ21hcmtlci1lbmQnLFxuICAgICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAgICdjbGFzcycsXG4gICAgXSxcblxuICAgIC8vIFRPRE86IGNoYW5nZSB0aGUgbGlzdCB0byBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgTUFTS19SRVBMQUNFX1RBR1M6IFtcbiAgICAgICAgJ0ZPUkVJR05PQkpFQ1QnLFxuICAgICAgICAnSU1BR0UnLFxuICAgICAgICAnVVNFJyxcbiAgICAgICAgJ1RFWFQnLFxuICAgICAgICAnVFNQQU4nLFxuICAgICAgICAnVEVYVFBBVEgnXG4gICAgXSxcblxuICAgIC8vIFRPRE86IGNoYW5nZSB0aGUgbGlzdCB0byBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgTUFTS19SRU1PVkVfVEFHUzogW1xuICAgICAgICAnVEVYVCcsXG4gICAgICAgICdUU1BBTicsXG4gICAgICAgICdURVhUUEFUSCdcbiAgICBdLFxuXG4gICAgdHJhbnNmb3JtTWFza0NoaWxkKGNlbGxWaWV3LCBjaGlsZEVsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIE1BU0tfQ0hJTERfQVRUUklCVVRFX0JMQUNLTElTVCxcbiAgICAgICAgICAgIE1BU0tfUkVQTEFDRV9UQUdTLFxuICAgICAgICAgICAgTUFTS19SRU1PVkVfVEFHU1xuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2hpbGRUYWdOYW1lID0gY2hpbGRFbC50YWdOYW1lKCk7XG4gICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHRoZSBlbGVtZW50IGluIHRoZSBtYXNrJ3MgaW1hZ2VcbiAgICAgICAgaWYgKCFWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KGNoaWxkRWwpIHx8IE1BU0tfUkVNT1ZFX1RBR1MuaW5jbHVkZXMoY2hpbGRUYWdOYW1lKSkge1xuICAgICAgICAgICAgY2hpbGRFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBlbGVtZW50IHdpdGggYSByZWN0YW5nbGVcbiAgICAgICAgaWYgKE1BU0tfUkVQTEFDRV9UQUdTLmluY2x1ZGVzKGNoaWxkVGFnTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGNsb25lKCkgbWV0aG9kIGRvZXMgbm90IGNoYW5nZSB0aGUgY2hpbGRyZW4gaWRzXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoaWxkID0gY2VsbFZpZXcudmVsLmZpbmRPbmUoYCMke2NoaWxkRWwuaWR9YCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZTogb3JpZ2luYWxOb2RlIH0gPSBvcmlnaW5hbENoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KG9yaWdpbmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxWaWV3Lm1vZGVsLmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IFYudHJhbnNmb3JtUmVjdChjaGlsZEJCb3gsIGNlbGxWaWV3LmdldE5vZGVNYXRyaXgob3JpZ2luYWxOb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gVigncmVjdCcsIGNoaWxkQkJveC50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBveCwgeTogb3kgfSA9IGNoaWxkQkJveC5jZW50ZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFuZ2xlLCBjeCA9IG94LCBjeSA9IG95IH0gPSBvcmlnaW5hbENoaWxkLnJvdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhbmdsZSkgcmVwbGFjZW1lbnQucm90YXRlKGFuZ2xlLCBjeCwgY3kpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGl0J3Mgbm90IGltcG9ydGFudCB0byBrZWVwIHRoZSBzYW1lIHNpYmxpbmcgaW5kZXggc2luY2UgYWxsIHN1Ym5vZGVzIGFyZSBmaWxsZWRcbiAgICAgICAgICAgICAgICBjaGlsZEVsLnBhcmVudCgpLmFwcGVuZChyZXBsYWNlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZEVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgdGhlIGVsZW1lbnQsIGJ1dCBjbGVhbiBpdCBmcm9tIGNlcnRhaW4gYXR0cmlidXRlc1xuICAgICAgICBNQVNLX0NISUxEX0FUVFJJQlVURV9CTEFDS0xJU1QuZm9yRWFjaChhdHRyTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICdmaWxsJyAmJiBjaGlsZEVsLmF0dHIoJ2ZpbGwnKSA9PT0gJ25vbmUnKSByZXR1cm47XG4gICAgICAgICAgICBjaGlsZEVsLnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hc2tSb290KF9jZWxsVmlldywgcm9vdEVsKSB7XG4gICAgICAgIGNvbnN0IHsgTUFTS19ST09UX0FUVFJJQlVURV9CTEFDS0xJU1QgfSA9IHRoaXM7XG4gICAgICAgIE1BU0tfUk9PVF9BVFRSSUJVVEVfQkxBQ0tMSVNULmZvckVhY2goYXR0ck5hbWUgPT4ge1xuICAgICAgICAgICAgcm9vdEVsLnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0TWFza1NoYXBlKGNlbGxWaWV3LCB2ZWwpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBNQVNLX1JFUExBQ0VfVEFHUyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWVwIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gdmVsLnRhZ05hbWUoKTtcbiAgICAgICAgbGV0IG1hc2tSb290O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ0cnKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbWFza1Jvb3QgPSB2ZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGZvckVhY2hEZXNjZW5kYW50KG1hc2tSb290LCBtYXNrQ2hpbGQgPT4gdGhpcy50cmFuc2Zvcm1NYXNrQ2hpbGQoY2VsbFZpZXcsIG1hc2tDaGlsZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE1BU0tfUkVQTEFDRV9UQUdTLmluY2x1ZGVzKHRhZ05hbWUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG1hc2tSb290ID0gdmVsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXNrUm9vdChjZWxsVmlldywgbWFza1Jvb3QpO1xuICAgICAgICByZXR1cm4gbWFza1Jvb3Q7XG4gICAgfSxcblxuICAgIGdldE1hc2tJZCgpIHtcbiAgICAgICAgcmV0dXJuIGBoaWdobGlnaHQtbWFzay0ke3RoaXMuY2lkfWA7XG4gICAgfSxcblxuICAgIGdldE1hc2soY2VsbFZpZXcsIHZOb2RlKSB7XG5cbiAgICAgICAgY29uc3QgeyBWSVNJQkxFLCBJTlZJU0lCTEUsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGFkZGluZywgYXR0cnMgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSAoJ3N0cm9rZS13aWR0aCcgaW4gYXR0cnMpID8gYXR0cnNbJ3N0cm9rZS13aWR0aCddIDogMTtcbiAgICAgICAgY29uc3QgaGFzTm9kZUZpbGwgPSB2Tm9kZS5hdHRyKCdmaWxsJykgIT09ICdub25lJztcbiAgICAgICAgbGV0IG1hZ25ldFN0cm9rZVdpZHRoID0gcGFyc2VGbG9hdCh2Tm9kZS5hdHRyKCdzdHJva2Utd2lkdGgnKSk7XG4gICAgICAgIGlmIChpc05hTihtYWduZXRTdHJva2VXaWR0aCkpIG1hZ25ldFN0cm9rZVdpZHRoID0gMTtcbiAgICAgICAgLy8gc3Ryb2tlIG9mIHRoZSBpbnZpc2libGUgc2hhcGVcbiAgICAgICAgY29uc3QgbWluU3Ryb2tlV2lkdGggPSBtYWduZXRTdHJva2VXaWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgICAvLyBzdHJva2Ugb2YgdGhlIHZpc2libGUgc2hhcGVcbiAgICAgICAgY29uc3QgbWF4U3Ryb2tlV2lkdGggPSBtaW5TdHJva2VXaWR0aCArIHN0cm9rZVdpZHRoICogMjtcbiAgICAgICAgbGV0IG1hc2tFbCA9IHRoaXMuZ2V0TWFza1NoYXBlKGNlbGxWaWV3LCB2Tm9kZSk7XG4gICAgICAgIGlmICghbWFza0VsKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qodk5vZGUubm9kZSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlY3QgaXMgdmlzaWJsZVxuICAgICAgICAgICAgbm9kZUJCb3guaW5mbGF0ZShub2RlQkJveC53aWR0aCA/IDAgOiAwLjUsIG5vZGVCQm94LmhlaWdodCA/IDAgOiAwLjUpO1xuICAgICAgICAgICAgbWFza0VsID0gIFYoJ3JlY3QnLCBub2RlQkJveC50b0pTT04oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFza0VsLmF0dHIoYXR0cnMpO1xuICAgICAgICByZXR1cm4gVignbWFzaycsIHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMuZ2V0TWFza0lkKClcbiAgICAgICAgfSkuYXBwZW5kKFtcbiAgICAgICAgICAgIG1hc2tFbC5jbG9uZSgpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdmaWxsJzogaGFzTm9kZUZpbGwgPyBWSVNJQkxFIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiBWSVNJQkxFLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBtYXhTdHJva2VXaWR0aFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXNrRWwuY2xvbmUoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbCc6IGhhc05vZGVGaWxsID8gSU5WSVNJQkxFIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiBJTlZJU0lCTEUsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG1pblN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTWFzayhwYXBlcikge1xuICAgICAgICBjb25zdCBtYXNrTm9kZSA9IHBhcGVyLnN2Zy5nZXRFbGVtZW50QnlJZCh0aGlzLmdldE1hc2tJZCgpKTtcbiAgICAgICAgaWYgKG1hc2tOb2RlKSB7XG4gICAgICAgICAgICBwYXBlci5kZWZzLnJlbW92ZUNoaWxkKG1hc2tOb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRNYXNrKHBhcGVyLCBtYXNrRWwpIHtcbiAgICAgICAgcGFwZXIuZGVmcy5hcHBlbmRDaGlsZChtYXNrRWwubm9kZSk7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodChjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBhdHRycywgbWFza0NsaXAgPSBNQVNLX0NMSVAsIGxheWVyIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjb2xvciA9ICgnc3Ryb2tlJyBpbiBhdHRycykgPyBhdHRyc1snc3Ryb2tlJ10gOiAnIzAwMDAwMCc7XG4gICAgICAgIGlmICghbGF5ZXIgJiYgbm9kZSA9PT0gY2VsbFZpZXcuZWwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBoaWdobGlnaHRlciBpcyBhcHBlbmRlZCB0byB0aGUgY2VsbFZpZXdcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBjZWxsVmlldyB3cmFwcGluZyBncm91cFxuICAgICAgICAgICAgLy8gaXQncyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBoaWdobGlnaHRlciBmaXJzdFxuICAgICAgICAgICAgdmVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qobm9kZSkuaW5mbGF0ZShwYWRkaW5nICsgbWFza0NsaXApO1xuICAgICAgICBjb25zdCBoaWdobGlnaHRNYXRyaXggPSB0aGlzLmdldE5vZGVNYXRyaXgoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICBjb25zdCBtYXNrRWwgPSB0aGlzLmdldE1hc2soY2VsbFZpZXcsIFYobm9kZSkpO1xuICAgICAgICB0aGlzLmFkZE1hc2soY2VsbFZpZXcucGFwZXIsIG1hc2tFbCk7XG4gICAgICAgIHZlbC5hdHRyKGhpZ2hsaWdodGVyQkJveC50b0pTT04oKSk7XG4gICAgICAgIHZlbC5hdHRyKHtcbiAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKGhpZ2hsaWdodE1hdHJpeCksXG4gICAgICAgICAgICAnbWFzayc6IGB1cmwoIyR7bWFza0VsLmlkfSlgLFxuICAgICAgICAgICAgJ2ZpbGwnOiBjb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQoY2VsbFZpZXcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXNrKGNlbGxWaWV3LnBhcGVyKTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbIlYiLCJIaWdobGlnaHRlclZpZXciLCJNQVNLX0NMSVAiLCJmb3JFYWNoRGVzY2VuZGFudCIsInZlbCIsImZuIiwiZGVzY2VuZGFudHMiLCJjaGlsZHJlbiIsImxlbmd0aCIsImRlc2NlbmRhbnQiLCJzaGlmdCIsInB1c2giLCJtYXNrIiwiZXh0ZW5kIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImF0dHJpYnV0ZXMiLCJvcHRpb25zIiwicGFkZGluZyIsIm1hc2tDbGlwIiwiZGVlcCIsImF0dHJzIiwiVklTSUJMRSIsIklOVklTSUJMRSIsIk1BU0tfUk9PVF9BVFRSSUJVVEVfQkxBQ0tMSVNUIiwiTUFTS19DSElMRF9BVFRSSUJVVEVfQkxBQ0tMSVNUIiwiTUFTS19SRVBMQUNFX1RBR1MiLCJNQVNLX1JFTU9WRV9UQUdTIiwidHJhbnNmb3JtTWFza0NoaWxkIiwiY2VsbFZpZXciLCJjaGlsZEVsIiwiY2hpbGRUYWdOYW1lIiwiaXNTVkdHcmFwaGljc0VsZW1lbnQiLCJpbmNsdWRlcyIsInJlbW92ZSIsIm9yaWdpbmFsQ2hpbGQiLCJmaW5kT25lIiwiaWQiLCJub2RlIiwib3JpZ2luYWxOb2RlIiwiY2hpbGRCQm94IiwiZ2V0Tm9kZUJvdW5kaW5nUmVjdCIsIm1vZGVsIiwiaXNFbGVtZW50IiwidHJhbnNmb3JtUmVjdCIsImdldE5vZGVNYXRyaXgiLCJyZXBsYWNlbWVudCIsInRvSlNPTiIsIngiLCJveCIsInkiLCJveSIsImNlbnRlciIsImFuZ2xlIiwiY3giLCJjeSIsInJvdGF0ZSIsInBhcmVudCIsImFwcGVuZCIsImZvckVhY2giLCJhdHRyTmFtZSIsImF0dHIiLCJyZW1vdmVBdHRyIiwidHJhbnNmb3JtTWFza1Jvb3QiLCJfY2VsbFZpZXciLCJyb290RWwiLCJnZXRNYXNrU2hhcGUiLCJtYXNrUm9vdCIsImNsb25lIiwibWFza0NoaWxkIiwiZ2V0TWFza0lkIiwiY2lkIiwiZ2V0TWFzayIsInZOb2RlIiwic3Ryb2tlV2lkdGgiLCJoYXNOb2RlRmlsbCIsIm1hZ25ldFN0cm9rZVdpZHRoIiwicGFyc2VGbG9hdCIsImlzTmFOIiwibWluU3Ryb2tlV2lkdGgiLCJtYXhTdHJva2VXaWR0aCIsIm1hc2tFbCIsIm5vZGVCQm94IiwiaW5mbGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwicmVtb3ZlTWFzayIsInBhcGVyIiwibWFza05vZGUiLCJzdmciLCJnZXRFbGVtZW50QnlJZCIsImRlZnMiLCJyZW1vdmVDaGlsZCIsImFkZE1hc2siLCJhcHBlbmRDaGlsZCIsImhpZ2hsaWdodCIsImxheWVyIiwiY29sb3IiLCJlbCIsImhpZ2hsaWdodGVyQkJveCIsImhpZ2hsaWdodE1hdHJpeCIsIm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nIiwidW5oaWdobGlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/mask.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/opacity.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/opacity.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   opacity: () => (/* binding */ opacity)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n\n\n\nconst opacity = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n    UPDATABLE: false,\n    MOUNTABLE: false,\n    opacityClassName: _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix(\"highlight-opacity\"),\n    highlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).addClass(this.opacityClassName);\n    },\n    unhighlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).removeClass(this.opacityClassName);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL29wYWNpdHkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFDWDtBQUM4QjtBQUV0RCxNQUFNRyxVQUFVRCxxRUFBZUEsQ0FBQ0UsTUFBTSxDQUFDO0lBRTFDQyxXQUFXO0lBQ1hDLFdBQVc7SUFFWEMsa0JBQWtCUCwrREFBdUIsQ0FBQztJQUUxQ1MsV0FBVyxTQUFTQyxTQUFTLEVBQUVDLElBQUk7UUFDL0JWLHdEQUFDQSxDQUFDVSxNQUFNQyxRQUFRLENBQUMsSUFBSSxDQUFDTCxnQkFBZ0I7SUFDMUM7SUFFQU0sYUFBYSxTQUFTSCxTQUFTLEVBQUVDLElBQUk7UUFDakNWLHdEQUFDQSxDQUFDVSxNQUFNRyxXQUFXLENBQUMsSUFBSSxDQUFDUCxnQkFBZ0I7SUFDN0M7QUFFSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL29wYWNpdHkubWpzPzRmZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvcGFjaXR5ID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICBVUERBVEFCTEU6IGZhbHNlLFxuICAgIE1PVU5UQUJMRTogZmFsc2UsXG5cbiAgICBvcGFjaXR5Q2xhc3NOYW1lOiB1dGlsLmFkZENsYXNzTmFtZVByZWZpeCgnaGlnaGxpZ2h0LW9wYWNpdHknKSxcblxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oX2NlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIFYobm9kZSkuYWRkQ2xhc3ModGhpcy5vcGFjaXR5Q2xhc3NOYW1lKTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbm9kZSkge1xuICAgICAgICBWKG5vZGUpLnJlbW92ZUNsYXNzKHRoaXMub3BhY2l0eUNsYXNzTmFtZSk7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwiViIsIkhpZ2hsaWdodGVyVmlldyIsIm9wYWNpdHkiLCJleHRlbmQiLCJVUERBVEFCTEUiLCJNT1VOVEFCTEUiLCJvcGFjaXR5Q2xhc3NOYW1lIiwiYWRkQ2xhc3NOYW1lUHJlZml4IiwiaGlnaGxpZ2h0IiwiX2NlbGxWaWV3Iiwibm9kZSIsImFkZENsYXNzIiwidW5oaWdobGlnaHQiLCJyZW1vdmVDbGFzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/opacity.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/highlighters/stroke.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/jointjs/src/highlighters/stroke.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stroke: () => (/* binding */ stroke)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/HighlighterView.mjs\");\n\n\n\nconst stroke = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n    tagName: \"path\",\n    className: \"highlight-stroke\",\n    attributes: {\n        \"pointer-events\": \"none\",\n        \"vector-effect\": \"non-scaling-stroke\",\n        \"fill\": \"none\"\n    },\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            \"stroke-width\": 3,\n            \"stroke\": \"#FEB663\"\n        }\n    },\n    getPathData (cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === \"PATH\" && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rectToPath((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n    highlightConnection (cellView) {\n        this.vel.attr(\"d\", cellView.getSerializedConnection());\n    },\n    highlightNode (cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + nodeBBox.width / 2;\n            const cy = nodeBBox.y + nodeBBox.height / 2;\n            nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            \"d\": this.getPathData(cellView, node),\n            \"transform\": _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix)\n        });\n    },\n    highlight (cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvaGlnaGxpZ2h0ZXJzL3N0cm9rZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyQztBQUNaO0FBQzhCO0FBRXRELE1BQU1HLFNBQVNELHFFQUFlQSxDQUFDRSxNQUFNLENBQUM7SUFFekNDLFNBQVM7SUFDVEMsV0FBVztJQUNYQyxZQUFZO1FBQ1Isa0JBQWtCO1FBQ2xCLGlCQUFpQjtRQUNqQixRQUFRO0lBQ1o7SUFFQUMsU0FBUztRQUNMQyxTQUFTO1FBQ1RDLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxpQkFBaUI7UUFDakJDLE9BQU87WUFDSCxnQkFBZ0I7WUFDaEIsVUFBVTtRQUNkO0lBQ0o7SUFFQUMsYUFBWUMsUUFBUSxFQUFFQyxJQUFJO1FBQ3RCLE1BQU0sRUFBRVIsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUN4QixNQUFNLEVBQUVJLGVBQWUsRUFBRSxHQUFHSjtRQUM1QixJQUFJUztRQUNKLElBQUk7WUFDQSxNQUFNQyxRQUFRakIsd0RBQUNBLENBQUNlO1lBQ2hCQyxJQUFJQyxNQUFNQyxpQkFBaUIsR0FBR0MsSUFBSTtZQUNsQyxJQUFJRixNQUFNYixPQUFPLE9BQU8sVUFBVU8saUJBQWlCO2dCQUMvQyxNQUFNUyxxQkFBcUJKLEVBQUVLLE1BQU0sQ0FBQyxTQUFTO2dCQUM3QyxJQUFJRCxxQkFBcUIsR0FBRztvQkFDeEJKLElBQUlBLEVBQUVNLE1BQU0sQ0FBQyxHQUFHRjtnQkFDcEI7WUFDSjtRQUNKLEVBQUUsT0FBT0csT0FBTztZQUNaLCtDQUErQztZQUMvQyw0Q0FBNEM7WUFDNUMsTUFBTUMsV0FBV1YsU0FBU1csbUJBQW1CLENBQUNWO1lBQzlDQyxJQUFJaEIsb0RBQUNBLENBQUMwQixVQUFVLENBQUMzQix1REFBTUEsQ0FBQyxDQUFDLEdBQUdRLFNBQVNpQixTQUFTRyxNQUFNO1FBQ3hEO1FBQ0EsT0FBT1g7SUFDWDtJQUVBWSxxQkFBb0JkLFFBQVE7UUFDeEIsSUFBSSxDQUFDZSxHQUFHLENBQUNDLElBQUksQ0FBQyxLQUFLaEIsU0FBU2lCLHVCQUF1QjtJQUN2RDtJQUVBQyxlQUFjbEIsUUFBUSxFQUFFQyxJQUFJO1FBQ3hCLE1BQU0sRUFBRWMsR0FBRyxFQUFFdEIsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUM3QixNQUFNLEVBQUVDLE9BQU8sRUFBRXlCLEtBQUssRUFBRSxHQUFHMUI7UUFDM0IsSUFBSTJCLGtCQUFrQixJQUFJLENBQUNDLGFBQWEsQ0FBQ3JCLFVBQVVDO1FBQ25ELHdDQUF3QztRQUN4QyxJQUFJUCxTQUFTO1lBQ1QsSUFBSSxDQUFDeUIsU0FBU2xCLFNBQVNELFNBQVNzQixFQUFFLEVBQUU7Z0JBQ2hDLGlEQUFpRDtnQkFDakQseURBQXlEO2dCQUN6RCxpREFBaUQ7Z0JBQ2pEUCxJQUFJUSxNQUFNO1lBQ2Q7WUFDQSxJQUFJYixXQUFXVixTQUFTVyxtQkFBbUIsQ0FBQ1Y7WUFDNUMsTUFBTXVCLEtBQUtkLFNBQVNlLENBQUMsR0FBSWYsU0FBU2dCLEtBQUssR0FBRztZQUMxQyxNQUFNQyxLQUFLakIsU0FBU2tCLENBQUMsR0FBSWxCLFNBQVNtQixNQUFNLEdBQUc7WUFDM0NuQixXQUFXeEIsb0RBQUNBLENBQUM0QyxhQUFhLENBQUNwQixVQUFVVTtZQUNyQyxNQUFNTSxRQUFRSyxLQUFLQyxHQUFHLENBQUN0QixTQUFTZ0IsS0FBSyxFQUFFO1lBQ3ZDLE1BQU1HLFNBQVNFLEtBQUtDLEdBQUcsQ0FBQ3RCLFNBQVNtQixNQUFNLEVBQUU7WUFDekMsTUFBTUksS0FBSyxDQUFDUCxRQUFRaEMsT0FBTSxJQUFLZ0M7WUFDL0IsTUFBTVEsS0FBSyxDQUFDTCxTQUFTbkMsT0FBTSxJQUFLbUM7WUFDaEMsTUFBTU0sZ0JBQWdCakQsb0RBQUNBLENBQUNrRCxlQUFlLENBQUM7Z0JBQ3BDQyxHQUFHSjtnQkFDSEssR0FBRztnQkFDSEMsR0FBRztnQkFDSHJDLEdBQUdnQztnQkFDSE0sR0FBR2hCLEtBQUtTLEtBQUtUO2dCQUNiaUIsR0FBR2QsS0FBS08sS0FBS1A7WUFDakI7WUFDQVAsa0JBQWtCQSxnQkFBZ0JzQixRQUFRLENBQUNQO1FBQy9DO1FBQ0FwQixJQUFJQyxJQUFJLENBQUM7WUFDTCxLQUFLLElBQUksQ0FBQ2pCLFdBQVcsQ0FBQ0MsVUFBVUM7WUFDaEMsYUFBYWYsb0RBQUNBLENBQUN5RCx1QkFBdUIsQ0FBQ3ZCO1FBQzNDO0lBQ0o7SUFFQXdCLFdBQVU1QyxRQUFRLEVBQUVDLElBQUk7UUFDcEIsTUFBTSxFQUFFYyxHQUFHLEVBQUV0QixPQUFPLEVBQUUsR0FBRyxJQUFJO1FBQzdCc0IsSUFBSUMsSUFBSSxDQUFDdkIsUUFBUUssS0FBSztRQUN0QixJQUFJRSxTQUFTNkMsZ0JBQWdCLENBQUM1QyxPQUFPO1lBQ2pDLElBQUksQ0FBQ2EsbUJBQW1CLENBQUNkO1FBQzdCLE9BQU87WUFDSCxJQUFJLENBQUNrQixhQUFhLENBQUNsQixVQUFVQztRQUNqQztJQUNKO0FBRUosR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL2hpZ2hsaWdodGVycy9zdHJva2UubWpzPzNmNjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgSGlnaGxpZ2h0ZXJWaWV3IH0gZnJvbSAnLi4vZGlhL0hpZ2hsaWdodGVyVmlldy5tanMnO1xuXG5leHBvcnQgY29uc3Qgc3Ryb2tlID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgY2xhc3NOYW1lOiAnaGlnaGxpZ2h0LXN0cm9rZScsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICd2ZWN0b3ItZWZmZWN0JzogJ25vbi1zY2FsaW5nLXN0cm9rZScsXG4gICAgICAgICdmaWxsJzogJ25vbmUnXG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgcng6IDAsXG4gICAgICAgIHJ5OiAwLFxuICAgICAgICB1c2VGaXJzdFN1YnBhdGg6IGZhbHNlLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDMsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyNGRUI2NjMnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGF0aERhdGEoY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHVzZUZpcnN0U3VicGF0aCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2Tm9kZSA9IFYobm9kZSk7XG4gICAgICAgICAgICBkID0gdk5vZGUuY29udmVydFRvUGF0aERhdGEoKS50cmltKCk7XG4gICAgICAgICAgICBpZiAodk5vZGUudGFnTmFtZSgpID09PSAnUEFUSCcgJiYgdXNlRmlyc3RTdWJwYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kU3VicGF0aEluZGV4ID0gZC5zZWFyY2goLy5NL2kpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kU3VicGF0aEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gZC5zdWJzdHIoMCwgc2Vjb25kU3VicGF0aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBGYWlsZWQgdG8gZ2V0IHBhdGggZGF0YSBmcm9tIG1hZ25ldCBlbGVtZW50LlxuICAgICAgICAgICAgLy8gRHJhdyBhIHJlY3RhbmdsZSBhcm91bmQgdGhlIG5vZGUgaW5zdGVhZC5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVCQm94ID0gY2VsbFZpZXcuZ2V0Tm9kZUJvdW5kaW5nUmVjdChub2RlKTtcbiAgICAgICAgICAgIGQgPSBWLnJlY3RUb1BhdGgoYXNzaWduKHt9LCBvcHRpb25zLCBub2RlQkJveC50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH0sXG5cbiAgICBoaWdobGlnaHRDb25uZWN0aW9uKGNlbGxWaWV3KSB7XG4gICAgICAgIHRoaXMudmVsLmF0dHIoJ2QnLCBjZWxsVmlldy5nZXRTZXJpYWxpemVkQ29ubmVjdGlvbigpKTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0Tm9kZShjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IHZlbCwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBsYXllciB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGhpZ2hsaWdodE1hdHJpeCA9IHRoaXMuZ2V0Tm9kZU1hdHJpeChjZWxsVmlldywgbm9kZSk7XG4gICAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIHRoZSBoaWdobGlnaHQgZWxlbWVudC5cbiAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlmICghbGF5ZXIgJiYgbm9kZSA9PT0gY2VsbFZpZXcuZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGlnaGxpZ2h0ZXIgaXMgYXBwZW5kZWQgdG8gdGhlIGNlbGxWaWV3XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlIG1lYXN1cmUgdGhlIHNpemUgb2YgdGhlIGNlbGxWaWV3IHdyYXBwaW5nIGdyb3VwXG4gICAgICAgICAgICAgICAgLy8gaXQncyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBoaWdobGlnaHRlciBmaXJzdFxuICAgICAgICAgICAgICAgIHZlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBub2RlQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjeCA9IG5vZGVCQm94LnggKyAobm9kZUJCb3gud2lkdGggLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gbm9kZUJCb3gueSArIChub2RlQkJveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIG5vZGVCQm94ID0gVi50cmFuc2Zvcm1SZWN0KG5vZGVCQm94LCBoaWdobGlnaHRNYXRyaXgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChub2RlQkJveC53aWR0aCwgMSk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChub2RlQkJveC5oZWlnaHQsIDEpO1xuICAgICAgICAgICAgY29uc3Qgc3ggPSAod2lkdGggKyBwYWRkaW5nKSAvIHdpZHRoO1xuICAgICAgICAgICAgY29uc3Qgc3kgPSAoaGVpZ2h0ICsgcGFkZGluZykgLyBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nTWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoe1xuICAgICAgICAgICAgICAgIGE6IHN4LFxuICAgICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgICAgICBkOiBzeSxcbiAgICAgICAgICAgICAgICBlOiBjeCAtIHN4ICogY3gsXG4gICAgICAgICAgICAgICAgZjogY3kgLSBzeSAqIGN5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhpZ2hsaWdodE1hdHJpeCA9IGhpZ2hsaWdodE1hdHJpeC5tdWx0aXBseShwYWRkaW5nTWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICB2ZWwuYXR0cih7XG4gICAgICAgICAgICAnZCc6IHRoaXMuZ2V0UGF0aERhdGEoY2VsbFZpZXcsIG5vZGUpLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcoaGlnaGxpZ2h0TWF0cml4KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0KGNlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgdmVsLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICB2ZWwuYXR0cihvcHRpb25zLmF0dHJzKTtcbiAgICAgICAgaWYgKGNlbGxWaWV3LmlzTm9kZUNvbm5lY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29ubmVjdGlvbihjZWxsVmlldyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE5vZGUoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJWIiwiSGlnaGxpZ2h0ZXJWaWV3Iiwic3Ryb2tlIiwiZXh0ZW5kIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImF0dHJpYnV0ZXMiLCJvcHRpb25zIiwicGFkZGluZyIsInJ4IiwicnkiLCJ1c2VGaXJzdFN1YnBhdGgiLCJhdHRycyIsImdldFBhdGhEYXRhIiwiY2VsbFZpZXciLCJub2RlIiwiZCIsInZOb2RlIiwiY29udmVydFRvUGF0aERhdGEiLCJ0cmltIiwic2Vjb25kU3VicGF0aEluZGV4Iiwic2VhcmNoIiwic3Vic3RyIiwiZXJyb3IiLCJub2RlQkJveCIsImdldE5vZGVCb3VuZGluZ1JlY3QiLCJyZWN0VG9QYXRoIiwidG9KU09OIiwiaGlnaGxpZ2h0Q29ubmVjdGlvbiIsInZlbCIsImF0dHIiLCJnZXRTZXJpYWxpemVkQ29ubmVjdGlvbiIsImhpZ2hsaWdodE5vZGUiLCJsYXllciIsImhpZ2hsaWdodE1hdHJpeCIsImdldE5vZGVNYXRyaXgiLCJlbCIsInJlbW92ZSIsImN4IiwieCIsIndpZHRoIiwiY3kiLCJ5IiwiaGVpZ2h0IiwidHJhbnNmb3JtUmVjdCIsIk1hdGgiLCJtYXgiLCJzeCIsInN5IiwicGFkZGluZ01hdHJpeCIsImNyZWF0ZVNWR01hdHJpeCIsImEiLCJiIiwiYyIsImUiLCJmIiwibXVsdGlwbHkiLCJtYXRyaXhUb1RyYW5zZm9ybVN0cmluZyIsImhpZ2hsaWdodCIsImlzTm9kZUNvbm5lY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/highlighters/stroke.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/layout/ports/port.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/layout/ports/port.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolute: () => (/* binding */ absolute),\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   ellipse: () => (/* binding */ ellipse),\n/* harmony export */   ellipseSpread: () => (/* binding */ ellipseSpread),\n/* harmony export */   fn: () => (/* binding */ fn),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   line: () => (/* binding */ line),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top)\n/* harmony export */ });\n/* harmony import */ var _dia_attributes_calc_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dia/attributes/calc.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/attributes/calc.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n\n\n\nfunction portTransformAttrs(point, angle, opt) {\n    var trans = point.toJSON();\n    trans.angle = angle || 0;\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, trans);\n}\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt((index + 0.5) / ports.length);\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2));\n}\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n    var ellipse = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse.fromRect(elBBox);\n    return ports.map(function(port, index, ports) {\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if ((0,_dia_attributes_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcAttribute)(x)) {\n        x = Number((0,_dia_attributes_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcAttribute)(x, bbox));\n    }\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if ((0,_dia_attributes_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcAttribute)(y)) {\n        y = Number((0,_dia_attributes_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcAttribute)(y, bbox));\n    }\n    return {\n        x,\n        y,\n        angle\n    };\n}\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(x || 0, y || 0);\n}\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const absolute = function(ports, elBBox) {\n    return ports.map((port)=>{\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const line = function(ports, elBBox, opt) {\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n    return lineLayout(ports, start, end, elBBox);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */ const bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */ const ellipseSpread = function(ports, elBBox, opt) {\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */ const ellipse = function(ports, elBBox, opt) {\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvbGF5b3V0L3BvcnRzL3BvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRjtBQUM1QztBQUNNO0FBRTdDLFNBQVNJLG1CQUFtQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEdBQUc7SUFFekMsSUFBSUMsUUFBUUgsTUFBTUksTUFBTTtJQUV4QkQsTUFBTUYsS0FBSyxHQUFHQSxTQUFTO0lBRXZCLE9BQU9ILHFEQUFhLENBQUMsQ0FBQyxHQUFHSSxLQUFLQztBQUNsQztBQUVBLFNBQVNHLFdBQVdDLEtBQUssRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07SUFDckMsT0FBT0gsTUFBTUksR0FBRyxDQUFDLFNBQVNDLElBQUksRUFBRUMsS0FBSyxFQUFFTixLQUFLO1FBQ3hDLElBQUlPLElBQUksSUFBSSxDQUFDQyxPQUFPLENBQUUsQ0FBQ0YsUUFBUSxHQUFFLElBQUtOLE1BQU1TLE1BQU07UUFDbEQsbUNBQW1DO1FBQ25DLElBQUlKLEtBQUtLLEVBQUUsSUFBSUwsS0FBS00sRUFBRSxFQUFFO1lBQ3BCSixFQUFFSyxNQUFNLENBQUNQLEtBQUtLLEVBQUUsSUFBSSxHQUFHTCxLQUFLTSxFQUFFLElBQUk7UUFDdEM7UUFDQSxPQUFPbkIsbUJBQW1CZSxFQUFFTSxLQUFLLElBQUksR0FBR0MsYUFBYVgsUUFBUUU7SUFDakUsR0FBR2YsOENBQU0sQ0FBQ1csSUFBSUM7QUFDbEI7QUFFQSxTQUFTYyxjQUFjaEIsS0FBSyxFQUFFRyxNQUFNLEVBQUVjLFVBQVUsRUFBRUMsTUFBTTtJQUVwRCxJQUFJQyxTQUFTaEIsT0FBT2dCLE1BQU07SUFDMUIsSUFBSUMsUUFBUWpCLE9BQU9rQixLQUFLLEdBQUdsQixPQUFPbUIsTUFBTTtJQUN4QyxJQUFJckIsS0FBS0UsT0FBT29CLFNBQVM7SUFFekIsSUFBSUMsVUFBVWxDLGlEQUFTLENBQUNvQyxRQUFRLENBQUN2QjtJQUVqQyxPQUFP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QUFLO1FBQ2pFLE9BQU8sQ0FBQ3RELFFBQVEsTUFBTXNELFFBQVEsS0FBS0Y7SUFDdkM7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvbGF5b3V0L3BvcnRzL3BvcnQubWpzPzI1ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXZhbENhbGNBdHRyaWJ1dGUsIGlzQ2FsY0F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2RpYS9hdHRyaWJ1dGVzL2NhbGMubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIHBvcnRUcmFuc2Zvcm1BdHRycyhwb2ludCwgYW5nbGUsIG9wdCkge1xuXG4gICAgdmFyIHRyYW5zID0gcG9pbnQudG9KU09OKCk7XG5cbiAgICB0cmFucy5hbmdsZSA9IGFuZ2xlIHx8IDA7XG5cbiAgICByZXR1cm4gdXRpbC5kZWZhdWx0cyh7fSwgb3B0LCB0cmFucyk7XG59XG5cbmZ1bmN0aW9uIGxpbmVMYXlvdXQocG9ydHMsIHAxLCBwMiwgZWxCQm94KSB7XG4gICAgcmV0dXJuIHBvcnRzLm1hcChmdW5jdGlvbihwb3J0LCBpbmRleCwgcG9ydHMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50QXQoKChpbmRleCArIDAuNSkgLyBwb3J0cy5sZW5ndGgpKTtcbiAgICAgICAgLy8gYGR4YCxgZHlgIHBlciBwb3J0IG9mZnNldCBvcHRpb25cbiAgICAgICAgaWYgKHBvcnQuZHggfHwgcG9ydC5keSkge1xuICAgICAgICAgICAgcC5vZmZzZXQocG9ydC5keCB8fCAwLCBwb3J0LmR5IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3J0VHJhbnNmb3JtQXR0cnMocC5yb3VuZCgpLCAwLCBhcmdUcmFuc2Zvcm0oZWxCQm94LCBwb3J0KSk7XG4gICAgfSwgZy5saW5lKHAxLCBwMikpO1xufVxuXG5mdW5jdGlvbiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIHN0ZXBGbikge1xuXG4gICAgdmFyIGNlbnRlciA9IGVsQkJveC5jZW50ZXIoKTtcbiAgICB2YXIgcmF0aW8gPSBlbEJCb3gud2lkdGggLyBlbEJCb3guaGVpZ2h0O1xuICAgIHZhciBwMSA9IGVsQkJveC50b3BNaWRkbGUoKTtcblxuICAgIHZhciBlbGxpcHNlID0gZy5FbGxpcHNlLmZyb21SZWN0KGVsQkJveCk7XG5cbiAgICByZXR1cm4gcG9ydHMubWFwKGZ1bmN0aW9uKHBvcnQsIGluZGV4LCBwb3J0cykge1xuXG4gICAgICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGUgKyBzdGVwRm4oaW5kZXgsIHBvcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBwMiA9IHAxLmNsb25lKClcbiAgICAgICAgICAgIC5yb3RhdGUoY2VudGVyLCAtYW5nbGUpXG4gICAgICAgICAgICAuc2NhbGUocmF0aW8sIDEsIGNlbnRlcik7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gcG9ydC5jb21wZW5zYXRlUm90YXRpb24gPyAtZWxsaXBzZS50YW5nZW50VGhldGEocDIpIDogMDtcblxuICAgICAgICAvLyBgZHhgLGBkeWAgcGVyIHBvcnQgb2Zmc2V0IG9wdGlvblxuICAgICAgICBpZiAocG9ydC5keCB8fCBwb3J0LmR5KSB7XG4gICAgICAgICAgICBwMi5vZmZzZXQocG9ydC5keCB8fCAwLCBwb3J0LmR5IHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYGRyYCBkZWx0YSByYWRpdXMgb3B0aW9uXG4gICAgICAgIGlmIChwb3J0LmRyKSB7XG4gICAgICAgICAgICBwMi5tb3ZlKGNlbnRlciwgcG9ydC5kcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9ydFRyYW5zZm9ybUF0dHJzKHAyLnJvdW5kKCksIHRoZXRhLCBhcmdUcmFuc2Zvcm0oZWxCQm94LCBwb3J0KSk7XG4gICAgfSk7XG59XG5cblxuZnVuY3Rpb24gYXJnVHJhbnNmb3JtKGJib3gsIGFyZ3MpIHtcbiAgICBsZXQgeyB4LCB5LCBhbmdsZSB9ID0gYXJncztcbiAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoeCkpIHtcbiAgICAgICAgeCA9IHBhcnNlRmxvYXQoeCkgLyAxMDAgKiBiYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAoaXNDYWxjQXR0cmlidXRlKHgpKSB7XG4gICAgICAgIHggPSBOdW1iZXIoZXZhbENhbGNBdHRyaWJ1dGUoeCwgYmJveCkpO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoeSkpIHtcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoeSkgLyAxMDAgKiBiYm94LmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGlzQ2FsY0F0dHJpYnV0ZSh5KSkge1xuICAgICAgICB5ID0gTnVtYmVyKGV2YWxDYWxjQXR0cmlidXRlKHksIGJib3gpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgYW5nbGUgfTtcbn1cblxuLy8gQ3JlYXRlcyBhIHBvaW50IHN0b3JlZCBpbiBhcmd1bWVudHNcbmZ1bmN0aW9uIGFyZ1BvaW50KGJib3gsIGFyZ3MpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGFyZ1RyYW5zZm9ybShiYm94LCBhcmdzKTtcbiAgICByZXR1cm4gbmV3IGcuUG9pbnQoeCB8fCAwLCB5IHx8IDApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFic29sdXRlID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCkge1xuICAgIHJldHVybiBwb3J0cy5tYXAocG9ydCA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gYXJnUG9pbnQoZWxCQm94LCBwb3J0KS5yb3VuZCgpLnRvSlNPTigpO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbi5hbmdsZSA9IHBvcnQuYW5nbGUgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgZm4gPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gb3B0LmZuKHBvcnRzLCBlbEJCb3gsIG9wdCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBsaW5lID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG5cbiAgICB2YXIgc3RhcnQgPSBhcmdQb2ludChlbEJCb3gsIG9wdC5zdGFydCB8fCBlbEJCb3gub3JpZ2luKCkpO1xuICAgIHZhciBlbmQgPSBhcmdQb2ludChlbEJCb3gsIG9wdC5lbmQgfHwgZWxCQm94LmNvcm5lcigpKTtcblxuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBzdGFydCwgZW5kLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgbGVmdCA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBlbEJCb3gub3JpZ2luKCksIGVsQkJveC5ib3R0b21MZWZ0KCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCByaWdodCA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBlbEJCb3gudG9wUmlnaHQoKSwgZWxCQm94LmNvcm5lcigpLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgdG9wID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxpbmVMYXlvdXQocG9ydHMsIGVsQkJveC5vcmlnaW4oKSwgZWxCQm94LnRvcFJpZ2h0KCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBib3R0b20gPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGluZUxheW91dChwb3J0cywgZWxCQm94LmJvdHRvbUxlZnQoKSwgZWxCQm94LmNvcm5lcigpLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBlbGxpcHNlU3ByZWFkID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG5cbiAgICB2YXIgc3RhcnRBbmdsZSA9IG9wdC5zdGFydEFuZ2xlIHx8IDA7XG4gICAgdmFyIHN0ZXBBbmdsZSA9IG9wdC5zdGVwIHx8IDM2MCAvIHBvcnRzLmxlbmd0aDtcblxuICAgIHJldHVybiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCAqIHN0ZXBBbmdsZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgZWxsaXBzZSA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuXG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBvcHQuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHZhciBzdGVwQW5nbGUgPSBvcHQuc3RlcCB8fCAyMDtcblxuICAgIHJldHVybiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIGZ1bmN0aW9uKGluZGV4LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ICsgMC41IC0gY291bnQgLyAyKSAqIHN0ZXBBbmdsZTtcbiAgICB9KTtcbn07XG5cbiJdLCJuYW1lcyI6WyJldmFsQ2FsY0F0dHJpYnV0ZSIsImlzQ2FsY0F0dHJpYnV0ZSIsImciLCJ1dGlsIiwicG9ydFRyYW5zZm9ybUF0dHJzIiwicG9pbnQiLCJhbmdsZSIsIm9wdCIsInRyYW5zIiwidG9KU09OIiwiZGVmYXVsdHMiLCJsaW5lTGF5b3V0IiwicG9ydHMiLCJwMSIsInAyIiwiZWxCQm94IiwibWFwIiwicG9ydCIsImluZGV4IiwicCIsInBvaW50QXQiLCJsZW5ndGgiLCJkeCIsImR5Iiwib2Zmc2V0Iiwicm91bmQiLCJhcmdUcmFuc2Zvcm0iLCJsaW5lIiwiZWxsaXBzZUxheW91dCIsInN0YXJ0QW5nbGUiLCJzdGVwRm4iLCJjZW50ZXIiLCJyYXRpbyIsIndpZHRoIiwiaGVpZ2h0IiwidG9wTWlkZGxlIiwiZWxsaXBzZSIsIkVsbGlwc2UiLCJmcm9tUmVjdCIsImNsb25lIiwicm90YXRlIiwic2NhbGUiLCJ0aGV0YSIsImNvbXBlbnNhdGVSb3RhdGlvbiIsInRhbmdlbnRUaGV0YSIsImRyIiwibW92ZSIsImJib3giLCJhcmdzIiwieCIsInkiLCJpc1BlcmNlbnRhZ2UiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwiYXJnUG9pbnQiLCJQb2ludCIsImFic29sdXRlIiwidHJhbnNmb3JtYXRpb24iLCJmbiIsInN0YXJ0Iiwib3JpZ2luIiwiZW5kIiwiY29ybmVyIiwibGVmdCIsImJvdHRvbUxlZnQiLCJyaWdodCIsInRvcFJpZ2h0IiwidG9wIiwiYm90dG9tIiwiZWxsaXBzZVNwcmVhZCIsInN0ZXBBbmdsZSIsInN0ZXAiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/layout/ports/port.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/layout/ports/portLabel.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/jointjs/src/layout/ports/portLabel.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   inside: () => (/* binding */ inside),\n/* harmony export */   insideOriented: () => (/* binding */ insideOriented),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   manual: () => (/* binding */ manual),\n/* harmony export */   outside: () => (/* binding */ outside),\n/* harmony export */   outsideOriented: () => (/* binding */ outsideOriented),\n/* harmony export */   radial: () => (/* binding */ radial),\n/* harmony export */   radialOriented: () => (/* binding */ radialOriented),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n\nfunction labelAttributes(opt1, opt2) {\n    // use value from `opt2` if it is missing in `opt1`\n    // use value from this object if it is missing in `opt2` as well\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep({}, opt1, opt2, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {}\n    });\n}\nfunction getBBoxAngles(elBBox) {\n    var center = elBBox.center();\n    var tl = center.theta(elBBox.origin());\n    var bl = center.theta(elBBox.bottomLeft());\n    var br = center.theta(elBBox.corner());\n    var tr = center.theta(elBBox.topRight());\n    return [\n        tl,\n        tr,\n        br,\n        bl\n    ];\n}\nfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, {\n        offset: 15\n    });\n    var angle = elBBox.center().theta(portPosition);\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n        y = \".3em\";\n        tx = offset;\n        ty = 0;\n        textAnchor = \"start\";\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = \"start\";\n            y = \".3em\";\n        } else {\n            textAnchor = \"middle\";\n            y = \"0\";\n        }\n    } else if (angle < topRightAngle) {\n        y = \".3em\";\n        tx = -offset;\n        ty = 0;\n        textAnchor = \"end\";\n    } else {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = \"start\";\n            y = \".3em\";\n        } else {\n            textAnchor = \"middle\";\n            y = \".6em\";\n        }\n    }\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: {\n            labelText: {\n                y,\n                textAnchor\n            }\n        }\n    });\n}\nfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, {\n        offset: 15\n    });\n    var angle = elBBox.center().theta(portPosition);\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n        y = \".3em\";\n        tx = -offset;\n        ty = 0;\n        textAnchor = \"end\";\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = \"start\";\n            y = \".3em\";\n        } else {\n            textAnchor = \"middle\";\n            y = \".6em\";\n        }\n    } else if (angle < topRightAngle) {\n        y = \".3em\";\n        tx = offset;\n        ty = 0;\n        textAnchor = \"start\";\n    } else {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = \"start\";\n            y = \".3em\";\n        } else {\n            textAnchor = \"middle\";\n            y = \"0\";\n        }\n    }\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: {\n            labelText: {\n                y,\n                textAnchor\n            }\n        }\n    });\n}\nfunction radialLayout(portCenterOffset, autoOrient, opt) {\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, {\n        offset: 20\n    });\n    var origin = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.point(0, 0);\n    var angle = -portCenterOffset.theta(origin);\n    var orientAngle = angle;\n    var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();\n    var y = \".3em\";\n    var textAnchor;\n    if ((angle + 90) % 180 === 0) {\n        textAnchor = autoOrient ? \"end\" : \"middle\";\n        if (!autoOrient && angle === -270) {\n            y = \"0em\";\n        }\n    } else if (angle > -270 && angle < -90) {\n        textAnchor = \"start\";\n        orientAngle = angle - 180;\n    } else {\n        textAnchor = \"end\";\n    }\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(offset.x),\n        y: round(offset.y),\n        angle: autoOrient ? orientAngle : 0,\n        attrs: {\n            labelText: {\n                y,\n                textAnchor\n            }\n        }\n    });\n}\nconst manual = function(_portPosition, _elBBox, opt) {\n    return labelAttributes(opt);\n};\nconst left = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: -15,\n        attrs: {\n            labelText: {\n                y: \".3em\",\n                textAnchor: \"end\"\n            }\n        }\n    });\n};\nconst right = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: 15,\n        attrs: {\n            labelText: {\n                y: \".3em\",\n                textAnchor: \"start\"\n            }\n        }\n    });\n};\nconst top = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: -15,\n        attrs: {\n            labelText: {\n                y: \"0\",\n                textAnchor: \"middle\"\n            }\n        }\n    });\n};\nconst bottom = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: 15,\n        attrs: {\n            labelText: {\n                y: \".6em\",\n                textAnchor: \"middle\"\n            }\n        }\n    });\n};\nconst outsideOriented = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, true, opt);\n};\nconst outside = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, false, opt);\n};\nconst insideOriented = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, true, opt);\n};\nconst inside = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, false, opt);\n};\nconst radial = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n};\nconst radialOriented = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvbGF5b3V0L3BvcnRzL3BvcnRMYWJlbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNNO0FBRTdDLFNBQVNFLGdCQUFnQkMsSUFBSSxFQUFFQyxJQUFJO0lBRS9CLG1EQUFtRDtJQUNuRCxnRUFBZ0U7SUFDaEUsT0FBT0gseURBQWlCLENBQUMsQ0FBQyxHQUFHRSxNQUFNQyxNQUFNO1FBQ3JDRSxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsT0FBTztRQUNQQyxPQUFPLENBQUM7SUFDWjtBQUNKO0FBRUEsU0FBU0MsY0FBY0MsTUFBTTtJQUV6QixJQUFJQyxTQUFTRCxPQUFPQyxNQUFNO0lBRTFCLElBQUlDLEtBQUtELE9BQU9FLEtBQUssQ0FBQ0gsT0FBT0ksTUFBTTtJQUNuQyxJQUFJQyxLQUFLSixPQUFPRSxLQUFLLENBQUNILE9BQU9NLFVBQVU7SUFDdkMsSUFBSUMsS0FBS04sT0FBT0UsS0FBSyxDQUFDSCxPQUFPUSxNQUFNO0lBQ25DLElBQUlDLEtBQUtSLE9BQU9FLEtBQUssQ0FBQ0gsT0FBT1UsUUFBUTtJQUVyQyxPQUFPO1FBQUNSO1FBQUlPO1FBQUlGO1FBQUlGO0tBQUc7QUFDM0I7QUFFQSxTQUFTTSxjQUFjQyxZQUFZLEVBQUVaLE1BQU0sRUFBRWEsVUFBVSxFQUFFQyxHQUFHO0lBRXhEQSxNQUFNeEIscURBQWEsQ0FBQyxDQUFDLEdBQUd3QixLQUFLO1FBQUVFLFFBQVE7SUFBRztJQUMxQyxJQUFJbkIsUUFBUUcsT0FBT0MsTUFBTSxHQUFHRSxLQUFLLENBQUNTO0lBRWxDLElBQUlLLElBQUlDLElBQUl0QixHQUFHdUI7SUFDZixJQUFJSCxTQUFTRixJQUFJRSxNQUFNO0lBQ3ZCLElBQUlJLGNBQWM7SUFFbEIsTUFBTSxDQUFDQyxjQUFjQyxpQkFBaUJDLGtCQUFrQkMsY0FBYyxHQUFHekIsY0FBY0M7SUFDdkYsSUFBSSxRQUFTc0IsbUJBQXFCekIsUUFBUTBCLGtC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QzVELE9BQU9lLGFBQWFqQixhQUFhc0IsVUFBVSxDQUFDbEMsT0FBT0MsTUFBTSxLQUFLLE1BQU1hO0FBQ3hFLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9sYXlvdXQvcG9ydHMvcG9ydExhYmVsLm1qcz9mYWJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGxhYmVsQXR0cmlidXRlcyhvcHQxLCBvcHQyKSB7XG5cbiAgICAvLyB1c2UgdmFsdWUgZnJvbSBgb3B0MmAgaWYgaXQgaXMgbWlzc2luZyBpbiBgb3B0MWBcbiAgICAvLyB1c2UgdmFsdWUgZnJvbSB0aGlzIG9iamVjdCBpZiBpdCBpcyBtaXNzaW5nIGluIGBvcHQyYCBhcyB3ZWxsXG4gICAgcmV0dXJuIHV0aWwuZGVmYXVsdHNEZWVwKHt9LCBvcHQxLCBvcHQyLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICBhdHRyczoge31cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QkJveEFuZ2xlcyhlbEJCb3gpIHtcblxuICAgIHZhciBjZW50ZXIgPSBlbEJCb3guY2VudGVyKCk7XG5cbiAgICB2YXIgdGwgPSBjZW50ZXIudGhldGEoZWxCQm94Lm9yaWdpbigpKTtcbiAgICB2YXIgYmwgPSBjZW50ZXIudGhldGEoZWxCQm94LmJvdHRvbUxlZnQoKSk7XG4gICAgdmFyIGJyID0gY2VudGVyLnRoZXRhKGVsQkJveC5jb3JuZXIoKSk7XG4gICAgdmFyIHRyID0gY2VudGVyLnRoZXRhKGVsQkJveC50b3BSaWdodCgpKTtcblxuICAgIHJldHVybiBbdGwsIHRyLCBiciwgYmxdO1xufVxuXG5mdW5jdGlvbiBvdXRzaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCBhdXRvT3JpZW50LCBvcHQpIHtcblxuICAgIG9wdCA9IHV0aWwuZGVmYXVsdHMoe30sIG9wdCwgeyBvZmZzZXQ6IDE1IH0pO1xuICAgIHZhciBhbmdsZSA9IGVsQkJveC5jZW50ZXIoKS50aGV0YShwb3J0UG9zaXRpb24pO1xuXG4gICAgdmFyIHR4LCB0eSwgeSwgdGV4dEFuY2hvcjtcbiAgICB2YXIgb2Zmc2V0ID0gb3B0Lm9mZnNldDtcbiAgICB2YXIgb3JpZW50QW5nbGUgPSAwO1xuXG4gICAgY29uc3QgW3RvcExlZnRBbmdsZSwgYm90dG9tTGVmdEFuZ2xlLCBib3R0b21SaWdodEFuZ2xlLCB0b3BSaWdodEFuZ2xlXSA9IGdldEJCb3hBbmdsZXMoZWxCQm94KTtcbiAgICBpZiAoKGFuZ2xlIDwgYm90dG9tTGVmdEFuZ2xlKSB8fCAoYW5nbGUgPiBib3R0b21SaWdodEFuZ2xlKSkge1xuICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB0eCA9IG9mZnNldDtcbiAgICAgICAgdHkgPSAwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICB9IGVsc2UgaWYgKGFuZ2xlIDwgdG9wTGVmdEFuZ2xlKSB7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgdHkgPSAtb2Zmc2V0O1xuICAgICAgICBpZiAoYXV0b09yaWVudCkge1xuICAgICAgICAgICAgb3JpZW50QW5nbGUgPSAtOTA7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB5ID0gJzAnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IHRvcFJpZ2h0QW5nbGUpIHtcbiAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgdHggPSAtb2Zmc2V0O1xuICAgICAgICB0eSA9IDA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHR5ID0gb2Zmc2V0O1xuICAgICAgICBpZiAoYXV0b09yaWVudCkge1xuICAgICAgICAgICAgb3JpZW50QW5nbGUgPSA5MDtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIHkgPSAnLjZlbSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHg6IHJvdW5kKHR4KSxcbiAgICAgICAgeTogcm91bmQodHkpLFxuICAgICAgICBhbmdsZTogb3JpZW50QW5nbGUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5LCB0ZXh0QW5jaG9yIH19XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgYXV0b09yaWVudCwgb3B0KSB7XG5cbiAgICBvcHQgPSB1dGlsLmRlZmF1bHRzKHt9LCBvcHQsIHsgb2Zmc2V0OiAxNSB9KTtcbiAgICB2YXIgYW5nbGUgPSBlbEJCb3guY2VudGVyKCkudGhldGEocG9ydFBvc2l0aW9uKTtcblxuICAgIHZhciB0eCwgdHksIHksIHRleHRBbmNob3I7XG4gICAgdmFyIG9mZnNldCA9IG9wdC5vZmZzZXQ7XG4gICAgdmFyIG9yaWVudEFuZ2xlID0gMDtcblxuICAgIGNvbnN0IFt0b3BMZWZ0QW5nbGUsIGJvdHRvbUxlZnRBbmdsZSwgYm90dG9tUmlnaHRBbmdsZSwgdG9wUmlnaHRBbmdsZV0gPSBnZXRCQm94QW5nbGVzKGVsQkJveCk7XG4gICAgaWYgKChhbmdsZSA8IGJvdHRvbUxlZnRBbmdsZSkgfHwgKGFuZ2xlID4gYm90dG9tUmlnaHRBbmdsZSkpIHtcbiAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgdHggPSAtb2Zmc2V0O1xuICAgICAgICB0eSA9IDA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICB9IGVsc2UgaWYgKGFuZ2xlIDwgdG9wTGVmdEFuZ2xlKSB7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgdHkgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChhdXRvT3JpZW50KSB7XG4gICAgICAgICAgICBvcmllbnRBbmdsZSA9IDkwO1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgeSA9ICcuNmVtJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCB0b3BSaWdodEFuZ2xlKSB7XG4gICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIHR4ID0gb2Zmc2V0O1xuICAgICAgICB0eSA9IDA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgdHkgPSAtb2Zmc2V0O1xuICAgICAgICBpZiAoYXV0b09yaWVudCkge1xuICAgICAgICAgICAgb3JpZW50QW5nbGUgPSAtOTA7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB5ID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB4OiByb3VuZCh0eCksXG4gICAgICAgIHk6IHJvdW5kKHR5KSxcbiAgICAgICAgYW5nbGU6IG9yaWVudEFuZ2xlLFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeSwgdGV4dEFuY2hvciB9fVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByYWRpYWxMYXlvdXQocG9ydENlbnRlck9mZnNldCwgYXV0b09yaWVudCwgb3B0KSB7XG5cbiAgICBvcHQgPSB1dGlsLmRlZmF1bHRzKHt9LCBvcHQsIHsgb2Zmc2V0OiAyMCB9KTtcblxuICAgIHZhciBvcmlnaW4gPSBnLnBvaW50KDAsIDApO1xuICAgIHZhciBhbmdsZSA9IC1wb3J0Q2VudGVyT2Zmc2V0LnRoZXRhKG9yaWdpbik7XG4gICAgdmFyIG9yaWVudEFuZ2xlID0gYW5nbGU7XG4gICAgdmFyIG9mZnNldCA9IHBvcnRDZW50ZXJPZmZzZXQuY2xvbmUoKVxuICAgICAgICAubW92ZShvcmlnaW4sIG9wdC5vZmZzZXQpXG4gICAgICAgIC5kaWZmZXJlbmNlKHBvcnRDZW50ZXJPZmZzZXQpXG4gICAgICAgIC5yb3VuZCgpO1xuXG4gICAgdmFyIHkgPSAnLjNlbSc7XG4gICAgdmFyIHRleHRBbmNob3I7XG5cbiAgICBpZiAoKGFuZ2xlICsgOTApICUgMTgwID09PSAwKSB7XG4gICAgICAgIHRleHRBbmNob3IgPSBhdXRvT3JpZW50ID8gJ2VuZCcgOiAnbWlkZGxlJztcbiAgICAgICAgaWYgKCFhdXRvT3JpZW50ICYmIGFuZ2xlID09PSAtMjcwKSB7XG4gICAgICAgICAgICB5ID0gJzBlbSc7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuZ2xlID4gLTI3MCAmJiBhbmdsZSA8IC05MCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgb3JpZW50QW5nbGUgPSBhbmdsZSAtIDE4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB4OiByb3VuZChvZmZzZXQueCksXG4gICAgICAgIHk6IHJvdW5kKG9mZnNldC55KSxcbiAgICAgICAgYW5nbGU6ICgoYXV0b09yaWVudCkgPyBvcmllbnRBbmdsZSA6IDApLFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeSwgdGV4dEFuY2hvciB9fVxuICAgIH0pO1xufVxuXG5leHBvcnQgY29uc3QgbWFudWFsID0gZnVuY3Rpb24oX3BvcnRQb3NpdGlvbiwgX2VsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlZnQgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeDogLTE1LFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeTogJy4zZW0nLCB0ZXh0QW5jaG9yOiAnZW5kJyB9fSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCByaWdodCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB4OiAxNSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHk6ICcuM2VtJywgdGV4dEFuY2hvcjogJ3N0YXJ0JyB9fSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b3AgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeTogLTE1LFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeTogJzAnLCB0ZXh0QW5jaG9yOiAnbWlkZGxlJyB9fSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBib3R0b20gPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeTogMTUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5OiAnLjZlbScsIHRleHRBbmNob3I6ICdtaWRkbGUnIH19LFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IG91dHNpZGVPcmllbnRlZCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gb3V0c2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgdHJ1ZSwgb3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBvdXRzaWRlID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBvdXRzaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCBmYWxzZSwgb3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBpbnNpZGVPcmllbnRlZCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gaW5zaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCB0cnVlLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGluc2lkZSA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gaW5zaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCBmYWxzZSwgb3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCByYWRpYWwgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIHJhZGlhbExheW91dChwb3J0UG9zaXRpb24uZGlmZmVyZW5jZShlbEJCb3guY2VudGVyKCkpLCBmYWxzZSwgb3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCByYWRpYWxPcmllbnRlZCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gcmFkaWFsTGF5b3V0KHBvcnRQb3NpdGlvbi5kaWZmZXJlbmNlKGVsQkJveC5jZW50ZXIoKSksIHRydWUsIG9wdCk7XG59O1xuIl0sIm5hbWVzIjpbImciLCJ1dGlsIiwibGFiZWxBdHRyaWJ1dGVzIiwib3B0MSIsIm9wdDIiLCJkZWZhdWx0c0RlZXAiLCJ4IiwieSIsImFuZ2xlIiwiYXR0cnMiLCJnZXRCQm94QW5nbGVzIiwiZWxCQm94IiwiY2VudGVyIiwidGwiLCJ0aGV0YSIsIm9yaWdpbiIsImJsIiwiYm90dG9tTGVmdCIsImJyIiwiY29ybmVyIiwidHIiLCJ0b3BSaWdodCIsIm91dHNpZGVMYXlvdXQiLCJwb3J0UG9zaXRpb24iLCJhdXRvT3JpZW50Iiwib3B0IiwiZGVmYXVsdHMiLCJvZmZzZXQiLCJ0eCIsInR5IiwidGV4dEFuY2hvciIsIm9yaWVudEFuZ2xlIiwidG9wTGVmdEFuZ2xlIiwiYm90dG9tTGVmdEFuZ2xlIiwiYm90dG9tUmlnaHRBbmdsZSIsInRvcFJpZ2h0QW5nbGUiLCJyb3VuZCIsIk1hdGgiLCJsYWJlbFRleHQiLCJpbnNpZGVMYXlvdXQiLCJyYWRpYWxMYXlvdXQiLCJwb3J0Q2VudGVyT2Zmc2V0IiwicG9pbnQiLCJjbG9uZSIsIm1vdmUiLCJkaWZmZXJlbmNlIiwibWFudWFsIiwiX3BvcnRQb3NpdGlvbiIsIl9lbEJCb3giLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJvdXRzaWRlT3JpZW50ZWQiLCJvdXRzaWRlIiwiaW5zaWRlT3JpZW50ZWQiLCJpbnNpZGUiLCJyYWRpYWwiLCJyYWRpYWxPcmllbnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/layout/ports/portLabel.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/linkAnchors/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/linkAnchors/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectionClosest: () => (/* binding */ connectionClosest),\n/* harmony export */   connectionLength: () => (/* binding */ connectionLength),\n/* harmony export */   connectionPerpendicular: () => (/* binding */ connectionPerpendicular),\n/* harmony export */   connectionRatio: () => (/* binding */ connectionRatio),\n/* harmony export */   resolveRef: () => (/* binding */ resolveRef)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n    var ratio = \"ratio\" in opt ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n    var length = \"length\" in opt ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, {\n        segmentSubdivisions: segmentSubdivisions\n    });\n    var horizontalIntersections = horizontalLine.intersect(path, {\n        segmentSubdivisions: segmentSubdivisions\n    });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if (\"fallbackAt\" in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    return closestPoint;\n}\nfunction resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = \"fixedAt\" in opt ? opt.fixedAt : \"50%\";\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n// joint.linkAnchors\n\nconst connectionPerpendicular = resolveRef(_connectionPerpendicular);\nconst connectionClosest = resolveRef(_connectionClosest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvbGlua0FuY2hvcnMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0k7QUFFakQsU0FBU0csZ0JBQWdCQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBRWxELElBQUlDLFFBQVEsV0FBWUQsTUFBT0EsSUFBSUMsS0FBSyxHQUFHO0lBQzNDLE9BQU9KLEtBQUtLLGVBQWUsQ0FBQ0Q7QUFDaEM7QUFFQSxTQUFTRSxpQkFBaUJOLElBQUksRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLEdBQUc7SUFFbkQsSUFBSUksU0FBUyxZQUFhSixNQUFPQSxJQUFJSSxNQUFNLEdBQUc7SUFDOUMsT0FBT1AsS0FBS1EsZ0JBQWdCLENBQUNEO0FBQ2pDO0FBRUEsU0FBU0UseUJBQXlCVCxJQUFJLEVBQUVDLE9BQU8sRUFBRVMsUUFBUSxFQUFFUCxHQUFHO0lBRTFELElBQUlRLFNBQVM7SUFDYixJQUFJQyxPQUFPWixLQUFLYSxhQUFhO0lBQzdCLElBQUlDLHNCQUFzQmQsS0FBS2UseUJBQXlCO0lBQ3hELElBQUlDLGVBQWUsSUFBSXBCLDhDQUFJQSxDQUFDYyxTQUFTTyxLQUFLLEdBQUdDLE1BQU0sQ0FBQyxHQUFHUCxTQUFTRCxTQUFTTyxLQUFLLEdBQUdDLE1BQU0sQ0FBQyxHQUFHLENBQUNQO0lBQzVGLElBQUlRLGlCQUFpQixJQUFJdkIsOENBQUlBLENBQUNjLFNBQVNPLEtBQUssR0FBR0MsTUFBTSxDQUFDUCxRQUFRLElBQUlELFNBQVNPLEtBQUssR0FBR0MsTUFBTSxDQUFDLENBQUNQLFFBQVE7SUFDbkcsSUFBSVMsd0JBQXdCSixhQUFhSyxTQUFTLENBQUNULE1BQU07UUFBRUUscUJBQXFCQTtJQUFvQjtJQUNwRyxJQUFJUSwwQkFBMEJILGVBQWVFLFNBQVMsQ0FBQ1QsTUFBTTtRQUFFRSxxQkFBcUJBO0lBQW9CO0lBQ3hHLElBQUlTLGdCQUFnQixFQUFFO0lBQ3RCLElBQUlILHVCQUF1QkksTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLEtBQUssQ0FBQ0osZUFBZUg7SUFDckUsSUFBSUUseUJBQXlCRSxNQUFNQyxTQUFTLENBQUNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDSixlQUFlRDtJQUN2RSxJQUFJQyxjQUFjaEIsTUFBTSxHQUFHLEdBQUcsT0FBT0csU0FBU2tCLGFBQWEsQ0FBQ0w7SUFDNUQsSUFBSSxnQkFBZ0JwQixLQUFLO1FBQ3JCLE9BQU8wQixlQUFlN0IsTUFBTUcsSUFBSTJCLFVBQVU7SUFDOUM7SUFDQSxPQUFPQyxrQkFBa0IvQixNQUFNQyxTQUFTUyxVQUFVUDtBQUN0RDtBQUVBLFNBQVM2QixtQkFBbUJoQyxJQUFJLEVBQUVDLE9BQU8sRUFBRVMsUUFBUSxFQUFFdUIsSUFBSTtJQUVyRCxJQUFJQyxlQUFlbEMsS0FBS21DLGVBQWUsQ0FBQ3pCO0lBQ3hDLElBQUksQ0FBQ3dCLGNBQWMsT0FBTyxJQUFJckMsK0NBQUtBO0lBQ25DLE9BQU9xQztBQUNYO0FBRU8sU0FBU0UsV0FBV0MsRUFBRTtJQUN6QixPQUFPLFNBQVNyQyxJQUFJLEVBQUVzQyxNQUFNLEVBQUVDLEdBQUcsRUFBRXBDLEdBQUc7UUFDbEMsSUFBSW9DLGVBQWVDLFNBQVM7WUFDeEIsSUFBSUMsVUFBVSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsUUFBUSxDQUFDSjtZQUNsQyxJQUFJN0I7WUFDSixJQUFJK0IsU0FBUztnQkFDVCxJQUFJQSxRQUFRRyxnQkFBZ0IsQ0FBQ0wsTUFBTTtvQkFDL0IsSUFBSU0sV0FBVyxhQUFjMUMsTUFBT0EsSUFBSTJDLE9BQU8sR0FBRztvQkFDbERwQyxXQUFXbUIsZUFBZVksU0FBU0k7Z0JBQ3ZDLE9BQU87b0JBQ0huQyxXQUFXK0IsUUFBUU0sV0FBVyxDQUFDUixLQUFLUyxNQUFNO2dCQUM5QztZQUNKLE9BQU87Z0JBQ0gsdUJBQXVCO2dCQUN2QnRDLFdBQVcsSUFBSWIsK0NBQUtBO1lBQ3hCO1lBQ0EsT0FBT3dDLEdBQUdZLElBQUksQ0FBQyxJQUFJLEVBQUVqRCxNQUFNc0MsUUFBUTVCLFVBQVVQO1FBQ2pEO1FBQ0EsT0FBT2tDLEdBQUdWLEtBQUssQ0FBQyxJQUFJLEVBQUV1QjtJQUMxQjtBQUNKO0FBRUEsU0FBU3JCLGVBQWU3QixJQUFJLEVBQUVtRCxLQUFLO0lBQy9CLElBQUlDLGNBQWNDLFdBQVdGO0lBQzdCLElBQUlyRCw2REFBWUEsQ0FBQ3FELFFBQVE7UUFDckIsT0FBT25ELEtBQUtLLGVBQWUsQ0FBQytDLGNBQWM7SUFDOUMsT0FBTztRQUNILE9BQU9wRCxLQUFLUSxnQkFBZ0IsQ0FBQzRDO0lBQ2pDO0FBQ0o7QUFFQSxvQkFBb0I7QUFDeUI7QUFDdEMsTUFBTUUsMEJBQTBCbEIsV0FBVzNCLDBCQUEwQjtBQUNyRSxNQUFNc0Isb0JBQW9CSyxXQUFXSixvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9saW5rQW5jaG9ycy9pbmRleC5tanM/Y2JkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaW5lLCBQb2ludCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzUGVyY2VudGFnZSB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gY29ubmVjdGlvblJhdGlvKHZpZXcsIF9tYWduZXQsIF9yZWZQb2ludCwgb3B0KSB7XG5cbiAgICB2YXIgcmF0aW8gPSAoJ3JhdGlvJyBpbiBvcHQpID8gb3B0LnJhdGlvIDogMC41O1xuICAgIHJldHVybiB2aWV3LmdldFBvaW50QXRSYXRpbyhyYXRpbyk7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3Rpb25MZW5ndGgodmlldywgX21hZ25ldCwgX3JlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciBsZW5ndGggPSAoJ2xlbmd0aCcgaW4gb3B0KSA/IG9wdC5sZW5ndGggOiAyMDtcbiAgICByZXR1cm4gdmlldy5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIF9jb25uZWN0aW9uUGVycGVuZGljdWxhcih2aWV3LCBfbWFnbmV0LCByZWZQb2ludCwgb3B0KSB7XG5cbiAgICB2YXIgT0ZGU0VUID0gMWU2O1xuICAgIHZhciBwYXRoID0gdmlldy5nZXRDb25uZWN0aW9uKCk7XG4gICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSB2aWV3LmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKTtcbiAgICB2YXIgdmVydGljYWxMaW5lID0gbmV3IExpbmUocmVmUG9pbnQuY2xvbmUoKS5vZmZzZXQoMCwgT0ZGU0VUKSwgcmVmUG9pbnQuY2xvbmUoKS5vZmZzZXQoMCwgLU9GRlNFVCkpO1xuICAgIHZhciBob3Jpem9udGFsTGluZSA9IG5ldyBMaW5lKHJlZlBvaW50LmNsb25lKCkub2Zmc2V0KE9GRlNFVCwgMCksIHJlZlBvaW50LmNsb25lKCkub2Zmc2V0KC1PRkZTRVQsIDApKTtcbiAgICB2YXIgdmVydGljYWxJbnRlcnNlY3Rpb25zID0gdmVydGljYWxMaW5lLmludGVyc2VjdChwYXRoLCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHNlZ21lbnRTdWJkaXZpc2lvbnMgfSk7XG4gICAgdmFyIGhvcml6b250YWxJbnRlcnNlY3Rpb25zID0gaG9yaXpvbnRhbExpbmUuaW50ZXJzZWN0KHBhdGgsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9KTtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIGlmICh2ZXJ0aWNhbEludGVyc2VjdGlvbnMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGludGVyc2VjdGlvbnMsIHZlcnRpY2FsSW50ZXJzZWN0aW9ucyk7XG4gICAgaWYgKGhvcml6b250YWxJbnRlcnNlY3Rpb25zKSBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbnRlcnNlY3Rpb25zLCBob3Jpem9udGFsSW50ZXJzZWN0aW9ucyk7XG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkgcmV0dXJuIHJlZlBvaW50LmNob29zZUNsb3Nlc3QoaW50ZXJzZWN0aW9ucyk7XG4gICAgaWYgKCdmYWxsYmFja0F0JyBpbiBvcHQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMaW5rKHZpZXcsIG9wdC5mYWxsYmFja0F0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25DbG9zZXN0KHZpZXcsIF9tYWduZXQsIHJlZlBvaW50LCBvcHQpO1xufVxuXG5mdW5jdGlvbiBfY29ubmVjdGlvbkNsb3Nlc3QodmlldywgX21hZ25ldCwgcmVmUG9pbnQsIF9vcHQpIHtcblxuICAgIHZhciBjbG9zZXN0UG9pbnQgPSB2aWV3LmdldENsb3Nlc3RQb2ludChyZWZQb2ludCk7XG4gICAgaWYgKCFjbG9zZXN0UG9pbnQpIHJldHVybiBuZXcgUG9pbnQoKTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVJlZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbih2aWV3LCBtYWduZXQsIHJlZiwgb3B0KSB7XG4gICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVmVmlldyA9IHRoaXMucGFwZXIuZmluZFZpZXcocmVmKTtcbiAgICAgICAgICAgIHZhciByZWZQb2ludDtcbiAgICAgICAgICAgIGlmIChyZWZWaWV3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlZpZXcuaXNOb2RlQ29ubmVjdGlvbihyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9ICgnZml4ZWRBdCcgaW4gb3B0KSA/IG9wdC5maXhlZEF0IDogJzUwJSc7XG4gICAgICAgICAgICAgICAgICAgIHJlZlBvaW50ID0gZ2V0UG9pbnRBdExpbmsocmVmVmlldywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZlBvaW50ID0gcmVmVmlldy5nZXROb2RlQkJveChyZWYpLmNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgICAgICAgICByZWZQb2ludCA9IG5ldyBQb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdmlldywgbWFnbmV0LCByZWZQb2ludCwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludEF0TGluayh2aWV3LCB2YWx1ZSkge1xuICAgIHZhciBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmIChpc1BlcmNlbnRhZ2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2aWV3LmdldFBvaW50QXRSYXRpbyhwYXJzZWRWYWx1ZSAvIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0UG9pbnRBdExlbmd0aChwYXJzZWRWYWx1ZSk7XG4gICAgfVxufVxuXG4vLyBqb2ludC5saW5rQW5jaG9yc1xuZXhwb3J0IHsgY29ubmVjdGlvblJhdGlvLCBjb25uZWN0aW9uTGVuZ3RoIH07XG5leHBvcnQgY29uc3QgY29ubmVjdGlvblBlcnBlbmRpY3VsYXIgPSByZXNvbHZlUmVmKF9jb25uZWN0aW9uUGVycGVuZGljdWxhcik7XG5leHBvcnQgY29uc3QgY29ubmVjdGlvbkNsb3Nlc3QgPSByZXNvbHZlUmVmKF9jb25uZWN0aW9uQ2xvc2VzdCk7XG4iXSwibmFtZXMiOlsiTGluZSIsIlBvaW50IiwiaXNQZXJjZW50YWdlIiwiY29ubmVjdGlvblJhdGlvIiwidmlldyIsIl9tYWduZXQiLCJfcmVmUG9pbnQiLCJvcHQiLCJyYXRpbyIsImdldFBvaW50QXRSYXRpbyIsImNvbm5lY3Rpb25MZW5ndGgiLCJsZW5ndGgiLCJnZXRQb2ludEF0TGVuZ3RoIiwiX2Nvbm5lY3Rpb25QZXJwZW5kaWN1bGFyIiwicmVmUG9pbnQiLCJPRkZTRVQiLCJwYXRoIiwiZ2V0Q29ubmVjdGlvbiIsInNlZ21lbnRTdWJkaXZpc2lvbnMiLCJnZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zIiwidmVydGljYWxMaW5lIiwiY2xvbmUiLCJvZmZzZXQiLCJob3Jpem9udGFsTGluZSIsInZlcnRpY2FsSW50ZXJzZWN0aW9ucyIsImludGVyc2VjdCIsImhvcml6b250YWxJbnRlcnNlY3Rpb25zIiwiaW50ZXJzZWN0aW9ucyIsIkFycmF5IiwicHJvdG90eXBlIiwicHVzaCIsImFwcGx5IiwiY2hvb3NlQ2xvc2VzdCIsImdldFBvaW50QXRMaW5rIiwiZmFsbGJhY2tBdCIsImNvbm5lY3Rpb25DbG9zZXN0IiwiX2Nvbm5lY3Rpb25DbG9zZXN0IiwiX29wdCIsImNsb3Nlc3RQb2ludCIsImdldENsb3Nlc3RQb2ludCIsInJlc29sdmVSZWYiLCJmbiIsIm1hZ25ldCIsInJlZiIsIkVsZW1lbnQiLCJyZWZWaWV3IiwicGFwZXIiLCJmaW5kVmlldyIsImlzTm9kZUNvbm5lY3Rpb24iLCJkaXN0YW5jZSIsImZpeGVkQXQiLCJnZXROb2RlQkJveCIsImNlbnRlciIsImNhbGwiLCJhcmd1bWVudHMiLCJ2YWx1ZSIsInBhcnNlZFZhbHVlIiwicGFyc2VGbG9hdCIsImNvbm5lY3Rpb25QZXJwZW5kaWN1bGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/linkAnchors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/mvc/View.mjs":
/*!***********************************************!*\
  !*** ./node_modules/jointjs/src/mvc/View.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   View: () => (/* binding */ View),\n/* harmony export */   views: () => (/* binding */ views)\n/* harmony export */ });\n/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ \"(ssr)/./node_modules/backbone/backbone.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/jointjs/src/config/index.mjs\");\n\n\n\n\n\nconst views = {};\nconst View = backbone__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    options: {},\n    theme: null,\n    themeClassNamePrefix: _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.addClassNamePrefix(\"theme-\"),\n    requireSetThemeOverride: false,\n    defaultTheme: _config_index_mjs__WEBPACK_IMPORTED_MODULE_3__.config.defaultTheme,\n    children: null,\n    childNodes: null,\n    DETACHABLE: true,\n    UPDATE_PRIORITY: 2,\n    FLAG_INSERT: 1 << 30,\n    FLAG_REMOVE: 1 << 29,\n    FLAG_INIT: 1 << 28,\n    constructor: function(options) {\n        this.requireSetThemeOverride = options && !!options.theme;\n        this.options = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign({}, this.options, options);\n        backbone__WEBPACK_IMPORTED_MODULE_0__.View.call(this, options);\n    },\n    initialize: function() {\n        views[this.cid] = this;\n        this.setTheme(this.options.theme || this.defaultTheme);\n        this.init();\n    },\n    unmount: function() {\n        if (this.svgElement) {\n            this.vel.remove();\n        } else {\n            this.$el.remove();\n        }\n    },\n    isMounted: function() {\n        return this.el.parentNode !== null;\n    },\n    renderChildren: function(children) {\n        children || (children = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"children\"));\n        if (children) {\n            var isSVG = this.svgElement;\n            var namespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].namespace[isSVG ? \"svg\" : \"xhtml\"];\n            var doc = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.parseDOMJSON(children, namespace);\n            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n            this.childNodes = doc.selectors;\n        }\n        return this;\n    },\n    findAttribute: function(attributeName, node) {\n        var currentNode = node;\n        while(currentNode && currentNode.nodeType === 1){\n            var attributeValue = currentNode.getAttribute(attributeName);\n            // attribute found\n            if (attributeValue) return attributeValue;\n            // do not climb up the DOM\n            if (currentNode === this.el) return null;\n            // try parent node\n            currentNode = currentNode.parentNode;\n        }\n        return null;\n    },\n    // Override the Backbone `_ensureElement()` method in order to create an\n    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n    // Expose class name setter as a separate method.\n    _ensureElement: function() {\n        if (!this.el) {\n            var tagName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"tagName\");\n            var attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"attributes\"));\n            var style = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"style\"));\n            if (this.id) attrs.id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"id\");\n            this.setElement(this._createElement(tagName));\n            this._setAttributes(attrs);\n            this._setStyle(style);\n        } else {\n            this.setElement(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"el\"));\n        }\n        this._ensureElClassName();\n    },\n    _setAttributes: function(attrs) {\n        if (this.svgElement) {\n            this.vel.attr(attrs);\n        } else {\n            this.$el.attr(attrs);\n        }\n    },\n    _setStyle: function(style) {\n        this.$el.css(style);\n    },\n    _createElement: function(tagName) {\n        if (this.svgElement) {\n            return document.createElementNS(_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].namespace.svg, tagName);\n        } else {\n            return document.createElement(tagName);\n        }\n    },\n    // Utilize an alternative DOM manipulation API by\n    // adding an element reference wrapped in Vectorizer.\n    _setElement: function(el) {\n        this.$el = el instanceof backbone__WEBPACK_IMPORTED_MODULE_0__.$ ? el : backbone__WEBPACK_IMPORTED_MODULE_0__.$(el);\n        this.el = this.$el[0];\n        if (this.svgElement) this.vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.el);\n    },\n    _ensureElClassName: function() {\n        var className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"className\");\n        if (!className) return;\n        var prefixedClassName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.addClassNamePrefix(className);\n        // Note: className removal here kept for backwards compatibility only\n        if (this.svgElement) {\n            this.vel.removeClass(className).addClass(prefixedClassName);\n        } else {\n            this.$el.removeClass(className).addClass(prefixedClassName);\n        }\n    },\n    init: function() {\n    // Intentionally empty.\n    // This method is meant to be overridden.\n    },\n    onRender: function() {\n    // Intentionally empty.\n    // This method is meant to be overridden.\n    },\n    confirmUpdate: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        return 0;\n    },\n    setTheme: function(theme, opt) {\n        opt = opt || {};\n        // Theme is already set, override is required, and override has not been set.\n        // Don't set the theme.\n        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n            return this;\n        }\n        this.removeThemeClassName();\n        this.addThemeClassName(theme);\n        this.onSetTheme(this.theme /* oldTheme */ , theme /* newTheme */ );\n        this.theme = theme;\n        return this;\n    },\n    addThemeClassName: function(theme) {\n        theme = theme || this.theme;\n        if (!theme) return this;\n        var className = this.themeClassNamePrefix + theme;\n        if (this.svgElement) {\n            this.vel.addClass(className);\n        } else {\n            this.$el.addClass(className);\n        }\n        return this;\n    },\n    removeThemeClassName: function(theme) {\n        theme = theme || this.theme;\n        var className = this.themeClassNamePrefix + theme;\n        if (this.svgElement) {\n            this.vel.removeClass(className);\n        } else {\n            this.$el.removeClass(className);\n        }\n        return this;\n    },\n    onSetTheme: function(oldTheme, newTheme) {\n    // Intentionally empty.\n    // This method is meant to be overridden.\n    },\n    remove: function() {\n        this.onRemove();\n        this.undelegateDocumentEvents();\n        views[this.cid] = null;\n        backbone__WEBPACK_IMPORTED_MODULE_0__.View.prototype.remove.apply(this, arguments);\n        return this;\n    },\n    onRemove: function() {\n    // Intentionally empty.\n    // This method is meant to be overridden.\n    },\n    getEventNamespace: function() {\n        // Returns a per-session unique namespace\n        return \".joint-event-ns-\" + this.cid;\n    },\n    delegateElementEvents: function(element, events, data) {\n        if (!events) return this;\n        data || (data = {});\n        var eventNS = this.getEventNamespace();\n        for(var eventName in events){\n            var method = events[eventName];\n            if (typeof method !== \"function\") method = this[method];\n            if (!method) continue;\n            jquery__WEBPACK_IMPORTED_MODULE_1__(element).on(eventName + eventNS, data, method.bind(this));\n        }\n        return this;\n    },\n    undelegateElementEvents: function(element) {\n        jquery__WEBPACK_IMPORTED_MODULE_1__(element).off(this.getEventNamespace());\n        return this;\n    },\n    delegateDocumentEvents: function(events, data) {\n        events || (events = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result(this, \"documentEvents\"));\n        return this.delegateElementEvents(document, events, data);\n    },\n    undelegateDocumentEvents: function() {\n        return this.undelegateElementEvents(document);\n    },\n    eventData: function(evt, data) {\n        if (!evt) throw new Error(\"eventData(): event object required.\");\n        var currentData = evt.data;\n        var key = \"__\" + this.cid + \"__\";\n        if (data === undefined) {\n            if (!currentData) return {};\n            return currentData[key] || {};\n        }\n        currentData || (currentData = evt.data = {});\n        currentData[key] || (currentData[key] = {});\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign(currentData[key], data);\n        return this;\n    },\n    stopPropagation: function(evt) {\n        this.eventData(evt, {\n            propagationStopped: true\n        });\n        return this;\n    },\n    isPropagationStopped: function(evt) {\n        return !!this.eventData(evt).propagationStopped;\n    }\n}, {\n    extend: function() {\n        var args = Array.from(arguments);\n        // Deep clone the prototype and static properties objects.\n        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n        var protoProps = args[0] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign({}, args[0]) || {};\n        var staticProps = args[1] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign({}, args[1]) || {};\n        // Need the real render method so that we can wrap it and call it later.\n        var renderFn = protoProps.render || this.prototype && this.prototype.render || null;\n        /*\n            Wrap the real render method so that:\n                .. `onRender` is always called.\n                .. `this` is always returned.\n        */ protoProps.render = function() {\n            if (typeof renderFn === \"function\") {\n                // Call the original render method.\n                renderFn.apply(this, arguments);\n            }\n            if (this.render.__render__ === renderFn) {\n                // Should always call onRender() method.\n                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n                this.onRender();\n            }\n            // Should always return itself.\n            return this;\n        };\n        protoProps.render.__render__ = renderFn;\n        return backbone__WEBPACK_IMPORTED_MODULE_0__.View.extend.call(this, protoProps, staticProps);\n    }\n});\nconst DoubleTapEventName = \"dbltap\";\nif (jquery__WEBPACK_IMPORTED_MODULE_1__.event && !(DoubleTapEventName in jquery__WEBPACK_IMPORTED_MODULE_1__.event.special)) {\n    const maxDelay = _config_index_mjs__WEBPACK_IMPORTED_MODULE_3__.config.doubleTapInterval;\n    const minDelay = 30;\n    jquery__WEBPACK_IMPORTED_MODULE_1__.event.special[DoubleTapEventName] = {\n        bindType: \"touchend\",\n        delegateType: \"touchend\",\n        handle: function(event, ...args) {\n            const { handleObj, target } = event;\n            const targetData = jquery__WEBPACK_IMPORTED_MODULE_1__.data(target);\n            const now = new Date().getTime();\n            const delta = \"lastTouch\" in targetData ? now - targetData.lastTouch : 0;\n            if (delta < maxDelay && delta > minDelay) {\n                targetData.lastTouch = null;\n                event.type = handleObj.origType;\n                // let jQuery handle the triggering of \"dbltap\" event handlers\n                handleObj.handler.call(this, event, ...args);\n            } else {\n                targetData.lastTouch = now;\n            }\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvbXZjL1ZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ1Q7QUFDbUI7QUFDWDtBQUNjO0FBRXRDLE1BQU1LLFFBQVEsQ0FBQyxFQUFFO0FBRWpCLE1BQU1DLE9BQU9OLDBDQUFhLENBQUNPLE1BQU0sQ0FBQztJQUVyQ0MsU0FBUyxDQUFDO0lBQ1ZDLE9BQU87SUFDUEMsc0JBQXNCUiwrREFBdUIsQ0FBQztJQUM5Q1UseUJBQXlCO0lBQ3pCQyxjQUFjVCxxREFBTUEsQ0FBQ1MsWUFBWTtJQUNqQ0MsVUFBVTtJQUNWQyxZQUFZO0lBRVpDLFlBQVk7SUFDWkMsaUJBQWlCO0lBQ2pCQyxhQUFhLEtBQUc7SUFDaEJDLGFBQWEsS0FBRztJQUNoQkMsV0FBVyxLQUFHO0lBRWRDLGFBQWEsU0FBU2IsT0FBTztRQUV6QixJQUFJLENBQUNJLHVCQUF1QixHQUFHSixXQUFXLENBQUMsQ0FBQ0EsUUFBUUMsS0FBSztRQUN6RCxJQUFJLENBQUNELE9BQU8sR0FBR04sbURBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDTSxPQUFPLEVBQUVBO1FBRTdDUiwwQ0FBYSxDQUFDdUIsSUFBSSxDQUFDLElBQUksRUFBRWY7SUFDN0I7SUFFQWdCLFlBQVk7UUFFUm5CLEtBQUssQ0FBQyxJQUFJLENBQUNvQixHQUFHLENBQUMsR0FBRyxJQUFJO1FBRXRCLElBQUksQ0FBQ0MsUUFBUSxDQUFDLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ0MsS0FBSyxJQUFJLElBQUksQ0FBQ0ksWUFBWTtRQUNyRCxJQUFJLENBQUNjLElBQUk7SUFDYjtJQUVBQyxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNDLFVBQVUsRUFBRTtZQUNqQixJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsTUFBTTtRQUNuQixPQUFPO1lBQ0gsSUFBSSxDQUFDQyxHQUFHLENBQUNELE1BQU07UUFDbkI7SUFDSjtJQUVBRSxXQUFXO1FBQ1AsT0FBTyxJQUFJLENB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Q3hDLHlGQUF5RjtnQkFDekYsSUFBSSxDQUFDekMsUUFBUTtZQUNqQjtZQUVBLCtCQUErQjtZQUMvQixPQUFPLElBQUk7UUFDZjtRQUVBdUMsV0FBV0csTUFBTSxDQUFDQyxVQUFVLEdBQUdGO1FBRS9CLE9BQU9uSCwwQ0FBYSxDQUFDTyxNQUFNLENBQUNnQixJQUFJLENBQUMsSUFBSSxFQUFFMEYsWUFBWUM7SUFDdkQ7QUFDSixHQUFHO0FBRUgsTUFBTUkscUJBQXFCO0FBQzNCLElBQUlySCx5Q0FBTyxJQUFJLENBQUVxSCxDQUFBQSxzQkFBc0JySCx5Q0FBTyxDQUFDdUgsT0FBTyxHQUFHO0lBQ3JELE1BQU1DLFdBQVdySCxxREFBTUEsQ0FBQ3NILGlCQUFpQjtJQUN6QyxNQUFNQyxXQUFXO0lBQ2pCMUgseUNBQU8sQ0FBQ3VILE9BQU8sQ0FBQ0YsbUJBQW1CLEdBQUc7UUFDbENNLFVBQVU7UUFDVkMsY0FBYztRQUNkQyxRQUFRLFNBQVNQLEtBQUssRUFBRSxHQUFHVCxJQUFJO1lBQzNCLE1BQU0sRUFBRWlCLFNBQVMsRUFBRUMsTUFBTSxFQUFFLEdBQUdUO1lBQzlCLE1BQU1VLGFBQWNoSSx3Q0FBTSxDQUFDK0g7WUFDM0IsTUFBTUUsTUFBTSxJQUFJQyxPQUFPQyxPQUFPO1lBQzlCLE1BQU1DLFFBQVEsZUFBZUosYUFBYUMsTUFBTUQsV0FBV0ssU0FBUyxHQUFHO1lBQ3ZFLElBQUlELFFBQVFaLFlBQVlZLFFBQVFWLFVBQVU7Z0JBQ3RDTSxXQUFXSyxTQUFTLEdBQUc7Z0JBQ3ZCZixNQUFNZ0IsSUFBSSxHQUFHUixVQUFVUyxRQUFRO2dCQUMvQiw4REFBOEQ7Z0JBQzlEVCxVQUFVVSxPQUFPLENBQUNsSCxJQUFJLENBQUMsSUFBSSxFQUFFZ0csVUFBVVQ7WUFDM0MsT0FBTztnQkFDSG1CLFdBQVdLLFNBQVMsR0FBR0o7WUFDM0I7UUFDSjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9tdmMvVmlldy5tanM/NTgxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnO1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCB2aWV3cyA9IHt9O1xuXG5leHBvcnQgY29uc3QgVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHt9LFxuICAgIHRoZW1lOiBudWxsLFxuICAgIHRoZW1lQ2xhc3NOYW1lUHJlZml4OiB1dGlsLmFkZENsYXNzTmFtZVByZWZpeCgndGhlbWUtJyksXG4gICAgcmVxdWlyZVNldFRoZW1lT3ZlcnJpZGU6IGZhbHNlLFxuICAgIGRlZmF1bHRUaGVtZTogY29uZmlnLmRlZmF1bHRUaGVtZSxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgICBjaGlsZE5vZGVzOiBudWxsLFxuXG4gICAgREVUQUNIQUJMRTogdHJ1ZSxcbiAgICBVUERBVEVfUFJJT1JJVFk6IDIsXG4gICAgRkxBR19JTlNFUlQ6IDE8PDMwLFxuICAgIEZMQUdfUkVNT1ZFOiAxPDwyOSxcbiAgICBGTEFHX0lOSVQ6IDE8PDI4LFxuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnJlcXVpcmVTZXRUaGVtZU92ZXJyaWRlID0gb3B0aW9ucyAmJiAhIW9wdGlvbnMudGhlbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEJhY2tib25lLlZpZXcuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmlld3NbdGhpcy5jaWRdID0gdGhpcztcblxuICAgICAgICB0aGlzLnNldFRoZW1lKHRoaXMub3B0aW9ucy50aGVtZSB8fCB0aGlzLmRlZmF1bHRUaGVtZSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH0sXG5cbiAgICB1bm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5wYXJlbnROb2RlICE9PSBudWxsO1xuICAgIH0sXG5cbiAgICByZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGRyZW4gfHwgKGNoaWxkcmVuID0gdXRpbC5yZXN1bHQodGhpcywgJ2NoaWxkcmVuJykpO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBpc1NWRyA9IHRoaXMuc3ZnRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBWLm5hbWVzcGFjZVtpc1NWRyA/ICdzdmcnIDogJ3hodG1sJ107XG4gICAgICAgICAgICB2YXIgZG9jID0gdXRpbC5wYXJzZURPTUpTT04oY2hpbGRyZW4sIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAoaXNTVkcgPyB0aGlzLnZlbCA6IHRoaXMuJGVsKS5lbXB0eSgpLmFwcGVuZChkb2MuZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmluZEF0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlTmFtZSwgbm9kZSkge1xuXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZm91bmRcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSkgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgLy8gZG8gbm90IGNsaW1iIHVwIHRoZSBET01cbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5lbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyB0cnkgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0aGUgQmFja2JvbmUgYF9lbnN1cmVFbGVtZW50KClgIG1ldGhvZCBpbiBvcmRlciB0byBjcmVhdGUgYW5cbiAgICAvLyBzdmcgZWxlbWVudCAoZS5nLiwgYDxnPmApIG5vZGUgdGhhdCB3cmFwcyBhbGwgdGhlIG5vZGVzIG9mIHRoZSBDZWxsIHZpZXcuXG4gICAgLy8gRXhwb3NlIGNsYXNzIG5hbWUgc2V0dGVyIGFzIGEgc2VwYXJhdGUgbWV0aG9kLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHV0aWwucmVzdWx0KHRoaXMsICd0YWdOYW1lJyk7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB1dGlsLmFzc2lnbih7fSwgdXRpbC5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB1dGlsLmFzc2lnbih7fSwgdXRpbC5yZXN1bHQodGhpcywgJ3N0eWxlJykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIGF0dHJzLmlkID0gdXRpbC5yZXN1bHQodGhpcywgJ2lkJyk7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCh1dGlsLnJlc3VsdCh0aGlzLCAnZWwnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5zdXJlRWxDbGFzc05hbWUoKTtcbiAgICB9LFxuXG4gICAgX3NldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVsLmF0dHIoYXR0cnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuYXR0cihhdHRycyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB0aGlzLiRlbC5jc3Moc3R5bGUpO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFYubmFtZXNwYWNlLnN2ZywgdGFnTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVdGlsaXplIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJIGJ5XG4gICAgLy8gYWRkaW5nIGFuIGVsZW1lbnQgcmVmZXJlbmNlIHdyYXBwZWQgaW4gVmVjdG9yaXplci5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdGhpcy4kZWwgPSBlbCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyBlbCA6IEJhY2tib25lLiQoZWwpO1xuICAgICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHRoaXMudmVsID0gVih0aGlzLmVsKTtcbiAgICB9LFxuXG4gICAgX2Vuc3VyZUVsQ2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHV0aWwucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgaWYgKCFjbGFzc05hbWUpIHJldHVybjtcbiAgICAgICAgdmFyIHByZWZpeGVkQ2xhc3NOYW1lID0gdXRpbC5hZGRDbGFzc05hbWVQcmVmaXgoY2xhc3NOYW1lKTtcbiAgICAgICAgLy8gTm90ZTogY2xhc3NOYW1lIHJlbW92YWwgaGVyZSBrZXB0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSkuYWRkQ2xhc3MocHJlZml4ZWRDbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKS5hZGRDbGFzcyhwcmVmaXhlZENsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgfSxcblxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAgICB9LFxuXG4gICAgY29uZmlybVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBzZXRUaGVtZTogZnVuY3Rpb24odGhlbWUsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICAvLyBUaGVtZSBpcyBhbHJlYWR5IHNldCwgb3ZlcnJpZGUgaXMgcmVxdWlyZWQsIGFuZCBvdmVycmlkZSBoYXMgbm90IGJlZW4gc2V0LlxuICAgICAgICAvLyBEb24ndCBzZXQgdGhlIHRoZW1lLlxuICAgICAgICBpZiAodGhpcy50aGVtZSAmJiB0aGlzLnJlcXVpcmVTZXRUaGVtZU92ZXJyaWRlICYmICFvcHQub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdmVUaGVtZUNsYXNzTmFtZSgpO1xuICAgICAgICB0aGlzLmFkZFRoZW1lQ2xhc3NOYW1lKHRoZW1lKTtcbiAgICAgICAgdGhpcy5vblNldFRoZW1lKHRoaXMudGhlbWUvKiBvbGRUaGVtZSAqLywgdGhlbWUvKiBuZXdUaGVtZSAqLyk7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkVGhlbWVDbGFzc05hbWU6IGZ1bmN0aW9uKHRoZW1lKSB7XG5cbiAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB0aGlzLnRoZW1lO1xuICAgICAgICBpZiAoIXRoZW1lKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy50aGVtZUNsYXNzTmFtZVByZWZpeCArIHRoZW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVsLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVRoZW1lQ2xhc3NOYW1lOiBmdW5jdGlvbih0aGVtZSkge1xuXG4gICAgICAgIHRoZW1lID0gdGhlbWUgfHwgdGhpcy50aGVtZTtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy50aGVtZUNsYXNzTmFtZVByZWZpeCArIHRoZW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uU2V0VGhlbWU6IGZ1bmN0aW9uKG9sZFRoZW1lLCBuZXdUaGVtZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5LlxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLlxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMub25SZW1vdmUoKTtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcblxuICAgICAgICB2aWV3c1t0aGlzLmNpZF0gPSBudWxsO1xuXG4gICAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgfSxcblxuICAgIGdldEV2ZW50TmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmV0dXJucyBhIHBlci1zZXNzaW9uIHVuaXF1ZSBuYW1lc3BhY2VcbiAgICAgICAgcmV0dXJuICcuam9pbnQtZXZlbnQtbnMtJyArIHRoaXMuY2lkO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZUVsZW1lbnRFdmVudHM6IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50cywgZGF0YSkge1xuICAgICAgICBpZiAoIWV2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSB7fSk7XG4gICAgICAgIHZhciBldmVudE5TID0gdGhpcy5nZXRFdmVudE5hbWVzcGFjZSgpO1xuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykgbWV0aG9kID0gdGhpc1ttZXRob2RdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgJChlbGVtZW50KS5vbihldmVudE5hbWUgKyBldmVudE5TLCBkYXRhLCBtZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuZGVsZWdhdGVFbGVtZW50RXZlbnRzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICQoZWxlbWVudCkub2ZmKHRoaXMuZ2V0RXZlbnROYW1lc3BhY2UoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZURvY3VtZW50RXZlbnRzOiBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICAgICAgZXZlbnRzIHx8IChldmVudHMgPSB1dGlsLnJlc3VsdCh0aGlzLCAnZG9jdW1lbnRFdmVudHMnKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlRWxlbWVudEV2ZW50cyhkb2N1bWVudCwgZXZlbnRzLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgdW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZWxlZ2F0ZUVsZW1lbnRFdmVudHMoZG9jdW1lbnQpO1xuICAgIH0sXG5cbiAgICBldmVudERhdGE6IGZ1bmN0aW9uKGV2dCwgZGF0YSkge1xuICAgICAgICBpZiAoIWV2dCkgdGhyb3cgbmV3IEVycm9yKCdldmVudERhdGEoKTogZXZlbnQgb2JqZWN0IHJlcXVpcmVkLicpO1xuICAgICAgICB2YXIgY3VycmVudERhdGEgPSBldnQuZGF0YTtcbiAgICAgICAgdmFyIGtleSA9ICdfXycgKyB0aGlzLmNpZCArICdfXyc7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudERhdGEpIHJldHVybiB7fTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0YVtrZXldIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRhIHx8IChjdXJyZW50RGF0YSA9IGV2dC5kYXRhID0ge30pO1xuICAgICAgICBjdXJyZW50RGF0YVtrZXldIHx8IChjdXJyZW50RGF0YVtrZXldID0ge30pO1xuICAgICAgICB1dGlsLmFzc2lnbihjdXJyZW50RGF0YVtrZXldLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBwcm9wYWdhdGlvblN0b3BwZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZXZlbnREYXRhKGV2dCkucHJvcGFnYXRpb25TdG9wcGVkO1xuICAgIH1cblxufSwge1xuXG4gICAgZXh0ZW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBEZWVwIGNsb25lIHRoZSBwcm90b3R5cGUgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9iamVjdHMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgdW5leHBlY3RlZCBiZWhhdmlvciB3aGVyZSBzb21lIHByb3BlcnRpZXMgYXJlIG92ZXJ3cml0dGVuIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIHByb3RvUHJvcHMgPSBhcmdzWzBdICYmIHV0aWwuYXNzaWduKHt9LCBhcmdzWzBdKSB8fCB7fTtcbiAgICAgICAgdmFyIHN0YXRpY1Byb3BzID0gYXJnc1sxXSAmJiB1dGlsLmFzc2lnbih7fSwgYXJnc1sxXSkgfHwge307XG5cbiAgICAgICAgLy8gTmVlZCB0aGUgcmVhbCByZW5kZXIgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHdyYXAgaXQgYW5kIGNhbGwgaXQgbGF0ZXIuXG4gICAgICAgIHZhciByZW5kZXJGbiA9IHByb3RvUHJvcHMucmVuZGVyIHx8ICh0aGlzLnByb3RvdHlwZSAmJiB0aGlzLnByb3RvdHlwZS5yZW5kZXIpIHx8IG51bGw7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFdyYXAgdGhlIHJlYWwgcmVuZGVyIG1ldGhvZCBzbyB0aGF0OlxuICAgICAgICAgICAgICAgIC4uIGBvblJlbmRlcmAgaXMgYWx3YXlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAuLiBgdGhpc2AgaXMgYWx3YXlzIHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBwcm90b1Byb3BzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbmRlckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgcmVuZGVyIG1ldGhvZC5cbiAgICAgICAgICAgICAgICByZW5kZXJGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXIuX19yZW5kZXJfXyA9PT0gcmVuZGVyRm4pIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYWx3YXlzIGNhbGwgb25SZW5kZXIoKSBtZXRob2QuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGNhbGwgaXQgb25seSBvbmNlIHdoZW4gcmVuZGVyRm4gaXMgYWN0dWFsIHByb3RvdHlwZSBtZXRob2QgaS5lLiBub3QgdGhlIHdyYXBwZXJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb3RvUHJvcHMucmVuZGVyLl9fcmVuZGVyX18gPSByZW5kZXJGbjtcblxuICAgICAgICByZXR1cm4gQmFja2JvbmUuVmlldy5leHRlbmQuY2FsbCh0aGlzLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcyk7XG4gICAgfVxufSk7XG5cbmNvbnN0IERvdWJsZVRhcEV2ZW50TmFtZSA9ICdkYmx0YXAnO1xuaWYgKCQuZXZlbnQgJiYgIShEb3VibGVUYXBFdmVudE5hbWUgaW4gJC5ldmVudC5zcGVjaWFsKSkge1xuICAgIGNvbnN0IG1heERlbGF5ID0gY29uZmlnLmRvdWJsZVRhcEludGVydmFsO1xuICAgIGNvbnN0IG1pbkRlbGF5ID0gMzA7XG4gICAgJC5ldmVudC5zcGVjaWFsW0RvdWJsZVRhcEV2ZW50TmFtZV0gPSB7XG4gICAgICAgIGJpbmRUeXBlOiAndG91Y2hlbmQnLFxuICAgICAgICBkZWxlZ2F0ZVR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgIGhhbmRsZTogZnVuY3Rpb24oZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFuZGxlT2JqLCB0YXJnZXQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSAgPSAkLmRhdGEodGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSAnbGFzdFRvdWNoJyBpbiB0YXJnZXREYXRhID8gbm93IC0gdGFyZ2V0RGF0YS5sYXN0VG91Y2ggOiAwO1xuICAgICAgICAgICAgaWYgKGRlbHRhIDwgbWF4RGVsYXkgJiYgZGVsdGEgPiBtaW5EZWxheSkge1xuICAgICAgICAgICAgICAgIHRhcmdldERhdGEubGFzdFRvdWNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgIC8vIGxldCBqUXVlcnkgaGFuZGxlIHRoZSB0cmlnZ2VyaW5nIG9mIFwiZGJsdGFwXCIgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0VG91Y2ggPSBub3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbIkJhY2tib25lIiwiJCIsInV0aWwiLCJWIiwiY29uZmlnIiwidmlld3MiLCJWaWV3IiwiZXh0ZW5kIiwib3B0aW9ucyIsInRoZW1lIiwidGhlbWVDbGFzc05hbWVQcmVmaXgiLCJhZGRDbGFzc05hbWVQcmVmaXgiLCJyZXF1aXJlU2V0VGhlbWVPdmVycmlkZSIsImRlZmF1bHRUaGVtZSIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsIkRFVEFDSEFCTEUiLCJVUERBVEVfUFJJT1JJVFkiLCJGTEFHX0lOU0VSVCIsIkZMQUdfUkVNT1ZFIiwiRkxBR19JTklUIiwiY29uc3RydWN0b3IiLCJhc3NpZ24iLCJjYWxsIiwiaW5pdGlhbGl6ZSIsImNpZCIsInNldFRoZW1lIiwiaW5pdCIsInVubW91bnQiLCJzdmdFbGVtZW50IiwidmVsIiwicmVtb3ZlIiwiJGVsIiwiaXNNb3VudGVkIiwiZWwiLCJwYXJlbnROb2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJyZXN1bHQiLCJpc1NWRyIsIm5hbWVzcGFjZSIsImRvYyIsInBhcnNlRE9NSlNPTiIsImVtcHR5IiwiYXBwZW5kIiwiZnJhZ21lbnQiLCJzZWxlY3RvcnMiLCJmaW5kQXR0cmlidXRlIiwiYXR0cmlidXRlTmFtZSIsIm5vZGUiLCJjdXJyZW50Tm9kZSIsIm5vZGVUeXBlIiwiYXR0cmlidXRlVmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJfZW5zdXJlRWxlbWVudCIsInRhZ05hbWUiLCJhdHRycyIsInN0eWxlIiwiaWQiLCJzZXRFbGVtZW50IiwiX2NyZWF0ZUVsZW1lbnQiLCJfc2V0QXR0cmlidXRlcyIsIl9zZXRTdHlsZSIsIl9lbnN1cmVFbENsYXNzTmFtZSIsImF0dHIiLCJjc3MiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInN2ZyIsImNyZWF0ZUVsZW1lbnQiLCJfc2V0RWxlbWVudCIsImNsYXNzTmFtZSIsInByZWZpeGVkQ2xhc3NOYW1lIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsIm9uUmVuZGVyIiwiY29uZmlybVVwZGF0ZSIsIm9wdCIsIm92ZXJyaWRlIiwicmVtb3ZlVGhlbWVDbGFzc05hbWUiLCJhZGRUaGVtZUNsYXNzTmFtZSIsIm9uU2V0VGhlbWUiLCJvbGRUaGVtZSIsIm5ld1RoZW1lIiwib25SZW1vdmUiLCJ1bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMiLCJwcm90b3R5cGUiLCJhcHBseSIsImFyZ3VtZW50cyIsImdldEV2ZW50TmFtZXNwYWNlIiwiZGVsZWdhdGVFbGVtZW50RXZlbnRzIiwiZWxlbWVudCIsImV2ZW50cyIsImRhdGEiLCJldmVudE5TIiwiZXZlbnROYW1lIiwibWV0aG9kIiwib24iLCJiaW5kIiwidW5kZWxlZ2F0ZUVsZW1lbnRFdmVudHMiLCJvZmYiLCJkZWxlZ2F0ZURvY3VtZW50RXZlbnRzIiwiZXZlbnREYXRhIiwiZXZ0IiwiRXJyb3IiLCJjdXJyZW50RGF0YSIsImtleSIsInVuZGVmaW5lZCIsInN0b3BQcm9wYWdhdGlvbiIsInByb3BhZ2F0aW9uU3RvcHBlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiYXJncyIsIkFycmF5IiwiZnJvbSIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInJlbmRlckZuIiwicmVuZGVyIiwiX19yZW5kZXJfXyIsIkRvdWJsZVRhcEV2ZW50TmFtZSIsImV2ZW50Iiwic3BlY2lhbCIsIm1heERlbGF5IiwiZG91YmxlVGFwSW50ZXJ2YWwiLCJtaW5EZWxheSIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwiaGFuZGxlT2JqIiwidGFyZ2V0IiwidGFyZ2V0RGF0YSIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiZGVsdGEiLCJsYXN0VG91Y2giLCJ0eXBlIiwib3JpZ1R5cGUiLCJoYW5kbGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/mvc/View.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/jointjs/src/routers/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: () => (/* reexport safe */ _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__.manhattan),\n/* harmony export */   metro: () => (/* reexport safe */ _metro_mjs__WEBPACK_IMPORTED_MODULE_4__.metro),\n/* harmony export */   normal: () => (/* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_0__.normal),\n/* harmony export */   oneSide: () => (/* reexport safe */ _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__.oneSide),\n/* harmony export */   orthogonal: () => (/* reexport safe */ _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__.orthogonal),\n/* harmony export */   rightAngle: () => (/* reexport safe */ _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__.rightAngle)\n/* harmony export */ });\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/normal.mjs\");\n/* harmony import */ var _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oneSide.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/oneSide.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/orthogonal.mjs\");\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manhattan.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/manhattan.mjs\");\n/* harmony import */ var _metro_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metro.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/metro.mjs\");\n/* harmony import */ var _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rightAngle.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/rightAngle.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0M7QUFDRztBQUNEO0FBQ0o7QUFDSyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL3JvdXRlcnMvaW5kZXgubWpzP2VlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9ub3JtYWwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25lU2lkZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vcnRob2dvbmFsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL21hbmhhdHRhbi5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRyby5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9yaWdodEFuZ2xlLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/manhattan.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/routers/manhattan.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: () => (/* binding */ manhattan)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/orthogonal.mjs\");\n\n\n\nvar config = {\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [],\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [\n        \"basic.Text\"\n    ],\n    // possible starting directions from an element\n    startDirections: [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ],\n    // possible ending directions to an element\n    endDirections: [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ],\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: {\n            x: 0,\n            y: -1\n        },\n        right: {\n            x: 1,\n            y: 0\n        },\n        bottom: {\n            x: 0,\n            y: 1\n        },\n        left: {\n            x: -1,\n            y: 0\n        }\n    },\n    // cost of an orthogonal step\n    cost: function() {\n        return this.step;\n    },\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n        var step = this.step;\n        var cost = this.cost();\n        return [\n            {\n                offsetX: step,\n                offsetY: 0,\n                cost: cost\n            },\n            {\n                offsetX: -step,\n                offsetY: 0,\n                cost: cost\n            },\n            {\n                offsetX: 0,\n                offsetY: step,\n                cost: cost\n            },\n            {\n                offsetX: 0,\n                offsetY: -step,\n                cost: cost\n            }\n        ];\n    },\n    // a penalty received for direction change\n    penalties: function() {\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n        var step = this.step;\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)) {\n            throw new Error(\"Manhattan requires the orthogonal router as default fallback.\");\n        }\n        return (0,_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n    },\n    /* Deprecated */ // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n        return null; // null result will trigger the fallbackRouter\n    // left for reference:\n    /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/ },\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n// HELPER CLASSES //\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\nObstacleMap.prototype.build = function(graph, link) {\n    var opt = this.options;\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeEnds).reduce(function(res, item) {\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n        return res;\n    }, []);\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n    var source = graph.getCell(link.get(\"source\").id);\n    if (source) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n    var target = graph.getCell(link.get(\"target\").id);\n    if (target) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n    graph.getElements().reduce(function(map, element) {\n        var isExcludedType = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeTypes).includes(element.get(\"type\"));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n            for(var x = origin.x; x <= corner.x; x += mapGridSize){\n                for(var y = origin.y; y <= corner.y; y += mapGridSize){\n                    var gridKey = x + \"@\" + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n        return map;\n    }, this.map);\n    return this;\n};\nObstacleMap.prototype.isPointAccessible = function(point) {\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\nSortedSet.prototype.add = function(item, value) {\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n    this.values[item] = value;\n    var index = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.sortedIndex(this.items, item, (function(i) {\n        return this.values[i];\n    }).bind(this));\n    this.items.splice(index, 0, item);\n};\nSortedSet.prototype.remove = function(item) {\n    this.hash[item] = this.CLOSE;\n};\nSortedSet.prototype.isOpen = function(item) {\n    return this.hash[item] === this.OPEN;\n};\nSortedSet.prototype.isClose = function(item) {\n    return this.hash[item] === this.CLOSE;\n};\nSortedSet.prototype.isEmpty = function() {\n    return this.items.length === 0;\n};\nSortedSet.prototype.pop = function() {\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n// HELPERS //\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n    return linkView.sourceBBox.clone();\n}\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n    return linkView.targetBBox.clone();\n}\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + quadrant / 2);\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n    var step = opt.step;\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(start.x + distanceX, start.y + distanceY);\n}\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n    var directionChange = Math.abs(angle1 - angle2);\n    return directionChange > 180 ? 360 - directionChange : directionChange;\n}\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n    var step = opt.step;\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n        direction.gridOffsetX = direction.offsetX / step * grid.x;\n        direction.gridOffsetY = direction.offsetY / step * grid.y;\n    });\n}\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n    // return step if diff = 0\n    if (!diff) return step;\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n    return step + stepCorrection;\n}\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n    var source = grid.source;\n    var snappedX = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.y - source.y, grid.y) + source.y;\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(snappedX, snappedY);\n}\n// round the point to opt.precision\nfunction round(point, precision) {\n    return point.round(precision);\n}\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n    return point.clone().toString();\n}\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\n// PATHFINDING //\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n    var route = [];\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n    var point;\n    while(parent){\n        // point is assumed to be aligned already\n        point = points[currentKey];\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n    return route;\n}\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n    var min = Infinity;\n    for(var i = 0, len = endPoints.length; i < len; i++){\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n    return min;\n}\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n    var anchorCenterVector = anchor.difference(bbox.center());\n    var keys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n            var intersectionLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(anchor, endpoint);\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for(var i = 0; i < numIntersections; i++){\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n        return res;\n    }, []);\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n    return rectPoints;\n}\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n    var precision = opt.precision;\n    // Get grid for this route.\n    var sourceAnchor, targetAnchor;\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n    // Get pathfinding points.\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n    // set of points we start pathfinding from\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n    } else {\n        start = sourceAnchor;\n        startPoints = [\n            start\n        ];\n    }\n    // set of points we want the pathfinding to finish at\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n    } else {\n        end = targetAnchor;\n        endPoints = [\n            end\n        ];\n    }\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter((p)=>!isPointObstacle(p));\n    endPoints = endPoints.filter((p)=>!isPointObstacle(p));\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n        for(var i = 0, n = startPoints.length; i < n; i++){\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n            var key = getKey(startPoint);\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = previousRouteDirectionAngle === undefined;\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n        var numDirections = directions.length;\n        var endPointsKeys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while(!openSet.isEmpty() && loopsRemaining > 0){\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n            var isRouteBeginning = currentParent === undefined; // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for(var j = 0; j < startPoints.length; j++){\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = isRouteBeginning && samePoints;\n            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n            // go over all possible directions and find neighbors\n            for(i = 0; i < numDirections; i++){\n                direction = directions[i];\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) {\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n                // The current direction is ok.\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n                if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n            loopsRemaining--;\n        }\n    }\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n// resolve some of the options\nfunction resolveOptions(opt) {\n    opt.directions = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, \"directions\");\n    opt.penalties = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, \"penalties\");\n    opt.paddingBox = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, \"paddingBox\");\n    opt.padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, \"padding\");\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n        var point1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0);\n        var point2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(direction.offsetX, direction.offsetY);\n        direction.angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(point1.theta(point2));\n    });\n}\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n    resolveOptions(opt);\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === \"function\") {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point)=>!map.isPointAccessible(point);\n    }\n    var oldVertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n    for(var i = 0, len = oldVertices.length; i <= len; i++){\n        var partialRoute = null;\n        from = to || sourceBBox;\n        to = oldVertices[i];\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n            to = targetBBox;\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get(\"source\").id || !linkView.model.get(\"target\").id;\n            if (isEndingAtPoint && _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = from === sourceBBox ? sourceAnchor : from;\n                var dragTo = to.origin();\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n        if (partialRoute === null) {\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n        var leadPoint = partialRoute[0];\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n    return newVertices;\n}\n// public function\nconst manhattan = function(vertices, opt, linkView) {\n    return router(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9tYW5oYXR0YW4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ007QUFDSTtBQUU5QyxJQUFJRyxTQUFTO0lBRVQsMEVBQTBFO0lBQzFFQyxNQUFNO0lBRU4sbUVBQW1FO0lBQ25FLGlDQUFpQztJQUNqQ0MsY0FBYztJQUVkLG1FQUFtRTtJQUNuRUMsV0FBVztJQUVYLDhCQUE4QjtJQUM5QkMsMkJBQTJCO0lBRTNCLHVEQUF1RDtJQUN2RCxvRkFBb0Y7SUFDcEYseUJBQXlCO0lBQ3pCQyxlQUFlO0lBRWYsa0VBQWtFO0lBQ2xFQyxhQUFhLEVBQUU7SUFFZixtRUFBbUU7SUFDbkVDLGNBQWM7UUFBQztLQUFhO0lBRTVCLCtDQUErQztJQUMvQ0MsaUJBQWlCO1FBQUM7UUFBTztRQUFTO1FBQVU7S0FBTztJQUVuRCwyQ0FBMkM7SUFDM0NDLGVBQWU7UUFBQztRQUFPO1FBQVM7UUFBVTtLQUFPO0lBRWpELHVEQUF1RDtJQUN2REMsY0FBYztRQUNWQyxLQUFLO1lBQUVDLEdBQUc7WUFBR0MsR0FBRyxDQUFDO1FBQUU7UUFDbkJDLE9BQU87WUFBRUYsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFDcEJFLFFBQVE7WUFBRUgsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFDckJHLE1BQU07WUFBRUosR0FBRyxDQUFDO1lBQUdDLEdBQUc7UUFBRTtJQUN4QjtJQUVBLDZCQUE2QjtJQUM3QkksTUFBTTtRQUVGLE9BQU8sSUFBSSxDQUFDaEIsSUFBSTtJQUNwQjtJQUVBLDBEQUEwRDtJQUMxRCxzQ0FBc0M7SUFDdENpQixZQUFZO1FBRVIsSUFBSWpCLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3BCLElBQUlnQixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUVwQixPQUFPO1lBQ0g7Z0JBQUVFLFNBQVNsQjtnQkFBTW1CLFNBQVM7Z0JBQUdILE1BQU1BO1lBQUs7WUFDeEM7Z0JBQUVFLFNBQVMsQ0FB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QUlvTixXQUFXLFNBQVU3SSxhQUFjSSxlQUFlN0U7Z0JBQ3RELElBQUl1TixTQUFTdE4sR0FBR3NDLE1BQU07Z0JBRXRCNkssZUFBZTFOLElBQUlRLGFBQWEsQ0FBQ3FNLElBQUksQ0FBQzVNLFVBQVUyTixVQUFVQyxRQUFRN047WUFDdEU7UUFDSjtRQUVBLHVGQUF1RjtRQUN2RjBOLGVBQWVBLGdCQUFnQjlDLFVBQVVpQyxJQUFJLENBQUM1TSxVQUFVSyxNQUFNQyxJQUFJVixpQkFBaUJHO1FBRW5GLElBQUkwTixpQkFBaUIsTUFBTTtZQUN2QixPQUFPMU4sSUFBSUYsY0FBYyxDQUFDQyxVQUFVQyxLQUFLQztRQUM3QztRQUVBLElBQUk0SSxZQUFZNkUsWUFBWSxDQUFDLEVBQUU7UUFFL0Isa0ZBQWtGO1FBQ2xGLElBQUk3RSxhQUFhQSxVQUFVRixNQUFNLENBQUNOLFlBQVlxRixhQUFhN0ksS0FBSztRQUVoRSxvQ0FBb0M7UUFDcEN3RCxZQUFZcUYsWUFBWSxDQUFDQSxhQUFhL0ksTUFBTSxHQUFHLEVBQUUsSUFBSTBEO1FBRXJEeUYsTUFBTWpOLFNBQVMsQ0FBQ2MsSUFBSSxDQUFDb00sS0FBSyxDQUFDTixhQUFhQztJQUM1QztJQUVBLE9BQU9EO0FBQ1g7QUFFQSxrQkFBa0I7QUFDWCxNQUFNTyxZQUFZLFNBQVNqTyxRQUFRLEVBQUVDLEdBQUcsRUFBRUMsUUFBUTtJQUNyRCxPQUFPb04sT0FBT3ROLFVBQVU3QixtREFBVyxDQUFDLENBQUMsR0FBR0UsUUFBUTRCLE1BQU1DO0FBQzFELEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9yb3V0ZXJzL21hbmhhdHRhbi5tanM/NmE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgb3J0aG9nb25hbCB9IGZyb20gJy4vb3J0aG9nb25hbC5tanMnO1xuXG52YXIgY29uZmlnID0ge1xuXG4gICAgLy8gc2l6ZSBvZiB0aGUgc3RlcCB0byBmaW5kIGEgcm91dGUgKHRoZSBncmlkIG9mIHRoZSBtYW5oYXR0YW4gcGF0aGZpbmRlcilcbiAgICBzdGVwOiAxMCxcblxuICAgIC8vIHRoZSBudW1iZXIgb2Ygcm91dGUgZmluZGluZyBsb29wcyB0aGF0IGNhdXNlIHRoZSByb3V0ZXIgdG8gYWJvcnRcbiAgICAvLyByZXR1cm5zIGZhbGxiYWNrIHJvdXRlIGluc3RlYWRcbiAgICBtYXhpbXVtTG9vcHM6IDIwMDAsXG5cbiAgICAvLyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIGZsb2F0aW5nIHBvaW50IGNvb3JkaW5hdGVzXG4gICAgcHJlY2lzaW9uOiAxLFxuXG4gICAgLy8gbWF4aW11bSBjaGFuZ2Ugb2YgZGlyZWN0aW9uXG4gICAgbWF4QWxsb3dlZERpcmVjdGlvbkNoYW5nZTogOTAsXG5cbiAgICAvLyBzaG91bGQgdGhlIHJvdXRlciB1c2UgcGVycGVuZGljdWxhciBsaW5rVmlldyBvcHRpb24/XG4gICAgLy8gZG9lcyBub3QgY29ubmVjdCBhbmNob3Igb2YgZWxlbWVudCBidXQgcmF0aGVyIGEgcG9pbnQgY2xvc2UtYnkgdGhhdCBpcyBvcnRob2dvbmFsXG4gICAgLy8gdGhpcyBsb29rcyBtdWNoIGJldHRlclxuICAgIHBlcnBlbmRpY3VsYXI6IHRydWUsXG5cbiAgICAvLyBzaG91bGQgdGhlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IG5vdCBiZSBjb25zaWRlcmVkIGFzIG9ic3RhY2xlcz9cbiAgICBleGNsdWRlRW5kczogW10sIC8vICdzb3VyY2UnLCAndGFyZ2V0J1xuXG4gICAgLy8gc2hvdWxkIGNlcnRhaW4gdHlwZXMgb2YgZWxlbWVudHMgbm90IGJlIGNvbnNpZGVyZWQgYXMgb2JzdGFjbGVzP1xuICAgIGV4Y2x1ZGVUeXBlczogWydiYXNpYy5UZXh0J10sXG5cbiAgICAvLyBwb3NzaWJsZSBzdGFydGluZyBkaXJlY3Rpb25zIGZyb20gYW4gZWxlbWVudFxuICAgIHN0YXJ0RGlyZWN0aW9uczogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcblxuICAgIC8vIHBvc3NpYmxlIGVuZGluZyBkaXJlY3Rpb25zIHRvIGFuIGVsZW1lbnRcbiAgICBlbmREaXJlY3Rpb25zOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuXG4gICAgLy8gc3BlY2lmeSB0aGUgZGlyZWN0aW9ucyB1c2VkIGFib3ZlIGFuZCB3aGF0IHRoZXkgbWVhblxuICAgIGRpcmVjdGlvbk1hcDoge1xuICAgICAgICB0b3A6IHsgeDogMCwgeTogLTEgfSxcbiAgICAgICAgcmlnaHQ6IHsgeDogMSwgeTogMCB9LFxuICAgICAgICBib3R0b206IHsgeDogMCwgeTogMSB9LFxuICAgICAgICBsZWZ0OiB7IHg6IC0xLCB5OiAwIH1cbiAgICB9LFxuXG4gICAgLy8gY29zdCBvZiBhbiBvcnRob2dvbmFsIHN0ZXBcbiAgICBjb3N0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwO1xuICAgIH0sXG5cbiAgICAvLyBhbiBhcnJheSBvZiBkaXJlY3Rpb25zIHRvIGZpbmQgbmV4dCBwb2ludHMgb24gdGhlIHJvdXRlXG4gICAgLy8gZGlmZmVyZW50IGZyb20gc3RhcnQvZW5kIGRpcmVjdGlvbnNcbiAgICBkaXJlY3Rpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcbiAgICAgICAgdmFyIGNvc3QgPSB0aGlzLmNvc3QoKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwLCBvZmZzZXRZOiAwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwLCBvZmZzZXRZOiAwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IDAsIG9mZnNldFk6IHN0ZXAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogLXN0ZXAsIGNvc3Q6IGNvc3QgfVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyBhIHBlbmFsdHkgcmVjZWl2ZWQgZm9yIGRpcmVjdGlvbiBjaGFuZ2VcbiAgICBwZW5hbHRpZXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAwOiAwLFxuICAgICAgICAgICAgNDU6IHRoaXMuc3RlcCAvIDIsXG4gICAgICAgICAgICA5MDogdGhpcy5zdGVwIC8gMlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBwYWRkaW5nIGFwcGxpZWQgb24gdGhlIGVsZW1lbnQgYm91bmRpbmcgYm94ZXNcbiAgICBwYWRkaW5nQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogLXN0ZXAsXG4gICAgICAgICAgICB5OiAtc3RlcCxcbiAgICAgICAgICAgIHdpZHRoOiAyICogc3RlcCxcbiAgICAgICAgICAgIGhlaWdodDogMiAqIHN0ZXBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHBvaW50IGlzIGFuIG9ic3RhY2xlIG9yIG5vdC5cbiAgICAvLyBJZiB1c2VkLCB0aGUgYHBhZGRpbmdgLCBgZXhjbHVkZUVuZHNgYW5kIGBleGNsdWRlVHlwZXNgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgLy8gKHBvaW50OiBkaWEuUG9pbnQpID0+IGJvb2xlYW47XG4gICAgaXNQb2ludE9ic3RhY2xlOiBudWxsLFxuXG4gICAgLy8gYSByb3V0ZXIgdG8gdXNlIHdoZW4gdGhlIG1hbmhhdHRhbiByb3V0ZXIgZmFpbHNcbiAgICAvLyAob25lIG9mIHRoZSBwYXJ0aWFsIHJvdXRlcyByZXR1cm5zIG51bGwpXG4gICAgZmFsbGJhY2tSb3V0ZXI6IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzRnVuY3Rpb24ob3J0aG9nb25hbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFuaGF0dGFuIHJlcXVpcmVzIHRoZSBvcnRob2dvbmFsIHJvdXRlciBhcyBkZWZhdWx0IGZhbGxiYWNrLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9ydGhvZ29uYWwodmVydGljZXMsIHV0aWwuYXNzaWduKHt9LCBjb25maWcsIG9wdCksIGxpbmtWaWV3KTtcbiAgICB9LFxuXG4gICAgLyogRGVwcmVjYXRlZCAqL1xuICAgIC8vIGEgc2ltcGxlIHJvdXRlIHVzZWQgaW4gc2l0dWF0aW9ucyB3aGVuIG1haW4gcm91dGluZyBtZXRob2QgZmFpbHNcbiAgICAvLyAoZXhjZWVkIG1heCBudW1iZXIgb2YgbG9vcCBpdGVyYXRpb25zLCBpbmFjY2Vzc2libGUpXG4gICAgZmFsbGJhY2tSb3V0ZTogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdCkge1xuXG4gICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIHJlc3VsdCB3aWxsIHRyaWdnZXIgdGhlIGZhbGxiYWNrUm91dGVyXG5cbiAgICAgICAgLy8gbGVmdCBmb3IgcmVmZXJlbmNlOlxuICAgICAgICAvKi8vIEZpbmQgYW4gb3J0aG9nb25hbCByb3V0ZSBpZ25vcmluZyBvYnN0YWNsZXMuXG5cbiAgICAgICAgdmFyIHBvaW50ID0gKChvcHQucHJldmlvdXNEaXJBbmdsZSB8fCAwKSAlIDE4MCA9PT0gMClcbiAgICAgICAgICAgICAgICA/IG5ldyBnLlBvaW50KGZyb20ueCwgdG8ueSlcbiAgICAgICAgICAgICAgICA6IG5ldyBnLlBvaW50KHRvLngsIGZyb20ueSk7XG5cbiAgICAgICAgcmV0dXJuIFtwb2ludF07Ki9cbiAgICB9LFxuXG4gICAgLy8gaWYgYSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaXQncyB1c2VkIHRvIHJvdXRlIHRoZSBsaW5rIHdoaWxlIGRyYWdnaW5nIGFuIGVuZFxuICAgIC8vIGkuZS4gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdCkgeyByZXR1cm4gW107IH1cbiAgICBkcmFnZ2luZ1JvdXRlOiBudWxsXG59O1xuXG4vLyBIRUxQRVIgQ0xBU1NFUyAvL1xuXG4vLyBNYXAgb2Ygb2JzdGFjbGVzXG4vLyBIZWxwZXIgc3RydWN0dXJlIHRvIGlkZW50aWZ5IHdoZXRoZXIgYSBwb2ludCBsaWVzIGluc2lkZSBhbiBvYnN0YWNsZS5cbmZ1bmN0aW9uIE9ic3RhY2xlTWFwKG9wdCkge1xuXG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHQ7XG4gICAgLy8gdGVsbHMgaG93IHRvIGRpdmlkZSB0aGUgcGFwZXIgd2hlbiBjcmVhdGluZyB0aGUgZWxlbWVudHMgbWFwXG4gICAgdGhpcy5tYXBHcmlkU2l6ZSA9IDEwMDtcbn1cblxuT2JzdGFjbGVNYXAucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oZ3JhcGgsIGxpbmspIHtcblxuICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAvLyBzb3VyY2Ugb3IgdGFyZ2V0IGVsZW1lbnQgY291bGQgYmUgZXhjbHVkZWQgZnJvbSBzZXQgb2Ygb2JzdGFjbGVzXG4gICAgdmFyIGV4Y2x1ZGVkRW5kcyA9IHV0aWwudG9BcnJheShvcHQuZXhjbHVkZUVuZHMpLnJlZHVjZShmdW5jdGlvbihyZXMsIGl0ZW0pIHtcblxuICAgICAgICB2YXIgZW5kID0gbGluay5nZXQoaXRlbSk7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gZ3JhcGguZ2V0Q2VsbChlbmQuaWQpO1xuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gRXhjbHVkZSBhbnkgZW1iZWRkZWQgZWxlbWVudHMgZnJvbSB0aGUgc291cmNlIGFuZCB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGV4Y2x1ZGVkQW5jZXN0b3JzID0gW107XG5cbiAgICB2YXIgc291cmNlID0gZ3JhcGguZ2V0Q2VsbChsaW5rLmdldCgnc291cmNlJykuaWQpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZXhjbHVkZWRBbmNlc3RvcnMgPSB1dGlsLnVuaW9uKGV4Y2x1ZGVkQW5jZXN0b3JzLCBzb3VyY2UuZ2V0QW5jZXN0b3JzKCkubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmlkO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdyYXBoLmdldENlbGwobGluay5nZXQoJ3RhcmdldCcpLmlkKTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGV4Y2x1ZGVkQW5jZXN0b3JzID0gdXRpbC51bmlvbihleGNsdWRlZEFuY2VzdG9ycywgdGFyZ2V0LmdldEFuY2VzdG9ycygpLm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5pZDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkcyBhIG1hcCBvZiBhbGwgZWxlbWVudHMgZm9yIHF1aWNrZXIgb2JzdGFjbGUgcXVlcmllcyAoaS5lLiBpcyBhIHBvaW50IGNvbnRhaW5lZFxuICAgIC8vIGluIGFueSBvYnN0YWNsZT8pIChhIHNpbXBsaWZpZWQgZ3JpZCBzZWFyY2gpLlxuICAgIC8vIFRoZSBwYXBlciBpcyBkaXZpZGVkIGludG8gc21hbGxlciBjZWxscywgd2hlcmUgZWFjaCBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB3aGljaFxuICAgIC8vIGVsZW1lbnRzIGJlbG9uZyB0byBpdC4gV2hlbiB3ZSBxdWVyeSB3aGV0aGVyIGEgcG9pbnQgbGllcyBpbnNpZGUgYW4gb2JzdGFjbGUgd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIGdvIHRocm91Z2ggYWxsIG9ic3RhY2xlcywgd2UgY2hlY2sgb25seSB0aG9zZSBpbiBhIHBhcnRpY3VsYXIgY2VsbC5cbiAgICB2YXIgbWFwR3JpZFNpemUgPSB0aGlzLm1hcEdyaWRTaXplO1xuXG4gICAgZ3JhcGguZ2V0RWxlbWVudHMoKS5yZWR1Y2UoZnVuY3Rpb24obWFwLCBlbGVtZW50KSB7XG5cbiAgICAgICAgdmFyIGlzRXhjbHVkZWRUeXBlID0gdXRpbC50b0FycmF5KG9wdC5leGNsdWRlVHlwZXMpLmluY2x1ZGVzKGVsZW1lbnQuZ2V0KCd0eXBlJykpO1xuICAgICAgICB2YXIgaXNFeGNsdWRlZEVuZCA9IGV4Y2x1ZGVkRW5kcy5maW5kKGZ1bmN0aW9uKGV4Y2x1ZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuaWQgPT09IGVsZW1lbnQuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNFeGNsdWRlZEFuY2VzdG9yID0gZXhjbHVkZWRBbmNlc3RvcnMuaW5jbHVkZXMoZWxlbWVudC5pZCk7XG5cbiAgICAgICAgdmFyIGlzRXhjbHVkZWQgPSBpc0V4Y2x1ZGVkVHlwZSB8fCBpc0V4Y2x1ZGVkRW5kIHx8IGlzRXhjbHVkZWRBbmNlc3RvcjtcbiAgICAgICAgaWYgKCFpc0V4Y2x1ZGVkKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsZW1lbnQuZ2V0QkJveCgpLm1vdmVBbmRFeHBhbmQob3B0LnBhZGRpbmdCb3gpO1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gYmJveC5vcmlnaW4oKS5zbmFwVG9HcmlkKG1hcEdyaWRTaXplKTtcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSBiYm94LmNvcm5lcigpLnNuYXBUb0dyaWQobWFwR3JpZFNpemUpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gb3JpZ2luLng7IHggPD0gY29ybmVyLng7IHggKz0gbWFwR3JpZFNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gb3JpZ2luLnk7IHkgPD0gY29ybmVyLnk7IHkgKz0gbWFwR3JpZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyaWRLZXkgPSB4ICsgJ0AnICsgeTtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2dyaWRLZXldID0gbWFwW2dyaWRLZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBtYXBbZ3JpZEtleV0ucHVzaChiYm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHRoaXMubWFwKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuT2JzdGFjbGVNYXAucHJvdG90eXBlLmlzUG9pbnRBY2Nlc3NpYmxlID0gZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgIHZhciBtYXBLZXkgPSBwb2ludC5jbG9uZSgpLnNuYXBUb0dyaWQodGhpcy5tYXBHcmlkU2l6ZSkudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiB1dGlsLnRvQXJyYXkodGhpcy5tYXBbbWFwS2V5XSkuZXZlcnkoZnVuY3Rpb24ob2JzdGFjbGUpIHtcbiAgICAgICAgcmV0dXJuICFvYnN0YWNsZS5jb250YWluc1BvaW50KHBvaW50KTtcbiAgICB9KTtcbn07XG5cbi8vIFNvcnRlZCBTZXRcbi8vIFNldCBvZiBpdGVtcyBzb3J0ZWQgYnkgZ2l2ZW4gdmFsdWUuXG5mdW5jdGlvbiBTb3J0ZWRTZXQoKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuaGFzaCA9IHt9O1xuICAgIHRoaXMudmFsdWVzID0ge307XG4gICAgdGhpcy5PUEVOID0gMTtcbiAgICB0aGlzLkNMT1NFID0gMjtcbn1cblxuU29ydGVkU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXG4gICAgaWYgKHRoaXMuaGFzaFtpdGVtXSkge1xuICAgICAgICAvLyBpdGVtIHJlbW92YWxcbiAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc2hbaXRlbV0gPSB0aGlzLk9QRU47XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZXNbaXRlbV0gPSB2YWx1ZTtcblxuICAgIHZhciBpbmRleCA9IHV0aWwuc29ydGVkSW5kZXgodGhpcy5pdGVtcywgaXRlbSwgZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbaV07XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbn07XG5cblNvcnRlZFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgdGhpcy5oYXNoW2l0ZW1dID0gdGhpcy5DTE9TRTtcbn07XG5cblNvcnRlZFNldC5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzaFtpdGVtXSA9PT0gdGhpcy5PUEVOO1xufTtcblxuU29ydGVkU2V0LnByb3RvdHlwZS5pc0Nsb3NlID0gZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzaFtpdGVtXSA9PT0gdGhpcy5DTE9TRTtcbn07XG5cblNvcnRlZFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwO1xufTtcblxuU29ydGVkU2V0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgIHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgIHJldHVybiBpdGVtO1xufTtcblxuLy8gSEVMUEVSUyAvL1xuXG4vLyByZXR1cm4gc291cmNlIGJib3hcbmZ1bmN0aW9uIGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgLy8gZXhwYW5kIGJ5IHBhZGRpbmcgYm94XG4gICAgaWYgKG9wdCAmJiBvcHQucGFkZGluZ0JveCkgcmV0dXJuIGxpbmtWaWV3LnNvdXJjZUJCb3guY2xvbmUoKS5tb3ZlQW5kRXhwYW5kKG9wdC5wYWRkaW5nQm94KTtcblxuICAgIHJldHVybiBsaW5rVmlldy5zb3VyY2VCQm94LmNsb25lKCk7XG59XG5cbi8vIHJldHVybiB0YXJnZXQgYmJveFxuZnVuY3Rpb24gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KSB7XG5cbiAgICAvLyBleHBhbmQgYnkgcGFkZGluZyBib3hcbiAgICBpZiAob3B0ICYmIG9wdC5wYWRkaW5nQm94KSByZXR1cm4gbGlua1ZpZXcudGFyZ2V0QkJveC5jbG9uZSgpLm1vdmVBbmRFeHBhbmQob3B0LnBhZGRpbmdCb3gpO1xuXG4gICAgcmV0dXJuIGxpbmtWaWV3LnRhcmdldEJCb3guY2xvbmUoKTtcbn1cblxuLy8gcmV0dXJuIHNvdXJjZSBhbmNob3JcbmZ1bmN0aW9uIGdldFNvdXJjZUFuY2hvcihsaW5rVmlldywgb3B0KSB7XG5cbiAgICBpZiAobGlua1ZpZXcuc291cmNlQW5jaG9yKSByZXR1cm4gbGlua1ZpZXcuc291cmNlQW5jaG9yO1xuXG4gICAgLy8gZmFsbGJhY2s6IGNlbnRlciBvZiBiYm94XG4gICAgdmFyIHNvdXJjZUJCb3ggPSBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHJldHVybiBzb3VyY2VCQm94LmNlbnRlcigpO1xufVxuXG4vLyByZXR1cm4gdGFyZ2V0IGFuY2hvclxuZnVuY3Rpb24gZ2V0VGFyZ2V0QW5jaG9yKGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIGlmIChsaW5rVmlldy50YXJnZXRBbmNob3IpIHJldHVybiBsaW5rVmlldy50YXJnZXRBbmNob3I7XG5cbiAgICAvLyBmYWxsYmFjazogY2VudGVyIG9mIGJib3hcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgcmV0dXJuIHRhcmdldEJCb3guY2VudGVyKCk7IC8vIGRlZmF1bHRcbn1cblxuLy8gcmV0dXJucyBhIGRpcmVjdGlvbiBpbmRleCBmcm9tIHN0YXJ0IHBvaW50IHRvIGVuZCBwb2ludFxuLy8gY29ycmVjdHMgZm9yIGdyaWQgZGVmb3JtYXRpb24gYmV0d2VlbiBzdGFydCBhbmQgZW5kXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25BbmdsZShzdGFydCwgZW5kLCBudW1EaXJlY3Rpb25zLCBncmlkLCBvcHQpIHtcblxuICAgIHZhciBxdWFkcmFudCA9IDM2MCAvIG51bURpcmVjdGlvbnM7XG4gICAgdmFyIGFuZ2xlVGhldGEgPSBzdGFydC50aGV0YShmaXhBbmdsZUVuZChzdGFydCwgZW5kLCBncmlkLCBvcHQpKTtcbiAgICB2YXIgbm9ybWFsaXplZEFuZ2xlID0gZy5ub3JtYWxpemVBbmdsZShhbmdsZVRoZXRhICsgKHF1YWRyYW50IC8gMikpO1xuICAgIHJldHVybiBxdWFkcmFudCAqIE1hdGguZmxvb3Iobm9ybWFsaXplZEFuZ2xlIC8gcXVhZHJhbnQpO1xufVxuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldERpcmVjdGlvbkFuZ2xlKClcbi8vIGNvcnJlY3RzIGZvciBncmlkIGRlZm9ybWF0aW9uXG4vLyAoaWYgYSBwb2ludCBpcyBvbmUgZ3JpZCBzdGVwcyBhd2F5IGZyb20gYW5vdGhlciBpbiBib3RoIGRpbWVuc2lvbnMsXG4vLyBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIDQ1IGRlZ3JlZXMgYXdheSwgZXZlbiBpZiB0aGUgcmVhbCBhbmdsZSBpcyBkaWZmZXJlbnQpXG4vLyB0aGlzIGNhdXNlcyB2aXNpYmxlIGFuZ2xlIGRpc2NyZXBhbmNpZXMgaWYgYG9wdC5zdGVwYCBpcyBtdWNoIGxhcmdlciB0aGFuIGBwYXBlci5ncmlkU2l6ZWBcbmZ1bmN0aW9uIGZpeEFuZ2xlRW5kKHN0YXJ0LCBlbmQsIGdyaWQsIG9wdCkge1xuXG4gICAgdmFyIHN0ZXAgPSBvcHQuc3RlcDtcblxuICAgIHZhciBkaWZmWCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICB2YXIgZGlmZlkgPSBlbmQueSAtIHN0YXJ0Lnk7XG5cbiAgICB2YXIgZ3JpZFN0ZXBzWCA9IGRpZmZYIC8gZ3JpZC54O1xuICAgIHZhciBncmlkU3RlcHNZID0gZGlmZlkgLyBncmlkLnk7XG5cbiAgICB2YXIgZGlzdGFuY2VYID0gZ3JpZFN0ZXBzWCAqIHN0ZXA7XG4gICAgdmFyIGRpc3RhbmNlWSA9IGdyaWRTdGVwc1kgKiBzdGVwO1xuXG4gICAgcmV0dXJuIG5ldyBnLlBvaW50KHN0YXJ0LnggKyBkaXN0YW5jZVgsIHN0YXJ0LnkgKyBkaXN0YW5jZVkpO1xufVxuXG4vLyByZXR1cm4gdGhlIGNoYW5nZSBpbiBkaXJlY3Rpb24gYmV0d2VlbiB0d28gZGlyZWN0aW9uIGFuZ2xlc1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQ2hhbmdlKGFuZ2xlMSwgYW5nbGUyKSB7XG5cbiAgICB2YXIgZGlyZWN0aW9uQ2hhbmdlID0gTWF0aC5hYnMoYW5nbGUxIC0gYW5nbGUyKTtcbiAgICByZXR1cm4gKGRpcmVjdGlvbkNoYW5nZSA+IDE4MCkgPyAoMzYwIC0gZGlyZWN0aW9uQ2hhbmdlKSA6IGRpcmVjdGlvbkNoYW5nZTtcbn1cblxuLy8gZml4IGRpcmVjdGlvbiBvZmZzZXRzIGFjY29yZGluZyB0byBjdXJyZW50IGdyaWRcbmZ1bmN0aW9uIGdldEdyaWRPZmZzZXRzKGRpcmVjdGlvbnMsIGdyaWQsIG9wdCkge1xuXG4gICAgdmFyIHN0ZXAgPSBvcHQuc3RlcDtcblxuICAgIHV0aWwudG9BcnJheShvcHQuZGlyZWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbihkaXJlY3Rpb24pIHtcblxuICAgICAgICBkaXJlY3Rpb24uZ3JpZE9mZnNldFggPSAoZGlyZWN0aW9uLm9mZnNldFggLyBzdGVwKSAqIGdyaWQueDtcbiAgICAgICAgZGlyZWN0aW9uLmdyaWRPZmZzZXRZID0gKGRpcmVjdGlvbi5vZmZzZXRZIC8gc3RlcCkgKiBncmlkLnk7XG4gICAgfSk7XG59XG5cbi8vIGdldCBncmlkIHNpemUgaW4geCBhbmQgeSBkaW1lbnNpb25zLCBhZGFwdGVkIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuZnVuY3Rpb24gZ2V0R3JpZChzdGVwLCBzb3VyY2UsIHRhcmdldCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UuY2xvbmUoKSxcbiAgICAgICAgeDogZ2V0R3JpZERpbWVuc2lvbih0YXJnZXQueCAtIHNvdXJjZS54LCBzdGVwKSxcbiAgICAgICAgeTogZ2V0R3JpZERpbWVuc2lvbih0YXJnZXQueSAtIHNvdXJjZS55LCBzdGVwKVxuICAgIH07XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0R3JpZCgpXG5mdW5jdGlvbiBnZXRHcmlkRGltZW5zaW9uKGRpZmYsIHN0ZXApIHtcblxuICAgIC8vIHJldHVybiBzdGVwIGlmIGRpZmYgPSAwXG4gICAgaWYgKCFkaWZmKSByZXR1cm4gc3RlcDtcblxuICAgIHZhciBhYnNEaWZmID0gTWF0aC5hYnMoZGlmZik7XG4gICAgdmFyIG51bVN0ZXBzID0gTWF0aC5yb3VuZChhYnNEaWZmIC8gc3RlcCk7XG5cbiAgICAvLyByZXR1cm4gYWJzRGlmZiBpZiBsZXNzIHRoYW4gb25lIHN0ZXAgYXBhcnRcbiAgICBpZiAoIW51bVN0ZXBzKSByZXR1cm4gYWJzRGlmZjtcblxuICAgIC8vIG90aGVyd2lzZSwgcmV0dXJuIGNvcnJlY3RlZCBzdGVwXG4gICAgdmFyIHJvdW5kZWREaWZmID0gbnVtU3RlcHMgKiBzdGVwO1xuICAgIHZhciByZW1haW5kZXIgPSBhYnNEaWZmIC0gcm91bmRlZERpZmY7XG4gICAgdmFyIHN0ZXBDb3JyZWN0aW9uID0gcmVtYWluZGVyIC8gbnVtU3RlcHM7XG5cbiAgICByZXR1cm4gc3RlcCArIHN0ZXBDb3JyZWN0aW9uO1xufVxuXG4vLyByZXR1cm4gYSBjbG9uZSBvZiBwb2ludCBzbmFwcGVkIHRvIGdyaWRcbmZ1bmN0aW9uIHNuYXBUb0dyaWQocG9pbnQsIGdyaWQpIHtcblxuICAgIHZhciBzb3VyY2UgPSBncmlkLnNvdXJjZTtcblxuICAgIHZhciBzbmFwcGVkWCA9IGcuc25hcFRvR3JpZChwb2ludC54IC0gc291cmNlLngsIGdyaWQueCkgKyBzb3VyY2UueDtcbiAgICB2YXIgc25hcHBlZFkgPSBnLnNuYXBUb0dyaWQocG9pbnQueSAtIHNvdXJjZS55LCBncmlkLnkpICsgc291cmNlLnk7XG5cbiAgICByZXR1cm4gbmV3IGcuUG9pbnQoc25hcHBlZFgsIHNuYXBwZWRZKTtcbn1cblxuLy8gcm91bmQgdGhlIHBvaW50IHRvIG9wdC5wcmVjaXNpb25cbmZ1bmN0aW9uIHJvdW5kKHBvaW50LCBwcmVjaXNpb24pIHtcblxuICAgIHJldHVybiBwb2ludC5yb3VuZChwcmVjaXNpb24pO1xufVxuXG4vLyBzbmFwIHRvIGdyaWQgYW5kIHRoZW4gcm91bmQgdGhlIHBvaW50XG5mdW5jdGlvbiBhbGlnbihwb2ludCwgZ3JpZCwgcHJlY2lzaW9uKSB7XG5cbiAgICByZXR1cm4gcm91bmQoc25hcFRvR3JpZChwb2ludC5jbG9uZSgpLCBncmlkKSwgcHJlY2lzaW9uKTtcbn1cblxuLy8gcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcG9pbnRcbi8vIHN0cmluZyBpcyByb3VuZGVkIGluIGJvdGggZGltZW5zaW9uc1xuZnVuY3Rpb24gZ2V0S2V5KHBvaW50KSB7XG5cbiAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS50b1N0cmluZygpO1xufVxuXG4vLyByZXR1cm4gYSBub3JtYWxpemVkIHZlY3RvciBmcm9tIGdpdmVuIHBvaW50XG4vLyB1c2VkIHRvIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIGEgZGlmZmVyZW5jZSBvZiB0d28gcG9pbnRzXG5mdW5jdGlvbiBub3JtYWxpemVQb2ludChwb2ludCkge1xuXG4gICAgcmV0dXJuIG5ldyBnLlBvaW50KFxuICAgICAgICBwb2ludC54ID09PSAwID8gMCA6IE1hdGguYWJzKHBvaW50LngpIC8gcG9pbnQueCxcbiAgICAgICAgcG9pbnQueSA9PT0gMCA/IDAgOiBNYXRoLmFicyhwb2ludC55KSAvIHBvaW50LnlcbiAgICApO1xufVxuXG4vLyBQQVRIRklORElORyAvL1xuXG4vLyByZWNvbnN0cnVjdHMgYSByb3V0ZSBieSBjb25jYXRlbmF0aW5nIHBvaW50cyB3aXRoIHRoZWlyIHBhcmVudHNcbmZ1bmN0aW9uIHJlY29uc3RydWN0Um91dGUocGFyZW50cywgcG9pbnRzLCB0YWlsUG9pbnQsIGZyb20sIHRvLCBncmlkLCBvcHQpIHtcblxuICAgIHZhciByb3V0ZSA9IFtdO1xuXG4gICAgdmFyIHByZXZEaWZmID0gbm9ybWFsaXplUG9pbnQodG8uZGlmZmVyZW5jZSh0YWlsUG9pbnQpKTtcblxuICAgIC8vIHRhaWxQb2ludCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuICAgIHZhciBjdXJyZW50S2V5ID0gZ2V0S2V5KHRhaWxQb2ludCk7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbY3VycmVudEtleV07XG5cbiAgICB2YXIgcG9pbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuXG4gICAgICAgIC8vIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2N1cnJlbnRLZXldO1xuXG4gICAgICAgIHZhciBkaWZmID0gbm9ybWFsaXplUG9pbnQocG9pbnQuZGlmZmVyZW5jZShwYXJlbnQpKTtcbiAgICAgICAgaWYgKCFkaWZmLmVxdWFscyhwcmV2RGlmZikpIHtcbiAgICAgICAgICAgIHJvdXRlLnVuc2hpZnQocG9pbnQpO1xuICAgICAgICAgICAgcHJldkRpZmYgPSBkaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyZW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG4gICAgICAgIGN1cnJlbnRLZXkgPSBnZXRLZXkocGFyZW50KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50c1tjdXJyZW50S2V5XTtcbiAgICB9XG5cbiAgICAvLyBsZWFkUG9pbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcbiAgICB2YXIgbGVhZFBvaW50ID0gcG9pbnRzW2N1cnJlbnRLZXldO1xuXG4gICAgdmFyIGZyb21EaWZmID0gbm9ybWFsaXplUG9pbnQobGVhZFBvaW50LmRpZmZlcmVuY2UoZnJvbSkpO1xuICAgIGlmICghZnJvbURpZmYuZXF1YWxzKHByZXZEaWZmKSkge1xuICAgICAgICByb3V0ZS51bnNoaWZ0KGxlYWRQb2ludCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBoZXVyaXN0aWMgbWV0aG9kIHRvIGRldGVybWluZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG5mdW5jdGlvbiBlc3RpbWF0ZUNvc3QoZnJvbSwgZW5kUG9pbnRzKSB7XG5cbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW5kUG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb3N0ID0gZnJvbS5tYW5oYXR0YW5EaXN0YW5jZShlbmRQb2ludHNbaV0pO1xuICAgICAgICBpZiAoY29zdCA8IG1pbikgbWluID0gY29zdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xufVxuXG4vLyBmaW5kIHBvaW50cyBhcm91bmQgdGhlIGJib3ggdGFraW5nIGdpdmVuIGRpcmVjdGlvbnMgaW50byBhY2NvdW50XG4vLyBsaW5lcyBhcmUgZHJhd24gZnJvbSBhbmNob3IgaW4gZ2l2ZW4gZGlyZWN0aW9ucywgaW50ZXJzZWN0aW9ucyByZWNvcmRlZFxuLy8gaWYgYW5jaG9yIGlzIG91dHNpZGUgYmJveCwgb25seSB0aG9zZSBkaXJlY3Rpb25zIHRoYXQgaW50ZXJzZWN0IGdldCBhIHJlY3QgcG9pbnRcbi8vIHRoZSBhbmNob3IgaXRzZWxmIGlzIHJldHVybmVkIGFzIHJlY3QgcG9pbnQgKHJlcHJlc2VudGluZyBzb21lIGRpcmVjdGlvbnMpXG4vLyAoc2luY2UgdGhvc2UgZGlyZWN0aW9ucyBhcmUgdW5vYnN0cnVjdGVkIGJ5IHRoZSBiYm94KVxuZnVuY3Rpb24gZ2V0UmVjdFBvaW50cyhhbmNob3IsIGJib3gsIGRpcmVjdGlvbkxpc3QsIGdyaWQsIG9wdCkge1xuXG4gICAgdmFyIHByZWNpc2lvbiA9IG9wdC5wcmVjaXNpb247XG4gICAgdmFyIGRpcmVjdGlvbk1hcCA9IG9wdC5kaXJlY3Rpb25NYXA7XG5cbiAgICB2YXIgYW5jaG9yQ2VudGVyVmVjdG9yID0gYW5jaG9yLmRpZmZlcmVuY2UoYmJveC5jZW50ZXIoKSk7XG5cbiAgICB2YXIga2V5cyA9IHV0aWwuaXNPYmplY3QoZGlyZWN0aW9uTWFwKSA/IE9iamVjdC5rZXlzKGRpcmVjdGlvbk1hcCkgOiBbXTtcbiAgICB2YXIgZGlyTGlzdCA9IHV0aWwudG9BcnJheShkaXJlY3Rpb25MaXN0KTtcbiAgICB2YXIgcmVjdFBvaW50cyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uKHJlcywga2V5KSB7XG5cbiAgICAgICAgaWYgKGRpckxpc3QuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvbk1hcFtrZXldO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBsaW5lIHRoYXQgaXMgZ3VhcmFudGVlZCB0byBpbnRlcnNlY3QgdGhlIGJib3ggaWYgYmJveCBpcyBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAvLyBldmVuIGlmIGFuY2hvciBsaWVzIG91dHNpZGUgb2YgYmJveFxuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gbmV3IGcuUG9pbnQoXG4gICAgICAgICAgICAgICAgYW5jaG9yLnggKyBkaXJlY3Rpb24ueCAqIChNYXRoLmFicyhhbmNob3JDZW50ZXJWZWN0b3IueCkgKyBiYm94LndpZHRoKSxcbiAgICAgICAgICAgICAgICBhbmNob3IueSArIGRpcmVjdGlvbi55ICogKE1hdGguYWJzKGFuY2hvckNlbnRlclZlY3Rvci55KSArIGJib3guaGVpZ2h0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25MaW5lID0gbmV3IGcuTGluZShhbmNob3IsIGVuZHBvaW50KTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBmYXJ0aGVyIGludGVyc2VjdGlvbiwgaW4gY2FzZSB0aGVyZSBhcmUgdHdvXG4gICAgICAgICAgICAvLyAodGhhdCBoYXBwZW5zIGlmIGFuY2hvciBsaWVzIG5leHQgdG8gYmJveClcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9uTGluZS5pbnRlcnNlY3QoYmJveCkgfHwgW107XG4gICAgICAgICAgICB2YXIgbnVtSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGZhcnRoZXN0SW50ZXJzZWN0aW9uRGlzdGFuY2U7XG4gICAgICAgICAgICB2YXIgZmFydGhlc3RJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1JbnRlcnNlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYW5jaG9yLnNxdWFyZWREaXN0YW5jZShjdXJyZW50SW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZhcnRoZXN0SW50ZXJzZWN0aW9uRGlzdGFuY2UgPT09IHVuZGVmaW5lZCkgfHwgKGRpc3RhbmNlID4gZmFydGhlc3RJbnRlcnNlY3Rpb25EaXN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFydGhlc3RJbnRlcnNlY3Rpb25EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBmYXJ0aGVzdEludGVyc2VjdGlvbiA9IGN1cnJlbnRJbnRlcnNlY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhbiBpbnRlcnNlY3Rpb24gd2FzIGZvdW5kIGluIHRoaXMgZGlyZWN0aW9uLCBpdCBpcyBvdXIgcmVjdFBvaW50XG4gICAgICAgICAgICBpZiAoZmFydGhlc3RJbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBhbGlnbihmYXJ0aGVzdEludGVyc2VjdGlvbiwgZ3JpZCwgcHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZWN0UG9pbnQgbGllcyBpbnNpZGUgdGhlIGJib3gsIG9mZnNldCBpdCBieSBvbmUgbW9yZSBzdGVwXG4gICAgICAgICAgICAgICAgaWYgKGJib3guY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBhbGlnbihwb2ludC5vZmZzZXQoZGlyZWN0aW9uLnggKiBncmlkLngsIGRpcmVjdGlvbi55ICogZ3JpZC55KSwgZ3JpZCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGVuIGFkZCB0aGUgcG9pbnQgdG8gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgICAgIC8vIGFsaWduZWRcbiAgICAgICAgICAgICAgICByZXMucHVzaChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIGlmIGFuY2hvciBsaWVzIG91dHNpZGUgb2YgYmJveCwgYWRkIGl0IHRvIHRoZSBhcnJheSBvZiBwb2ludHNcbiAgICBpZiAoIWJib3guY29udGFpbnNQb2ludChhbmNob3IpKSB7XG4gICAgICAgIC8vIGFsaWduZWRcbiAgICAgICAgcmVjdFBvaW50cy5wdXNoKGFsaWduKGFuY2hvciwgZ3JpZCwgcHJlY2lzaW9uKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RQb2ludHM7XG59XG5cbi8vIGZpbmRzIHRoZSByb3V0ZSBiZXR3ZWVuIHR3byBwb2ludHMvcmVjdGFuZ2xlcyAoYGZyb21gLCBgdG9gKSBpbXBsZW1lbnRpbmcgQSogYWxnb3JpdGhtXG4vLyByZWN0YW5nbGVzIGdldCByZWN0IHBvaW50cyBhc3NpZ25lZCBieSBnZXRSZWN0UG9pbnRzKClcbmZ1bmN0aW9uIGZpbmRSb3V0ZShmcm9tLCB0bywgaXNQb2ludE9ic3RhY2xlLCBvcHQpIHtcblxuICAgIHZhciBwcmVjaXNpb24gPSBvcHQucHJlY2lzaW9uO1xuXG4gICAgLy8gR2V0IGdyaWQgZm9yIHRoaXMgcm91dGUuXG5cbiAgICB2YXIgc291cmNlQW5jaG9yLCB0YXJnZXRBbmNob3I7XG5cbiAgICBpZiAoZnJvbSBpbnN0YW5jZW9mIGcuUmVjdCkgeyAvLyBgZnJvbWAgaXMgc291cmNlQkJveFxuICAgICAgICBzb3VyY2VBbmNob3IgPSByb3VuZChnZXRTb3VyY2VBbmNob3IodGhpcywgb3B0KS5jbG9uZSgpLCBwcmVjaXNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUFuY2hvciA9IHJvdW5kKGZyb20uY2xvbmUoKSwgcHJlY2lzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAodG8gaW5zdGFuY2VvZiBnLlJlY3QpIHsgLy8gYHRvYCBpcyB0YXJnZXRCQm94XG4gICAgICAgIHRhcmdldEFuY2hvciA9IHJvdW5kKGdldFRhcmdldEFuY2hvcih0aGlzLCBvcHQpLmNsb25lKCksIHByZWNpc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0QW5jaG9yID0gcm91bmQodG8uY2xvbmUoKSwgcHJlY2lzaW9uKTtcbiAgICB9XG5cbiAgICB2YXIgZ3JpZCA9IGdldEdyaWQob3B0LnN0ZXAsIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yKTtcblxuICAgIC8vIEdldCBwYXRoZmluZGluZyBwb2ludHMuXG5cbiAgICB2YXIgc3RhcnQsIGVuZDsgLy8gYWxpZ25lZCB3aXRoIGdyaWQgYnkgZGVmaW5pdGlvblxuICAgIHZhciBzdGFydFBvaW50cywgZW5kUG9pbnRzOyAvLyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgd2l0aCBncmlkIGFscmVhZHlcblxuICAgIC8vIHNldCBvZiBwb2ludHMgd2Ugc3RhcnQgcGF0aGZpbmRpbmcgZnJvbVxuICAgIGlmIChmcm9tIGluc3RhbmNlb2YgZy5SZWN0KSB7IC8vIGBmcm9tYCBpcyBzb3VyY2VCQm94XG4gICAgICAgIHN0YXJ0ID0gc291cmNlQW5jaG9yO1xuICAgICAgICBzdGFydFBvaW50cyA9IGdldFJlY3RQb2ludHMoc3RhcnQsIGZyb20sIG9wdC5zdGFydERpcmVjdGlvbnMsIGdyaWQsIG9wdCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IHNvdXJjZUFuY2hvcjtcbiAgICAgICAgc3RhcnRQb2ludHMgPSBbc3RhcnRdO1xuICAgIH1cblxuICAgIC8vIHNldCBvZiBwb2ludHMgd2Ugd2FudCB0aGUgcGF0aGZpbmRpbmcgdG8gZmluaXNoIGF0XG4gICAgaWYgKHRvIGluc3RhbmNlb2YgZy5SZWN0KSB7IC8vIGB0b2AgaXMgdGFyZ2V0QkJveFxuICAgICAgICBlbmQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgIGVuZFBvaW50cyA9IGdldFJlY3RQb2ludHModGFyZ2V0QW5jaG9yLCB0bywgb3B0LmVuZERpcmVjdGlvbnMsIGdyaWQsIG9wdCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgIGVuZFBvaW50cyA9IFtlbmRdO1xuICAgIH1cblxuICAgIC8vIHRha2UgaW50byBhY2NvdW50IG9ubHkgYWNjZXNzaWJsZSByZWN0IHBvaW50cyAodGhvc2Ugbm90IHVuZGVyIG9ic3RhY2xlcylcbiAgICBzdGFydFBvaW50cyA9IHN0YXJ0UG9pbnRzLmZpbHRlcihwID0+ICFpc1BvaW50T2JzdGFjbGUocCkpO1xuICAgIGVuZFBvaW50cyA9IGVuZFBvaW50cy5maWx0ZXIocCA9PiAhaXNQb2ludE9ic3RhY2xlKHApKTtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgYW4gYWNjZXNzaWJsZSByb3V0ZSBwb2ludCBvbiBib3RoIHNpZGVzLlxuICAgIC8vIE90aGVyd2lzZSwgdXNlIGZhbGxiYWNrUm91dGUoKS5cbiAgICBpZiAoc3RhcnRQb2ludHMubGVuZ3RoID4gMCAmJiBlbmRQb2ludHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIFRoZSBzZXQgb2YgdGVudGF0aXZlIHBvaW50cyB0byBiZSBldmFsdWF0ZWQsIGluaXRpYWxseSBjb250YWluaW5nIHRoZSBzdGFydCBwb2ludHMuXG4gICAgICAgIC8vIFJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyIGZvciBzaW1wbGljaXR5LlxuICAgICAgICB2YXIgb3BlblNldCA9IG5ldyBTb3J0ZWRTZXQoKTtcbiAgICAgICAgLy8gS2VlcHMgcmVmZXJlbmNlIHRvIGFjdHVhbCBwb2ludHMgZm9yIGdpdmVuIGVsZW1lbnRzIG9mIHRoZSBvcGVuIHNldC5cbiAgICAgICAgdmFyIHBvaW50cyA9IHt9O1xuICAgICAgICAvLyBLZWVwcyByZWZlcmVuY2UgdG8gYSBwb2ludCB0aGF0IGlzIGltbWVkaWF0ZSBwcmVkZWNlc3NvciBvZiBnaXZlbiBlbGVtZW50LlxuICAgICAgICB2YXIgcGFyZW50cyA9IHt9O1xuICAgICAgICAvLyBDb3N0IGZyb20gc3RhcnQgdG8gYSBwb2ludCBhbG9uZyBiZXN0IGtub3duIHBhdGguXG4gICAgICAgIHZhciBjb3N0cyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3RhcnRQb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzdGFydFBvaW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG4gICAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnRzW2ldO1xuXG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KHN0YXJ0UG9pbnQpO1xuXG4gICAgICAgICAgICBvcGVuU2V0LmFkZChrZXksIGVzdGltYXRlQ29zdChzdGFydFBvaW50LCBlbmRQb2ludHMpKTtcbiAgICAgICAgICAgIHBvaW50c1trZXldID0gc3RhcnRQb2ludDtcbiAgICAgICAgICAgIGNvc3RzW2tleV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZpb3VzUm91dGVEaXJlY3Rpb25BbmdsZSA9IG9wdC5wcmV2aW91c0RpcmVjdGlvbkFuZ2xlOyAvLyB1bmRlZmluZWQgZm9yIGZpcnN0IHJvdXRlXG4gICAgICAgIHZhciBpc1BhdGhCZWdpbm5pbmcgPSAocHJldmlvdXNSb3V0ZURpcmVjdGlvbkFuZ2xlID09PSB1bmRlZmluZWQpO1xuXG4gICAgICAgIC8vIGRpcmVjdGlvbnNcbiAgICAgICAgdmFyIGRpcmVjdGlvbiwgZGlyZWN0aW9uQ2hhbmdlO1xuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IG9wdC5kaXJlY3Rpb25zO1xuICAgICAgICBnZXRHcmlkT2Zmc2V0cyhkaXJlY3Rpb25zLCBncmlkLCBvcHQpO1xuXG4gICAgICAgIHZhciBudW1EaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGVuZFBvaW50c0tleXMgPSB1dGlsLnRvQXJyYXkoZW5kUG9pbnRzKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBlbmRQb2ludCkge1xuICAgICAgICAgICAgLy8gZW5kUG9pbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcblxuICAgICAgICAgICAgdmFyIGtleSA9IGdldEtleShlbmRQb2ludCk7XG4gICAgICAgICAgICByZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIC8vIG1haW4gcm91dGUgZmluZGluZyBsb29wXG4gICAgICAgIHZhciBsb29wc1JlbWFpbmluZyA9IG9wdC5tYXhpbXVtTG9vcHM7XG4gICAgICAgIHdoaWxlICghb3BlblNldC5pc0VtcHR5KCkgJiYgbG9vcHNSZW1haW5pbmcgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGZyb20gdGhlIG9wZW4gbGlzdFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBvcGVuU2V0LnBvcCgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IHBvaW50c1tjdXJyZW50S2V5XTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50c1tjdXJyZW50S2V5XTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29zdCA9IGNvc3RzW2N1cnJlbnRLZXldO1xuXG4gICAgICAgICAgICB2YXIgaXNSb3V0ZUJlZ2lubmluZyA9IChjdXJyZW50UGFyZW50ID09PSB1bmRlZmluZWQpOyAvLyB1bmRlZmluZWQgZm9yIHJvdXRlIHN0YXJ0c1xuICAgICAgICAgICAgdmFyIGlzU3RhcnQgPSBjdXJyZW50UG9pbnQuZXF1YWxzKHN0YXJ0KTsgLy8gKGlzIHNvdXJjZSBhbmNob3Igb3IgYGZyb21gIHBvaW50KSA9IGNhbiBsZWF2ZSBpbiBhbnkgZGlyZWN0aW9uXG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlO1xuICAgICAgICAgICAgaWYgKCFpc1JvdXRlQmVnaW5uaW5nKSBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gZ2V0RGlyZWN0aW9uQW5nbGUoY3VycmVudFBhcmVudCwgY3VycmVudFBvaW50LCBudW1EaXJlY3Rpb25zLCBncmlkLCBvcHQpOyAvLyBhIHZlcnRleCBvbiB0aGUgcm91dGVcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1BhdGhCZWdpbm5pbmcpIHByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBwcmV2aW91c1JvdXRlRGlyZWN0aW9uQW5nbGU7IC8vIGJlZ2lubmluZyBvZiByb3V0ZSBvbiB0aGUgcGF0aFxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzU3RhcnQpIHByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBnZXREaXJlY3Rpb25BbmdsZShzdGFydCwgY3VycmVudFBvaW50LCBudW1EaXJlY3Rpb25zLCBncmlkLCBvcHQpOyAvLyBiZWdpbm5pbmcgb2YgcGF0aCwgc3RhcnQgcmVjdCBwb2ludFxuICAgICAgICAgICAgZWxzZSBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gbnVsbDsgLy8gYmVnaW5uaW5nIG9mIHBhdGgsIHNvdXJjZSBhbmNob3Igb3IgYGZyb21gIHBvaW50XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHJlYWNoZWQgYW55IGVuZHBvaW50XG4gICAgICAgICAgICB2YXIgc2FtZVBvaW50cyA9IHN0YXJ0UG9pbnRzLmxlbmd0aCA9PT0gZW5kUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzYW1lUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGFydFBvaW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0UG9pbnRzW2pdLmVxdWFscyhlbmRQb2ludHNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1lUG9pbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBza2lwRW5kQ2hlY2sgPSAoaXNSb3V0ZUJlZ2lubmluZyAmJiBzYW1lUG9pbnRzKTtcbiAgICAgICAgICAgIGlmICghc2tpcEVuZENoZWNrICYmIChlbmRQb2ludHNLZXlzLmluZGV4T2YoY3VycmVudEtleSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICBvcHQucHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IHByZXZpb3VzRGlyZWN0aW9uQW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0Um91dGUocGFyZW50cywgcG9pbnRzLCBjdXJyZW50UG9pbnQsIHN0YXJ0LCBlbmQsIGdyaWQsIG9wdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdvIG92ZXIgYWxsIHBvc3NpYmxlIGRpcmVjdGlvbnMgYW5kIGZpbmQgbmVpZ2hib3JzXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGlyZWN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25BbmdsZSA9IGRpcmVjdGlvbi5hbmdsZTtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25DaGFuZ2UgPSBnZXREaXJlY3Rpb25DaGFuZ2UocHJldmlvdXNEaXJlY3Rpb25BbmdsZSwgZGlyZWN0aW9uQW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRpcmVjdGlvbiBjaGFuZ2VkIHJhcGlkbHksIGRvbid0IHVzZSB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gYW55IGRpcmVjdGlvbiBpcyBhbGxvd2VkIGZvciBzdGFydGluZyBwb2ludHNcbiAgICAgICAgICAgICAgICBpZiAoIShpc1BhdGhCZWdpbm5pbmcgJiYgaXNTdGFydCkgJiYgZGlyZWN0aW9uQ2hhbmdlID4gb3B0Lm1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2UpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yUG9pbnQgPSBhbGlnbihjdXJyZW50UG9pbnQuY2xvbmUoKS5vZmZzZXQoZGlyZWN0aW9uLmdyaWRPZmZzZXRYLCBkaXJlY3Rpb24uZ3JpZE9mZnNldFkpLCBncmlkLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvcktleSA9IGdldEtleShuZWlnaGJvclBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIENsb3NlZCBwb2ludHMgZnJvbSB0aGUgb3BlblNldCB3ZXJlIGFscmVhZHkgZXZhbHVhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChvcGVuU2V0LmlzQ2xvc2UobmVpZ2hib3JLZXkpIHx8IGlzUG9pbnRPYnN0YWNsZShuZWlnaGJvclBvaW50KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBlbnRlciBlbmQgcG9pbnRzIGF0IGFuIGFjY2VwdGFibGUgYW5nbGUuXG4gICAgICAgICAgICAgICAgaWYgKGVuZFBvaW50c0tleXMuaW5kZXhPZihuZWlnaGJvcktleSkgPj0gMCkgeyAvLyBuZWlnaGJvciBpcyBhbiBlbmQgcG9pbnRcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZWlnaGJvckVuZCA9IG5laWdoYm9yUG9pbnQuZXF1YWxzKGVuZCk7IC8vIChpcyB0YXJnZXQgYW5jaG9yIG9yIGB0b2AgcG9pbnQpID0gY2FuIGJlIGVudGVyZWQgaW4gYW55IGRpcmVjdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOZWlnaGJvckVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZERpcmVjdGlvbkFuZ2xlID0gZ2V0RGlyZWN0aW9uQW5nbGUobmVpZ2hib3JQb2ludCwgZW5kLCBudW1EaXJlY3Rpb25zLCBncmlkLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZERpcmVjdGlvbkNoYW5nZSA9IGdldERpcmVjdGlvbkNoYW5nZShkaXJlY3Rpb25BbmdsZSwgZW5kRGlyZWN0aW9uQW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRGlyZWN0aW9uQ2hhbmdlID4gb3B0Lm1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZGlyZWN0aW9uIGlzIG9rLlxuXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yQ29zdCA9IGRpcmVjdGlvbi5jb3N0O1xuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvclBlbmFsdHkgPSBpc1N0YXJ0ID8gMCA6IG9wdC5wZW5hbHRpZXNbZGlyZWN0aW9uQ2hhbmdlXTsgLy8gbm8gcGVuYWx0aWVzIGZvciBzdGFydCBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBjb3N0RnJvbVN0YXJ0ID0gY3VycmVudENvc3QgKyBuZWlnaGJvckNvc3QgKyBuZWlnaGJvclBlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5TZXQuaXNPcGVuKG5laWdoYm9yS2V5KSB8fCAoY29zdEZyb21TdGFydCA8IGNvc3RzW25laWdoYm9yS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVpZ2hib3IgcG9pbnQgaGFzIG5vdCBiZWVuIHByb2Nlc3NlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgdGhlIGNvc3Qgb2YgdGhlIHBhdGggZnJvbSBzdGFydCBpcyBsb3dlciB0aGFuIHByZXZpb3VzbHkgY2FsY3VsYXRlZFxuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tuZWlnaGJvcktleV0gPSBuZWlnaGJvclBvaW50O1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzW25laWdoYm9yS2V5XSA9IGN1cnJlbnRQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgY29zdHNbbmVpZ2hib3JLZXldID0gY29zdEZyb21TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgb3BlblNldC5hZGQobmVpZ2hib3JLZXksIGNvc3RGcm9tU3RhcnQgKyBlc3RpbWF0ZUNvc3QobmVpZ2hib3JQb2ludCwgZW5kUG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb29wc1JlbWFpbmluZy0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm8gcm91dGUgZm91bmQgKGB0b2AgcG9pbnQgZWl0aGVyIHdhc24ndCBhY2Nlc3NpYmxlIG9yIGZpbmRpbmcgcm91dGUgdG9va1xuICAgIC8vIHdheSB0b28gbXVjaCBjYWxjdWxhdGlvbilcbiAgICByZXR1cm4gb3B0LmZhbGxiYWNrUm91dGUuY2FsbCh0aGlzLCBzdGFydCwgZW5kLCBvcHQpO1xufVxuXG4vLyByZXNvbHZlIHNvbWUgb2YgdGhlIG9wdGlvbnNcbmZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKG9wdCkge1xuXG4gICAgb3B0LmRpcmVjdGlvbnMgPSB1dGlsLnJlc3VsdChvcHQsICdkaXJlY3Rpb25zJyk7XG4gICAgb3B0LnBlbmFsdGllcyA9IHV0aWwucmVzdWx0KG9wdCwgJ3BlbmFsdGllcycpO1xuICAgIG9wdC5wYWRkaW5nQm94ID0gdXRpbC5yZXN1bHQob3B0LCAncGFkZGluZ0JveCcpO1xuICAgIG9wdC5wYWRkaW5nID0gdXRpbC5yZXN1bHQob3B0LCAncGFkZGluZycpO1xuXG4gICAgaWYgKG9wdC5wYWRkaW5nKSB7XG4gICAgICAgIC8vIGlmIGJvdGggcHJvdmlkZWQsIG9wdC5wYWRkaW5nIHdpbnMgb3ZlciBvcHQucGFkZGluZ0JveFxuICAgICAgICB2YXIgc2lkZXMgPSB1dGlsLm5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nKTtcbiAgICAgICAgb3B0LnBhZGRpbmdCb3ggPSB7XG4gICAgICAgICAgICB4OiAtc2lkZXMubGVmdCxcbiAgICAgICAgICAgIHk6IC1zaWRlcy50b3AsXG4gICAgICAgICAgICB3aWR0aDogc2lkZXMubGVmdCArIHNpZGVzLnJpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0OiBzaWRlcy50b3AgKyBzaWRlcy5ib3R0b21cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB1dGlsLnRvQXJyYXkob3B0LmRpcmVjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgdmFyIHBvaW50MSA9IG5ldyBnLlBvaW50KDAsIDApO1xuICAgICAgICB2YXIgcG9pbnQyID0gbmV3IGcuUG9pbnQoZGlyZWN0aW9uLm9mZnNldFgsIGRpcmVjdGlvbi5vZmZzZXRZKTtcblxuICAgICAgICBkaXJlY3Rpb24uYW5nbGUgPSBnLm5vcm1hbGl6ZUFuZ2xlKHBvaW50MS50aGV0YShwb2ludDIpKTtcbiAgICB9KTtcbn1cblxuLy8gaW5pdGlhbGl6YXRpb24gb2YgdGhlIHJvdXRlIGZpbmRpbmdcbmZ1bmN0aW9uIHJvdXRlcih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuXG4gICAgcmVzb2x2ZU9wdGlvbnMob3B0KTtcblxuICAgIC8vIGVuYWJsZS9kaXNhYmxlIGxpbmtWaWV3IHBlcnBlbmRpY3VsYXIgb3B0aW9uXG4gICAgbGlua1ZpZXcub3B0aW9ucy5wZXJwZW5kaWN1bGFyID0gISFvcHQucGVycGVuZGljdWxhcjtcblxuICAgIHZhciBzb3VyY2VCQm94ID0gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KTtcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCk7XG5cbiAgICB2YXIgc291cmNlQW5jaG9yID0gZ2V0U291cmNlQW5jaG9yKGxpbmtWaWV3LCBvcHQpO1xuICAgIC8vdmFyIHRhcmdldEFuY2hvciA9IGdldFRhcmdldEFuY2hvcihsaW5rVmlldywgb3B0KTtcblxuICAgIC8vIHBhdGhmaW5kaW5nXG4gICAgbGV0IGlzUG9pbnRPYnN0YWNsZTtcbiAgICBpZiAodHlwZW9mIG9wdC5pc1BvaW50T2JzdGFjbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaXNQb2ludE9ic3RhY2xlID0gb3B0LmlzUG9pbnRPYnN0YWNsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgT2JzdGFjbGVNYXAob3B0KTtcbiAgICAgICAgbWFwLmJ1aWxkKGxpbmtWaWV3LnBhcGVyLm1vZGVsLCBsaW5rVmlldy5tb2RlbCk7XG4gICAgICAgIGlzUG9pbnRPYnN0YWNsZSA9IChwb2ludCkgPT4gIW1hcC5pc1BvaW50QWNjZXNzaWJsZShwb2ludCk7XG4gICAgfVxuXG4gICAgdmFyIG9sZFZlcnRpY2VzID0gdXRpbC50b0FycmF5KHZlcnRpY2VzKS5tYXAoZy5Qb2ludCk7XG4gICAgdmFyIG5ld1ZlcnRpY2VzID0gW107XG4gICAgdmFyIHRhaWxQb2ludCA9IHNvdXJjZUFuY2hvcjsgLy8gdGhlIG9yaWdpbiBvZiBmaXJzdCByb3V0ZSdzIGdyaWQsIGRvZXMgbm90IG5lZWQgc25hcHBpbmdcblxuICAgIC8vIGZpbmQgYSByb3V0ZSBieSBjb25jYXRlbmF0aW5nIGFsbCBwYXJ0aWFsIHJvdXRlcyAocm91dGVzIG5lZWQgdG8gcGFzcyB0aHJvdWdoIHZlcnRpY2VzKVxuICAgIC8vIHNvdXJjZSAtPiB2ZXJ0ZXhbMV0gLT4gLi4uIC0+IHZlcnRleFtuXSAtPiB0YXJnZXRcbiAgICB2YXIgdG8sIGZyb207XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2xkVmVydGljZXMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgdmFyIHBhcnRpYWxSb3V0ZSA9IG51bGw7XG5cbiAgICAgICAgZnJvbSA9IHRvIHx8IHNvdXJjZUJCb3g7XG4gICAgICAgIHRvID0gb2xkVmVydGljZXNbaV07XG5cbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGFzdCBpdGVyYXRpb25cbiAgICAgICAgICAgIC8vIHdlIHJhbiB0aHJvdWdoIGFsbCB2ZXJ0aWNlcyBpbiBvbGRWZXJ0aWNlc1xuICAgICAgICAgICAgLy8gJ3RvJyBpcyBub3QgYSB2ZXJ0ZXguXG5cbiAgICAgICAgICAgIHRvID0gdGFyZ2V0QkJveDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBvaW50IChpLmUuIGl0J3Mgbm90IGFuIGVsZW1lbnQpLCB3ZVxuICAgICAgICAgICAgLy8gc2hvdWxkIHVzZSBkcmFnZ2luZyByb3V0ZSBpbnN0ZWFkIG9mIG1haW4gcm91dGluZyBtZXRob2QgaWYgaXQgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICAgICAgICB2YXIgaXNFbmRpbmdBdFBvaW50ID0gIWxpbmtWaWV3Lm1vZGVsLmdldCgnc291cmNlJykuaWQgfHwgIWxpbmtWaWV3Lm1vZGVsLmdldCgndGFyZ2V0JykuaWQ7XG5cbiAgICAgICAgICAgIGlmIChpc0VuZGluZ0F0UG9pbnQgJiYgdXRpbC5pc0Z1bmN0aW9uKG9wdC5kcmFnZ2luZ1JvdXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgcGFzc2luZyBwb2ludHMgb25seSAobm90IHJlY3RzKS5cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0Zyb20gPSAoZnJvbSA9PT0gc291cmNlQkJveCkgPyBzb3VyY2VBbmNob3IgOiBmcm9tO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnVG8gPSB0by5vcmlnaW4oKTtcblxuICAgICAgICAgICAgICAgIHBhcnRpYWxSb3V0ZSA9IG9wdC5kcmFnZ2luZ1JvdXRlLmNhbGwobGlua1ZpZXcsIGRyYWdGcm9tLCBkcmFnVG8sIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBwYXJ0aWFsIHJvdXRlIGhhcyBub3QgYmVlbiBjYWxjdWxhdGVkIHlldCB1c2UgdGhlIG1haW4gcm91dGluZyBtZXRob2QgdG8gZmluZCBvbmVcbiAgICAgICAgcGFydGlhbFJvdXRlID0gcGFydGlhbFJvdXRlIHx8IGZpbmRSb3V0ZS5jYWxsKGxpbmtWaWV3LCBmcm9tLCB0bywgaXNQb2ludE9ic3RhY2xlLCBvcHQpO1xuXG4gICAgICAgIGlmIChwYXJ0aWFsUm91dGUgPT09IG51bGwpIHsgLy8gdGhlIHBhcnRpYWwgcm91dGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gb3B0LmZhbGxiYWNrUm91dGVyKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWFkUG9pbnQgPSBwYXJ0aWFsUm91dGVbMF07XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBmaXJzdCBwb2ludCBpZiB0aGUgcHJldmlvdXMgcGFydGlhbCByb3V0ZSBoYWQgdGhlIHNhbWUgcG9pbnQgYXMgbGFzdFxuICAgICAgICBpZiAobGVhZFBvaW50ICYmIGxlYWRQb2ludC5lcXVhbHModGFpbFBvaW50KSkgcGFydGlhbFJvdXRlLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gc2F2ZSB0YWlsUG9pbnQgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgIHRhaWxQb2ludCA9IHBhcnRpYWxSb3V0ZVtwYXJ0aWFsUm91dGUubGVuZ3RoIC0gMV0gfHwgdGFpbFBvaW50O1xuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG5ld1ZlcnRpY2VzLCBwYXJ0aWFsUm91dGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdWZXJ0aWNlcztcbn1cblxuLy8gcHVibGljIGZ1bmN0aW9uXG5leHBvcnQgY29uc3QgbWFuaGF0dGFuID0gZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcbiAgICByZXR1cm4gcm91dGVyKHZlcnRpY2VzLCB1dGlsLmFzc2lnbih7fSwgY29uZmlnLCBvcHQpLCBsaW5rVmlldyk7XG59O1xuIl0sIm5hbWVzIjpbImciLCJ1dGlsIiwib3J0aG9nb25hbCIsImNvbmZpZyIsInN0ZXAiLCJtYXhpbXVtTG9vcHMiLCJwcmVjaXNpb24iLCJtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlIiwicGVycGVuZGljdWxhciIsImV4Y2x1ZGVFbmRzIiwiZXhjbHVkZVR5cGVzIiwic3RhcnREaXJlY3Rpb25zIiwiZW5kRGlyZWN0aW9ucyIsImRpcmVjdGlvbk1hcCIsInRvcCIsIngiLCJ5IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiY29zdCIsImRpcmVjdGlvbnMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBlbmFsdGllcyIsInBhZGRpbmdCb3giLCJ3aWR0aCIsImhlaWdodCIsImlzUG9pbnRPYnN0YWNsZSIsImZhbGxiYWNrUm91dGVyIiwidmVydGljZXMiLCJvcHQiLCJsaW5rVmlldyIsImlzRnVuY3Rpb24iLCJFcnJvciIsImFzc2lnbiIsImZhbGxiYWNrUm91dGUiLCJmcm9tIiwidG8iLCJkcmFnZ2luZ1JvdXRlIiwiT2JzdGFjbGVNYXAiLCJtYXAiLCJvcHRpb25zIiwibWFwR3JpZFNpemUiLCJwcm90b3R5cGUiLCJidWlsZCIsImdyYXBoIiwibGluayIsImV4Y2x1ZGVkRW5kcyIsInRvQXJyYXkiLCJyZWR1Y2UiLCJyZXMiLCJpdGVtIiwiZW5kIiwiZ2V0IiwiY2VsbCIsImdldENlbGwiLCJpZCIsInB1c2giLCJleGNsdWRlZEFuY2VzdG9ycyIsInNvdXJjZSIsInVuaW9uIiwiZ2V0QW5jZXN0b3JzIiwidGFyZ2V0IiwiZ2V0RWxlbWVudHMiLCJlbGVtZW50IiwiaXNFeGNsdWRlZFR5cGUiLCJpbmNsdWRlcyIsImlzRXhjbHVkZWRFbmQiLCJmaW5kIiwiZXhjbHVkZWQiLCJpc0V4Y2x1ZGVkQW5jZXN0b3IiLCJpc0V4Y2x1ZGVkIiwiYmJveCIsImdldEJCb3giLCJtb3ZlQW5kRXhwYW5kIiwib3JpZ2luIiwic25hcFRvR3JpZCIsImNvcm5lciIsImdyaWRLZXkiLCJpc1BvaW50QWNjZXNzaWJsZSIsInBvaW50IiwibWFwS2V5IiwiY2xvbmUiLCJ0b1N0cmluZyIsImV2ZXJ5Iiwib2JzdGFjbGUiLCJjb250YWluc1BvaW50IiwiU29ydGVkU2V0IiwiaXRlbXMiLCJoYXNoIiwidmFsdWVzIiwiT1BFTiIsIkNMT1NFIiwiYWRkIiwidmFsdWUiLCJzcGxpY2UiLCJpbmRleE9mIiwiaW5kZXgiLCJzb3J0ZWRJbmRleCIsImkiLCJiaW5kIiwicmVtb3ZlIiwiaXNPcGVuIiwiaXNDbG9zZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJwb3AiLCJzaGlmdCIsImdldFNvdXJjZUJCb3giLCJzb3VyY2VCQm94IiwiZ2V0VGFyZ2V0QkJveCIsInRhcmdldEJCb3giLCJnZXRTb3VyY2VBbmNob3IiLCJzb3VyY2VBbmNob3IiLCJjZW50ZXIiLCJnZXRUYXJnZXRBbmNob3IiLCJ0YXJnZXRBbmNob3IiLCJnZXREaXJlY3Rpb25BbmdsZSIsInN0YXJ0IiwibnVtRGlyZWN0aW9ucyIsImdyaWQiLCJxdWFkcmFudCIsImFuZ2xlVGhldGEiLCJ0aGV0YSIsImZpeEFuZ2xlRW5kIiwibm9ybWFsaXplZEFuZ2xlIiwibm9ybWFsaXplQW5nbGUiLCJNYXRoIiwiZmxvb3IiLCJkaWZmWCIsImRpZmZZIiwiZ3JpZFN0ZXBzWCIsImdyaWRTdGVwc1kiLCJkaXN0YW5jZVgiLCJkaXN0YW5jZVkiLCJQb2ludCIsImdldERpcmVjdGlvbkNoYW5nZSIsImFuZ2xlMSIsImFuZ2xlMiIsImRpcmVjdGlvbkNoYW5nZSIsImFicyIsImdldEdyaWRPZmZzZXRzIiwiZm9yRWFjaCIsImRpcmVjdGlvbiIsImdyaWRPZmZzZXRYIiwiZ3JpZE9mZnNldFkiLCJnZXRHcmlkIiwiZ2V0R3JpZERpbWVuc2lvbiIsImRpZmYiLCJhYnNEaWZmIiwibnVtU3RlcHMiLCJyb3VuZCIsInJvdW5kZWREaWZmIiwicmVtYWluZGVyIiwic3RlcENvcnJlY3Rpb24iLCJzbmFwcGVkWCIsInNuYXBwZWRZIiwiYWxpZ24iLCJnZXRLZXkiLCJub3JtYWxpemVQb2ludCIsInJlY29uc3RydWN0Um91dGUiLCJwYXJlbnRzIiwicG9pbnRzIiwidGFpbFBvaW50Iiwicm91dGUiLCJwcmV2RGlmZiIsImRpZmZlcmVuY2UiLCJjdXJyZW50S2V5IiwicGFyZW50IiwiZXF1YWxzIiwidW5zaGlmdCIsImxlYWRQb2ludCIsImZyb21EaWZmIiwiZXN0aW1hdGVDb3N0IiwiZW5kUG9pbnRzIiwibWluIiwiSW5maW5pdHkiLCJsZW4iLCJtYW5oYXR0YW5EaXN0YW5jZSIsImdldFJlY3RQb2ludHMiLCJhbmNob3IiLCJkaXJlY3Rpb25MaXN0IiwiYW5jaG9yQ2VudGVyVmVjdG9yIiwia2V5cyIsImlzT2JqZWN0IiwiT2JqZWN0IiwiZGlyTGlzdCIsInJlY3RQb2ludHMiLCJrZXkiLCJlbmRwb2ludCIsImludGVyc2VjdGlvbkxpbmUiLCJMaW5lIiwiaW50ZXJzZWN0aW9ucyIsImludGVyc2VjdCIsIm51bUludGVyc2VjdGlvbnMiLCJmYXJ0aGVzdEludGVyc2VjdGlvbkRpc3RhbmNlIiwiZmFydGhlc3RJbnRlcnNlY3Rpb24iLCJjdXJyZW50SW50ZXJzZWN0aW9uIiwiZGlzdGFuY2UiLCJzcXVhcmVkRGlzdGFuY2UiLCJ1bmRlZmluZWQiLCJvZmZzZXQiLCJmaW5kUm91dGUiLCJSZWN0Iiwic3RhcnRQb2ludHMiLCJmaWx0ZXIiLCJwIiwib3BlblNldCIsImNvc3RzIiwibiIsInN0YXJ0UG9pbnQiLCJwcmV2aW91c1JvdXRlRGlyZWN0aW9uQW5nbGUiLCJwcmV2aW91c0RpcmVjdGlvbkFuZ2xlIiwiaXNQYXRoQmVnaW5uaW5nIiwiZW5kUG9pbnRzS2V5cyIsImVuZFBvaW50IiwibG9vcHNSZW1haW5pbmciLCJjdXJyZW50UG9pbnQiLCJjdXJyZW50UGFyZW50IiwiY3VycmVudENvc3QiLCJpc1JvdXRlQmVnaW5uaW5nIiwiaXNTdGFydCIsInNhbWVQb2ludHMiLCJqIiwic2tpcEVuZENoZWNrIiwiZGlyZWN0aW9uQW5nbGUiLCJhbmdsZSIsIm5laWdoYm9yUG9pbnQiLCJuZWlnaGJvcktleSIsImlzTmVpZ2hib3JFbmQiLCJlbmREaXJlY3Rpb25BbmdsZSIsImVuZERpcmVjdGlvbkNoYW5nZSIsIm5laWdoYm9yQ29zdCIsIm5laWdoYm9yUGVuYWx0eSIsImNvc3RGcm9tU3RhcnQiLCJjYWxsIiwicmVzb2x2ZU9wdGlvbnMiLCJyZXN1bHQiLCJwYWRkaW5nIiwic2lkZXMiLCJub3JtYWxpemVTaWRlcyIsInBvaW50MSIsInBvaW50MiIsInJvdXRlciIsInBhcGVyIiwibW9kZWwiLCJvbGRWZXJ0aWNlcyIsIm5ld1ZlcnRpY2VzIiwicGFydGlhbFJvdXRlIiwiaXNFbmRpbmdBdFBvaW50IiwiZHJhZ0Zyb20iLCJkcmFnVG8iLCJBcnJheSIsImFwcGx5IiwibWFuaGF0dGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/manhattan.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/metro.mjs":
/*!****************************************************!*\
  !*** ./node_modules/jointjs/src/routers/metro.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   metro: () => (/* binding */ metro)\n/* harmony export */ });\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./manhattan.mjs */ \"(ssr)/./node_modules/jointjs/src/routers/manhattan.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n\n\n\nvar config = {\n    maxAllowedDirectionChange: 45,\n    // cost of a diagonal step\n    diagonalCost: function() {\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n        return [\n            {\n                offsetX: step,\n                offsetY: 0,\n                cost: cost\n            },\n            {\n                offsetX: step,\n                offsetY: step,\n                cost: diagonalCost\n            },\n            {\n                offsetX: 0,\n                offsetY: step,\n                cost: cost\n            },\n            {\n                offsetX: -step,\n                offsetY: step,\n                cost: diagonalCost\n            },\n            {\n                offsetX: -step,\n                offsetY: 0,\n                cost: cost\n            },\n            {\n                offsetX: -step,\n                offsetY: -step,\n                cost: diagonalCost\n            },\n            {\n                offsetX: 0,\n                offsetY: -step,\n                cost: cost\n            },\n            {\n                offsetX: step,\n                offsetY: -step,\n                cost: diagonalCost\n            }\n        ];\n    },\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n        var theta = from.theta(to);\n        var route = [];\n        var a = {\n            x: to.x,\n            y: from.y\n        };\n        var b = {\n            x: from.x,\n            y: to.y\n        };\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n        var p1 = theta % 90 < 45 ? a : b;\n        var l1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(from, p1);\n        var alpha = 90 * Math.ceil(theta / 90);\n        var p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(l1.squaredLength(), _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toRad(alpha + 135), p1);\n        var l2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(to, p2);\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n        var directionFrom = intersectionPoint ? point : from;\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + quadrant / 2);\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n        opt.previousDirectionAngle = directionAngle;\n        if (point) route.push(point.round());\n        route.push(to);\n        return route;\n    }\n};\n// public function\nconst metro = function(vertices, opt, linkView) {\n    if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)) {\n        throw new Error(\"Metro requires the manhattan router.\");\n    }\n    return (0,_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, config, opt), linkView);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9tZXRyby5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQ0Y7QUFDTjtBQUVwQyxJQUFJRyxTQUFTO0lBRVRDLDJCQUEyQjtJQUUzQiwwQkFBMEI7SUFDMUJDLGNBQWM7UUFFVixJQUFJQyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixPQUFPQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ0gsT0FBT0EsUUFBUTtJQUM5QztJQUVBLDBEQUEwRDtJQUMxRCxzQ0FBc0M7SUFDdENJLFlBQVk7UUFFUixJQUFJSixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixJQUFJSyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixJQUFJTixlQUFlLElBQUksQ0FBQ0EsWUFBWTtRQUVwQyxPQUFPO1lBQ0g7Z0JBQUVPLFNBQVNOO2dCQUFNTyxTQUFTO2dCQUFHRixNQUFNQTtZQUFLO1lBQ3hDO2dCQUFFQyxTQUFTTjtnQkFBTU8sU0FBU1A7Z0JBQU1LLE1BQU1OO1lBQWE7WUFDbkQ7Z0JBQUVPLFNBQVM7Z0JBQUdDLFNBQVNQO2dCQUFNSyxNQUFNQTtZQUFLO1lBQ3hDO2dCQUFFQyxTQUFTLENBQUNOO2dCQUFNTyxTQUFTUDtnQkFBTUssTUFBTU47WUFBYTtZQUNwRDtnQkFBRU8sU0FBUyxDQUFDTjtnQkFBTU8sU0FBUztnQkFBR0YsTUFBTUE7WUFBSztZQUN6QztnQkFBRUMsU0FBUyxDQUFDTjtnQkFBTU8sU0FBUyxDQUFDUDtnQkFBTUssTUFBTU47WUFBYTtZQUNyRDtnQkFBRU8sU0FBUztnQkFBR0MsU0FBUyxDQUFDUDtnQkFBTUssTUFBTUE7WUFBSztZQUN6QztnQkFBRUMsU0FBU047Z0JBQU1PLFNBQVMsQ0FBQ1A7Z0JBQU1LLE1BQU1OO1lBQWE7U0FDdkQ7SUFDTDtJQUVBLG1FQUFtRTtJQUNuRSx1REFBdUQ7SUFDdkRTLGVBQWUsU0FBU0MsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLEdBQUc7UUFFakMsa0VBQWtFO1FBRWxFLElBQUlDLFFBQVFILEtBQUtHLEtBQUssQ0FBQ0Y7UUFFdkIsSUFBSUcsUUFBUSxFQUFFO1FBRWQsSUFBSUMsSUFBSTtZQUFFQyxHQUFHTCxHQUFHSyxDQUFDO1lBQUVDLEdBQUdQLEtBQUtPLENBQUM7UUFBQztRQUM3QixJQUFJQyxJQUFJO1lBQUVGLEdBQUdOLEtBQUtNLENBQUM7WUFBRUMsR0FBR04sR0FBR00sQ0FBQztRQUFDO1FBRTdCLElBQUlKLFFBQVEsTUFBTSxJQUFJO1lBQ2xCLElBQUlNLElBQUlKO1lBQ1JBLElBQUlHO1lBQ0pBLElBQUlDO1FBQ1I7UUFFQSxJQUFJQyxLQUFLLFFBQVMsS0FBTSxLQUFLTCxJQUFJRztRQUNqQyxJQUFJRyxLQUFLLElBQUl4Qiw4Q0FBTSxDQUFDYSxNQUFNVTtRQUUxQixJQUFJRyxRQUFRLEtBQUtyQixLQUFLQyxJQUFJLENBQUNVLFFBQVE7UUFFbkMsSUFBSVcsS0FBSzNCLCtDQUFPLENBQUM2QixTQUFTLENBQUNMLEdBQUdNLGFBQWEsSUFBSTlCLCtDQUFPLENBQUMwQixRQUFRLE1BQU1IO1FBQ3JFLElBQUlTLEtBQUssSUFBSWhDLDhDQUFNLENBQUNjLElBQUlhO1FBRXhCLElBQUlNLG9CQUFvQlQsR0FBR1UsWUFBWSxDQUFDRjtRQUN4QyxJQUFJRyxRQUFRRixvQkFBb0JBLG9CQUFvQm5CO1FBRXBELElBQUlzQixnQkFBZ0JILG9CQUFvQkUsUUFBUXRCO1FBRWhELElBQUl3QixXQUFXLE1BQU10QixJQUFJUCxVQUFVLENBQUM4QixNQUFNO1FBQzFDLElBQUlDLGFBQWFILGNBQWNwQixLQUFLLENBQUNGO1FBQ3JDLElBQUkwQixrQkFBa0J4Qyx3REFBZ0IsQ0FBQ3VDLGFBQWNGLFdBQVc7UUFDaEUsSUFBSUssaUJBQWlCTCxXQUFXaEMsS0FBS3NDLEtBQUssQ0FBQ0gsa0JBQWtCSDtRQUU3RHRCLElBQUk2QixzQkFBc0IsR0FBR0Y7UUFFN0IsSUFBSVAsT0FBT2xCLE1BQU00QixJQUFJLENBQUNWLE1BQU1XLEtBQUs7UUFDakM3QixNQUFNNEIsSUFBSSxDQUFDL0I7UUFFWCxPQUFPRztJQUNYO0FBQ0o7QUFFQSxrQkFBa0I7QUFDWCxNQUFNOEIsUUFBUSxTQUFTQyxRQUFRLEVBQUVqQyxHQUFHLEVBQUVrQyxRQUFRO0lBRWpELElBQUksQ0FBQ2xELHVEQUFlLENBQUNELHFEQUFTQSxHQUFHO1FBQzdCLE1BQU0sSUFBSXFELE1BQU07SUFDcEI7SUFFQSxPQUFPckQseURBQVNBLENBQUNrRCxVQUFVakQsbURBQVcsQ0FBQyxDQUFDLEdBQUdFLFFBQVFjLE1BQU1rQztBQUM3RCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9tZXRyby5tanM/ZGQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYW5oYXR0YW4gfSBmcm9tICcuL21hbmhhdHRhbi5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxudmFyIGNvbmZpZyA9IHtcblxuICAgIG1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2U6IDQ1LFxuXG4gICAgLy8gY29zdCBvZiBhIGRpYWdvbmFsIHN0ZXBcbiAgICBkaWFnb25hbENvc3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGguc3FydChzdGVwICogc3RlcCA8PCAxKSk7XG4gICAgfSxcblxuICAgIC8vIGFuIGFycmF5IG9mIGRpcmVjdGlvbnMgdG8gZmluZCBuZXh0IHBvaW50cyBvbiB0aGUgcm91dGVcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSBzdGFydC9lbmQgZGlyZWN0aW9uc1xuICAgIGRpcmVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuICAgICAgICB2YXIgY29zdCA9IHRoaXMuY29zdCgpO1xuICAgICAgICB2YXIgZGlhZ29uYWxDb3N0ID0gdGhpcy5kaWFnb25hbENvc3QoKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwLCBvZmZzZXRZOiAwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAsIG9mZnNldFk6IHN0ZXAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAwLCBvZmZzZXRZOiBzdGVwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwLCBvZmZzZXRZOiBzdGVwLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAsIG9mZnNldFk6IDAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAsIG9mZnNldFk6IC1zdGVwLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogLXN0ZXAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogc3RlcCwgb2Zmc2V0WTogLXN0ZXAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9XG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8vIGEgc2ltcGxlIHJvdXRlIHVzZWQgaW4gc2l0dWF0aW9ucyB3aGVuIG1haW4gcm91dGluZyBtZXRob2QgZmFpbHNcbiAgICAvLyAoZXhjZWVkIG1heCBudW1iZXIgb2YgbG9vcCBpdGVyYXRpb25zLCBpbmFjY2Vzc2libGUpXG4gICAgZmFsbGJhY2tSb3V0ZTogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdCkge1xuXG4gICAgICAgIC8vIEZpbmQgYSByb3V0ZSB3aGljaCBicmVha3MgYnkgNDUgZGVncmVlcyBpZ25vcmluZyBhbGwgb2JzdGFjbGVzLlxuXG4gICAgICAgIHZhciB0aGV0YSA9IGZyb20udGhldGEodG8pO1xuXG4gICAgICAgIHZhciByb3V0ZSA9IFtdO1xuXG4gICAgICAgIHZhciBhID0geyB4OiB0by54LCB5OiBmcm9tLnkgfTtcbiAgICAgICAgdmFyIGIgPSB7IHg6IGZyb20ueCwgeTogdG8ueSB9O1xuXG4gICAgICAgIGlmICh0aGV0YSAlIDE4MCA+IDkwKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGIgPSB0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAxID0gKHRoZXRhICUgOTApIDwgNDUgPyBhIDogYjtcbiAgICAgICAgdmFyIGwxID0gbmV3IGcuTGluZShmcm9tLCBwMSk7XG5cbiAgICAgICAgdmFyIGFscGhhID0gOTAgKiBNYXRoLmNlaWwodGhldGEgLyA5MCk7XG5cbiAgICAgICAgdmFyIHAyID0gZy5Qb2ludC5mcm9tUG9sYXIobDEuc3F1YXJlZExlbmd0aCgpLCBnLnRvUmFkKGFscGhhICsgMTM1KSwgcDEpO1xuICAgICAgICB2YXIgbDIgPSBuZXcgZy5MaW5lKHRvLCBwMik7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gbDEuaW50ZXJzZWN0aW9uKGwyKTtcbiAgICAgICAgdmFyIHBvaW50ID0gaW50ZXJzZWN0aW9uUG9pbnQgPyBpbnRlcnNlY3Rpb25Qb2ludCA6IHRvO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb25Gcm9tID0gaW50ZXJzZWN0aW9uUG9pbnQgPyBwb2ludCA6IGZyb207XG5cbiAgICAgICAgdmFyIHF1YWRyYW50ID0gMzYwIC8gb3B0LmRpcmVjdGlvbnMubGVuZ3RoO1xuICAgICAgICB2YXIgYW5nbGVUaGV0YSA9IGRpcmVjdGlvbkZyb20udGhldGEodG8pO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEFuZ2xlID0gZy5ub3JtYWxpemVBbmdsZShhbmdsZVRoZXRhICsgKHF1YWRyYW50IC8gMikpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uQW5nbGUgPSBxdWFkcmFudCAqIE1hdGguZmxvb3Iobm9ybWFsaXplZEFuZ2xlIC8gcXVhZHJhbnQpO1xuXG4gICAgICAgIG9wdC5wcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gZGlyZWN0aW9uQW5nbGU7XG5cbiAgICAgICAgaWYgKHBvaW50KSByb3V0ZS5wdXNoKHBvaW50LnJvdW5kKCkpO1xuICAgICAgICByb3V0ZS5wdXNoKHRvKTtcblxuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxufTtcblxuLy8gcHVibGljIGZ1bmN0aW9uXG5leHBvcnQgY29uc3QgbWV0cm8gPSBmdW5jdGlvbih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuXG4gICAgaWYgKCF1dGlsLmlzRnVuY3Rpb24obWFuaGF0dGFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldHJvIHJlcXVpcmVzIHRoZSBtYW5oYXR0YW4gcm91dGVyLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYW5oYXR0YW4odmVydGljZXMsIHV0aWwuYXNzaWduKHt9LCBjb25maWcsIG9wdCksIGxpbmtWaWV3KTtcbn07XG5cbiJdLCJuYW1lcyI6WyJtYW5oYXR0YW4iLCJ1dGlsIiwiZyIsImNvbmZpZyIsIm1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2UiLCJkaWFnb25hbENvc3QiLCJzdGVwIiwiTWF0aCIsImNlaWwiLCJzcXJ0IiwiZGlyZWN0aW9ucyIsImNvc3QiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImZhbGxiYWNrUm91dGUiLCJmcm9tIiwidG8iLCJvcHQiLCJ0aGV0YSIsInJvdXRlIiwiYSIsIngiLCJ5IiwiYiIsInQiLCJwMSIsImwxIiwiTGluZSIsImFscGhhIiwicDIiLCJQb2ludCIsImZyb21Qb2xhciIsInNxdWFyZWRMZW5ndGgiLCJ0b1JhZCIsImwyIiwiaW50ZXJzZWN0aW9uUG9pbnQiLCJpbnRlcnNlY3Rpb24iLCJwb2ludCIsImRpcmVjdGlvbkZyb20iLCJxdWFkcmFudCIsImxlbmd0aCIsImFuZ2xlVGhldGEiLCJub3JtYWxpemVkQW5nbGUiLCJub3JtYWxpemVBbmdsZSIsImRpcmVjdGlvbkFuZ2xlIiwiZmxvb3IiLCJwcmV2aW91c0RpcmVjdGlvbkFuZ2xlIiwicHVzaCIsInJvdW5kIiwibWV0cm8iLCJ2ZXJ0aWNlcyIsImxpbmtWaWV3IiwiaXNGdW5jdGlvbiIsIkVycm9yIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/metro.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/normal.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/jointjs/src/routers/normal.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: () => (/* binding */ normal)\n/* harmony export */ });\n// Does not make any changes to vertices.\n// Returns the arguments that are passed to it, unchanged.\nconst normal = function(vertices, opt, linkView) {\n    return vertices;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9ub3JtYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5Q0FBeUM7QUFDekMsMERBQTBEO0FBQ25ELE1BQU1BLFNBQVMsU0FBU0MsUUFBUSxFQUFFQyxHQUFHLEVBQUVDLFFBQVE7SUFFbEQsT0FBT0Y7QUFDWCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9ub3JtYWwubWpzPzg0ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG9lcyBub3QgbWFrZSBhbnkgY2hhbmdlcyB0byB2ZXJ0aWNlcy5cbi8vIFJldHVybnMgdGhlIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgdG8gaXQsIHVuY2hhbmdlZC5cbmV4cG9ydCBjb25zdCBub3JtYWwgPSBmdW5jdGlvbih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xufTtcbiJdLCJuYW1lcyI6WyJub3JtYWwiLCJ2ZXJ0aWNlcyIsIm9wdCIsImxpbmtWaWV3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/normal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/oneSide.mjs":
/*!******************************************************!*\
  !*** ./node_modules/jointjs/src/routers/oneSide.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oneSide: () => (/* binding */ oneSide)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nconst oneSide = function(vertices, opt, linkView) {\n    var side = opt.side || \"bottom\";\n    var padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeSides(opt.padding || 40);\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n    var coordinate, dimension, direction;\n    switch(side){\n        case \"bottom\":\n            direction = 1;\n            coordinate = \"y\";\n            dimension = \"height\";\n            break;\n        case \"top\":\n            direction = -1;\n            coordinate = \"y\";\n            dimension = \"height\";\n            break;\n        case \"left\":\n            direction = -1;\n            coordinate = \"x\";\n            dimension = \"width\";\n            break;\n        case \"right\":\n            direction = 1;\n            coordinate = \"x\";\n            dimension = \"width\";\n            break;\n        default:\n            throw new Error(\"Router: invalid side\");\n    }\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n    // make link orthogonal (at least the first and last vertex).\n    if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n    return [\n        sourcePoint\n    ].concat(vertices, targetPoint);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9vbmVTaWRlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUUxQyxnREFBZ0Q7QUFDaEQsRUFBRTtBQUNGLGFBQWE7QUFDYiw2RUFBNkU7QUFDN0Usc0VBQXNFO0FBQ3RFLEVBQUU7QUFDSyxNQUFNQyxVQUFVLFNBQVNDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxRQUFRO0lBRW5ELElBQUlDLE9BQU9GLElBQUlFLElBQUksSUFBSTtJQUN2QixJQUFJQyxVQUFVTiwyREFBbUIsQ0FBQ0csSUFBSUcsT0FBTyxJQUFJO0lBRWpELG9EQUFvRDtJQUNwRCxrREFBa0Q7SUFDbEQsSUFBSUUsYUFBYUosU0FBU0ksVUFBVTtJQUNwQyxJQUFJQyxhQUFhTCxTQUFTSyxVQUFVO0lBQ3BDLElBQUlDLGNBQWNGLFdBQVdHLE1BQU07SUFDbkMsSUFBSUMsY0FBY0gsV0FBV0UsTUFBTTtJQUVuQyxJQUFJRSxZQUFZQyxXQUFXQztJQUUzQixPQUFRVjtRQUNKLEtBQUs7WUFDRFUsWUFBWTtZQUNaRixhQUFhO1lBQ2JDLFlBQVk7WUFDWjtRQUNKLEtBQUs7WUFDREMsWUFBWSxDQUFDO1lBQ2JGLGFBQWE7WUFDYkMsWUFBWTtZQUNaO1FBQ0osS0FBSztZQUNEQyxZQUFZLENBQUM7WUFDYkYsYUFBYTtZQUNiQyxZQUFZO1lBQ1o7UUFDSixLQUFLO1lBQ0RDLFlBQVk7WUFDWkYsYUFBYTtZQUNiQyxZQUFZO1lBQ1o7UUFDSjtZQUNJLE1BQU0sSUFBSUUsTUFBTTtJQUN4QjtJQUVBLG1FQUFtRTtJQUNuRU4sV0FBVyxDQUFDRyxXQUFXLElBQUlFLFlBQWFQLENBQUFBLFVBQVUsQ0FBQ00sVUFBVSxHQUFHLElBQUlSLE9BQU8sQ0FBQ0QsS0FBSztJQUNqRk8sV0FBVyxDQUFDQyxXQUFXLElBQUlFLFlBQWFOLENBQUFBLFVBQVUsQ0FBQ0ssVUFBVSxHQUFHLElBQUlSLE9BQU8sQ0FBQ0QsS0FBSztJQUVqRiw2REFBNkQ7SUFDN0QsSUFBSSxZQUFjSyxDQUFBQSxXQUFXLENBQUNHLFdBQVcsR0FBR0QsV0FBVyxDQUFDQyxXQUFXLElBQUssR0FBRztRQUN2RUQsV0FBVyxDQUFDQyxXQUFXLEdBQUdILFdBQVcsQ0FBQ0csV0FBVztJQUNyRCxPQUFPO1FBQ0hILFdBQVcsQ0FBQ0csV0FBVyxHQUFHRCxXQUFXLENBQUNDLFdBQVc7SUFDckQ7SUFFQSxPQUFPO1FBQUNIO0tBQVksQ0FBQ08sTUFBTSxDQUFDZixVQUFVVTtBQUMxQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9vbmVTaWRlLm1qcz9hYTAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG4vLyBSb3V0ZXMgdGhlIGxpbmsgYWx3YXlzIHRvL2Zyb20gYSBjZXJ0YWluIHNpZGVcbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAgIHBhZGRpbmcgLi4uIGdhcCBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCB0aGUgZmlyc3QgdmVydGV4LiA6OiBEZWZhdWx0IDQwLlxuLy8gICBzaWRlIC4uLiAnbGVmdCcgfCAncmlnaHQnIHwgJ3RvcCcgfCAnYm90dG9tJyA6OiBEZWZhdWx0ICdib3R0b20nLlxuLy9cbmV4cG9ydCBjb25zdCBvbmVTaWRlID0gZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIHZhciBzaWRlID0gb3B0LnNpZGUgfHwgJ2JvdHRvbSc7XG4gICAgdmFyIHBhZGRpbmcgPSB1dGlsLm5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nIHx8IDQwKTtcblxuICAgIC8vIExpbmtWaWV3IGNvbnRhaW5zIGNhY2hlZCBzb3VyY2UgYW4gdGFyZ2V0IGJib3hlcy5cbiAgICAvLyBOb3RlIHRoYXQgdGhvc2UgYXJlIEdlb21ldHJ5IHJlY3RhbmdsZSBvYmplY3RzLlxuICAgIHZhciBzb3VyY2VCQm94ID0gbGlua1ZpZXcuc291cmNlQkJveDtcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGxpbmtWaWV3LnRhcmdldEJCb3g7XG4gICAgdmFyIHNvdXJjZVBvaW50ID0gc291cmNlQkJveC5jZW50ZXIoKTtcbiAgICB2YXIgdGFyZ2V0UG9pbnQgPSB0YXJnZXRCQm94LmNlbnRlcigpO1xuXG4gICAgdmFyIGNvb3JkaW5hdGUsIGRpbWVuc2lvbiwgZGlyZWN0aW9uO1xuXG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd5JztcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneSc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnaGVpZ2h0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd4JztcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnd2lkdGgnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlcjogaW52YWxpZCBzaWRlJyk7XG4gICAgfVxuXG4gICAgLy8gbW92ZSB0aGUgcG9pbnRzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCB0byBvdXRzaWRlIG9mIGl0LlxuICAgIHNvdXJjZVBvaW50W2Nvb3JkaW5hdGVdICs9IGRpcmVjdGlvbiAqIChzb3VyY2VCQm94W2RpbWVuc2lvbl0gLyAyICsgcGFkZGluZ1tzaWRlXSk7XG4gICAgdGFyZ2V0UG9pbnRbY29vcmRpbmF0ZV0gKz0gZGlyZWN0aW9uICogKHRhcmdldEJCb3hbZGltZW5zaW9uXSAvIDIgKyBwYWRkaW5nW3NpZGVdKTtcblxuICAgIC8vIG1ha2UgbGluayBvcnRob2dvbmFsIChhdCBsZWFzdCB0aGUgZmlyc3QgYW5kIGxhc3QgdmVydGV4KS5cbiAgICBpZiAoKGRpcmVjdGlvbiAqIChzb3VyY2VQb2ludFtjb29yZGluYXRlXSAtIHRhcmdldFBvaW50W2Nvb3JkaW5hdGVdKSkgPiAwKSB7XG4gICAgICAgIHRhcmdldFBvaW50W2Nvb3JkaW5hdGVdID0gc291cmNlUG9pbnRbY29vcmRpbmF0ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlUG9pbnRbY29vcmRpbmF0ZV0gPSB0YXJnZXRQb2ludFtjb29yZGluYXRlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZVBvaW50XS5jb25jYXQodmVydGljZXMsIHRhcmdldFBvaW50KTtcbn07XG4iXSwibmFtZXMiOlsidXRpbCIsIm9uZVNpZGUiLCJ2ZXJ0aWNlcyIsIm9wdCIsImxpbmtWaWV3Iiwic2lkZSIsInBhZGRpbmciLCJub3JtYWxpemVTaWRlcyIsInNvdXJjZUJCb3giLCJ0YXJnZXRCQm94Iiwic291cmNlUG9pbnQiLCJjZW50ZXIiLCJ0YXJnZXRQb2ludCIsImNvb3JkaW5hdGUiLCJkaW1lbnNpb24iLCJkaXJlY3Rpb24iLCJFcnJvciIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/oneSide.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/orthogonal.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/jointjs/src/routers/orthogonal.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orthogonal: () => (/* binding */ orthogonal)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: \"S\",\n    S: \"N\",\n    E: \"W\",\n    W: \"E\"\n};\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n// HELPERS //\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n    var p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n    return p;\n}\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n    return bbox[bearing === \"W\" || bearing === \"E\" ? \"width\" : \"height\"];\n}\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n    if (from.x === to.x) return from.y > to.y ? \"N\" : \"S\";\n    if (from.y === to.y) return from.x > to.x ? \"W\" : \"E\";\n    return null;\n}\n// transform point to a rect\nfunction getPointBox(p) {\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(p.x, p.y, 0, 0);\n}\nfunction getPaddingBox(opt) {\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides(opt.padding || opt.elementPadding || 20);\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n// PARTIAL ROUTERS //\nfunction vertexVertex(from, to, bearing) {\n    var p1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y);\n    var p2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n    var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n    return {\n        points: [\n            p\n        ],\n        direction: getBearing(p, to)\n    };\n}\nfunction elementVertex(from, to, fromBBox) {\n    var p = freeJoin(from, to, fromBBox);\n    return {\n        points: [\n            p\n        ],\n        direction: getBearing(p, to)\n    };\n}\nfunction vertexElement(from, to, toBBox, bearing) {\n    var route = {};\n    var points = [\n        new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y),\n        new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y)\n    ];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n    var p;\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n        route.points = [\n            p\n        ];\n        route.direction = getBearing(p, to);\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n        p = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.difference(points, freePoints)[0];\n        var p2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n        route.points = [\n            p1,\n            p2\n        ];\n        route.direction = getBearing(p2, to);\n    }\n    return route;\n}\nfunction elementElement(from, to, fromBBox, toBBox) {\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n    if (fromBBox.containsPoint(p1)) {\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n        if (toBBox.containsPoint(p2)) {\n            var fromBorder = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(fromBorder, toBorder).midpoint();\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n            route.points = [\n                startRoute.points[0],\n                endRoute.points[0]\n            ];\n            route.direction = endRoute.direction;\n        }\n    }\n    return route;\n}\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n    var p1, p2, p3;\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n    p2 = freeJoin(p1, end, boundary);\n    if (p1.round().equals(p2.round())) {\n        p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [\n            p2,\n            p3,\n            p1\n        ] : [\n            p1,\n            p3,\n            p2\n        ];\n    } else {\n        route.points = reversed ? [\n            p2,\n            p1\n        ] : [\n            p1,\n            p2\n        ];\n    }\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n    return route;\n}\n// MAIN ROUTER //\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nfunction orthogonal(vertices, opt, linkView) {\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n    vertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n    var bearing; // bearing of previous route segment\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for(var i = 0, max = vertices.length - 1; i < max; i++){\n        var route = null;\n        var from = vertices[i];\n        var to = vertices[i + 1];\n        var isOrthogonal = !!getBearing(from, to);\n        if (i === 0) {\n            if (i + 1 === max) {\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n            } else {\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n        } else if (i + 1 === max) {\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n        } else if (!isOrthogonal) {\n            route = vertexVertex(from, to, bearing);\n        }\n        // applicable to all routes:\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n    return orthogonalVertices;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9vcnRob2dvbmFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9DO0FBQ007QUFFMUMsOEJBQThCO0FBQzlCLElBQUlFLFlBQVk7SUFDWkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztBQUNQO0FBRUEscUJBQXFCO0FBQ3JCLElBQUlDLFVBQVU7SUFDVkosR0FBRyxDQUFDSyxLQUFLQyxFQUFFLEdBQUcsSUFBSTtJQUNsQkwsR0FBRyxDQUFDSSxLQUFLQyxFQUFFLEdBQUc7SUFDZEosR0FBRztJQUNIQyxHQUFHRSxLQUFLQyxFQUFFO0FBQ2Q7QUFFQSxhQUFhO0FBRWIseUZBQXlGO0FBQ3pGLG1CQUFtQjtBQUNuQixTQUFTQyxTQUFTQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsSUFBSTtJQUUxQixJQUFJQyxJQUFJLElBQUlkLCtDQUFPLENBQUNXLEdBQUdLLENBQUMsRUFBRUosR0FBR0ssQ0FBQztJQUM5QixJQUFJSixLQUFLSyxhQUFhLENBQUNKLElBQUlBLElBQUksSUFBSWQsK0NBQU8sQ0FBQ1ksR0FBR0ksQ0FBQyxFQUFFTCxHQUFHTSxDQUFDO0lBQ3JELHFCQUFxQjtJQUNyQix1Q0FBdUM7SUFFdkMsT0FBT0g7QUFDWDtBQUVBLHNFQUFzRTtBQUN0RSxTQUFTSyxZQUFZTixJQUFJLEVBQUVPLE9BQU87SUFFOUIsT0FBT1AsSUFBSSxDQUFDLFlBQWEsT0FBT08sWUFBWSxNQUFPLFVBQVUsU0FBUztBQUMxRTtBQUVBLCtEQUErRDtBQUMvRCxTQUFTQyxXQUFXQyxJQUFJLEVBQUVDLEVBQUU7SUFFeEIsSUFBSUQsS0FBS04sQ0FBQyxLQUFLTyxHQUFHUCxDQUFDLEVBQUUsT0FBTyxLQUFNQyxDQUFDLEdBQUdNLEdBQUdOLENBQUMsR0FBSSxNQUFNO0lBQ3BELElBQUlLLEtBQUtMLENBQUMsS0FBS00sR0FBR04sQ0FBQyxFQUFFLE9BQU8sS0FBTUQsQ0FB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LG1CQUFtQkQsSUFBSSxDQUFDMUU7UUFDNUI7SUFDSjtJQUVBLE9BQU8yRTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9vcnRob2dvbmFsLm1qcz84NDdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbi8vIGJlYXJpbmcgLT4gb3Bwb3NpdGUgYmVhcmluZ1xudmFyIG9wcG9zaXRlcyA9IHtcbiAgICBOOiAnUycsXG4gICAgUzogJ04nLFxuICAgIEU6ICdXJyxcbiAgICBXOiAnRSdcbn07XG5cbi8vIGJlYXJpbmcgLT4gcmFkaWFuc1xudmFyIHJhZGlhbnMgPSB7XG4gICAgTjogLU1hdGguUEkgLyAyICogMyxcbiAgICBTOiAtTWF0aC5QSSAvIDIsXG4gICAgRTogMCxcbiAgICBXOiBNYXRoLlBJXG59O1xuXG4vLyBIRUxQRVJTIC8vXG5cbi8vIHJldHVybnMgYSBwb2ludCBgcGAgd2hlcmUgbGluZXMgcCxwMSBhbmQgcCxwMiBhcmUgcGVycGVuZGljdWxhciBhbmQgcCBpcyBub3QgY29udGFpbmVkXG4vLyBpbiB0aGUgZ2l2ZW4gYm94XG5mdW5jdGlvbiBmcmVlSm9pbihwMSwgcDIsIGJib3gpIHtcblxuICAgIHZhciBwID0gbmV3IGcuUG9pbnQocDEueCwgcDIueSk7XG4gICAgaWYgKGJib3guY29udGFpbnNQb2ludChwKSkgcCA9IG5ldyBnLlBvaW50KHAyLngsIHAxLnkpO1xuICAgIC8vIGtlcHQgZm9yIHJlZmVyZW5jZVxuICAgIC8vIGlmIChiYm94LmNvbnRhaW5zUG9pbnQocCkpIHAgPSBudWxsO1xuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIHJldHVybnMgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBvZiBhIGJib3ggYmFzZWQgb24gdGhlIGdpdmVuIGJlYXJpbmdcbmZ1bmN0aW9uIGdldEJCb3hTaXplKGJib3gsIGJlYXJpbmcpIHtcblxuICAgIHJldHVybiBiYm94WyhiZWFyaW5nID09PSAnVycgfHwgYmVhcmluZyA9PT0gJ0UnKSA/ICd3aWR0aCcgOiAnaGVpZ2h0J107XG59XG5cbi8vIHNpbXBsZSBiZWFyaW5nIG1ldGhvZCAoY2FsY3VsYXRlcyBvbmx5IG9ydGhvZ29uYWwgY2FyZGluYWxzKVxuZnVuY3Rpb24gZ2V0QmVhcmluZyhmcm9tLCB0bykge1xuXG4gICAgaWYgKGZyb20ueCA9PT0gdG8ueCkgcmV0dXJuIChmcm9tLnkgPiB0by55KSA/ICdOJyA6ICdTJztcbiAgICBpZiAoZnJvbS55ID09PSB0by55KSByZXR1cm4gKGZyb20ueCA+IHRvLngpID8gJ1cnIDogJ0UnO1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyB0cmFuc2Zvcm0gcG9pbnQgdG8gYSByZWN0XG5mdW5jdGlvbiBnZXRQb2ludEJveChwKSB7XG5cbiAgICByZXR1cm4gbmV3IGcuUmVjdChwLngsIHAueSwgMCwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldFBhZGRpbmdCb3gob3B0KSB7XG5cbiAgICAvLyBpZiBib3RoIHByb3ZpZGVkLCBvcHQucGFkZGluZyB3aW5zIG92ZXIgb3B0LmVsZW1lbnRQYWRkaW5nXG4gICAgdmFyIHNpZGVzID0gdXRpbC5ub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyB8fCBvcHQuZWxlbWVudFBhZGRpbmcgfHwgMjApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogLXNpZGVzLmxlZnQsXG4gICAgICAgIHk6IC1zaWRlcy50b3AsXG4gICAgICAgIHdpZHRoOiBzaWRlcy5sZWZ0ICsgc2lkZXMucmlnaHQsXG4gICAgICAgIGhlaWdodDogc2lkZXMudG9wICsgc2lkZXMuYm90dG9tXG4gICAgfTtcbn1cblxuLy8gcmV0dXJuIHNvdXJjZSBiYm94XG5mdW5jdGlvbiBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIHJldHVybiBsaW5rVmlldy5zb3VyY2VCQm94LmNsb25lKCkubW92ZUFuZEV4cGFuZChnZXRQYWRkaW5nQm94KG9wdCkpO1xufVxuXG4vLyByZXR1cm4gdGFyZ2V0IGJib3hcbmZ1bmN0aW9uIGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgcmV0dXJuIGxpbmtWaWV3LnRhcmdldEJCb3guY2xvbmUoKS5tb3ZlQW5kRXhwYW5kKGdldFBhZGRpbmdCb3gob3B0KSk7XG59XG5cbi8vIHJldHVybiBzb3VyY2UgYW5jaG9yXG5mdW5jdGlvbiBnZXRTb3VyY2VBbmNob3IobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgaWYgKGxpbmtWaWV3LnNvdXJjZUFuY2hvcikgcmV0dXJuIGxpbmtWaWV3LnNvdXJjZUFuY2hvcjtcblxuICAgIC8vIGZhbGxiYWNrOiBjZW50ZXIgb2YgYmJveFxuICAgIHZhciBzb3VyY2VCQm94ID0gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KTtcbiAgICByZXR1cm4gc291cmNlQkJveC5jZW50ZXIoKTtcbn1cblxuLy8gcmV0dXJuIHRhcmdldCBhbmNob3JcbmZ1bmN0aW9uIGdldFRhcmdldEFuY2hvcihsaW5rVmlldywgb3B0KSB7XG5cbiAgICBpZiAobGlua1ZpZXcudGFyZ2V0QW5jaG9yKSByZXR1cm4gbGlua1ZpZXcudGFyZ2V0QW5jaG9yO1xuXG4gICAgLy8gZmFsbGJhY2s6IGNlbnRlciBvZiBiYm94XG4gICAgdmFyIHRhcmdldEJCb3ggPSBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHJldHVybiB0YXJnZXRCQm94LmNlbnRlcigpOyAvLyBkZWZhdWx0XG59XG5cbi8vIFBBUlRJQUwgUk9VVEVSUyAvL1xuXG5mdW5jdGlvbiB2ZXJ0ZXhWZXJ0ZXgoZnJvbSwgdG8sIGJlYXJpbmcpIHtcblxuICAgIHZhciBwMSA9IG5ldyBnLlBvaW50KGZyb20ueCwgdG8ueSk7XG4gICAgdmFyIHAyID0gbmV3IGcuUG9pbnQodG8ueCwgZnJvbS55KTtcbiAgICB2YXIgZDEgPSBnZXRCZWFyaW5nKGZyb20sIHAxKTtcbiAgICB2YXIgZDIgPSBnZXRCZWFyaW5nKGZyb20sIHAyKTtcbiAgICB2YXIgb3Bwb3NpdGUgPSBvcHBvc2l0ZXNbYmVhcmluZ107XG5cbiAgICB2YXIgcCA9IChkMSA9PT0gYmVhcmluZyB8fCAoZDEgIT09IG9wcG9zaXRlICYmIChkMiA9PT0gb3Bwb3NpdGUgfHwgZDIgIT09IGJlYXJpbmcpKSkgPyBwMSA6IHAyO1xuXG4gICAgcmV0dXJuIHsgcG9pbnRzOiBbcF0sIGRpcmVjdGlvbjogZ2V0QmVhcmluZyhwLCB0bykgfTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFZlcnRleChmcm9tLCB0bywgZnJvbUJCb3gpIHtcblxuICAgIHZhciBwID0gZnJlZUpvaW4oZnJvbSwgdG8sIGZyb21CQm94KTtcblxuICAgIHJldHVybiB7IHBvaW50czogW3BdLCBkaXJlY3Rpb246IGdldEJlYXJpbmcocCwgdG8pIH07XG59XG5cbmZ1bmN0aW9uIHZlcnRleEVsZW1lbnQoZnJvbSwgdG8sIHRvQkJveCwgYmVhcmluZykge1xuXG4gICAgdmFyIHJvdXRlID0ge307XG5cbiAgICB2YXIgcG9pbnRzID0gW25ldyBnLlBvaW50KGZyb20ueCwgdG8ueSksIG5ldyBnLlBvaW50KHRvLngsIGZyb20ueSldO1xuICAgIHZhciBmcmVlUG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuICAgICAgICByZXR1cm4gIXRvQkJveC5jb250YWluc1BvaW50KHB0KTtcbiAgICB9KTtcbiAgICB2YXIgZnJlZUJlYXJpbmdQb2ludHMgPSBmcmVlUG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuICAgICAgICByZXR1cm4gZ2V0QmVhcmluZyhwdCwgZnJvbSkgIT09IGJlYXJpbmc7XG4gICAgfSk7XG5cbiAgICB2YXIgcDtcblxuICAgIGlmIChmcmVlQmVhcmluZ1BvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRyeSB0byBwaWNrIGEgcG9pbnQgd2hpY2ggYmVhcnMgdGhlIHNhbWUgZGlyZWN0aW9uIGFzIHRoZSBwcmV2aW91cyBzZWdtZW50LlxuXG4gICAgICAgIHAgPSBmcmVlQmVhcmluZ1BvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCZWFyaW5nKGZyb20sIHB0KSA9PT0gYmVhcmluZztcbiAgICAgICAgfSkucG9wKCk7XG4gICAgICAgIHAgPSBwIHx8IGZyZWVCZWFyaW5nUG9pbnRzWzBdO1xuXG4gICAgICAgIHJvdXRlLnBvaW50cyA9IFtwXTtcbiAgICAgICAgcm91dGUuZGlyZWN0aW9uID0gZ2V0QmVhcmluZyhwLCB0byk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIZXJlIHdlIGZvdW5kIG9ubHkgcG9pbnRzIHdoaWNoIGFyZSBlaXRoZXIgY29udGFpbmVkIGluIHRoZSBlbGVtZW50IG9yIHRoZXkgd291bGQgY3JlYXRlXG4gICAgICAgIC8vIGEgbGluayBzZWdtZW50IGdvaW5nIGluIG9wcG9zaXRlIGRpcmVjdGlvbiBmcm9tIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIC8vIFdlIHRha2UgdGhlIHBvaW50IGluc2lkZSBlbGVtZW50IGFuZCBtb3ZlIGl0IG91dHNpZGUgdGhlIGVsZW1lbnQgaW4gdGhlIGRpcmVjdGlvbiB0aGVcbiAgICAgICAgLy8gcm91dGUgaXMgZ29pbmcuIE5vdyB3ZSBjYW4gam9pbiB0aGlzIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgZW5kICh1c2luZyBmcmVlSm9pbikuXG5cbiAgICAgICAgcCA9IHV0aWwuZGlmZmVyZW5jZShwb2ludHMsIGZyZWVQb2ludHMpWzBdO1xuXG4gICAgICAgIHZhciBwMiA9IChuZXcgZy5Qb2ludCh0bykpLm1vdmUocCwgLWdldEJCb3hTaXplKHRvQkJveCwgYmVhcmluZykgLyAyKTtcbiAgICAgICAgdmFyIHAxID0gZnJlZUpvaW4ocDIsIGZyb20sIHRvQkJveCk7XG5cbiAgICAgICAgcm91dGUucG9pbnRzID0gW3AxLCBwMl07XG4gICAgICAgIHJvdXRlLmRpcmVjdGlvbiA9IGdldEJlYXJpbmcocDIsIHRvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGU7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRFbGVtZW50KGZyb20sIHRvLCBmcm9tQkJveCwgdG9CQm94KSB7XG5cbiAgICB2YXIgcm91dGUgPSBlbGVtZW50VmVydGV4KHRvLCBmcm9tLCB0b0JCb3gpO1xuICAgIHZhciBwMSA9IHJvdXRlLnBvaW50c1swXTtcblxuICAgIGlmIChmcm9tQkJveC5jb250YWluc1BvaW50KHAxKSkge1xuXG4gICAgICAgIHJvdXRlID0gZWxlbWVudFZlcnRleChmcm9tLCB0bywgZnJvbUJCb3gpO1xuICAgICAgICB2YXIgcDIgPSByb3V0ZS5wb2ludHNbMF07XG5cbiAgICAgICAgaWYgKHRvQkJveC5jb250YWluc1BvaW50KHAyKSkge1xuXG4gICAgICAgICAgICB2YXIgZnJvbUJvcmRlciA9IChuZXcgZy5Qb2ludChmcm9tKSkubW92ZShwMiwgLWdldEJCb3hTaXplKGZyb21CQm94LCBnZXRCZWFyaW5nKGZyb20sIHAyKSkgLyAyKTtcbiAgICAgICAgICAgIHZhciB0b0JvcmRlciA9IChuZXcgZy5Qb2ludCh0bykpLm1vdmUocDEsIC1nZXRCQm94U2l6ZSh0b0JCb3gsIGdldEJlYXJpbmcodG8sIHAxKSkgLyAyKTtcbiAgICAgICAgICAgIHZhciBtaWQgPSAobmV3IGcuTGluZShmcm9tQm9yZGVyLCB0b0JvcmRlcikpLm1pZHBvaW50KCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFydFJvdXRlID0gZWxlbWVudFZlcnRleChmcm9tLCBtaWQsIGZyb21CQm94KTtcbiAgICAgICAgICAgIHZhciBlbmRSb3V0ZSA9IHZlcnRleFZlcnRleChtaWQsIHRvLCBzdGFydFJvdXRlLmRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIHJvdXRlLnBvaW50cyA9IFtzdGFydFJvdXRlLnBvaW50c1swXSwgZW5kUm91dGUucG9pbnRzWzBdXTtcbiAgICAgICAgICAgIHJvdXRlLmRpcmVjdGlvbiA9IGVuZFJvdXRlLmRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3V0ZTtcbn1cblxuLy8gRmluZHMgcm91dGUgZm9yIHNpdHVhdGlvbnMgd2hlcmUgb25lIGVsZW1lbnQgaXMgaW5zaWRlIHRoZSBvdGhlci5cbi8vIFR5cGljYWxseSB0aGUgcm91dGUgaXMgZGlyZWN0ZWQgb3V0c2lkZSB0aGUgb3V0ZXIgZWxlbWVudCBmaXJzdCBhbmRcbi8vIHRoZW4gYmFjayB0b3dhcmRzIHRoZSBpbm5lciBlbGVtZW50LlxuZnVuY3Rpb24gaW5zaWRlRWxlbWVudChmcm9tLCB0bywgZnJvbUJCb3gsIHRvQkJveCwgYmVhcmluZykge1xuXG4gICAgdmFyIHJvdXRlID0ge307XG4gICAgdmFyIGJvdW5kYXJ5ID0gZnJvbUJCb3gudW5pb24odG9CQm94KS5pbmZsYXRlKDEpO1xuXG4gICAgLy8gc3RhcnQgZnJvbSB0aGUgcG9pbnQgd2hpY2ggaXMgY2xvc2VyIHRvIHRoZSBib3VuZGFyeVxuICAgIHZhciByZXZlcnNlZCA9IGJvdW5kYXJ5LmNlbnRlcigpLmRpc3RhbmNlKHRvKSA+IGJvdW5kYXJ5LmNlbnRlcigpLmRpc3RhbmNlKGZyb20pO1xuICAgIHZhciBzdGFydCA9IHJldmVyc2VkID8gdG8gOiBmcm9tO1xuICAgIHZhciBlbmQgPSByZXZlcnNlZCA/IGZyb20gOiB0bztcblxuICAgIHZhciBwMSwgcDIsIHAzO1xuXG4gICAgaWYgKGJlYXJpbmcpIHtcbiAgICAgICAgLy8gUG9pbnRzIG9uIGNpcmNsZSB3aXRoIHJhZGl1cyBlcXVhbHMgJ1cgKyBIYCBhcmUgYWx3YXlzIG91dHNpZGUgdGhlIHJlY3RhbmdsZVxuICAgICAgICAvLyB3aXRoIHdpZHRoIFcgYW5kIGhlaWdodCBIIGlmIHRoZSBjZW50ZXIgb2YgdGhhdCBjaXJjbGUgaXMgdGhlIGNlbnRlciBvZiB0aGF0IHJlY3RhbmdsZS5cbiAgICAgICAgcDEgPSBnLlBvaW50LmZyb21Qb2xhcihib3VuZGFyeS53aWR0aCArIGJvdW5kYXJ5LmhlaWdodCwgcmFkaWFuc1tiZWFyaW5nXSwgc3RhcnQpO1xuICAgICAgICBwMSA9IGJvdW5kYXJ5LnBvaW50TmVhcmVzdFRvUG9pbnQocDEpLm1vdmUocDEsIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAxID0gYm91bmRhcnkucG9pbnROZWFyZXN0VG9Qb2ludChzdGFydCkubW92ZShzdGFydCwgMSk7XG4gICAgfVxuXG4gICAgcDIgPSBmcmVlSm9pbihwMSwgZW5kLCBib3VuZGFyeSk7XG5cbiAgICBpZiAocDEucm91bmQoKS5lcXVhbHMocDIucm91bmQoKSkpIHtcbiAgICAgICAgcDIgPSBnLlBvaW50LmZyb21Qb2xhcihib3VuZGFyeS53aWR0aCArIGJvdW5kYXJ5LmhlaWdodCwgZy50b1JhZChwMS50aGV0YShzdGFydCkpICsgTWF0aC5QSSAvIDIsIGVuZCk7XG4gICAgICAgIHAyID0gYm91bmRhcnkucG9pbnROZWFyZXN0VG9Qb2ludChwMikubW92ZShlbmQsIDEpLnJvdW5kKCk7XG4gICAgICAgIHAzID0gZnJlZUpvaW4ocDEsIHAyLCBib3VuZGFyeSk7XG4gICAgICAgIHJvdXRlLnBvaW50cyA9IHJldmVyc2VkID8gW3AyLCBwMywgcDFdIDogW3AxLCBwMywgcDJdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGUucG9pbnRzID0gcmV2ZXJzZWQgPyBbcDIsIHAxXSA6IFtwMSwgcDJdO1xuICAgIH1cblxuICAgIHJvdXRlLmRpcmVjdGlvbiA9IHJldmVyc2VkID8gZ2V0QmVhcmluZyhwMSwgdG8pIDogZ2V0QmVhcmluZyhwMiwgdG8pO1xuXG4gICAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBNQUlOIFJPVVRFUiAvL1xuXG4vLyBSZXR1cm4gcG9pbnRzIHRocm91Z2ggd2hpY2ggYSBjb25uZWN0aW9uIG5lZWRzIHRvIGJlIGRyYXduIGluIG9yZGVyIHRvIG9idGFpbiBhbiBvcnRob2dvbmFsIGxpbmtcbi8vIHJvdXRpbmcgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGdvaW5nIHRocm91Z2ggYHZlcnRpY2VzYC5cbmV4cG9ydCBmdW5jdGlvbiBvcnRob2dvbmFsKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICB2YXIgc291cmNlQkJveCA9IGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgdmFyIHRhcmdldEJCb3ggPSBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpO1xuXG4gICAgdmFyIHNvdXJjZUFuY2hvciA9IGdldFNvdXJjZUFuY2hvcihsaW5rVmlldywgb3B0KTtcbiAgICB2YXIgdGFyZ2V0QW5jaG9yID0gZ2V0VGFyZ2V0QW5jaG9yKGxpbmtWaWV3LCBvcHQpO1xuXG4gICAgLy8gaWYgYW5jaG9yIGxpZXMgb3V0c2lkZSBvZiBiYm94LCB0aGUgYmJveCBleHBhbmRzIHRvIGluY2x1ZGUgaXRcbiAgICBzb3VyY2VCQm94ID0gc291cmNlQkJveC51bmlvbihnZXRQb2ludEJveChzb3VyY2VBbmNob3IpKTtcbiAgICB0YXJnZXRCQm94ID0gdGFyZ2V0QkJveC51bmlvbihnZXRQb2ludEJveCh0YXJnZXRBbmNob3IpKTtcblxuICAgIHZlcnRpY2VzID0gdXRpbC50b0FycmF5KHZlcnRpY2VzKS5tYXAoZy5Qb2ludCk7XG4gICAgdmVydGljZXMudW5zaGlmdChzb3VyY2VBbmNob3IpO1xuICAgIHZlcnRpY2VzLnB1c2godGFyZ2V0QW5jaG9yKTtcblxuICAgIHZhciBiZWFyaW5nOyAvLyBiZWFyaW5nIG9mIHByZXZpb3VzIHJvdXRlIHNlZ21lbnRcblxuICAgIHZhciBvcnRob2dvbmFsVmVydGljZXMgPSBbXTsgLy8gdGhlIGFycmF5IG9mIGZvdW5kIG9ydGhvZ29uYWwgdmVydGljZXMgdG8gYmUgcmV0dXJuZWRcbiAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gdmVydGljZXMubGVuZ3RoIC0gMTsgaSA8IG1heDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIHJvdXRlID0gbnVsbDtcblxuICAgICAgICB2YXIgZnJvbSA9IHZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgdG8gPSB2ZXJ0aWNlc1tpICsgMV07XG5cbiAgICAgICAgdmFyIGlzT3J0aG9nb25hbCA9ICEhZ2V0QmVhcmluZyhmcm9tLCB0byk7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHsgLy8gc291cmNlXG5cbiAgICAgICAgICAgIGlmIChpICsgMSA9PT0gbWF4KSB7IC8vIHJvdXRlIHNvdXJjZSAtPiB0YXJnZXRcblxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBvbmUgb2YgdGhlIGVsZW1lbnRzIGJ5IDFweCB0byBkZXRlY3Qgc2l0dWF0aW9ucyB3aGVuIHRoZSB0d29cbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyBhcmUgcG9zaXRpb25lZCBuZXh0IHRvIGVhY2ggb3RoZXIgd2l0aCBubyBnYXAgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlQkJveC5pbnRlcnNlY3QodGFyZ2V0QkJveC5jbG9uZSgpLmluZmxhdGUoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gaW5zaWRlRWxlbWVudChmcm9tLCB0bywgc291cmNlQkJveCwgdGFyZ2V0QkJveCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09ydGhvZ29uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBlbGVtZW50RWxlbWVudChmcm9tLCB0bywgc291cmNlQkJveCwgdGFyZ2V0QkJveCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByb3V0ZSBzb3VyY2UgLT4gdmVydGV4XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlQkJveC5jb250YWluc1BvaW50KHRvKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IGluc2lkZUVsZW1lbnQoZnJvbSwgdG8sIHNvdXJjZUJCb3gsIGdldFBvaW50Qm94KHRvKS5tb3ZlQW5kRXhwYW5kKGdldFBhZGRpbmdCb3gob3B0KSkpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNPcnRob2dvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gZWxlbWVudFZlcnRleChmcm9tLCB0bywgc291cmNlQkJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IG1heCkgeyAvLyByb3V0ZSB2ZXJ0ZXggLT4gdGFyZ2V0XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgb3ZlcmxhcHMgd2l0aCBwcmV2aW91cyBsaW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBpc09ydGhvZ29uYWxMb29wID0gaXNPcnRob2dvbmFsICYmIGdldEJlYXJpbmcodG8sIGZyb20pID09PSBiZWFyaW5nO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QkJveC5jb250YWluc1BvaW50KGZyb20pIHx8IGlzT3J0aG9nb25hbExvb3ApIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGluc2lkZUVsZW1lbnQoZnJvbSwgdG8sIGdldFBvaW50Qm94KGZyb20pLm1vdmVBbmRFeHBhbmQoZ2V0UGFkZGluZ0JveChvcHQpKSwgdGFyZ2V0QkJveCwgYmVhcmluZyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT3J0aG9nb25hbCkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gdmVydGV4RWxlbWVudChmcm9tLCB0bywgdGFyZ2V0QkJveCwgYmVhcmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICghaXNPcnRob2dvbmFsKSB7IC8vIHJvdXRlIHZlcnRleCAtPiB2ZXJ0ZXhcbiAgICAgICAgICAgIHJvdXRlID0gdmVydGV4VmVydGV4KGZyb20sIHRvLCBiZWFyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGxpY2FibGUgdG8gYWxsIHJvdXRlczpcblxuICAgICAgICAvLyBzZXQgYmVhcmluZyBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvcnRob2dvbmFsVmVydGljZXMsIHJvdXRlLnBvaW50cyk7XG4gICAgICAgICAgICBiZWFyaW5nID0gcm91dGUuZGlyZWN0aW9uO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvcnRob2dvbmFsIHJvdXRlIGFuZCBub3QgbG9vcGVkXG4gICAgICAgICAgICBiZWFyaW5nID0gZ2V0QmVhcmluZyhmcm9tLCB0byk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIGB0b2AgcG9pbnQgdG8gaWRlbnRpZmllZCBvcnRob2dvbmFsIHZlcnRpY2VzIGFycmF5XG4gICAgICAgIGlmIChpICsgMSA8IG1heCkge1xuICAgICAgICAgICAgb3J0aG9nb25hbFZlcnRpY2VzLnB1c2godG8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ydGhvZ29uYWxWZXJ0aWNlcztcbn1cbiJdLCJuYW1lcyI6WyJnIiwidXRpbCIsIm9wcG9zaXRlcyIsIk4iLCJTIiwiRSIsIlciLCJyYWRpYW5zIiwiTWF0aCIsIlBJIiwiZnJlZUpvaW4iLCJwMSIsInAyIiwiYmJveCIsInAiLCJQb2ludCIsIngiLCJ5IiwiY29udGFpbnNQb2ludCIsImdldEJCb3hTaXplIiwiYmVhcmluZyIsImdldEJlYXJpbmciLCJmcm9tIiwidG8iLCJnZXRQb2ludEJveCIsIlJlY3QiLCJnZXRQYWRkaW5nQm94Iiwib3B0Iiwic2lkZXMiLCJub3JtYWxpemVTaWRlcyIsInBhZGRpbmciLCJlbGVtZW50UGFkZGluZyIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsInJpZ2h0IiwiaGVpZ2h0IiwiYm90dG9tIiwiZ2V0U291cmNlQkJveCIsImxpbmtWaWV3Iiwic291cmNlQkJveCIsImNsb25lIiwibW92ZUFuZEV4cGFuZCIsImdldFRhcmdldEJCb3giLCJ0YXJnZXRCQm94IiwiZ2V0U291cmNlQW5jaG9yIiwic291cmNlQW5jaG9yIiwiY2VudGVyIiwiZ2V0VGFyZ2V0QW5jaG9yIiwidGFyZ2V0QW5jaG9yIiwidmVydGV4VmVydGV4IiwiZDEiLCJkMiIsIm9wcG9zaXRlIiwicG9pbnRzIiwiZGlyZWN0aW9uIiwiZWxlbWVudFZlcnRleCIsImZyb21CQm94IiwidmVydGV4RWxlbWVudCIsInRvQkJveCIsInJvdXRlIiwiZnJlZVBvaW50cyIsImZpbHRlciIsInB0IiwiZnJlZUJlYXJpbmdQb2ludHMiLCJsZW5ndGgiLCJwb3AiLCJkaWZmZXJlbmNlIiwibW92ZSIsImVsZW1lbnRFbGVtZW50IiwiZnJvbUJvcmRlciIsInRvQm9yZGVyIiwibWlkIiwiTGluZSIsIm1pZHBvaW50Iiwic3RhcnRSb3V0ZSIsImVuZFJvdXRlIiwiaW5zaWRlRWxlbWVudCIsImJvdW5kYXJ5IiwidW5pb24iLCJpbmZsYXRlIiwicmV2ZXJzZWQiLCJkaXN0YW5jZSIsInN0YXJ0IiwiZW5kIiwicDMiLCJmcm9tUG9sYXIiLCJwb2ludE5lYXJlc3RUb1BvaW50Iiwicm91bmQiLCJlcXVhbHMiLCJ0b1JhZCIsInRoZXRhIiwib3J0aG9nb25hbCIsInZlcnRpY2VzIiwidG9BcnJheSIsIm1hcCIsInVuc2hpZnQiLCJwdXNoIiwib3J0aG9nb25hbFZlcnRpY2VzIiwiaSIsIm1heCIsImlzT3J0aG9nb25hbCIsImludGVyc2VjdCIsImlzT3J0aG9nb25hbExvb3AiLCJBcnJheSIsInByb3RvdHlwZSIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/orthogonal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/routers/rightAngle.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/jointjs/src/routers/rightAngle.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rightAngle: () => (/* binding */ rightAngle)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/geometry.helpers.mjs\");\n\nconst Directions = {\n    AUTO: \"auto\",\n    LEFT: \"left\",\n    RIGHT: \"right\",\n    TOP: \"top\",\n    BOTTOM: \"bottom\",\n    ANCHOR_SIDE: \"anchor-side\",\n    MAGNET_SIDE: \"magnet-side\"\n};\nconst DEFINED_DIRECTIONS = [\n    Directions.LEFT,\n    Directions.RIGHT,\n    Directions.TOP,\n    Directions.BOTTOM\n];\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\nconst VERTICAL_DIRECTIONS = [\n    Directions.TOP,\n    Directions.BOTTOM\n];\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points).simplify({\n        threshold: 1\n    }).points;\n}\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n    let sourceSide;\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n    let targetSide;\n    if (!targetView) {\n        const targetLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n    return [\n        sourceSide,\n        targetSide\n    ];\n}\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) return Directions.RIGHT;\n    if (tx > ax && ty < smy0) return Directions.LEFT;\n    if (tx < smx0 && ty >= sy0) return Directions.TOP;\n    if (tx > smx1 && ty >= sy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    return Directions.TOP;\n}\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) return Directions.RIGHT;\n    if (tx > ax && ty > smy1) return Directions.LEFT;\n    if (tx < smx0 && ty <= sy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty <= sy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    return Directions.BOTTOM;\n}\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= sx0 && ty <= smy0) return Directions.LEFT;\n    if (tx >= sx0 && ty >= smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n        return Directions.TOP;\n    }\n    return Directions.LEFT;\n}\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= sx1 && ty <= smy0) return Directions.RIGHT;\n    if (tx <= sx1 && ty >= smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n        return Directions.TOP;\n    }\n    return Directions.RIGHT;\n}\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n    switch(sourceSide){\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n    switch(roundedAngle){\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n    const isElement = view && view.model.isElement();\n    const { x: x0, y: y0, width = 0, height = 0 } = isElement ? _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\nfunction pointDataFromVertex({ x, y }) {\n    const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x, y);\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n    const { x0, y0, width, height } = pointData;\n    switch(side){\n        case \"left\":\n            outsidePoint.x = x0 - margin;\n            break;\n        case \"right\":\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case \"top\":\n            outsidePoint.y = y0 - margin;\n            break;\n        case \"bottom\":\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n    return outsidePoint;\n}\nfunction routeBetweenPoints(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n    const isSourceEl = sourceView && sourceView.model.isElement();\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n    const [sourceSide, targetSide] = resolveSides(source, target);\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, {\n        point: sourcePoint,\n        x0: sx0,\n        y0: sy0,\n        width: sourceWidth,\n        height: sourceHeight\n    }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, {\n        point: targetPoint,\n        x0: tx0,\n        y0: ty0,\n        width: targetWidth,\n        height: targetHeight\n    }, targetMargin);\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n    if (sourceSide === \"left\" && targetSide === \"right\") {\n        if (smx0 <= tmx1) {\n            let y = middleOfHorizontalSides;\n            if (sx1 <= tx0) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        const x = (sox + tox) / 2;\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"right\" && targetSide === \"left\") {\n        if (smx1 >= tmx0) {\n            let y = middleOfHorizontalSides;\n            if (sox > tx1) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        const x = (sox + tox) / 2;\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"top\" && targetSide === \"bottom\") {\n        if (soy < toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n            if (soy < ty0) {\n                if (tx1 >= smx0 && tox < sox) {\n                    x = Math.min(tmx0, smx0);\n                } else if (tx0 <= smx1 && tox >= sox) {\n                    x = Math.max(tmx1, smx1);\n                }\n            }\n            return [\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x,\n                    y\n                },\n                {\n                    x,\n                    y: toy\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            {\n                x: sox,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    } else if (sourceSide === \"bottom\" && targetSide === \"top\") {\n        if (soy - sourceMargin > toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n            if (soy > ty1) {\n                if (tx1 >= smx0 && tox < sox) {\n                    x = Math.min(tmx0, smx0);\n                } else if (tx0 <= smx1 && tox >= sox) {\n                    x = Math.max(tmx1, smx1);\n                }\n            }\n            return [\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x,\n                    y\n                },\n                {\n                    x,\n                    y: toy\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            {\n                x: sox,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    } else if (sourceSide === \"top\" && targetSide === \"top\") {\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n        if (toy < soy) {\n            if (sox >= tmx1 || sox <= tmx0) {\n                return [\n                    {\n                        x: sox,\n                        y: Math.min(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.min(soy, toy)\n                    }\n                ];\n            } else if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= smx1 || tox <= smx0) {\n                return [\n                    {\n                        x: sox,\n                        y: Math.min(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.min(soy, toy)\n                    }\n                ];\n            } else if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n        return [\n            {\n                x: sox,\n                y: y2\n            },\n            {\n                x,\n                y: y2\n            },\n            {\n                x,\n                y: y1\n            },\n            {\n                x: tox,\n                y: y1\n            }\n        ];\n    } else if (sourceSide === \"bottom\" && targetSide === \"bottom\") {\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n        if (toy > soy) {\n            if (sox >= tmx1 || sox <= tmx0) {\n                return [\n                    {\n                        x: sox,\n                        y: Math.max(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.max(soy, toy)\n                    }\n                ];\n            } else if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= smx1 || tox <= smx0) {\n                return [\n                    {\n                        x: sox,\n                        y: Math.max(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.max(soy, toy)\n                    }\n                ];\n            } else if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n        return [\n            {\n                x: sox,\n                y: y2\n            },\n            {\n                x,\n                y: y2\n            },\n            {\n                x,\n                y: y1\n            },\n            {\n                x: tox,\n                y: y1\n            }\n        ];\n    } else if (sourceSide === \"left\" && targetSide === \"left\") {\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n        if (tox > sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n        return [\n            {\n                x: x2,\n                y: soy\n            },\n            {\n                x: x2,\n                y\n            },\n            {\n                x: x1,\n                y\n            },\n            {\n                x: x1,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"right\" && targetSide === \"right\") {\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n        if (tox < sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n        return [\n            {\n                x: x2,\n                y: soy\n            },\n            {\n                x: x2,\n                y\n            },\n            {\n                x: x1,\n                y\n            },\n            {\n                x: x1,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"top\" && targetSide === \"right\") {\n        if (soy > toy) {\n            if (sox < tox) {\n                let y = middleOfHorizontalSides;\n                if ((y > tcy || !isSourceEl) && y < tmy1 && sox < tx0) {\n                    y = tmy0;\n                }\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: toy\n                }\n            ];\n        }\n        const x = Math.max(middleOfVerticalSides, tmx1);\n        if (tox < sox && toy > sy0 && toy < sy1) {\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x,\n                    y: soy\n                },\n                {\n                    x: x,\n                    y: toy\n                }\n            ];\n        }\n        if (x > smx0 && toy > sy0 || tx0 > sx1) {\n            const y = Math.min(sy0 - sourceMargin, ty0 - targetMargin);\n            const x = Math.max(sx1 + sourceMargin, tx1 + targetMargin);\n            return [\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x,\n                    y\n                },\n                {\n                    x,\n                    y: toy\n                }\n            ];\n        }\n        return [\n            {\n                x: sox,\n                y: soy\n            },\n            {\n                x: Math.max(x, tox),\n                y: soy\n            },\n            {\n                x: Math.max(x, tox),\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"top\" && targetSide === \"left\") {\n        if (soy > toy) {\n            if (sox > tox) {\n                let y = middleOfHorizontalSides;\n                if ((y > tcy || !isSourceEl) && y < tmy1 && sox > tx1) {\n                    y = tmy0;\n                }\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: toy\n                }\n            ];\n        }\n        const x = Math.min(tmx0, middleOfVerticalSides);\n        if (sox < tox && sy1 >= toy) {\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x,\n                    y: soy\n                },\n                {\n                    x,\n                    y: toy\n                }\n            ];\n        }\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x,\n                    y\n                },\n                {\n                    x,\n                    y: toy\n                }\n            ];\n        }\n        return [\n            {\n                x: sox,\n                y: soy\n            },\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"bottom\" && targetSide === \"right\") {\n        if (soy < toy) {\n            if (sox < tox) {\n                let y = middleOfHorizontalSides;\n                if ((y < tcy || !isSourceEl) && y > tmy0 && sox < tx0) {\n                    y = tmy1;\n                }\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: toy\n                }\n            ];\n        } else {\n            if (sx0 < tox) {\n                const y = Math.max(smy1, tmy1);\n                const x = Math.max(smx1, tmx1);\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x,\n                        y\n                    },\n                    {\n                        x,\n                        y: toy\n                    }\n                ];\n            }\n        }\n        const x = middleOfVerticalSides;\n        return [\n            {\n                x: sox,\n                y: soy\n            },\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"bottom\" && targetSide === \"left\") {\n        if (soy < toy) {\n            if (sox > tox) {\n                let y = middleOfHorizontalSides;\n                if ((y < tcy || !isSourceEl) && y > tmy0 && sox > tx1) {\n                    y = tmy1;\n                }\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: toy\n                }\n            ];\n        } else {\n            if (sx1 > tox) {\n                const y = Math.max(smy1, tmy1);\n                const x = Math.min(smx0, tmx0);\n                return [\n                    {\n                        x: sox,\n                        y\n                    },\n                    {\n                        x,\n                        y\n                    },\n                    {\n                        x,\n                        y: toy\n                    }\n                ];\n            }\n        }\n        const x = middleOfVerticalSides;\n        return [\n            {\n                x: sox,\n                y: soy\n            },\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y: toy\n            }\n        ];\n    } else if (sourceSide === \"left\" && targetSide === \"bottom\") {\n        if (sox >= tox && soy >= tmy1) {\n            return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n        }\n        if (sox >= tx1 && soy < toy) {\n            const x = middleOfVerticalSides;\n            return [\n                {\n                    x,\n                    y: soy\n                },\n                {\n                    x,\n                    y: toy\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        if (tox < sx1 && ty1 <= sy0) {\n            const y = middleOfHorizontalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                }\n            ];\n        }\n        const x = Math.min(tmx0, sox);\n        const y = Math.max(smy1, tmy1);\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    } else if (sourceSide === \"left\" && targetSide === \"top\") {\n        if (sox > tox && soy < tmy0) {\n            return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n        }\n        if (sox >= tx1) {\n            if (soy > toy) {\n                const x = middleOfVerticalSides;\n                return [\n                    {\n                        x,\n                        y: soy\n                    },\n                    {\n                        x,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n        }\n        if (tox <= sx1 && toy > soy) {\n            const y = middleOfHorizontalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                }\n            ];\n        }\n        const x = toy < soy ? Math.min(smx0, tmx0) : smx0;\n        const y = Math.min(smy0, tmy0);\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    } else if (sourceSide === \"right\" && targetSide === \"top\") {\n        if (sox <= tox && soy < tmy0) {\n            return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n        }\n        if (sx1 < tx0 && soy > toy) {\n            let x = middleOfVerticalSides;\n            return [\n                {\n                    x,\n                    y: soy\n                },\n                {\n                    x,\n                    y: toy\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        if (tox < sox && ty0 > sy1) {\n            const y = middleOfHorizontalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                }\n            ];\n        }\n        const x = Math.max(smx1, tmx1);\n        const y = Math.min(smy0, tmy0);\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    } else if (sourceSide === \"right\" && targetSide === \"bottom\") {\n        if (sox <= tox && soy >= tmy1) {\n            return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n        }\n        if (sox <= tmx0 && soy < toy) {\n            const x = middleOfVerticalSides;\n            return [\n                {\n                    x,\n                    y: soy\n                },\n                {\n                    x,\n                    y: toy\n                },\n                {\n                    x: tox,\n                    y: toy\n                }\n            ];\n        }\n        if (tox > sx0 && ty1 < sy0) {\n            const y = middleOfHorizontalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: sox,\n                    y\n                },\n                {\n                    x: tox,\n                    y\n                }\n            ];\n        }\n        const x = Math.max(tmx1, sox);\n        const y = Math.max(smy1, tmy1);\n        return [\n            {\n                x,\n                y: soy\n            },\n            {\n                x,\n                y\n            },\n            {\n                x: tox,\n                y\n            }\n        ];\n    }\n}\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n    let resultVertices = [];\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n    const verticesData = vertices.map((v)=>pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n    if (sourcePoint.view && sourcePoint.view.model.isElement() && sourcePoint.view.model.getBBox().inflate(margin).containsPoint(firstVertex.point)) {\n        const [fromDirection] = resolveSides(sourcePoint, firstVertex);\n        const toDirection = fromDirection;\n        const dummySource = pointDataFromVertex(sourcePoint.point);\n        // Points do not usually have margin. Here we create a point with a margin.\n        dummySource.margin = margin;\n        dummySource.direction = fromDirection;\n        firstVertex.direction = toDirection;\n        resultVertices.push(...routeBetweenPoints(dummySource, firstVertex), firstVertex.point);\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n    for(let i = 0; i < verticesData.length - 1; i++){\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n        const segment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(from.point, to.point);\n        const segmentAngle = getSegmentAngle(segment);\n        if (segmentAngle % 90 === 0) {\n            // Since the segment is horizontal or vertical, we can skip the routing and just connect them with a straight line\n            const toDirection = ANGLE_DIRECTION_MAP[segmentAngle];\n            const accessDirection = OPPOSITE_DIRECTIONS[toDirection];\n            if (toDirection !== from.direction) {\n                resultVertices.push(from.point, to.point);\n                to.direction = accessDirection;\n            } else {\n                const angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle(segmentAngle - 90);\n                let dx = 0;\n                let dy = 0;\n                if (angle === 90) {\n                    dy = -margin;\n                } else if (angle === 180) {\n                    dx = -margin;\n                } else if (angle === 270) {\n                    dy = margin;\n                } else if (angle === 0) {\n                    dx = margin;\n                }\n                const p1 = {\n                    x: from.point.x + dx,\n                    y: from.point.y + dy\n                };\n                const p2 = {\n                    x: to.point.x + dx,\n                    y: to.point.y + dy\n                };\n                const segment2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(to.point, p2);\n                to.direction = ANGLE_DIRECTION_MAP[getSegmentAngle(segment2)];\n                // Constructing a loop\n                resultVertices.push(from.point, p1, p2, to.point);\n            }\n            continue;\n        }\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n        from.direction = fromDirection;\n        to.direction = toDirection;\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n    const lastVertex = verticesData[verticesData.length - 1];\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        if (targetPoint.view.model.getBBox().inflate(margin).containsPoint(lastVertex.point)) {\n            const [fromDirection] = resolveDirection(lastVertex, targetPoint);\n            const dummyTarget = pointDataFromVertex(targetPoint.point);\n            const [, toDirection] = resolveSides(lastVertex, targetPoint);\n            // we are creating a point that has a margin\n            dummyTarget.margin = margin;\n            dummyTarget.direction = toDirection;\n            lastVertex.direction = fromDirection;\n            resultVertices.push(...routeBetweenPoints(lastVertex, dummyTarget));\n        } else {\n            // the last point of `simplified` array is the last defined vertex\n            // grab the penultimate point and construct a line segment from it to the last vertex\n            // this will ensure that the last segment continues in a straight line\n            const simplified = simplifyPoints(resultVertices);\n            const segment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(simplified[simplified.length - 2], lastVertex.point);\n            const definedDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(segment))];\n            lastVertex.direction = definedDirection;\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([\n                ...lastSegmentRoute,\n                targetPoint.point\n            ]);\n            const lastSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n            if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const [vertexDirection] = resolveDirection(lastVertex, targetPoint);\n        lastVertex.direction = vertexDirection;\n        resultVertices.push(...routeBetweenPoints(lastVertex, targetPoint));\n    }\n    return simplifyPoints(resultVertices);\n}\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n    return [\n        sourceDirection,\n        targetDirection\n    ];\n}\nrightAngleRouter.Directions = Directions;\nconst rightAngle = rightAngleRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvcm91dGVycy9yaWdodEFuZ2xlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFFcEMsTUFBTUMsYUFBYTtJQUNmQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxhQUFhO0FBQ2pCO0FBRUEsTUFBTUMscUJBQXFCO0lBQUNSLFdBQVdFLElBQUk7SUFBRUYsV0FBV0csS0FBSztJQUFFSCxXQUFXSSxHQUFHO0lBQUVKLFdBQVdLLE1BQU07Q0FBQztBQUVqRyxNQUFNSSxzQkFBc0I7SUFDeEIsQ0FBQ1QsV0FBV0UsSUFBSSxDQUFDLEVBQUVGLFdBQVdHLEtBQUs7SUFDbkMsQ0FBQ0gsV0FBV0csS0FBSyxDQUFDLEVBQUVILFdBQVdFLElBQUk7SUFDbkMsQ0FBQ0YsV0FBV0ksR0FBRyxDQUFDLEVBQUVKLFdBQVdLLE1BQU07SUFDbkMsQ0FBQ0wsV0FBV0ssTUFBTSxDQUFDLEVBQUVMLFdBQVdJLEdBQUc7QUFDdkM7QUFFQSxNQUFNTSxzQkFBc0I7SUFBQ1YsV0FBV0ksR0FBRztJQUFFSixXQUFXSyxNQUFNO0NBQUM7QUFFL0QsTUFBTU0sc0JBQXNCO0lBQ3hCLEdBQUdYLFdBQVdHLEtBQUs7SUFDbkIsS0FBS0gsV0FBV0UsSUFBSTtJQUNwQixLQUFLRixXQUFXSSxHQUFHO0lBQ25CLElBQUlKLFdBQVdLLE1BQU07QUFDekI7QUFFQSxTQUFTTyxnQkFBZ0JDLElBQUk7SUFDekIsNkZBQTZGO0lBQzdGLE9BQU9BLEtBQUtDLEtBQUs7QUFDckI7QUFFQSxTQUFTQyxlQUFlQyxNQUFNO0lBQzFCLDRGQUE0RjtJQUM1RixrSEFBa0g7SUFDbEgsT0FBTyxJQUFJakIsa0RBQVUsQ0FBQ2lCLFFBQVFFLFFBQVEsQ0FBQztRQUFFQyxXQUFXO0lBQUUsR0FBR0gsTUFBTTtBQUNuRTtBQUVBLFNBQVNJLGFBQWFDLE1BQU0sRUFBRUMsTUFB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QUFJNEosS0FBSyxHQUFHO2dCQUNmdEgsa0JBQWtCc0ksV0FBVzlLLFdBQVdLLE1BQU0sR0FBR0wsV0FBV0UsSUFBSTtZQUNwRTtRQUNKLE9BQU87WUFDSGdDLGtCQUFrQjRJLFdBQVdoQixNQUFNLElBQUk5SixXQUFXSyxNQUFNLEdBQUdMLFdBQVdJLEdBQUcsR0FBR0ssbUJBQW1CLENBQUNrSixnQkFBZ0I7WUFFaEgsSUFBSUcsS0FBSyxHQUFHO2dCQUNSdEgsa0JBQWtCc0ksV0FBVzlLLFdBQVdHLEtBQUssR0FBR0gsV0FBV0ksR0FBRztZQUNsRSxPQUFPLElBQUkwSixLQUFLLEdBQUc7Z0JBQ2Z0SCxrQkFBa0JzSSxXQUFXOUssV0FBV0csS0FBSyxHQUFHSCxXQUFXSyxNQUFNO1lBQ3JFO1FBQ0o7SUFDSjtJQUVBLE9BQU87UUFBQzZCO1FBQWlCTTtLQUFnQjtBQUM3QztBQUVBdUYsaUJBQWlCL0gsVUFBVSxHQUFHQTtBQUV2QixNQUFNK0ssYUFBYWhELGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL3JvdXRlcnMvcmlnaHRBbmdsZS5tanM/NGQzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgRGlyZWN0aW9ucyA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIFRPUDogJ3RvcCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBBTkNIT1JfU0lERTogJ2FuY2hvci1zaWRlJyxcbiAgICBNQUdORVRfU0lERTogJ21hZ25ldC1zaWRlJ1xufTtcblxuY29uc3QgREVGSU5FRF9ESVJFQ1RJT05TID0gW0RpcmVjdGlvbnMuTEVGVCwgRGlyZWN0aW9ucy5SSUdIVCwgRGlyZWN0aW9ucy5UT1AsIERpcmVjdGlvbnMuQk9UVE9NXTtcblxuY29uc3QgT1BQT1NJVEVfRElSRUNUSU9OUyA9IHtcbiAgICBbRGlyZWN0aW9ucy5MRUZUXTogRGlyZWN0aW9ucy5SSUdIVCxcbiAgICBbRGlyZWN0aW9ucy5SSUdIVF06IERpcmVjdGlvbnMuTEVGVCxcbiAgICBbRGlyZWN0aW9ucy5UT1BdOiBEaXJlY3Rpb25zLkJPVFRPTSxcbiAgICBbRGlyZWN0aW9ucy5CT1RUT01dOiBEaXJlY3Rpb25zLlRPUFxufTtcblxuY29uc3QgVkVSVElDQUxfRElSRUNUSU9OUyA9IFtEaXJlY3Rpb25zLlRPUCwgRGlyZWN0aW9ucy5CT1RUT01dO1xuXG5jb25zdCBBTkdMRV9ESVJFQ1RJT05fTUFQID0ge1xuICAgIDA6IERpcmVjdGlvbnMuUklHSFQsXG4gICAgMTgwOiBEaXJlY3Rpb25zLkxFRlQsXG4gICAgMjcwOiBEaXJlY3Rpb25zLlRPUCxcbiAgICA5MDogRGlyZWN0aW9ucy5CT1RUT01cbn07XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnRBbmdsZShsaW5lKSB7XG4gICAgLy8gVE9ETzogdGhlIGFuZ2xlKCkgbWV0aG9kIGlzIGdlbmVyYWwgYW5kIHRoZXJlZm9yZSB1bm5lY2Vzc2FyaWx5IGhlYXZ5IGZvciBvcnRob2dvbmFsIGxpbmtzXG4gICAgcmV0dXJuIGxpbmUuYW5nbGUoKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlQb2ludHMocG9pbnRzKSB7XG4gICAgLy8gVE9ETzogdXNlIG93biBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiAoZmlsdGVyIHBvaW50cyB0aGF0IGRvIG5vdCBjaGFuZ2UgZGlyZWN0aW9uKS5cbiAgICAvLyBUbyBzaW1wbGlmeSBzZWdtZW50cyB0aGF0IGFyZSBhbG1vc3QgYWxpZ25lZCAoc3RhcnQgYW5kIGVuZCBwb2ludHMgZGlmZmVyIGJ5IGUuZy4gMC41cHgpLCB1c2UgYSB0aHJlc2hvbGQgb2YgMS5cbiAgICByZXR1cm4gbmV3IGcuUG9seWxpbmUocG9pbnRzKS5zaW1wbGlmeSh7IHRocmVzaG9sZDogMSB9KS5wb2ludHM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTaWRlcyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGNvbnN0IHsgcG9pbnQ6IHNvdXJjZVBvaW50LCB4MDogc3gwLCB5MDogc3kwLCB2aWV3OiBzb3VyY2VWaWV3LCBiYm94OiBzb3VyY2VCQm94LCBkaXJlY3Rpb246IHNvdXJjZURpcmVjdGlvbiB9ID0gc291cmNlO1xuICAgIGNvbnN0IHsgcG9pbnQ6IHRhcmdldFBvaW50LCB4MDogdHgwLCB5MDogdHkwLCB2aWV3OiB0YXJnZXRWaWV3LCBiYm94OiB0YXJnZXRCQm94LCBkaXJlY3Rpb246IHRhcmdldERpcmVjdGlvbiB9ID0gdGFyZ2V0O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG5cbiAgICBpZiAoIXNvdXJjZVZpZXcpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGlua0FuY2hvckJCb3ggPSBuZXcgZy5SZWN0KHN4MCwgc3kwLCAwLCAwKTtcbiAgICAgICAgc291cmNlU2lkZSA9IERFRklORURfRElSRUNUSU9OUy5pbmNsdWRlcyhzb3VyY2VEaXJlY3Rpb24pID8gc291cmNlRGlyZWN0aW9uIDogc291cmNlTGlua0FuY2hvckJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVZpZXcubW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgc291cmNlU2lkZSA9IGdldERpcmVjdGlvbkZvckxpbmtDb25uZWN0aW9uKHRhcmdldFBvaW50LCBzb3VyY2VQb2ludCwgc291cmNlVmlldyk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuQU5DSE9SX1NJREUpIHtcbiAgICAgICAgc291cmNlU2lkZSA9IHNvdXJjZUJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5NQUdORVRfU0lERSkge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlVmlldy5tb2RlbC5nZXRCQm94KCkuc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlRGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXRTaWRlO1xuXG4gICAgaWYgKCF0YXJnZXRWaWV3KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldExpbmtBbmNob3JCQm94ID0gbmV3IGcuUmVjdCh0eDAsIHR5MCwgMCwgMCk7XG4gICAgICAgIHRhcmdldFNpZGUgPSBERUZJTkVEX0RJUkVDVElPTlMuaW5jbHVkZXModGFyZ2V0RGlyZWN0aW9uKSA/IHRhcmdldERpcmVjdGlvbiA6IHRhcmdldExpbmtBbmNob3JCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRWaWV3Lm1vZGVsLmlzTGluaygpKSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSBnZXREaXJlY3Rpb25Gb3JMaW5rQ29ubmVjdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHRhcmdldFZpZXcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0RGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkFOQ0hPUl9TSURFKSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXREaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTUFHTkVUX1NJREUpIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldFZpZXcubW9kZWwuZ2V0QkJveCgpLnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldERpcmVjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZVNpZGUsIHRhcmdldFNpZGVdO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9yVG9wU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBtYXJnaW47XG4gICAgY29uc3Qgc214MSA9IHN4MSArIG1hcmdpbjtcbiAgICBjb25zdCBzbXkwID0gc3kwIC0gbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCB9ID0gYW5jaG9yO1xuICAgIGNvbnN0IHsgeDA6IHR4LCB5MDogdHkgfSA9IHRhcmdldDtcblxuICAgIGlmICh0eCA9PT0gYXggJiYgdHkgPCBzeTApIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPCBheCAmJiB0eSA8IHNteTApIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIGlmICh0eCA+IGF4ICYmIHR5IDwgc215MCkgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICBpZiAodHggPCBzbXgwICYmIHR5ID49IHN5MCkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIGlmICh0eCA+IHNteDEgJiYgdHkgPj0gc3kwKSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4ID49IHNteDAgJiYgdHggPD0gYXggJiYgdHkgPiBzeTEpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueCA8IHR4KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuICAgIGlmICh0eCA8PSBzbXgxICYmIHR4ID49IGF4ICYmIHR5ID4gc3kxKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPCB0eCkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cblxuICAgIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZvckJvdHRvbVNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpIHtcbiAgICBjb25zdCB7IHgwOiBzeDAsIHkwOiBzeTAsIHdpZHRoLCBoZWlnaHQsIHBvaW50OiBhbmNob3IsIG1hcmdpbiB9ID0gc291cmNlO1xuICAgIGNvbnN0IHN4MSA9IHN4MCArIHdpZHRoO1xuICAgIGNvbnN0IHN5MSA9IHN5MCArIGhlaWdodDtcbiAgICBjb25zdCBzbXgwID0gc3gwIC0gbWFyZ2luO1xuICAgIGNvbnN0IHNteDEgPSBzeDEgKyBtYXJnaW47XG4gICAgY29uc3Qgc215MSA9IHN5MSArIG1hcmdpbjtcblxuICAgIGNvbnN0IHsgeDogYXggfSA9IGFuY2hvcjtcbiAgICBjb25zdCB7IHgwOiB0eCwgeTA6IHR5IH0gPSB0YXJnZXQ7XG5cbiAgICBpZiAodHggPT09IGF4ICYmIHR5ID4gc3kxKSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4IDwgYXggJiYgdHkgPiBzbXkxKSByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICBpZiAodHggPiBheCAmJiB0eSA+IHNteTEpIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgaWYgKHR4IDwgc214MCAmJiB0eSA8PSBzeTEpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPiBzbXgxICYmIHR5IDw9IHN5MSkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIGlmICh0eCA+PSBzbXgwICYmIHR4IDw9IGF4ICYmIHR5IDwgc3kwKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPCB0eCkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cbiAgICBpZiAodHggPD0gc214MSAmJiB0eCA+PSBheCAmJiB0eSA8IHN5MCkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54IDwgdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICB9XG5cbiAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb3JMZWZ0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeTA6IHN5MCwgeDA6IHN4MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBtYXJnaW47XG4gICAgY29uc3Qgc215MCA9IHN5MCAtIG1hcmdpbjtcbiAgICBjb25zdCBzbXkxID0gc3kxICsgbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCwgeTogYXkgfSA9IGFuY2hvcjtcbiAgICBjb25zdCB7IHgwOiB0eCwgeTA6IHR5IH0gPSB0YXJnZXQ7XG5cbiAgICBpZiAodHggPCBheCAmJiB0eSA9PT0gYXkpIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIGlmICh0eCA8PSBzbXgwICYmIHR5IDwgYXkpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPD0gc214MCAmJiB0eSA+IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4ID49IHN4MCAmJiB0eSA8PSBzbXkwKSByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIGlmICh0eCA+PSBzeDAgJiYgdHkgPj0gc215MSkgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICBpZiAodHggPiBzeDEgJiYgdHkgPj0gc215MCAmJiB0eSA8PSBheSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC55IDwgdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICB9XG4gICAgaWYgKHR4ID4gc3gxICYmIHR5IDw9IHNteTEgJiYgdHkgPj0gYXkpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueSA8IHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZvclJpZ2h0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeTA6IHN5MCwgeDA6IHN4MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDEgPSBzeDEgKyBtYXJnaW47XG4gICAgY29uc3Qgc215MCA9IHN5MCAtIG1hcmdpbjtcbiAgICBjb25zdCBzbXkxID0gc3kxICsgbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCwgeTogYXkgfSA9IGFuY2hvcjtcbiAgICBjb25zdCB7IHgwOiB0eCwgeTA6IHR5IH0gPSB0YXJnZXQ7XG5cbiAgICBpZiAodHggPiBheCAmJiB0eSA9PT0gYXkpIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgaWYgKHR4ID49IHNteDEgJiYgdHkgPCBheSkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIGlmICh0eCA+PSBzbXgxICYmIHR5ID4gYXkpIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICBpZiAodHggPD0gc3gxICYmIHR5IDw9IHNteTApIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIGlmICh0eCA8PSBzeDEgJiYgdHkgPj0gc215MSkgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgaWYgKHR4IDwgc3gwICYmIHR5ID49IHNteTAgJiYgdHkgPD0gYXkpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueSA8IHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgfVxuICAgIGlmICh0eCA8IHN4MCAmJiB0eSA8PSBzbXkxICYmIHR5ID49IGF5KSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnkgPCB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIH1cblxuICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5pdGlhbERpcmVjdGlvbihzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IFtzb3VyY2VTaWRlXSA9IHJlc29sdmVTaWRlcyhzb3VyY2UsIHRhcmdldCk7XG5cbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlRPUDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yVG9wU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yUmlnaHRTb3VyY2VTaWRlKHNvdXJjZSwgdGFyZ2V0LCBuZXh0SW5MaW5lKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkJPVFRPTTpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yQm90dG9tU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVGb3JMZWZ0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25Gb3JMaW5rQ29ubmVjdGlvbihsaW5rT3JpZ2luLCBjb25uZWN0aW9uUG9pbnQsIGxpbmtWaWV3KSB7XG4gICAgY29uc3QgdGFuZ2VudCA9IGxpbmtWaWV3LmdldFRhbmdlbnRBdExlbmd0aChsaW5rVmlldy5nZXRDbG9zZXN0UG9pbnRMZW5ndGgoY29ubmVjdGlvblBvaW50KSk7XG4gICAgY29uc3Qgcm91bmRlZEFuZ2xlID0gTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUodGFuZ2VudCkgLyA5MCkgKiA5MDtcblxuICAgIGlmIChyb3VuZGVkQW5nbGUgJSAxODAgPT09IDAgJiYgbGlua09yaWdpbi55ID09PSBjb25uZWN0aW9uUG9pbnQueSkge1xuICAgICAgICByZXR1cm4gbGlua09yaWdpbi54IDwgY29ubmVjdGlvblBvaW50LnggPyBEaXJlY3Rpb25zLkxFRlQgOiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIH0gZWxzZSBpZiAobGlua09yaWdpbi54ID09PSBjb25uZWN0aW9uUG9pbnQueCkge1xuICAgICAgICByZXR1cm4gbGlua09yaWdpbi55IDwgY29ubmVjdGlvblBvaW50LnkgPyBEaXJlY3Rpb25zLlRPUCA6IERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIH1cblxuICAgIHN3aXRjaCAocm91bmRlZEFuZ2xlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxODA6XG4gICAgICAgIGNhc2UgMzYwOlxuICAgICAgICAgICAgcmV0dXJuIGxpbmtPcmlnaW4ueSA8IGNvbm5lY3Rpb25Qb2ludC55ID8gRGlyZWN0aW9ucy5UT1AgOiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICByZXR1cm4gbGlua09yaWdpbi54IDwgY29ubmVjdGlvblBvaW50LnggPyBEaXJlY3Rpb25zLkxFRlQgOiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9pbnREYXRhRnJvbUFuY2hvcih2aWV3LCBwb2ludCwgYmJveCwgZGlyZWN0aW9uLCBpc1BvcnQsIGZhbGxCYWNrQW5jaG9yLCBtYXJnaW4pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkFVVE8pIHtcbiAgICAgICAgZGlyZWN0aW9uID0gaXNQb3J0ID8gRGlyZWN0aW9ucy5NQUdORVRfU0lERSA6IERpcmVjdGlvbnMuQU5DSE9SX1NJREU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNFbGVtZW50ID0gdmlldyAmJiB2aWV3Lm1vZGVsLmlzRWxlbWVudCgpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB4OiB4MCxcbiAgICAgICAgeTogeTAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMFxuICAgIH0gPSBpc0VsZW1lbnQgPyBnLlJlY3QuZnJvbVJlY3RVbmlvbihiYm94LCB2aWV3Lm1vZGVsLmdldEJCb3goKSkgOiBmYWxsQmFja0FuY2hvcjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50LFxuICAgICAgICB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIHZpZXcsXG4gICAgICAgIGJib3gsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbWFyZ2luOiBpc0VsZW1lbnQgPyBtYXJnaW4gOiAwXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcG9pbnREYXRhRnJvbVZlcnRleCh7IHgsIHkgfSkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IGcuUG9pbnQoeCwgeSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgeDA6IHBvaW50LngsXG4gICAgICAgIHkwOiBwb2ludC55LFxuICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICBiYm94OiBuZXcgZy5SZWN0KHgsIHksIDAsIDApLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldE91dHNpZGVQb2ludChzaWRlLCBwb2ludERhdGEsIG1hcmdpbikge1xuICAgIGNvbnN0IG91dHNpZGVQb2ludCA9IHBvaW50RGF0YS5wb2ludC5jbG9uZSgpO1xuXG4gICAgY29uc3QgeyB4MCwgeTAsIHdpZHRoLCBoZWlnaHQgfSA9IHBvaW50RGF0YTtcblxuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIG91dHNpZGVQb2ludC54ID0geDAgLSBtYXJnaW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgb3V0c2lkZVBvaW50LnggPSB4MCArIHdpZHRoICsgbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBvdXRzaWRlUG9pbnQueSA9IHkwIC0gbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBvdXRzaWRlUG9pbnQueSA9IHkwICsgaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHNpZGVQb2ludDtcbn1cblxuZnVuY3Rpb24gcm91dGVCZXR3ZWVuUG9pbnRzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgeyBwb2ludDogc291cmNlUG9pbnQsIHgwOiBzeDAsIHkwOiBzeTAsIHZpZXc6IHNvdXJjZVZpZXcsIHdpZHRoOiBzb3VyY2VXaWR0aCwgaGVpZ2h0OiBzb3VyY2VIZWlnaHQsIG1hcmdpbjogc291cmNlTWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3QgeyBwb2ludDogdGFyZ2V0UG9pbnQsIHgwOiB0eDAsIHkwOiB0eTAsIHdpZHRoOiB0YXJnZXRXaWR0aCwgaGVpZ2h0OiB0YXJnZXRIZWlnaHQsIG1hcmdpbjogdGFyZ2V0TWFyZ2luIH0gPSB0YXJnZXQ7XG5cbiAgICBjb25zdCB0eDEgPSB0eDAgKyB0YXJnZXRXaWR0aDtcbiAgICBjb25zdCB0eTEgPSB0eTAgKyB0YXJnZXRIZWlnaHQ7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgc291cmNlV2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgc291cmNlSGVpZ2h0O1xuXG4gICAgY29uc3QgaXNTb3VyY2VFbCA9IHNvdXJjZVZpZXcgJiYgc291cmNlVmlldy5tb2RlbC5pc0VsZW1lbnQoKTtcblxuICAgIC8vIEtleSBjb29yZGluYXRlcyBpbmNsdWRpbmcgdGhlIG1hcmdpblxuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBzb3VyY2VNYXJnaW47XG4gICAgY29uc3Qgc214MSA9IHN4MSArIHNvdXJjZU1hcmdpbjtcbiAgICBjb25zdCBzbXkwID0gc3kwIC0gc291cmNlTWFyZ2luO1xuICAgIGNvbnN0IHNteTEgPSBzeTEgKyBzb3VyY2VNYXJnaW47XG5cbiAgICBjb25zdCB0bXgwID0gdHgwIC0gdGFyZ2V0TWFyZ2luO1xuICAgIGNvbnN0IHRteDEgPSB0eDEgKyB0YXJnZXRNYXJnaW47XG4gICAgY29uc3QgdG15MCA9IHR5MCAtIHRhcmdldE1hcmdpbjtcbiAgICBjb25zdCB0bXkxID0gdHkxICsgdGFyZ2V0TWFyZ2luO1xuXG4gICAgY29uc3QgW3NvdXJjZVNpZGUsIHRhcmdldFNpZGVdID0gcmVzb2x2ZVNpZGVzKHNvdXJjZSwgdGFyZ2V0KTtcblxuICAgIGNvbnN0IHNvdXJjZU91dHNpZGVQb2ludCA9IGdldE91dHNpZGVQb2ludChzb3VyY2VTaWRlLCB7IHBvaW50OiBzb3VyY2VQb2ludCwgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGg6IHNvdXJjZVdpZHRoLCBoZWlnaHQ6IHNvdXJjZUhlaWdodCB9LCBzb3VyY2VNYXJnaW4pO1xuICAgIGNvbnN0IHRhcmdldE91dHNpZGVQb2ludCA9IGdldE91dHNpZGVQb2ludCh0YXJnZXRTaWRlLCB7IHBvaW50OiB0YXJnZXRQb2ludCwgeDA6IHR4MCwgeTA6IHR5MCwgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldEhlaWdodCB9LCB0YXJnZXRNYXJnaW4pO1xuXG4gICAgY29uc3QgeyB4OiBzb3gsIHk6IHNveSB9ID0gc291cmNlT3V0c2lkZVBvaW50O1xuICAgIGNvbnN0IHsgeDogdG94LCB5OiB0b3kgfSA9IHRhcmdldE91dHNpZGVQb2ludDtcbiAgICBjb25zdCB0Y3ggPSAodHgwICsgdHgxKSAvIDI7XG4gICAgY29uc3QgdGN5ID0gKHR5MCArIHR5MSkgLyAyO1xuICAgIGNvbnN0IHNjeCA9IChzeDAgKyBzeDEpIC8gMjtcbiAgICBjb25zdCBzY3kgPSAoc3kwICsgc3kxKSAvIDI7XG4gICAgY29uc3QgbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzID0gKHNjeCA8IHRjeCA/IChzeDEgKyB0eDApIDogKHR4MSArIHN4MCkpIC8gMjtcbiAgICBjb25zdCBtaWRkbGVPZkhvcml6b250YWxTaWRlcyA9IChzY3kgPCB0Y3kgPyAoc3kxICsgdHkwKSA6ICh0eTEgKyBzeTApKSAvIDI7XG5cbiAgICBpZiAoc291cmNlU2lkZSA9PT0gJ2xlZnQnICYmIHRhcmdldFNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgaWYgKHNteDAgPD0gdG14MSkge1xuICAgICAgICAgICAgbGV0IHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcbiAgICAgICAgICAgIGlmIChzeDEgPD0gdHgwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5MSA+PSBzbXkwICYmIHRveSA8IHNveSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4odG15MCwgc215MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eTAgPD0gc215MSAmJiB0b3kgPj0gc295KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzbXkxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IChzb3ggKyB0b3gpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAncmlnaHQnICYmIHRhcmdldFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBpZiAoc214MSA+PSB0bXgwKSB7XG4gICAgICAgICAgICBsZXQgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgaWYgKHNveCA+IHR4MSkge1xuICAgICAgICAgICAgICAgIGlmICh0eTEgPj0gc215MCAmJiB0b3kgPCBzb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNteTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHkwIDw9IHNteTEgJiYgdG95ID49IHNveSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgodG15MSwgc215MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IChzb3ggKyB0b3gpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAndG9wJyAmJiB0YXJnZXRTaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBpZiAoc295IDwgdG95KSB7XG4gICAgICAgICAgICBsZXQgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgIGxldCB5ID0gc295O1xuXG4gICAgICAgICAgICBpZiAoc295IDwgdHkwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4MSA+PSBzbXgwICYmIHRveCA8IHNveCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG14MCwgc214MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eDAgPD0gc214MSAmJiB0b3ggPj0gc294KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heCh0bXgxLCBzbXgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ID0gKHNveSArIHRveSkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdib3R0b20nICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGlmIChzb3kgLSBzb3VyY2VNYXJnaW4gPiB0b3kpIHtcbiAgICAgICAgICAgIGxldCB4ID0gbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzO1xuICAgICAgICAgICAgbGV0IHkgPSBzb3k7XG5cbiAgICAgICAgICAgIGlmIChzb3kgPiB0eTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHgxID49IHNteDAgJiYgdG94IDwgc294KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbih0bXgwLCBzbXgwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR4MCA8PSBzbXgxICYmIHRveCA+PSBzb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRteDEsIHNteDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHkgPSAoc295ICsgdG95KSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3RvcCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5MSA9IE1hdGgubWluKChzeTEgKyB0eTApIC8gMiwgdG95KTtcbiAgICAgICAgbGV0IHkyID0gTWF0aC5taW4oKHN5MCArIHR5MSkgLyAyLCBzb3kpO1xuXG4gICAgICAgIGlmICh0b3kgPCBzb3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPj0gdG14MSB8fCBzb3ggPD0gdG14MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBNYXRoLm1pbihzb3ksIHRveSkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IE1hdGgubWluKHNveSwgdG95KSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG94ID4gc294KSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWluKHNveCwgdG14MCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heChzb3gsIHRteDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRveCA+PSBzbXgxIHx8IHRveCA8PSBzbXgwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IE1hdGgubWluKHNveSwgdG95KSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogTWF0aC5taW4oc295LCB0b3kpIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3ggPj0gc294KSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRveCwgc214MSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbih0b3gsIHNteDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiB5MiB9LFxuICAgICAgICAgICAgeyB4LCB5OiB5MiB9LFxuICAgICAgICAgICAgeyB4LCB5OiB5MSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHkxIH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdib3R0b20nICYmIHRhcmdldFNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTEgPSBNYXRoLm1heCgoc3kwICsgdHkxKSAvIDIsIHRveSk7XG4gICAgICAgIGxldCB5MiA9IE1hdGgubWF4KChzeTEgKyB0eTApIC8gMiwgc295KTtcblxuICAgICAgICBpZiAodG95ID4gc295KSB7XG4gICAgICAgICAgICBpZiAoc294ID49IHRteDEgfHwgc294IDw9IHRteDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogTWF0aC5tYXgoc295LCB0b3kpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBNYXRoLm1heChzb3ksIHRveSkgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRveCA+IHNveCkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbihzb3gsIHRteDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgoc294LCB0bXgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b3ggPj0gc214MSB8fCB0b3ggPD0gc214MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBNYXRoLm1heChzb3ksIHRveSkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IE1hdGgubWF4KHNveSwgdG95KSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG94ID49IHNveCkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heCh0b3gsIHNteDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG94LCBzbXgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogeTIgfSxcbiAgICAgICAgICAgIHsgeCwgeTogeTIgfSxcbiAgICAgICAgICAgIHsgeCwgeTogeTEgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5OiB5MSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnbGVmdCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgeDEgPSBNYXRoLm1pbigoc3gxICsgdHgwKSAvIDIsIHRveCk7XG4gICAgICAgIGxldCB4MiA9IE1hdGgubWluKChzeDAgKyB0eDEpIC8gMiwgc294KTtcblxuICAgICAgICBpZiAodG94ID4gc294KSB7XG4gICAgICAgICAgICBpZiAodG95IDw9IHNveSkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihzbXkwLCB0b3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgoc215MSwgdG95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b3kgPj0gc295KSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNveSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogeDIsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiB4MiwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdyaWdodCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5tYXgoKHN4MCArIHR4MSkgLyAyLCB0b3gpO1xuICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCgoc3gxICsgdHgwKSAvIDIsIHNveCk7XG5cbiAgICAgICAgaWYgKHRveCA8IHNveCkge1xuICAgICAgICAgICAgaWYgKHRveSA8PSBzb3kpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4oc215MCwgdG95KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHNteTEsIHRveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG95ID49IHNveSkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbih0bXkwLCBzb3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgodG15MSwgc295KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHgyLCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeDogeDIsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeDEsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeDEsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAndG9wJyAmJiB0YXJnZXRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGlmIChzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPCB0b3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCh5ID4gdGN5IHx8ICFpc1NvdXJjZUVsKSAmJiB5IDwgdG15MSAmJiBzb3ggPCB0eDApIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRteTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChtaWRkbGVPZlZlcnRpY2FsU2lkZXMsIHRteDEpO1xuXG4gICAgICAgIGlmICh0b3ggPCBzb3ggJiYgdG95ID4gc3kwICYmIHRveSA8IHN5MSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh4ID4gc214MCAmJiB0b3kgPiBzeTApIHx8IHR4MCA+IHN4MSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHN5MCAtIHNvdXJjZU1hcmdpbiwgdHkwIC0gdGFyZ2V0TWFyZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzeDEgKyBzb3VyY2VNYXJnaW4sIHR4MSArIHRhcmdldE1hcmdpbik7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHg6IE1hdGgubWF4KHgsIHRveCksIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiBNYXRoLm1heCh4LCB0b3gpLCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3RvcCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGlmIChzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPiB0b3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCh5ID4gdGN5IHx8ICFpc1NvdXJjZUVsKSAmJiB5IDwgdG15MSAmJiBzb3ggPiB0eDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRteTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3sgeDogc294LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4odG14MCwgbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc294IDwgdG94ICYmIHN5MSA+PSB0b3kpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IHNteDEgJiYgc295IDwgdHkxKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdib3R0b20nICYmIHRhcmdldFNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgaWYgKHNveSA8IHRveSkge1xuICAgICAgICAgICAgaWYgKHNveCA8IHRveCkge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHkgPCB0Y3kgfHwgIWlzU291cmNlRWwpICYmIHkgPiB0bXkwICYmIHNveCA8IHR4MCkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gdG15MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeDAgPCB0b3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc215MSwgdG15MSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNteDEsIHRteDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnYm90dG9tJyAmJiB0YXJnZXRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgaWYgKHNveSA8IHRveSkge1xuICAgICAgICAgICAgaWYgKHNveCA+IHRveCkge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHkgPCB0Y3kgfHwgIWlzU291cmNlRWwpICYmIHkgPiB0bXkwICYmIHNveCA+IHR4MSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gdG15MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeDEgPiB0b3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc215MSwgdG15MSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHNteDAsIHRteDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdsZWZ0JyAmJiB0YXJnZXRTaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBpZiAoc294ID49IHRveCAmJiBzb3kgPj0gdG15MSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNveCA+PSB0eDEgJiYgc295IDwgdG95KSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG94IDwgc3gxICYmIHR5MSA8PSBzeTApIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHRteDAsIHNveCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2xlZnQnICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGlmIChzb3ggPiB0b3ggJiYgc295IDwgdG15MCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNveCA+PSB0eDEpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3ggPD0gc3gxICYmIHRveSA+IHNveSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IHRveSA8IHNveSA/IE1hdGgubWluKHNteDAsIHRteDApIDogc214MDtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHNteTAsIHRteTApO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgIF07XG5cbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdyaWdodCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgaWYgKHNveCA8PSB0b3ggJiYgc295IDwgdG15MCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN4MSA8IHR4MCAmJiBzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgIGxldCB4ID0gbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG94IDwgc294ICYmIHR5MCA+IHN5MSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc214MSwgdG14MSk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3JpZ2h0JyAmJiB0YXJnZXRTaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBpZiAoc294IDw9IHRveCAmJiBzb3kgPj0gdG15MSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNveCA8PSB0bXgwICYmIHNveSA8IHRveSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRveCA+IHN4MCAmJiB0eTEgPCBzeTApIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHRteDEsIHNveCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmlnaHRBbmdsZVJvdXRlcih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuICAgIGNvbnN0IHsgc291cmNlRGlyZWN0aW9uID0gRGlyZWN0aW9ucy5BVVRPLCB0YXJnZXREaXJlY3Rpb24gPSBEaXJlY3Rpb25zLkFVVE8gfSA9IG9wdDtcbiAgICBjb25zdCBtYXJnaW4gPSBvcHQubWFyZ2luIHx8IDIwO1xuICAgIGNvbnN0IHVzZVZlcnRpY2VzID0gb3B0LnVzZVZlcnRpY2VzIHx8IGZhbHNlO1xuXG4gICAgY29uc3QgaXNTb3VyY2VQb3J0ID0gISFsaW5rVmlldy5tb2RlbC5zb3VyY2UoKS5wb3J0O1xuICAgIGNvbnN0IHNvdXJjZVBvaW50ID0gcG9pbnREYXRhRnJvbUFuY2hvcihsaW5rVmlldy5zb3VyY2VWaWV3LCBsaW5rVmlldy5zb3VyY2VBbmNob3IsIGxpbmtWaWV3LnNvdXJjZUJCb3gsIHNvdXJjZURpcmVjdGlvbiwgaXNTb3VyY2VQb3J0LCBsaW5rVmlldy5zb3VyY2VBbmNob3IsIG1hcmdpbik7XG5cbiAgICBjb25zdCBpc1RhcmdldFBvcnQgPSAhIWxpbmtWaWV3Lm1vZGVsLnRhcmdldCgpLnBvcnQ7XG4gICAgY29uc3QgdGFyZ2V0UG9pbnQgPSBwb2ludERhdGFGcm9tQW5jaG9yKGxpbmtWaWV3LnRhcmdldFZpZXcsIGxpbmtWaWV3LnRhcmdldEFuY2hvciwgbGlua1ZpZXcudGFyZ2V0QkJveCwgdGFyZ2V0RGlyZWN0aW9uLCBpc1RhcmdldFBvcnQsIGxpbmtWaWV3LnRhcmdldEFuY2hvciwgbWFyZ2luKTtcblxuICAgIGxldCByZXN1bHRWZXJ0aWNlcyA9IFtdO1xuXG4gICAgaWYgKCF1c2VWZXJ0aWNlcyB8fCB2ZXJ0aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsaWZ5UG9pbnRzKHJvdXRlQmV0d2VlblBvaW50cyhzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0aWNlc0RhdGEgPSB2ZXJ0aWNlcy5tYXAoKHYpID0+IHBvaW50RGF0YUZyb21WZXJ0ZXgodikpO1xuICAgIGNvbnN0IFtmaXJzdFZlcnRleF0gPSB2ZXJ0aWNlc0RhdGE7XG5cbiAgICBpZiAoc291cmNlUG9pbnQudmlldyAmJiBzb3VyY2VQb2ludC52aWV3Lm1vZGVsLmlzRWxlbWVudCgpICYmIHNvdXJjZVBvaW50LnZpZXcubW9kZWwuZ2V0QkJveCgpLmluZmxhdGUobWFyZ2luKS5jb250YWluc1BvaW50KGZpcnN0VmVydGV4LnBvaW50KSkge1xuICAgICAgICBjb25zdCBbZnJvbURpcmVjdGlvbl0gPSByZXNvbHZlU2lkZXMoc291cmNlUG9pbnQsIGZpcnN0VmVydGV4KTtcbiAgICAgICAgY29uc3QgdG9EaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBkdW1teVNvdXJjZSA9IHBvaW50RGF0YUZyb21WZXJ0ZXgoc291cmNlUG9pbnQucG9pbnQpO1xuICAgICAgICAvLyBQb2ludHMgZG8gbm90IHVzdWFsbHkgaGF2ZSBtYXJnaW4uIEhlcmUgd2UgY3JlYXRlIGEgcG9pbnQgd2l0aCBhIG1hcmdpbi5cbiAgICAgICAgZHVtbXlTb3VyY2UubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICBkdW1teVNvdXJjZS5kaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xuICAgICAgICBmaXJzdFZlcnRleC5kaXJlY3Rpb24gPSB0b0RpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhkdW1teVNvdXJjZSwgZmlyc3RWZXJ0ZXgpLCBmaXJzdFZlcnRleC5wb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBvaW50IHJlc3BvbnNpYmxlIGZvciB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gb2YgdGhlIHJvdXRlXG4gICAgICAgIGNvbnN0IG5leHQgPSB2ZXJ0aWNlc0RhdGFbMV0gfHwgdGFyZ2V0UG9pbnQ7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJlc29sdmVJbml0aWFsRGlyZWN0aW9uKHNvdXJjZVBvaW50LCBmaXJzdFZlcnRleCwgbmV4dCk7XG4gICAgICAgIGZpcnN0VmVydGV4LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhzb3VyY2VQb2ludCwgZmlyc3RWZXJ0ZXgpLCBmaXJzdFZlcnRleC5wb2ludCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlc0RhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB2ZXJ0aWNlc0RhdGFbaV07XG4gICAgICAgIGNvbnN0IHRvID0gdmVydGljZXNEYXRhW2kgKyAxXTtcblxuICAgICAgICBjb25zdCBzZWdtZW50ID0gbmV3IGcuTGluZShmcm9tLnBvaW50LCB0by5wb2ludCk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRBbmdsZSA9IGdldFNlZ21lbnRBbmdsZShzZWdtZW50KTtcbiAgICAgICAgaWYgKHNlZ21lbnRBbmdsZSAlIDkwID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgc2VnbWVudCBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCB3ZSBjYW4gc2tpcCB0aGUgcm91dGluZyBhbmQganVzdCBjb25uZWN0IHRoZW0gd2l0aCBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICAgIGNvbnN0IHRvRGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtzZWdtZW50QW5nbGVdO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzRGlyZWN0aW9uID0gT1BQT1NJVEVfRElSRUNUSU9OU1t0b0RpcmVjdGlvbl07XG5cbiAgICAgICAgICAgIGlmICh0b0RpcmVjdGlvbiAhPT0gZnJvbS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKGZyb20ucG9pbnQsIHRvLnBvaW50KTtcbiAgICAgICAgICAgICAgICB0by5kaXJlY3Rpb24gPSBhY2Nlc3NEaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gZy5ub3JtYWxpemVBbmdsZShzZWdtZW50QW5nbGUgLSA5MCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZHggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBkeSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPT09IDkwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gLW1hcmdpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ2xlID09PSAxODApIHtcbiAgICAgICAgICAgICAgICAgICAgZHggPSAtbWFyZ2luO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5nbGUgPT09IDI3MCkge1xuICAgICAgICAgICAgICAgICAgICBkeSA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHAxID0geyB4OiBmcm9tLnBvaW50LnggKyBkeCwgeTogZnJvbS5wb2ludC55ICsgZHkgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHsgeDogdG8ucG9pbnQueCArIGR4LCB5OiB0by5wb2ludC55ICsgZHkgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQyID0gbmV3IGcuTGluZSh0by5wb2ludCwgcDIpO1xuICAgICAgICAgICAgICAgIHRvLmRpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbZ2V0U2VnbWVudEFuZ2xlKHNlZ21lbnQyKV07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3RpbmcgYSBsb29wXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaChmcm9tLnBvaW50LCBwMSwgcDIsIHRvLnBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbZnJvbURpcmVjdGlvbiwgdG9EaXJlY3Rpb25dID0gcmVzb2x2ZURpcmVjdGlvbihmcm9tLCB0byk7XG5cbiAgICAgICAgZnJvbS5kaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xuICAgICAgICB0by5kaXJlY3Rpb24gPSB0b0RpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhmcm9tLCB0byksIHRvLnBvaW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0VmVydGV4ID0gdmVydGljZXNEYXRhW3ZlcnRpY2VzRGF0YS5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0YXJnZXRQb2ludC52aWV3ICYmIHRhcmdldFBvaW50LnZpZXcubW9kZWwuaXNFbGVtZW50KCkpIHtcbiAgICAgICAgaWYgKHRhcmdldFBvaW50LnZpZXcubW9kZWwuZ2V0QkJveCgpLmluZmxhdGUobWFyZ2luKS5jb250YWluc1BvaW50KGxhc3RWZXJ0ZXgucG9pbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBbZnJvbURpcmVjdGlvbl0gPSByZXNvbHZlRGlyZWN0aW9uKGxhc3RWZXJ0ZXgsIHRhcmdldFBvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IGR1bW15VGFyZ2V0ID0gcG9pbnREYXRhRnJvbVZlcnRleCh0YXJnZXRQb2ludC5wb2ludCk7XG4gICAgICAgICAgICBjb25zdCBbLCB0b0RpcmVjdGlvbl0gPSByZXNvbHZlU2lkZXMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgLy8gd2UgYXJlIGNyZWF0aW5nIGEgcG9pbnQgdGhhdCBoYXMgYSBtYXJnaW5cbiAgICAgICAgICAgIGR1bW15VGFyZ2V0Lm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgICAgIGR1bW15VGFyZ2V0LmRpcmVjdGlvbiA9IHRvRGlyZWN0aW9uO1xuICAgICAgICAgICAgbGFzdFZlcnRleC5kaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xuXG4gICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhsYXN0VmVydGV4LCBkdW1teVRhcmdldCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcG9pbnQgb2YgYHNpbXBsaWZpZWRgIGFycmF5IGlzIHRoZSBsYXN0IGRlZmluZWQgdmVydGV4XG4gICAgICAgICAgICAvLyBncmFiIHRoZSBwZW51bHRpbWF0ZSBwb2ludCBhbmQgY29uc3RydWN0IGEgbGluZSBzZWdtZW50IGZyb20gaXQgdG8gdGhlIGxhc3QgdmVydGV4XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBjb250aW51ZXMgaW4gYSBzdHJhaWdodCBsaW5lXG5cbiAgICAgICAgICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBzaW1wbGlmeVBvaW50cyhyZXN1bHRWZXJ0aWNlcyk7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gbmV3IGcuTGluZShzaW1wbGlmaWVkW3NpbXBsaWZpZWQubGVuZ3RoIC0gMl0sIGxhc3RWZXJ0ZXgucG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5lZERpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUoc2VnbWVudCkpXTtcbiAgICAgICAgICAgIGxhc3RWZXJ0ZXguZGlyZWN0aW9uID0gZGVmaW5lZERpcmVjdGlvbjtcblxuICAgICAgICAgICAgbGV0IGxhc3RTZWdtZW50Um91dGUgPSByb3V0ZUJldHdlZW5Qb2ludHMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgW3AxLCBwMl0gPSBzaW1wbGlmeVBvaW50cyhbLi4ubGFzdFNlZ21lbnRSb3V0ZSwgdGFyZ2V0UG9pbnQucG9pbnRdKTtcblxuICAgICAgICAgICAgY29uc3QgbGFzdFNlZ21lbnQgPSBuZXcgZy5MaW5lKHAxLCBwMik7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkTGFzdFNlZ21lbnRBbmdsZSA9IE1hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKGxhc3RTZWdtZW50KSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2VnbWVudERpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbcm91bmRlZExhc3RTZWdtZW50QW5nbGVdO1xuXG4gICAgICAgICAgICBpZiAobGFzdFNlZ21lbnREaXJlY3Rpb24gIT09IGRlZmluZWREaXJlY3Rpb24gJiYgZGVmaW5lZERpcmVjdGlvbiA9PT0gT1BQT1NJVEVfRElSRUNUSU9OU1tsYXN0U2VnbWVudERpcmVjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICBsYXN0VmVydGV4Lm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudFJvdXRlID0gcm91dGVCZXR3ZWVuUG9pbnRzKGxhc3RWZXJ0ZXgsIHRhcmdldFBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5sYXN0U2VnbWVudFJvdXRlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSB0YXJnZXQgaXMgb25seSBhIHBvaW50IHdlIGNhbiBhcHBseSB0aGUgc2FtZSBsb2dpYyBhcyBpZiB3ZSBjb25uZWN0ZWQgdHdvIHZlcnRpY2VzRGF0YVxuICAgICAgICBjb25zdCBbdmVydGV4RGlyZWN0aW9uXSA9IHJlc29sdmVEaXJlY3Rpb24obGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICBsYXN0VmVydGV4LmRpcmVjdGlvbiA9IHZlcnRleERpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhsYXN0VmVydGV4LCB0YXJnZXRQb2ludCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzaW1wbGlmeVBvaW50cyhyZXN1bHRWZXJ0aWNlcyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3Rpb24oZnJvbSwgdG8pIHtcbiAgICBjb25zdCBhY2Nlc3NEaXJlY3Rpb24gPSBmcm9tLmRpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpcmVjdGlvblZlcnRpY2FsID0gVkVSVElDQUxfRElSRUNUSU9OUy5pbmNsdWRlcyhhY2Nlc3NEaXJlY3Rpb24pO1xuXG4gICAgbGV0IHNvdXJjZURpcmVjdGlvbiA9IGZyb20uZGlyZWN0aW9uO1xuICAgIGxldCB0YXJnZXREaXJlY3Rpb24gPSB0by5kaXJlY3Rpb247XG5cbiAgICBpZiAoaXNEaXJlY3Rpb25WZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCBpc1RvQWJvdmUgPSBmcm9tLnBvaW50LnkgPiB0by5wb2ludC55O1xuICAgICAgICBjb25zdCBkeCA9IHRvLnBvaW50LnggLSBmcm9tLnBvaW50Lng7XG5cbiAgICAgICAgaWYgKGFjY2Vzc0RpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5CT1RUT00pIHtcbiAgICAgICAgICAgIC8vIElmIGlzVG9BYm92ZSA9PT0gZmFsc2UgYW5kIHdlIG5lZWQgZmlndXJlIG91dCBpZiB0byBnbyBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBPUFBPU0lURV9ESVJFQ1RJT05TW2FjY2Vzc0RpcmVjdGlvbl0gOiBkeCA+PSAwID8gRGlyZWN0aW9ucy5SSUdIVCA6IERpcmVjdGlvbnMuTEVGVDtcblxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuTEVGVCA6IERpcmVjdGlvbnMuVE9QO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5UT1A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpc1RvQWJvdmUgPT09IHRydWUgYW5kIHdlIG5lZWQgZmlndXJlIG91dCBpZiB0byBnbyBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBkeCA+PSAwID8gRGlyZWN0aW9ucy5SSUdIVCA6IERpcmVjdGlvbnMuTEVGVCA6IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5MRUZUO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc1RvTGVmdCA9IGZyb20ucG9pbnQueCA+IHRvLnBvaW50Lng7XG4gICAgICAgIGNvbnN0IGR5ID0gdG8ucG9pbnQueSAtIGZyb20ucG9pbnQueTtcblxuICAgICAgICBpZiAoYWNjZXNzRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlJJR0hUKSB7XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvTGVmdCA/IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXSA6IGR5ID49IDAgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuVE9QO1xuXG4gICAgICAgICAgICBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLlRPUCA6IERpcmVjdGlvbnMuTEVGVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuTEVGVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZURpcmVjdGlvbiA9IGlzVG9MZWZ0ID8gZHkgPj0gMCA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5UT1AgOiBPUFBPU0lURV9ESVJFQ1RJT05TW2FjY2Vzc0RpcmVjdGlvbl07XG5cbiAgICAgICAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvTGVmdCA/IERpcmVjdGlvbnMuUklHSFQgOiBEaXJlY3Rpb25zLlRPUDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZURpcmVjdGlvbiwgdGFyZ2V0RGlyZWN0aW9uXTtcbn1cblxucmlnaHRBbmdsZVJvdXRlci5EaXJlY3Rpb25zID0gRGlyZWN0aW9ucztcblxuZXhwb3J0IGNvbnN0IHJpZ2h0QW5nbGUgPSByaWdodEFuZ2xlUm91dGVyO1xuIl0sIm5hbWVzIjpbImciLCJEaXJlY3Rpb25zIiwiQVVUTyIsIkxFRlQiLCJSSUdIVCIsIlRPUCIsIkJPVFRPTSIsIkFOQ0hPUl9TSURFIiwiTUFHTkVUX1NJREUiLCJERUZJTkVEX0RJUkVDVElPTlMiLCJPUFBPU0lURV9ESVJFQ1RJT05TIiwiVkVSVElDQUxfRElSRUNUSU9OUyIsIkFOR0xFX0RJUkVDVElPTl9NQVAiLCJnZXRTZWdtZW50QW5nbGUiLCJsaW5lIiwiYW5nbGUiLCJzaW1wbGlmeVBvaW50cyIsInBvaW50cyIsIlBvbHlsaW5lIiwic2ltcGxpZnkiLCJ0aHJlc2hvbGQiLCJyZXNvbHZlU2lkZXMiLCJzb3VyY2UiLCJ0YXJnZXQiLCJwb2ludCIsInNvdXJjZVBvaW50IiwieDAiLCJzeDAiLCJ5MCIsInN5MCIsInZpZXciLCJzb3VyY2VWaWV3IiwiYmJveCIsInNvdXJjZUJCb3giLCJkaXJlY3Rpb24iLCJzb3VyY2VEaXJlY3Rpb24iLCJ0YXJnZXRQb2ludCIsInR4MCIsInR5MCIsInRhcmdldFZpZXciLCJ0YXJnZXRCQm94IiwidGFyZ2V0RGlyZWN0aW9uIiwic291cmNlU2lkZSIsInNvdXJjZUxpbmtBbmNob3JCQm94IiwiUmVjdCIsImluY2x1ZGVzIiwic2lkZU5lYXJlc3RUb1BvaW50IiwibW9kZWwiLCJpc0xpbmsiLCJnZXREaXJlY3Rpb25Gb3JMaW5rQ29ubmVjdGlvbiIsImdldEJCb3giLCJ0YXJnZXRTaWRlIiwidGFyZ2V0TGlua0FuY2hvckJCb3giLCJyZXNvbHZlRm9yVG9wU291cmNlU2lkZSIsIm5leHRJbkxpbmUiLCJ3aWR0aCIsImhlaWdodCIsImFuY2hvciIsIm1hcmdpbiIsInN4MSIsInN5MSIsInNteDAiLCJzbXgxIiwic215MCIsIngiLCJheCIsInR4IiwidHkiLCJyZXNvbHZlRm9yQm90dG9tU291cmNlU2lkZSIsInNteTEiLCJyZXNvbHZlRm9yTGVmdFNvdXJjZVNpZGUiLCJ5IiwiYXkiLCJyZXNvbHZlRm9yUmlnaHRTb3VyY2VTaWRlIiwicmVzb2x2ZUluaXRpYWxEaXJlY3Rpb24iLCJsaW5rT3JpZ2luIiwiY29ubmVjdGlvblBvaW50IiwibGlua1ZpZXciLCJ0YW5nZW50IiwiZ2V0VGFuZ2VudEF0TGVuZ3RoIiwiZ2V0Q2xvc2VzdFBvaW50TGVuZ3RoIiwicm91bmRlZEFuZ2xlIiwiTWF0aCIsInJvdW5kIiwicG9pbnREYXRhRnJvbUFuY2hvciIsImlzUG9ydCIsImZhbGxCYWNrQW5jaG9yIiwiaXNFbGVtZW50IiwiZnJvbVJlY3RVbmlvbiIsInBvaW50RGF0YUZyb21WZXJ0ZXgiLCJQb2ludCIsImdldE91dHNpZGVQb2ludCIsInNpZGUiLCJwb2ludERhdGEiLCJvdXRzaWRlUG9pbnQiLCJjbG9uZSIsInJvdXRlQmV0d2VlblBvaW50cyIsInNvdXJjZVdpZHRoIiwic291cmNlSGVpZ2h0Iiwic291cmNlTWFyZ2luIiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJ0YXJnZXRNYXJnaW4iLCJ0eDEiLCJ0eTEiLCJpc1NvdXJjZUVsIiwidG14MCIsInRteDEiLCJ0bXkwIiwidG15MSIsInNvdXJjZU91dHNpZGVQb2ludCIsInRhcmdldE91dHNpZGVQb2ludCIsInNveCIsInNveSIsInRveCIsInRveSIsInRjeCIsInRjeSIsInNjeCIsInNjeSIsIm1pZGRsZU9mVmVydGljYWxTaWRlcyIsIm1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzIiwibWluIiwibWF4IiwieTEiLCJ5MiIsIngxIiwieDIiLCJyaWdodEFuZ2xlUm91dGVyIiwidmVydGljZXMiLCJvcHQiLCJ1c2VWZXJ0aWNlcyIsImlzU291cmNlUG9ydCIsInBvcnQiLCJzb3VyY2VBbmNob3IiLCJpc1RhcmdldFBvcnQiLCJ0YXJnZXRBbmNob3IiLCJyZXN1bHRWZXJ0aWNlcyIsImxlbmd0aCIsInZlcnRpY2VzRGF0YSIsIm1hcCIsInYiLCJmaXJzdFZlcnRleCIsImluZmxhdGUiLCJjb250YWluc1BvaW50IiwiZnJvbURpcmVjdGlvbiIsInRvRGlyZWN0aW9uIiwiZHVtbXlTb3VyY2UiLCJwdXNoIiwibmV4dCIsImkiLCJmcm9tIiwidG8iLCJzZWdtZW50IiwiTGluZSIsInNlZ21lbnRBbmdsZSIsImFjY2Vzc0RpcmVjdGlvbiIsIm5vcm1hbGl6ZUFuZ2xlIiwiZHgiLCJkeSIsInAxIiwicDIiLCJzZWdtZW50MiIsInJlc29sdmVEaXJlY3Rpb24iLCJsYXN0VmVydGV4IiwiZHVtbXlUYXJnZXQiLCJzaW1wbGlmaWVkIiwiZGVmaW5lZERpcmVjdGlvbiIsImxhc3RTZWdtZW50Um91dGUiLCJsYXN0U2VnbWVudCIsInJvdW5kZWRMYXN0U2VnbWVudEFuZ2xlIiwibGFzdFNlZ21lbnREaXJlY3Rpb24iLCJ2ZXJ0ZXhEaXJlY3Rpb24iLCJpc0RpcmVjdGlvblZlcnRpY2FsIiwiaXNUb0Fib3ZlIiwiaXNUb0xlZnQiLCJyaWdodEFuZ2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/routers/rightAngle.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/shapes/basic.mjs":
/*!***************************************************!*\
  !*** ./node_modules/jointjs/src/shapes/basic.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse),\n/* harmony export */   Generic: () => (/* binding */ Generic),\n/* harmony export */   Image: () => (/* binding */ Image),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   Polygon: () => (/* binding */ Polygon),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   Rhombus: () => (/* binding */ Rhombus),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TextBlock: () => (/* binding */ TextBlock),\n/* harmony export */   TextBlockView: () => (/* binding */ TextBlockView),\n/* harmony export */   TextView: () => (/* binding */ TextView)\n/* harmony export */ });\n/* harmony import */ var _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/Element.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Element.mjs\");\n/* harmony import */ var _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/ElementView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/ElementView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/jointjs/src/util/util.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env/index.mjs */ \"(ssr)/./node_modules/jointjs/src/env/index.mjs\");\n\n\n\n\nconst Generic = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define(\"basic.Generic\", {\n    attrs: {\n        \".\": {\n            fill: \"#ffffff\",\n            stroke: \"none\"\n        }\n    }\n});\nconst Rect = Generic.define(\"basic.Rect\", {\n    attrs: {\n        \"rect\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\",\n            width: 100,\n            height: 60\n        },\n        \"text\": {\n            fill: \"#000000\",\n            text: \"\",\n            \"font-size\": 14,\n            \"ref-x\": .5,\n            \"ref-y\": .5,\n            \"text-anchor\": \"middle\",\n            \"y-alignment\": \"middle\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n});\nconst TextView = _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.extend({\n    presentationAttributes: _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.addPresentationAttributes({\n        // The element view is not automatically re-scaled to fit the model size\n        // when the attribute 'attrs' is changed.\n        attrs: [\n            \"SCALE\"\n        ]\n    }),\n    confirmUpdate: function() {\n        var flags = _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.confirmUpdate.apply(this, arguments);\n        if (this.hasFlag(flags, \"SCALE\")) {\n            this.resize();\n            flags = this.removeFlag(flags, \"SCALE\");\n        }\n        return flags;\n    }\n});\nconst Text = Generic.define(\"basic.Text\", {\n    attrs: {\n        \"text\": {\n            \"font-size\": 18,\n            fill: \"#000000\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>'\n});\nconst Circle = Generic.define(\"basic.Circle\", {\n    size: {\n        width: 60,\n        height: 60\n    },\n    attrs: {\n        \"circle\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\",\n            r: 30,\n            cx: 30,\n            cy: 30\n        },\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref-x\": .5,\n            \"ref-y\": .5,\n            \"y-alignment\": \"middle\",\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>'\n});\nconst Ellipse = Generic.define(\"basic.Ellipse\", {\n    size: {\n        width: 60,\n        height: 40\n    },\n    attrs: {\n        \"ellipse\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\",\n            rx: 30,\n            ry: 20,\n            cx: 30,\n            cy: 20\n        },\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref-x\": .5,\n            \"ref-y\": .5,\n            \"y-alignment\": \"middle\",\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>'\n});\nconst Polygon = Generic.define(\"basic.Polygon\", {\n    size: {\n        width: 60,\n        height: 40\n    },\n    attrs: {\n        \"polygon\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\"\n        },\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref-x\": .5,\n            \"ref-dy\": 20,\n            \"y-alignment\": \"middle\",\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>'\n});\nconst Polyline = Generic.define(\"basic.Polyline\", {\n    size: {\n        width: 60,\n        height: 40\n    },\n    attrs: {\n        \"polyline\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\"\n        },\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref-x\": .5,\n            \"ref-dy\": 20,\n            \"y-alignment\": \"middle\",\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>'\n});\nconst Image = Generic.define(\"basic.Image\", {\n    attrs: {\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref-x\": .5,\n            \"ref-dy\": 20,\n            \"y-alignment\": \"middle\",\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>'\n});\nconst Path = Generic.define(\"basic.Path\", {\n    size: {\n        width: 60,\n        height: 60\n    },\n    attrs: {\n        \"path\": {\n            fill: \"#ffffff\",\n            stroke: \"#000000\"\n        },\n        \"text\": {\n            \"font-size\": 14,\n            text: \"\",\n            \"text-anchor\": \"middle\",\n            \"ref\": \"path\",\n            \"ref-x\": .5,\n            \"ref-dy\": 10,\n            fill: \"#000000\",\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>'\n});\nconst Rhombus = Path.define(\"basic.Rhombus\", {\n    attrs: {\n        \"path\": {\n            d: \"M 30 0 L 60 30 30 60 0 30 z\"\n        },\n        \"text\": {\n            \"ref-y\": .5,\n            \"ref-dy\": null,\n            \"y-alignment\": \"middle\"\n        }\n    }\n});\nconst svgForeignObjectSupported = _env_index_mjs__WEBPACK_IMPORTED_MODULE_2__.env.test(\"svgforeignobject\");\nconst TextBlock = Generic.define(\"basic.TextBlock\", {\n    // see joint.css for more element styles\n    attrs: {\n        rect: {\n            fill: \"#ffffff\",\n            stroke: \"#000000\",\n            width: 80,\n            height: 100\n        },\n        text: {\n            fill: \"#000000\",\n            \"font-size\": 14,\n            \"font-family\": \"Arial, helvetica, sans-serif\"\n        },\n        \".content\": {\n            text: \"\",\n            \"ref-x\": .5,\n            \"ref-y\": .5,\n            \"y-alignment\": \"middle\",\n            \"x-alignment\": \"middle\"\n        }\n    },\n    content: \"\"\n}, {\n    markup: [\n        '<g class=\"rotatable\">',\n        '<g class=\"scalable\"><rect/></g>',\n        svgForeignObjectSupported ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>' : '<text class=\"content\"/>',\n        \"</g>\"\n    ].join(\"\"),\n    initialize: function() {\n        this.listenTo(this, \"change:size\", this.updateSize);\n        this.listenTo(this, \"change:content\", this.updateContent);\n        this.updateSize(this, this.get(\"size\"));\n        this.updateContent(this, this.get(\"content\"));\n        Generic.prototype.initialize.apply(this, arguments);\n    },\n    updateSize: function(cell, size) {\n        // Selector `foreignObject' doesn't work across all browsers, we're using class selector instead.\n        // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.\n        this.attr({\n            \".fobj\": (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)({}, size),\n            div: {\n                style: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)({}, size)\n            }\n        });\n    },\n    updateContent: function(cell, content) {\n        if (svgForeignObjectSupported) {\n            // Content element is a <div> element.\n            this.attr({\n                \".content\": {\n                    html: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.sanitizeHTML)(content)\n                }\n            });\n        } else {\n            // Content element is a <text> element.\n            // SVG elements don't have innerHTML attribute.\n            this.attr({\n                \".content\": {\n                    text: content\n                }\n            });\n        }\n    },\n    // Here for backwards compatibility:\n    setForeignObjectSize: function() {\n        this.updateSize.apply(this, arguments);\n    },\n    // Here for backwards compatibility:\n    setDivContent: function() {\n        this.updateContent.apply(this, arguments);\n    }\n});\n// TextBlockView implements the fallback for IE when no foreignObject exists and\n// the text needs to be manually broken.\nconst TextBlockView = _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.extend({\n    presentationAttributes: svgForeignObjectSupported ? _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.presentationAttributes : _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.addPresentationAttributes({\n        content: [\n            \"CONTENT\"\n        ],\n        size: [\n            \"CONTENT\"\n        ]\n    }),\n    initFlag: [\n        \"RENDER\",\n        \"CONTENT\"\n    ],\n    confirmUpdate: function() {\n        var flags = _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.confirmUpdate.apply(this, arguments);\n        if (this.hasFlag(flags, \"CONTENT\")) {\n            this.updateContent(this.model);\n            flags = this.removeFlag(flags, \"CONTENT\");\n        }\n        return flags;\n    },\n    update: function(_, renderingOnlyAttrs) {\n        var model = this.model;\n        if (!svgForeignObjectSupported) {\n            // Update everything but the content first.\n            var noTextAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.omit)(renderingOnlyAttrs || model.get(\"attrs\"), \".content\");\n            _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.update.call(this, model, noTextAttrs);\n            if (!renderingOnlyAttrs || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.has)(renderingOnlyAttrs, \".content\")) {\n                // Update the content itself.\n                this.updateContent(model, renderingOnlyAttrs);\n            }\n        } else {\n            _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.update.call(this, model, renderingOnlyAttrs);\n        }\n    },\n    updateContent: function(cell, renderingOnlyAttrs) {\n        // Create copy of the text attributes\n        var textAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.merge)({}, (renderingOnlyAttrs || cell.get(\"attrs\"))[\".content\"]);\n        textAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.omit)(textAttrs, \"text\");\n        // Break the content to fit the element size taking into account the attributes\n        // set on the model.\n        var text = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.breakText)(cell.get(\"content\"), cell.get(\"size\"), textAttrs, {\n            // measuring sandbox svg document\n            svgDocument: this.paper.svg\n        });\n        // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}\n        var attrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.setByPath)({}, \".content\", textAttrs, \"/\");\n        // Replace text attribute with the one we just processed.\n        attrs[\".content\"].text = text;\n        // Update the view using renderingOnlyAttributes parameter.\n        _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.update.call(this, cell, attrs);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvc2hhcGVzL2Jhc2ljLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDUTtBQUM0QztBQUMxRDtBQUVoQyxNQUFNVSxVQUFVVixxREFBT0EsQ0FBQ1csTUFBTSxDQUFDLGlCQUFpQjtJQUNuREMsT0FBTztRQUNILEtBQUs7WUFBRUMsTUFBTTtZQUFXQyxRQUFRO1FBQU87SUFDM0M7QUFDSixHQUFHO0FBRUksTUFBTUMsT0FBT0wsUUFBUUMsTUFBTSxDQUFDLGNBQWM7SUFDN0NDLE9BQU87UUFDSCxRQUFRO1lBQ0pDLE1BQU07WUFDTkMsUUFBUTtZQUNSRSxPQUFPO1lBQ1BDLFFBQVE7UUFDWjtRQUNBLFFBQVE7WUFDSkosTUFBTTtZQUNOSyxNQUFNO1lBQ04sYUFBYTtZQUNiLFNBQVM7WUFDVCxTQUFTO1lBQ1QsZUFBZTtZQUNmLGVBQWU7WUFDZixlQUFlO1FBQ25CO0lBQ0o7QUFDSixHQUFHO0lBQ0NDLFFBQVE7QUFDWixHQUFHO0FBRUksTUFBTUMsV0FBV25CLDZEQUFXQSxDQUFDb0IsTUFBTSxDQUFDO0lBRXZDQyx3QkFBd0JyQiw2REFBV0EsQ0FBQ3NCLHlCQUF5QixDQUFDO1FBQzFELHdFQUF3RTtRQUN4RSx5Q0FBeUM7UUFDekNYLE9BQU87WUFBQztTQUFRO0lBQ3BCO0lBRUFZLGVBQWU7UUFDWCxJQUFJQyxRQUFReEIsNkRBQVdBLENBQUN5QixTQUFTLENBQUNGLGFBQWEsQ0FBQ0csS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDNUQsSUFBSSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0osT0FBTyxVQUFVO1lBQzlCLElBQUksQ0FBQ0ssTUFBTTtZQUNYTCxRQUFRLElBQUksQ0FBQ00sVUFBVSxDQUFDTixPQUFPO1FBQ25DO1FBQ0EsT0FBT0E7SUFDWDtBQUNKLEdBQUc7QUFFSSxNQUFNTyxPQUFPdEIsUUFBUUMsTUFBTSxDQUFDLGNBQWM7SUFDN0NDLE9BQU87UUFDSCxR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RDtRQUMzRGpCLDZEQUFXQSxDQUFDeUIsU0FBUyxDQUFDMEMsTUFBTSxDQUFDSSxJQUFJLENBQUMsSUFBSSxFQUFFZCxNQUFNOUM7SUFDbEQ7QUFDSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvc2hhcGVzL2Jhc2ljLm1qcz9jOWU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9kaWEvRWxlbWVudC5tanMnO1xuaW1wb3J0IHsgRWxlbWVudFZpZXcgfSBmcm9tICcuLi9kaWEvRWxlbWVudFZpZXcubWpzJztcbmltcG9ydCB7IG9taXQsIGFzc2lnbiwgc2FuaXRpemVIVE1MLCBtZXJnZSwgaGFzLCBicmVha1RleHQsIHNldEJ5UGF0aCB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudi9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgR2VuZXJpYyA9IEVsZW1lbnQuZGVmaW5lKCdiYXNpYy5HZW5lcmljJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgICcuJzogeyBmaWxsOiAnI2ZmZmZmZicsIHN0cm9rZTogJ25vbmUnIH1cbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFJlY3QgPSBHZW5lcmljLmRlZmluZSgnYmFzaWMuUmVjdCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgICAncmVjdCc6IHtcbiAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICAgIGhlaWdodDogNjBcbiAgICAgICAgfSxcbiAgICAgICAgJ3RleHQnOiB7XG4gICAgICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICdmb250LXNpemUnOiAxNCxcbiAgICAgICAgICAgICdyZWYteCc6IC41LFxuICAgICAgICAgICAgJ3JlZi15JzogLjUsXG4gICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICd5LWFsaWdubWVudCc6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0FyaWFsLCBoZWx2ZXRpY2EsIHNhbnMtc2VyaWYnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj48ZyBjbGFzcz1cInNjYWxhYmxlXCI+PHJlY3QvPjwvZz48dGV4dC8+PC9nPidcbn0pO1xuXG5leHBvcnQgY29uc3QgVGV4dFZpZXcgPSBFbGVtZW50Vmlldy5leHRlbmQoe1xuXG4gICAgcHJlc2VudGF0aW9uQXR0cmlidXRlczogRWxlbWVudFZpZXcuYWRkUHJlc2VudGF0aW9uQXR0cmlidXRlcyh7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IHZpZXcgaXMgbm90IGF1dG9tYXRpY2FsbHkgcmUtc2NhbGVkIHRvIGZpdCB0aGUgbW9kZWwgc2l6ZVxuICAgICAgICAvLyB3aGVuIHRoZSBhdHRyaWJ1dGUgJ2F0dHJzJyBpcyBjaGFuZ2VkLlxuICAgICAgICBhdHRyczogWydTQ0FMRSddXG4gICAgfSksXG5cbiAgICBjb25maXJtVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gRWxlbWVudFZpZXcucHJvdG90eXBlLmNvbmZpcm1VcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFncywgJ1NDQUxFJykpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgJ1NDQUxFJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgVGV4dCA9IEdlbmVyaWMuZGVmaW5lKCdiYXNpYy5UZXh0Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgICd0ZXh0Jzoge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE4LFxuICAgICAgICAgICAgZmlsbDogJyMwMDAwMDAnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj48ZyBjbGFzcz1cInNjYWxhYmxlXCI+PHRleHQvPjwvZz48L2c+Jyxcbn0pO1xuXG5leHBvcnQgY29uc3QgQ2lyY2xlID0gR2VuZXJpYy5kZWZpbmUoJ2Jhc2ljLkNpcmNsZScsIHtcbiAgICBzaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiA2MCB9LFxuICAgIGF0dHJzOiB7XG4gICAgICAgICdjaXJjbGUnOiB7XG4gICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIHI6IDMwLFxuICAgICAgICAgICAgY3g6IDMwLFxuICAgICAgICAgICAgY3k6IDMwXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXh0Jzoge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE0LFxuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICdyZWYteCc6IC41LFxuICAgICAgICAgICAgJ3JlZi15JzogLjUsXG4gICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdBcmlhbCwgaGVsdmV0aWNhLCBzYW5zLXNlcmlmJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogJzxnIGNsYXNzPVwicm90YXRhYmxlXCI+PGcgY2xhc3M9XCJzY2FsYWJsZVwiPjxjaXJjbGUvPjwvZz48dGV4dC8+PC9nPicsXG59KTtcblxuZXhwb3J0IGNvbnN0IEVsbGlwc2UgPSBHZW5lcmljLmRlZmluZSgnYmFzaWMuRWxsaXBzZScsIHtcbiAgICBzaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiA0MCB9LFxuICAgIGF0dHJzOiB7XG4gICAgICAgICdlbGxpcHNlJzoge1xuICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICByeDogMzAsXG4gICAgICAgICAgICByeTogMjAsXG4gICAgICAgICAgICBjeDogMzAsXG4gICAgICAgICAgICBjeTogMjBcbiAgICAgICAgfSxcbiAgICAgICAgJ3RleHQnOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ3JlZi14JzogLjUsXG4gICAgICAgICAgICAncmVmLXknOiAuNSxcbiAgICAgICAgICAgICd5LWFsaWdubWVudCc6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0FyaWFsLCBoZWx2ZXRpY2EsIHNhbnMtc2VyaWYnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj48ZyBjbGFzcz1cInNjYWxhYmxlXCI+PGVsbGlwc2UvPjwvZz48dGV4dC8+PC9nPicsXG59KTtcblxuZXhwb3J0IGNvbnN0IFBvbHlnb24gPSBHZW5lcmljLmRlZmluZSgnYmFzaWMuUG9seWdvbicsIHtcbiAgICBzaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiA0MCB9LFxuICAgIGF0dHJzOiB7XG4gICAgICAgICdwb2x5Z29uJzoge1xuICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCdcbiAgICAgICAgfSxcbiAgICAgICAgJ3RleHQnOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ3JlZi14JzogLjUsXG4gICAgICAgICAgICAncmVmLWR5JzogMjAsXG4gICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdBcmlhbCwgaGVsdmV0aWNhLCBzYW5zLXNlcmlmJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogJzxnIGNsYXNzPVwicm90YXRhYmxlXCI+PGcgY2xhc3M9XCJzY2FsYWJsZVwiPjxwb2x5Z29uLz48L2c+PHRleHQvPjwvZz4nLFxufSk7XG5cbmV4cG9ydCBjb25zdCBQb2x5bGluZSA9IEdlbmVyaWMuZGVmaW5lKCdiYXNpYy5Qb2x5bGluZScsIHtcbiAgICBzaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiA0MCB9LFxuICAgIGF0dHJzOiB7XG4gICAgICAgICdwb2x5bGluZSc6IHtcbiAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXh0Jzoge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE0LFxuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICdyZWYteCc6IC41LFxuICAgICAgICAgICAgJ3JlZi1keSc6IDIwLFxuICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ21pZGRsZScsXG4gICAgICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnQXJpYWwsIGhlbHZldGljYSwgc2Fucy1zZXJpZidcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6ICc8ZyBjbGFzcz1cInJvdGF0YWJsZVwiPjxnIGNsYXNzPVwic2NhbGFibGVcIj48cG9seWxpbmUvPjwvZz48dGV4dC8+PC9nPicsXG59KTtcblxuZXhwb3J0IGNvbnN0IEltYWdlID0gR2VuZXJpYy5kZWZpbmUoJ2Jhc2ljLkltYWdlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgICd0ZXh0Jzoge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE0LFxuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICdyZWYteCc6IC41LFxuICAgICAgICAgICAgJ3JlZi1keSc6IDIwLFxuICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ21pZGRsZScsXG4gICAgICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnQXJpYWwsIGhlbHZldGljYSwgc2Fucy1zZXJpZidcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6ICc8ZyBjbGFzcz1cInJvdGF0YWJsZVwiPjxnIGNsYXNzPVwic2NhbGFibGVcIj48aW1hZ2UvPjwvZz48dGV4dC8+PC9nPicsXG59KTtcblxuZXhwb3J0IGNvbnN0IFBhdGggPSBHZW5lcmljLmRlZmluZSgnYmFzaWMuUGF0aCcsIHtcbiAgICBzaXplOiB7IHdpZHRoOiA2MCwgaGVpZ2h0OiA2MCB9LFxuICAgIGF0dHJzOiB7XG4gICAgICAgICdwYXRoJzoge1xuICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCdcbiAgICAgICAgfSxcbiAgICAgICAgJ3RleHQnOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ3JlZic6ICdwYXRoJyxcbiAgICAgICAgICAgICdyZWYteCc6IC41LFxuICAgICAgICAgICAgJ3JlZi1keSc6IDEwLFxuICAgICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0FyaWFsLCBoZWx2ZXRpY2EsIHNhbnMtc2VyaWYnXG4gICAgICAgIH1cbiAgICB9XG5cbn0sIHtcbiAgICBtYXJrdXA6ICc8ZyBjbGFzcz1cInJvdGF0YWJsZVwiPjxnIGNsYXNzPVwic2NhbGFibGVcIj48cGF0aC8+PC9nPjx0ZXh0Lz48L2c+Jyxcbn0pO1xuXG5leHBvcnQgY29uc3QgUmhvbWJ1cyA9IFBhdGguZGVmaW5lKCdiYXNpYy5SaG9tYnVzJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgICdwYXRoJzoge1xuICAgICAgICAgICAgZDogJ00gMzAgMCBMIDYwIDMwIDMwIDYwIDAgMzAgeidcbiAgICAgICAgfSxcbiAgICAgICAgJ3RleHQnOiB7XG4gICAgICAgICAgICAncmVmLXknOiAuNSxcbiAgICAgICAgICAgICdyZWYtZHknOiBudWxsLFxuICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ21pZGRsZSdcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBzdmdGb3JlaWduT2JqZWN0U3VwcG9ydGVkID0gZW52LnRlc3QoJ3N2Z2ZvcmVpZ25vYmplY3QnKTtcblxuZXhwb3J0IGNvbnN0IFRleHRCbG9jayA9IEdlbmVyaWMuZGVmaW5lKCdiYXNpYy5UZXh0QmxvY2snLCB7XG4gICAgLy8gc2VlIGpvaW50LmNzcyBmb3IgbW9yZSBlbGVtZW50IHN0eWxlc1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgd2lkdGg6IDgwLFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE0LFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0FyaWFsLCBoZWx2ZXRpY2EsIHNhbnMtc2VyaWYnXG4gICAgICAgIH0sXG4gICAgICAgICcuY29udGVudCc6IHtcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgJ3JlZi14JzogLjUsXG4gICAgICAgICAgICAncmVmLXknOiAuNSxcbiAgICAgICAgICAgICd5LWFsaWdubWVudCc6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZSdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250ZW50OiAnJ1xufSwge1xuICAgIG1hcmt1cDogW1xuICAgICAgICAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJzY2FsYWJsZVwiPjxyZWN0Lz48L2c+JyxcbiAgICAgICAgc3ZnRm9yZWlnbk9iamVjdFN1cHBvcnRlZFxuICAgICAgICAgICAgPyAnPGZvcmVpZ25PYmplY3QgY2xhc3M9XCJmb2JqXCI+PGJvZHkgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGRpdiBjbGFzcz1cImNvbnRlbnRcIi8+PC9ib2R5PjwvZm9yZWlnbk9iamVjdD4nXG4gICAgICAgICAgICA6ICc8dGV4dCBjbGFzcz1cImNvbnRlbnRcIi8+JyxcbiAgICAgICAgJzwvZz4nXG4gICAgXS5qb2luKCcnKSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcywgJ2NoYW5nZTpzaXplJywgdGhpcy51cGRhdGVTaXplKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCAnY2hhbmdlOmNvbnRlbnQnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUodGhpcywgdGhpcy5nZXQoJ3NpemUnKSk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGVudCh0aGlzLCB0aGlzLmdldCgnY29udGVudCcpKTtcbiAgICAgICAgR2VuZXJpYy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbihjZWxsLCBzaXplKSB7XG5cbiAgICAgICAgLy8gU2VsZWN0b3IgYGZvcmVpZ25PYmplY3QnIGRvZXNuJ3Qgd29yayBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3ZSdyZSB1c2luZyBjbGFzcyBzZWxlY3RvciBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBoYXZlIHRvIGNsb25lIHNpemUgYXMgd2UgZG9uJ3Qgd2FudCBhdHRyaWJ1dGVzLmRpdi5zdHlsZSB0byBiZSBzYW1lIG9iamVjdCBhcyBhdHRyaWJ1dGVzLnNpemUuXG4gICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAnLmZvYmonOiBhc3NpZ24oe30sIHNpemUpLFxuICAgICAgICAgICAgZGl2OiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IGFzc2lnbih7fSwgc2l6ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKGNlbGwsIGNvbnRlbnQpIHtcblxuICAgICAgICBpZiAoc3ZnRm9yZWlnbk9iamVjdFN1cHBvcnRlZCkge1xuXG4gICAgICAgICAgICAvLyBDb250ZW50IGVsZW1lbnQgaXMgYSA8ZGl2PiBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5hdHRyKHtcbiAgICAgICAgICAgICAgICAnLmNvbnRlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHNhbml0aXplSFRNTChjb250ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIENvbnRlbnQgZWxlbWVudCBpcyBhIDx0ZXh0PiBlbGVtZW50LlxuICAgICAgICAgICAgLy8gU1ZHIGVsZW1lbnRzIGRvbid0IGhhdmUgaW5uZXJIVE1MIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAgICAgJy5jb250ZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gSGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG4gICAgc2V0Rm9yZWlnbk9iamVjdFNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBIZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbiAgICBzZXREaXZDb250ZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59KTtcblxuLy8gVGV4dEJsb2NrVmlldyBpbXBsZW1lbnRzIHRoZSBmYWxsYmFjayBmb3IgSUUgd2hlbiBubyBmb3JlaWduT2JqZWN0IGV4aXN0cyBhbmRcbi8vIHRoZSB0ZXh0IG5lZWRzIHRvIGJlIG1hbnVhbGx5IGJyb2tlbi5cbmV4cG9ydCBjb25zdCBUZXh0QmxvY2tWaWV3ID0gRWxlbWVudFZpZXcuZXh0ZW5kKHtcblxuICAgIHByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IHN2Z0ZvcmVpZ25PYmplY3RTdXBwb3J0ZWRcbiAgICAgICAgPyBFbGVtZW50Vmlldy5wcm90b3R5cGUucHJlc2VudGF0aW9uQXR0cmlidXRlc1xuICAgICAgICA6IEVsZW1lbnRWaWV3LmFkZFByZXNlbnRhdGlvbkF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgY29udGVudDogWydDT05URU5UJ10sXG4gICAgICAgICAgICBzaXplOiBbJ0NPTlRFTlQnXVxuICAgICAgICB9KSxcblxuICAgIGluaXRGbGFnOiBbJ1JFTkRFUicsICdDT05URU5UJ10sXG5cbiAgICBjb25maXJtVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gRWxlbWVudFZpZXcucHJvdG90eXBlLmNvbmZpcm1VcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFncywgJ0NPTlRFTlQnKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50KHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsICdDT05URU5UJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKF8sIHJlbmRlcmluZ09ubHlBdHRycykge1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgICAgICAgaWYgKCFzdmdGb3JlaWduT2JqZWN0U3VwcG9ydGVkKSB7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBldmVyeXRoaW5nIGJ1dCB0aGUgY29udGVudCBmaXJzdC5cbiAgICAgICAgICAgIHZhciBub1RleHRBdHRycyA9IG9taXQocmVuZGVyaW5nT25seUF0dHJzIHx8IG1vZGVsLmdldCgnYXR0cnMnKSwgJy5jb250ZW50Jyk7XG4gICAgICAgICAgICBFbGVtZW50Vmlldy5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbW9kZWwsIG5vVGV4dEF0dHJzKTtcblxuICAgICAgICAgICAgaWYgKCFyZW5kZXJpbmdPbmx5QXR0cnMgfHwgaGFzKHJlbmRlcmluZ09ubHlBdHRycywgJy5jb250ZW50JykpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgaXRzZWxmLlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudChtb2RlbCwgcmVuZGVyaW5nT25seUF0dHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBFbGVtZW50Vmlldy5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbW9kZWwsIHJlbmRlcmluZ09ubHlBdHRycyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlQ29udGVudDogZnVuY3Rpb24oY2VsbCwgcmVuZGVyaW5nT25seUF0dHJzKSB7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGNvcHkgb2YgdGhlIHRleHQgYXR0cmlidXRlc1xuICAgICAgICB2YXIgdGV4dEF0dHJzID0gbWVyZ2Uoe30sIChyZW5kZXJpbmdPbmx5QXR0cnMgfHwgY2VsbC5nZXQoJ2F0dHJzJykpWycuY29udGVudCddKTtcblxuICAgICAgICB0ZXh0QXR0cnMgPSBvbWl0KHRleHRBdHRycywgJ3RleHQnKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgY29udGVudCB0byBmaXQgdGhlIGVsZW1lbnQgc2l6ZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBhdHRyaWJ1dGVzXG4gICAgICAgIC8vIHNldCBvbiB0aGUgbW9kZWwuXG4gICAgICAgIHZhciB0ZXh0ID0gYnJlYWtUZXh0KGNlbGwuZ2V0KCdjb250ZW50JyksIGNlbGwuZ2V0KCdzaXplJyksIHRleHRBdHRycywge1xuICAgICAgICAgICAgLy8gbWVhc3VyaW5nIHNhbmRib3ggc3ZnIGRvY3VtZW50XG4gICAgICAgICAgICBzdmdEb2N1bWVudDogdGhpcy5wYXBlci5zdmdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGF0dHJzIHdpdGggc2FtZSBzdHJ1Y3R1cmUgYXMgdGhlIG1vZGVsIGF0dHJzIHsgdGV4dDogeyAqdGV4dEF0dHJpYnV0ZXMqIH19XG4gICAgICAgIHZhciBhdHRycyA9IHNldEJ5UGF0aCh7fSwgJy5jb250ZW50JywgdGV4dEF0dHJzLCAnLycpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGV4dCBhdHRyaWJ1dGUgd2l0aCB0aGUgb25lIHdlIGp1c3QgcHJvY2Vzc2VkLlxuICAgICAgICBhdHRyc1snLmNvbnRlbnQnXS50ZXh0ID0gdGV4dDtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZpZXcgdXNpbmcgcmVuZGVyaW5nT25seUF0dHJpYnV0ZXMgcGFyYW1ldGVyLlxuICAgICAgICBFbGVtZW50Vmlldy5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgY2VsbCwgYXR0cnMpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbIkVsZW1lbnQiLCJFbGVtZW50VmlldyIsIm9taXQiLCJhc3NpZ24iLCJzYW5pdGl6ZUhUTUwiLCJtZXJnZSIsImhhcyIsImJyZWFrVGV4dCIsInNldEJ5UGF0aCIsImVudiIsIkdlbmVyaWMiLCJkZWZpbmUiLCJhdHRycyIsImZpbGwiLCJzdHJva2UiLCJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJ0ZXh0IiwibWFya3VwIiwiVGV4dFZpZXciLCJleHRlbmQiLCJwcmVzZW50YXRpb25BdHRyaWJ1dGVzIiwiYWRkUHJlc2VudGF0aW9uQXR0cmlidXRlcyIsImNvbmZpcm1VcGRhdGUiLCJmbGFncyIsInByb3RvdHlwZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiaGFzRmxhZyIsInJlc2l6ZSIsInJlbW92ZUZsYWciLCJUZXh0IiwiQ2lyY2xlIiwic2l6ZSIsInIiLCJjeCIsImN5IiwiRWxsaXBzZSIsInJ4IiwicnkiLCJQb2x5Z29uIiwiUG9seWxpbmUiLCJJbWFnZSIsIlBhdGgiLCJSaG9tYnVzIiwiZCIsInN2Z0ZvcmVpZ25PYmplY3RTdXBwb3J0ZWQiLCJ0ZXN0IiwiVGV4dEJsb2NrIiwicmVjdCIsImNvbnRlbnQiLCJqb2luIiwiaW5pdGlhbGl6ZSIsImxpc3RlblRvIiwidXBkYXRlU2l6ZSIsInVwZGF0ZUNvbnRlbnQiLCJnZXQiLCJjZWxsIiwiYXR0ciIsImRpdiIsInN0eWxlIiwiaHRtbCIsInNldEZvcmVpZ25PYmplY3RTaXplIiwic2V0RGl2Q29udGVudCIsIlRleHRCbG9ja1ZpZXciLCJpbml0RmxhZyIsIm1vZGVsIiwidXBkYXRlIiwiXyIsInJlbmRlcmluZ09ubHlBdHRycyIsIm5vVGV4dEF0dHJzIiwiY2FsbCIsInRleHRBdHRycyIsInN2Z0RvY3VtZW50IiwicGFwZXIiLCJzdmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/shapes/basic.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/shapes/uml.mjs":
/*!*************************************************!*\
  !*** ./node_modules/jointjs/src/shapes/uml.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Abstract: () => (/* binding */ Abstract),\n/* harmony export */   AbstractView: () => (/* binding */ AbstractView),\n/* harmony export */   Aggregation: () => (/* binding */ Aggregation),\n/* harmony export */   Association: () => (/* binding */ Association),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   ClassView: () => (/* binding */ ClassView),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   EndState: () => (/* binding */ EndState),\n/* harmony export */   Generalization: () => (/* binding */ Generalization),\n/* harmony export */   Implementation: () => (/* binding */ Implementation),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   InterfaceView: () => (/* binding */ InterfaceView),\n/* harmony export */   StartState: () => (/* binding */ StartState),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   Transition: () => (/* binding */ Transition)\n/* harmony export */ });\n/* harmony import */ var _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/ElementView.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/ElementView.mjs\");\n/* harmony import */ var _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dia/Link.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Link.mjs\");\n/* harmony import */ var _basic_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic.mjs */ \"(ssr)/./node_modules/jointjs/src/shapes/basic.mjs\");\n\n\n\nconst Class = _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Generic.define(\"uml.Class\", {\n    attrs: {\n        rect: {\n            \"width\": 200\n        },\n        \".uml-class-name-rect\": {\n            \"stroke\": \"black\",\n            \"stroke-width\": 2,\n            \"fill\": \"#3498db\"\n        },\n        \".uml-class-attrs-rect\": {\n            \"stroke\": \"black\",\n            \"stroke-width\": 2,\n            \"fill\": \"#2980b9\"\n        },\n        \".uml-class-methods-rect\": {\n            \"stroke\": \"black\",\n            \"stroke-width\": 2,\n            \"fill\": \"#2980b9\"\n        },\n        \".uml-class-name-text\": {\n            \"ref\": \".uml-class-name-rect\",\n            \"ref-y\": .5,\n            \"ref-x\": .5,\n            \"text-anchor\": \"middle\",\n            \"y-alignment\": \"middle\",\n            \"font-weight\": \"bold\",\n            \"fill\": \"black\",\n            \"font-size\": 12,\n            \"font-family\": \"Times New Roman\"\n        },\n        \".uml-class-attrs-text\": {\n            \"ref\": \".uml-class-attrs-rect\",\n            \"ref-y\": 5,\n            \"ref-x\": 5,\n            \"fill\": \"black\",\n            \"font-size\": 12,\n            \"font-family\": \"Times New Roman\"\n        },\n        \".uml-class-methods-text\": {\n            \"ref\": \".uml-class-methods-rect\",\n            \"ref-y\": 5,\n            \"ref-x\": 5,\n            \"fill\": \"black\",\n            \"font-size\": 12,\n            \"font-family\": \"Times New Roman\"\n        }\n    },\n    name: [],\n    attributes: [],\n    methods: []\n}, {\n    markup: [\n        '<g class=\"rotatable\">',\n        '<g class=\"scalable\">',\n        '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>',\n        \"</g>\",\n        '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>',\n        \"</g>\"\n    ].join(\"\"),\n    initialize: function() {\n        this.on(\"change:name change:attributes change:methods\", function() {\n            this.updateRectangles();\n            this.trigger(\"uml-update\");\n        }, this);\n        this.updateRectangles();\n        _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Generic.prototype.initialize.apply(this, arguments);\n    },\n    getClassName: function() {\n        return this.get(\"name\");\n    },\n    updateRectangles: function() {\n        var attrs = this.get(\"attrs\");\n        var rects = [\n            {\n                type: \"name\",\n                text: this.getClassName()\n            },\n            {\n                type: \"attrs\",\n                text: this.get(\"attributes\")\n            },\n            {\n                type: \"methods\",\n                text: this.get(\"methods\")\n            }\n        ];\n        var offsetY = 0;\n        rects.forEach(function(rect) {\n            var lines = Array.isArray(rect.text) ? rect.text : [\n                rect.text\n            ];\n            var rectHeight = lines.length * 20 + 20;\n            attrs[\".uml-class-\" + rect.type + \"-text\"].text = lines.join(\"\\n\");\n            attrs[\".uml-class-\" + rect.type + \"-rect\"].height = rectHeight;\n            attrs[\".uml-class-\" + rect.type + \"-rect\"].transform = \"translate(0,\" + offsetY + \")\";\n            offsetY += rectHeight;\n        });\n    }\n});\nconst ClassView = _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.extend({\n    initialize: function() {\n        _dia_ElementView_mjs__WEBPACK_IMPORTED_MODULE_1__.ElementView.prototype.initialize.apply(this, arguments);\n        this.listenTo(this.model, \"uml-update\", function() {\n            this.update();\n            this.resize();\n        });\n    }\n});\nconst Abstract = Class.define(\"uml.Abstract\", {\n    attrs: {\n        \".uml-class-name-rect\": {\n            fill: \"#e74c3c\"\n        },\n        \".uml-class-attrs-rect\": {\n            fill: \"#c0392b\"\n        },\n        \".uml-class-methods-rect\": {\n            fill: \"#c0392b\"\n        }\n    }\n}, {\n    getClassName: function() {\n        return [\n            \"<<Abstract>>\",\n            this.get(\"name\")\n        ];\n    }\n});\nconst AbstractView = ClassView;\nconst Interface = Class.define(\"uml.Interface\", {\n    attrs: {\n        \".uml-class-name-rect\": {\n            fill: \"#f1c40f\"\n        },\n        \".uml-class-attrs-rect\": {\n            fill: \"#f39c12\"\n        },\n        \".uml-class-methods-rect\": {\n            fill: \"#f39c12\"\n        }\n    }\n}, {\n    getClassName: function() {\n        return [\n            \"<<Interface>>\",\n            this.get(\"name\")\n        ];\n    }\n});\nconst InterfaceView = ClassView;\nconst Generalization = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Generalization\", {\n    attrs: {\n        \".marker-target\": {\n            d: \"M 20 0 L 0 10 L 20 20 z\",\n            fill: \"white\"\n        }\n    }\n});\nconst Implementation = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Implementation\", {\n    attrs: {\n        \".marker-target\": {\n            d: \"M 20 0 L 0 10 L 20 20 z\",\n            fill: \"white\"\n        },\n        \".connection\": {\n            \"stroke-dasharray\": \"3,3\"\n        }\n    }\n});\nconst Aggregation = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Aggregation\", {\n    attrs: {\n        \".marker-target\": {\n            d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n            fill: \"white\"\n        }\n    }\n});\nconst Composition = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Composition\", {\n    attrs: {\n        \".marker-target\": {\n            d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n            fill: \"black\"\n        }\n    }\n});\nconst Association = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Association\");\n// Statechart\nconst State = _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Generic.define(\"uml.State\", {\n    attrs: {\n        \".uml-state-body\": {\n            \"width\": 200,\n            \"height\": 200,\n            \"rx\": 10,\n            \"ry\": 10,\n            \"fill\": \"#ecf0f1\",\n            \"stroke\": \"#bdc3c7\",\n            \"stroke-width\": 3\n        },\n        \".uml-state-separator\": {\n            \"stroke\": \"#bdc3c7\",\n            \"stroke-width\": 2\n        },\n        \".uml-state-name\": {\n            \"ref\": \".uml-state-body\",\n            \"ref-x\": .5,\n            \"ref-y\": 5,\n            \"text-anchor\": \"middle\",\n            \"fill\": \"#000000\",\n            \"font-family\": \"Courier New\",\n            \"font-size\": 14\n        },\n        \".uml-state-events\": {\n            \"ref\": \".uml-state-separator\",\n            \"ref-x\": 5,\n            \"ref-y\": 5,\n            \"fill\": \"#000000\",\n            \"font-family\": \"Courier New\",\n            \"font-size\": 14\n        }\n    },\n    name: \"State\",\n    events: []\n}, {\n    markup: [\n        '<g class=\"rotatable\">',\n        '<g class=\"scalable\">',\n        '<rect class=\"uml-state-body\"/>',\n        \"</g>\",\n        '<path class=\"uml-state-separator\"/>',\n        '<text class=\"uml-state-name\"/>',\n        '<text class=\"uml-state-events\"/>',\n        \"</g>\"\n    ].join(\"\"),\n    initialize: function() {\n        this.on({\n            \"change:name\": this.updateName,\n            \"change:events\": this.updateEvents,\n            \"change:size\": this.updatePath\n        }, this);\n        this.updateName();\n        this.updateEvents();\n        this.updatePath();\n        _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Generic.prototype.initialize.apply(this, arguments);\n    },\n    updateName: function() {\n        this.attr(\".uml-state-name/text\", this.get(\"name\"));\n    },\n    updateEvents: function() {\n        this.attr(\".uml-state-events/text\", this.get(\"events\").join(\"\\n\"));\n    },\n    updatePath: function() {\n        var d = \"M 0 20 L \" + this.get(\"size\").width + \" 20\";\n        // We are using `silent: true` here because updatePath() is meant to be called\n        // on resize and there's no need to to update the element twice (`change:size`\n        // triggers also an update).\n        this.attr(\".uml-state-separator/d\", d, {\n            silent: true\n        });\n    }\n});\nconst StartState = _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Circle.define(\"uml.StartState\", {\n    type: \"uml.StartState\",\n    attrs: {\n        circle: {\n            \"fill\": \"#34495e\",\n            \"stroke\": \"#2c3e50\",\n            \"stroke-width\": 2,\n            \"rx\": 1\n        }\n    }\n});\nconst EndState = _basic_mjs__WEBPACK_IMPORTED_MODULE_0__.Generic.define(\"uml.EndState\", {\n    size: {\n        width: 20,\n        height: 20\n    },\n    attrs: {\n        \"circle.outer\": {\n            transform: \"translate(10, 10)\",\n            r: 10,\n            fill: \"#ffffff\",\n            stroke: \"#2c3e50\"\n        },\n        \"circle.inner\": {\n            transform: \"translate(10, 10)\",\n            r: 6,\n            fill: \"#34495e\"\n        }\n    }\n}, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>'\n});\nconst Transition = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_2__.Link.define(\"uml.Transition\", {\n    attrs: {\n        \".marker-target\": {\n            d: \"M 10 0 L 0 5 L 10 10 z\",\n            fill: \"#34495e\",\n            stroke: \"#2c3e50\"\n        },\n        \".connection\": {\n            stroke: \"#2c3e50\"\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvc2hhcGVzL3VtbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ2Q7QUFDTztBQUV2QyxNQUFNSSxRQUFRRiwrQ0FBT0EsQ0FBQ0csTUFBTSxDQUFDLGFBQWE7SUFDN0NDLE9BQU87UUFDSEMsTUFBTTtZQUFFLFNBQVM7UUFBSTtRQUVyQix3QkFBd0I7WUFBRSxVQUFVO1lBQVMsZ0JBQWdCO1lBQUcsUUFBUTtRQUFVO1FBQ2xGLHlCQUF5QjtZQUFFLFVBQVU7WUFBUyxnQkFBZ0I7WUFBRyxRQUFRO1FBQVU7UUFDbkYsMkJBQTJCO1lBQUUsVUFBVTtZQUFTLGdCQUFnQjtZQUFHLFFBQVE7UUFBVTtRQUVyRix3QkFBd0I7WUFDcEIsT0FBTztZQUNQLFNBQVM7WUFDVCxTQUFTO1lBQ1QsZUFBZTtZQUNmLGVBQWU7WUFDZixlQUFlO1lBQ2YsUUFBUTtZQUNSLGFBQWE7WUFDYixlQUFlO1FBQ25CO1FBQ0EseUJBQXlCO1lBQ3JCLE9BQU87WUFBeUIsU0FBUztZQUFHLFNBQVM7WUFDckQsUUFBUTtZQUFTLGFBQWE7WUFBSSxlQUFlO1FBQ3JEO1FBQ0EsMkJBQTJCO1lBQ3ZCLE9BQU87WUFBMkIsU0FBUztZQUFHLFNBQVM7WUFDdkQsUUFBUTtZQUFTLGFBQWE7WUFBSSxlQUFlO1FBQ3JEO0lBQ0o7SUFFQUMsTUFBTSxFQUFFO0lBQ1JDLFlBQVksRUFBRTtJQUNkQyxTQUFTLEVBQUU7QUFDZixHQUFHO0lBQ0NDLFFBQVE7UUFDSjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSCxDQUFDQyxJQUFJLENBQUM7SUFFUEMsWUFBWTtRQUVSLElBQUksQ0FBQ0MsRUFBRSxDQUFDLGdEQUFnRDtZQUNwRCxJQUFJLENBQUNDLGdCQUFnQjtZQUNyQixJQUFJLENBQUNDLE9BQU8sQ0FBQztRQUNqQixHQUFHLElBQUk7UUFFUCxJQUFJLENBQUNELGdCQUFnQjtRQUVyQmIsK0NBQU9BLENB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K0NBQUlBLENBQUNJLE1BQU0sQ0FBQyxrQkFBa0I7SUFDcERDLE9BQU87UUFDSCxrQkFBa0I7WUFBRXdDLEdBQUc7WUFBMEJMLE1BQU07WUFBV3VCLFFBQVE7UUFBVTtRQUNwRixlQUFlO1lBQUVBLFFBQVE7UUFBVTtJQUN2QztBQUNKLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy9zaGFwZXMvdW1sLm1qcz8yNzFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRWaWV3IH0gZnJvbSAnLi4vZGlhL0VsZW1lbnRWaWV3Lm1qcyc7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAnLi4vZGlhL0xpbmsubWpzJztcbmltcG9ydCB7IEdlbmVyaWMsIENpcmNsZSB9IGZyb20gJy4vYmFzaWMubWpzJztcblxuZXhwb3J0IGNvbnN0IENsYXNzID0gR2VuZXJpYy5kZWZpbmUoJ3VtbC5DbGFzcycsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByZWN0OiB7ICd3aWR0aCc6IDIwMCB9LFxuXG4gICAgICAgICcudW1sLWNsYXNzLW5hbWUtcmVjdCc6IHsgJ3N0cm9rZSc6ICdibGFjaycsICdzdHJva2Utd2lkdGgnOiAyLCAnZmlsbCc6ICcjMzQ5OGRiJyB9LFxuICAgICAgICAnLnVtbC1jbGFzcy1hdHRycy1yZWN0JzogeyAnc3Ryb2tlJzogJ2JsYWNrJywgJ3N0cm9rZS13aWR0aCc6IDIsICdmaWxsJzogJyMyOTgwYjknIH0sXG4gICAgICAgICcudW1sLWNsYXNzLW1ldGhvZHMtcmVjdCc6IHsgJ3N0cm9rZSc6ICdibGFjaycsICdzdHJva2Utd2lkdGgnOiAyLCAnZmlsbCc6ICcjMjk4MGI5JyB9LFxuXG4gICAgICAgICcudW1sLWNsYXNzLW5hbWUtdGV4dCc6IHtcbiAgICAgICAgICAgICdyZWYnOiAnLnVtbC1jbGFzcy1uYW1lLXJlY3QnLFxuICAgICAgICAgICAgJ3JlZi15JzogLjUsXG4gICAgICAgICAgICAncmVmLXgnOiAuNSxcbiAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ21pZGRsZScsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAgICAgICAnZmlsbCc6ICdibGFjaycsXG4gICAgICAgICAgICAnZm9udC1zaXplJzogMTIsXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnVGltZXMgTmV3IFJvbWFuJ1xuICAgICAgICB9LFxuICAgICAgICAnLnVtbC1jbGFzcy1hdHRycy10ZXh0Jzoge1xuICAgICAgICAgICAgJ3JlZic6ICcudW1sLWNsYXNzLWF0dHJzLXJlY3QnLCAncmVmLXknOiA1LCAncmVmLXgnOiA1LFxuICAgICAgICAgICAgJ2ZpbGwnOiAnYmxhY2snLCAnZm9udC1zaXplJzogMTIsICdmb250LWZhbWlseSc6ICdUaW1lcyBOZXcgUm9tYW4nXG4gICAgICAgIH0sXG4gICAgICAgICcudW1sLWNsYXNzLW1ldGhvZHMtdGV4dCc6IHtcbiAgICAgICAgICAgICdyZWYnOiAnLnVtbC1jbGFzcy1tZXRob2RzLXJlY3QnLCAncmVmLXknOiA1LCAncmVmLXgnOiA1LFxuICAgICAgICAgICAgJ2ZpbGwnOiAnYmxhY2snLCAnZm9udC1zaXplJzogMTIsICdmb250LWZhbWlseSc6ICdUaW1lcyBOZXcgUm9tYW4nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmFtZTogW10sXG4gICAgYXR0cmlidXRlczogW10sXG4gICAgbWV0aG9kczogW11cbn0sIHtcbiAgICBtYXJrdXA6IFtcbiAgICAgICAgJzxnIGNsYXNzPVwicm90YXRhYmxlXCI+JyxcbiAgICAgICAgJzxnIGNsYXNzPVwic2NhbGFibGVcIj4nLFxuICAgICAgICAnPHJlY3QgY2xhc3M9XCJ1bWwtY2xhc3MtbmFtZS1yZWN0XCIvPjxyZWN0IGNsYXNzPVwidW1sLWNsYXNzLWF0dHJzLXJlY3RcIi8+PHJlY3QgY2xhc3M9XCJ1bWwtY2xhc3MtbWV0aG9kcy1yZWN0XCIvPicsXG4gICAgICAgICc8L2c+JyxcbiAgICAgICAgJzx0ZXh0IGNsYXNzPVwidW1sLWNsYXNzLW5hbWUtdGV4dFwiLz48dGV4dCBjbGFzcz1cInVtbC1jbGFzcy1hdHRycy10ZXh0XCIvPjx0ZXh0IGNsYXNzPVwidW1sLWNsYXNzLW1ldGhvZHMtdGV4dFwiLz4nLFxuICAgICAgICAnPC9nPidcbiAgICBdLmpvaW4oJycpLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5vbignY2hhbmdlOm5hbWUgY2hhbmdlOmF0dHJpYnV0ZXMgY2hhbmdlOm1ldGhvZHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVjdGFuZ2xlcygpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd1bWwtdXBkYXRlJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlUmVjdGFuZ2xlcygpO1xuXG4gICAgICAgIEdlbmVyaWMucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCduYW1lJyk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlY3RhbmdsZXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0KCdhdHRycycpO1xuXG4gICAgICAgIHZhciByZWN0cyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogJ25hbWUnLCB0ZXh0OiB0aGlzLmdldENsYXNzTmFtZSgpIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdhdHRycycsIHRleHQ6IHRoaXMuZ2V0KCdhdHRyaWJ1dGVzJykgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ21ldGhvZHMnLCB0ZXh0OiB0aGlzLmdldCgnbWV0aG9kcycpIH1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgb2Zmc2V0WSA9IDA7XG5cbiAgICAgICAgcmVjdHMuZm9yRWFjaChmdW5jdGlvbihyZWN0KSB7XG5cbiAgICAgICAgICAgIHZhciBsaW5lcyA9IEFycmF5LmlzQXJyYXkocmVjdC50ZXh0KSA/IHJlY3QudGV4dCA6IFtyZWN0LnRleHRdO1xuICAgICAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSBsaW5lcy5sZW5ndGggKiAyMCArIDIwO1xuXG4gICAgICAgICAgICBhdHRyc1snLnVtbC1jbGFzcy0nICsgcmVjdC50eXBlICsgJy10ZXh0J10udGV4dCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgYXR0cnNbJy51bWwtY2xhc3MtJyArIHJlY3QudHlwZSArICctcmVjdCddLmhlaWdodCA9IHJlY3RIZWlnaHQ7XG4gICAgICAgICAgICBhdHRyc1snLnVtbC1jbGFzcy0nICsgcmVjdC50eXBlICsgJy1yZWN0J10udHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBvZmZzZXRZICsgJyknO1xuXG4gICAgICAgICAgICBvZmZzZXRZICs9IHJlY3RIZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBjb25zdCBDbGFzc1ZpZXcgPSBFbGVtZW50Vmlldy5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgRWxlbWVudFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICd1bWwtdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBBYnN0cmFjdCA9IENsYXNzLmRlZmluZSgndW1sLkFic3RyYWN0Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgICcudW1sLWNsYXNzLW5hbWUtcmVjdCc6IHsgZmlsbDogJyNlNzRjM2MnIH0sXG4gICAgICAgICcudW1sLWNsYXNzLWF0dHJzLXJlY3QnOiB7IGZpbGw6ICcjYzAzOTJiJyB9LFxuICAgICAgICAnLnVtbC1jbGFzcy1tZXRob2RzLXJlY3QnOiB7IGZpbGw6ICcjYzAzOTJiJyB9XG4gICAgfVxufSwge1xuXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFsnPDxBYnN0cmFjdD4+JywgdGhpcy5nZXQoJ25hbWUnKV07XG4gICAgfVxuXG59KTtcbmV4cG9ydCBjb25zdCBBYnN0cmFjdFZpZXcgPSBDbGFzc1ZpZXc7XG5cbmV4cG9ydCBjb25zdCBJbnRlcmZhY2UgPSBDbGFzcy5kZWZpbmUoJ3VtbC5JbnRlcmZhY2UnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgJy51bWwtY2xhc3MtbmFtZS1yZWN0JzogeyBmaWxsOiAnI2YxYzQwZicgfSxcbiAgICAgICAgJy51bWwtY2xhc3MtYXR0cnMtcmVjdCc6IHsgZmlsbDogJyNmMzljMTInIH0sXG4gICAgICAgICcudW1sLWNsYXNzLW1ldGhvZHMtcmVjdCc6IHsgZmlsbDogJyNmMzljMTInIH1cbiAgICB9XG59LCB7XG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFsnPDxJbnRlcmZhY2U+PicsIHRoaXMuZ2V0KCduYW1lJyldO1xuICAgIH1cbn0pO1xuZXhwb3J0IGNvbnN0IEludGVyZmFjZVZpZXcgPSBDbGFzc1ZpZXc7XG5cbmV4cG9ydCBjb25zdCBHZW5lcmFsaXphdGlvbiA9IExpbmsuZGVmaW5lKCd1bWwuR2VuZXJhbGl6YXRpb24nLCB7XG4gICAgYXR0cnM6IHsgJy5tYXJrZXItdGFyZ2V0JzogeyBkOiAnTSAyMCAwIEwgMCAxMCBMIDIwIDIwIHonLCBmaWxsOiAnd2hpdGUnIH19XG59KTtcblxuZXhwb3J0IGNvbnN0IEltcGxlbWVudGF0aW9uID0gTGluay5kZWZpbmUoJ3VtbC5JbXBsZW1lbnRhdGlvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgICAnLm1hcmtlci10YXJnZXQnOiB7IGQ6ICdNIDIwIDAgTCAwIDEwIEwgMjAgMjAgeicsIGZpbGw6ICd3aGl0ZScgfSxcbiAgICAgICAgJy5jb25uZWN0aW9uJzogeyAnc3Ryb2tlLWRhc2hhcnJheSc6ICczLDMnIH1cbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IEFnZ3JlZ2F0aW9uID0gTGluay5kZWZpbmUoJ3VtbC5BZ2dyZWdhdGlvbicsIHtcbiAgICBhdHRyczogeyAnLm1hcmtlci10YXJnZXQnOiB7IGQ6ICdNIDQwIDEwIEwgMjAgMjAgTCAwIDEwIEwgMjAgMCB6JywgZmlsbDogJ3doaXRlJyB9fVxufSk7XG5cbmV4cG9ydCBjb25zdCBDb21wb3NpdGlvbiA9IExpbmsuZGVmaW5lKCd1bWwuQ29tcG9zaXRpb24nLCB7XG4gICAgYXR0cnM6IHsgJy5tYXJrZXItdGFyZ2V0JzogeyBkOiAnTSA0MCAxMCBMIDIwIDIwIEwgMCAxMCBMIDIwIDAgeicsIGZpbGw6ICdibGFjaycgfX1cbn0pO1xuXG5leHBvcnQgY29uc3QgQXNzb2NpYXRpb24gPSBMaW5rLmRlZmluZSgndW1sLkFzc29jaWF0aW9uJyk7XG5cbi8vIFN0YXRlY2hhcnRcblxuZXhwb3J0IGNvbnN0IFN0YXRlID0gR2VuZXJpYy5kZWZpbmUoJ3VtbC5TdGF0ZScsIHtcbiAgICBhdHRyczoge1xuICAgICAgICAnLnVtbC1zdGF0ZS1ib2R5Jzoge1xuICAgICAgICAgICAgJ3dpZHRoJzogMjAwLCAnaGVpZ2h0JzogMjAwLCAncngnOiAxMCwgJ3J5JzogMTAsXG4gICAgICAgICAgICAnZmlsbCc6ICcjZWNmMGYxJywgJ3N0cm9rZSc6ICcjYmRjM2M3JywgJ3N0cm9rZS13aWR0aCc6IDNcbiAgICAgICAgfSxcbiAgICAgICAgJy51bWwtc3RhdGUtc2VwYXJhdG9yJzoge1xuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjYmRjM2M3JywgJ3N0cm9rZS13aWR0aCc6IDJcbiAgICAgICAgfSxcbiAgICAgICAgJy51bWwtc3RhdGUtbmFtZSc6IHtcbiAgICAgICAgICAgICdyZWYnOiAnLnVtbC1zdGF0ZS1ib2R5JywgJ3JlZi14JzogLjUsICdyZWYteSc6IDUsICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCcsICdmb250LWZhbWlseSc6ICdDb3VyaWVyIE5ldycsICdmb250LXNpemUnOiAxNFxuICAgICAgICB9LFxuICAgICAgICAnLnVtbC1zdGF0ZS1ldmVudHMnOiB7XG4gICAgICAgICAgICAncmVmJzogJy51bWwtc3RhdGUtc2VwYXJhdG9yJywgJ3JlZi14JzogNSwgJ3JlZi15JzogNSxcbiAgICAgICAgICAgICdmaWxsJzogJyMwMDAwMDAnLCAnZm9udC1mYW1pbHknOiAnQ291cmllciBOZXcnLCAnZm9udC1zaXplJzogMTRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBuYW1lOiAnU3RhdGUnLFxuICAgIGV2ZW50czogW11cblxufSwge1xuICAgIG1hcmt1cDogW1xuICAgICAgICAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj4nLFxuICAgICAgICAnPGcgY2xhc3M9XCJzY2FsYWJsZVwiPicsXG4gICAgICAgICc8cmVjdCBjbGFzcz1cInVtbC1zdGF0ZS1ib2R5XCIvPicsXG4gICAgICAgICc8L2c+JyxcbiAgICAgICAgJzxwYXRoIGNsYXNzPVwidW1sLXN0YXRlLXNlcGFyYXRvclwiLz4nLFxuICAgICAgICAnPHRleHQgY2xhc3M9XCJ1bWwtc3RhdGUtbmFtZVwiLz4nLFxuICAgICAgICAnPHRleHQgY2xhc3M9XCJ1bWwtc3RhdGUtZXZlbnRzXCIvPicsXG4gICAgICAgICc8L2c+J1xuICAgIF0uam9pbignJyksXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLm9uKHtcbiAgICAgICAgICAgICdjaGFuZ2U6bmFtZSc6IHRoaXMudXBkYXRlTmFtZSxcbiAgICAgICAgICAgICdjaGFuZ2U6ZXZlbnRzJzogdGhpcy51cGRhdGVFdmVudHMsXG4gICAgICAgICAgICAnY2hhbmdlOnNpemUnOiB0aGlzLnVwZGF0ZVBhdGhcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVOYW1lKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuXG4gICAgICAgIEdlbmVyaWMucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlTmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hdHRyKCcudW1sLXN0YXRlLW5hbWUvdGV4dCcsIHRoaXMuZ2V0KCduYW1lJykpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXR0cignLnVtbC1zdGF0ZS1ldmVudHMvdGV4dCcsIHRoaXMuZ2V0KCdldmVudHMnKS5qb2luKCdcXG4nKSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVBhdGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkID0gJ00gMCAyMCBMICcgKyB0aGlzLmdldCgnc2l6ZScpLndpZHRoICsgJyAyMCc7XG5cbiAgICAgICAgLy8gV2UgYXJlIHVzaW5nIGBzaWxlbnQ6IHRydWVgIGhlcmUgYmVjYXVzZSB1cGRhdGVQYXRoKCkgaXMgbWVhbnQgdG8gYmUgY2FsbGVkXG4gICAgICAgIC8vIG9uIHJlc2l6ZSBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHRvIHVwZGF0ZSB0aGUgZWxlbWVudCB0d2ljZSAoYGNoYW5nZTpzaXplYFxuICAgICAgICAvLyB0cmlnZ2VycyBhbHNvIGFuIHVwZGF0ZSkuXG4gICAgICAgIHRoaXMuYXR0cignLnVtbC1zdGF0ZS1zZXBhcmF0b3IvZCcsIGQsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgU3RhcnRTdGF0ZSA9IENpcmNsZS5kZWZpbmUoJ3VtbC5TdGFydFN0YXRlJywge1xuICAgIHR5cGU6ICd1bWwuU3RhcnRTdGF0ZScsXG4gICAgYXR0cnM6IHsgY2lyY2xlOiB7ICdmaWxsJzogJyMzNDQ5NWUnLCAnc3Ryb2tlJzogJyMyYzNlNTAnLCAnc3Ryb2tlLXdpZHRoJzogMiwgJ3J4JzogMSB9fVxufSk7XG5cbmV4cG9ydCBjb25zdCBFbmRTdGF0ZSA9IEdlbmVyaWMuZGVmaW5lKCd1bWwuRW5kU3RhdGUnLCB7XG4gICAgc2l6ZTogeyB3aWR0aDogMjAsIGhlaWdodDogMjAgfSxcbiAgICBhdHRyczoge1xuICAgICAgICAnY2lyY2xlLm91dGVyJzoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEwLCAxMCknLFxuICAgICAgICAgICAgcjogMTAsXG4gICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICBzdHJva2U6ICcjMmMzZTUwJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdjaXJjbGUuaW5uZXInOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTAsIDEwKScsXG4gICAgICAgICAgICByOiA2LFxuICAgICAgICAgICAgZmlsbDogJyMzNDQ5NWUnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiAnPGcgY2xhc3M9XCJyb3RhdGFibGVcIj48ZyBjbGFzcz1cInNjYWxhYmxlXCI+PGNpcmNsZSBjbGFzcz1cIm91dGVyXCIvPjxjaXJjbGUgY2xhc3M9XCJpbm5lclwiLz48L2c+PC9nPicsXG59KTtcblxuZXhwb3J0IGNvbnN0IFRyYW5zaXRpb24gPSBMaW5rLmRlZmluZSgndW1sLlRyYW5zaXRpb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgJy5tYXJrZXItdGFyZ2V0JzogeyBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsIGZpbGw6ICcjMzQ0OTVlJywgc3Ryb2tlOiAnIzJjM2U1MCcgfSxcbiAgICAgICAgJy5jb25uZWN0aW9uJzogeyBzdHJva2U6ICcjMmMzZTUwJyB9XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiRWxlbWVudFZpZXciLCJMaW5rIiwiR2VuZXJpYyIsIkNpcmNsZSIsIkNsYXNzIiwiZGVmaW5lIiwiYXR0cnMiLCJyZWN0IiwibmFtZSIsImF0dHJpYnV0ZXMiLCJtZXRob2RzIiwibWFya3VwIiwiam9pbiIsImluaXRpYWxpemUiLCJvbiIsInVwZGF0ZVJlY3RhbmdsZXMiLCJ0cmlnZ2VyIiwicHJvdG90eXBlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnZXRDbGFzc05hbWUiLCJnZXQiLCJyZWN0cyIsInR5cGUiLCJ0ZXh0Iiwib2Zmc2V0WSIsImZvckVhY2giLCJsaW5lcyIsIkFycmF5IiwiaXNBcnJheSIsInJlY3RIZWlnaHQiLCJsZW5ndGgiLCJoZWlnaHQiLCJ0cmFuc2Zvcm0iLCJDbGFzc1ZpZXciLCJleHRlbmQiLCJsaXN0ZW5UbyIsIm1vZGVsIiwidXBkYXRlIiwicmVzaXplIiwiQWJzdHJhY3QiLCJmaWxsIiwiQWJzdHJhY3RWaWV3IiwiSW50ZXJmYWNlIiwiSW50ZXJmYWNlVmlldyIsIkdlbmVyYWxpemF0aW9uIiwiZCIsIkltcGxlbWVudGF0aW9uIiwiQWdncmVnYXRpb24iLCJDb21wb3NpdGlvbiIsIkFzc29jaWF0aW9uIiwiU3RhdGUiLCJldmVudHMiLCJ1cGRhdGVOYW1lIiwidXBkYXRlRXZlbnRzIiwidXBkYXRlUGF0aCIsImF0dHIiLCJ3aWR0aCIsInNpbGVudCIsIlN0YXJ0U3RhdGUiLCJjaXJjbGUiLCJFbmRTdGF0ZSIsInNpemUiLCJyIiwic3Ryb2tlIiwiVHJhbnNpdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/shapes/uml.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/util/cloneCells.mjs":
/*!******************************************************!*\
  !*** ./node_modules/jointjs/src/util/cloneCells.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneCells: () => (/* binding */ cloneCells)\n/* harmony export */ });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nfunction cloneCells(cells) {\n    cells = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(cells);\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).forEach(function(cell) {\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop(\"source/id\", cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop(\"target/id\", cloneMap[target.id].id);\n            }\n        }\n        // Find the parent of the original cell\n        const parent = cell.get(\"parent\");\n        if (parent && cloneMap[parent]) {\n            clone.set(\"parent\", cloneMap[parent].id);\n        }\n        // Find the embeds of the original cell\n        const embeds = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cell.get(\"embeds\")).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n        if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(embeds)) {\n            clone.set(\"embeds\", embeds);\n        }\n    });\n    return cloneMap;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC9jbG9uZUNlbGxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUVwRCw0RkFBNEY7QUFDNUYsdURBQXVEO0FBQ3ZELDZFQUE2RTtBQUM3RSw0RUFBNEU7QUFDNUUsa0VBQWtFO0FBQ2xFLHVEQUF1RDtBQUN2RCxzRUFBc0U7QUFDdEUseUVBQXlFO0FBQ3pFLCtFQUErRTtBQUN4RSxTQUFTRyxXQUFXQyxLQUFLO0lBRTVCQSxRQUFRSiwrQ0FBSUEsQ0FBQ0k7SUFFYiwwREFBMEQ7SUFDMUQsb0VBQW9FO0lBQ3BFLG1DQUFtQztJQUNuQyxNQUFNQyxXQUFXSixrREFBT0EsQ0FBQ0csT0FBT0UsTUFBTSxDQUFDLFNBQVNDLEdBQUcsRUFBRUMsSUFBSTtRQUNyREQsR0FBRyxDQUFDQyxLQUFLQyxFQUFFLENBQUMsR0FBR0QsS0FBS0UsS0FBSztRQUN6QixPQUFPSDtJQUNYLEdBQUcsQ0FBQztJQUVKTixrREFBT0EsQ0FBQ0csT0FBT08sT0FBTyxDQUFDLFNBQVNILElBQUk7UUFFaEMsTUFBTUUsUUFBUUwsUUFBUSxDQUFDRyxLQUFLQyxFQUFFLENBQUM7UUFDL0IsdUJBQXVCO1FBRXZCLElBQUlDLE1BQU1FLE1BQU0sSUFBSTtZQUNoQixNQUFNQyxTQUFTSCxNQUFNRyxNQUFNO1lBQzNCLE1BQU1DLFNBQVNKLE1BQU1JLE1BQU07WUFDM0IsSUFBSUQsT0FBT0osRUFBRSxJQUFJSixRQUFRLENBQUNRLE9BQU9KLEVBQUUsQ0FBQyxFQUFFO2dCQUNsQyxtRUFBbUU7Z0JBQ25FLDJDQUEyQztnQkFDM0NDLE1BQU1LLElBQUksQ0FBQyxhQUFhVixRQUFRLENBQUNRLE9BQU9KLEVBQUUsQ0FBQyxDQUFDQSxFQUFFO1lBQ2xEO1lBQ0EsSUFBSUssT0FBT0wsRUFBRSxJQUFJSixRQUFRLENBQUNTLE9BQU9MLEVBQUUsQ0FBQyxFQUFFO2dCQUNsQyxtRUFBbUU7Z0JBQ25FLDJDQUEyQztnQkFDM0NDLE1BQU1LLElBQUksQ0FBQyxhQUFhVixRQUFRLENBQUNTLE9BQU9MLEVBQUUsQ0FBQyxDQUFDQSxFQUFFO1lBQ2xEO1FBQ0o7UUFFQSx1Q0FBdUM7UUFDdkMsTUFBTU8sU0FBU1IsS0FBS1MsR0FBRyxDQUFDO1FBQ3hCLElBQUlELFVBQVVYLFFBQVEsQ0FBQ1csT0FBTyxFQUFFO1lBQzVCTixNQUFNUSxHQUFHLENBQUMsVUFBVWIsUUFBUSxDQUFDVyxPQUFPLENBQUNQLEVBQUU7UUFDM0M7UUFFQSx1Q0FBdUM7UUFDdkMsTUFBTVUsU0FBU2xCLGtEQUFPQSxDQUFDTyxLQUFLUyxHQUFHLENBQUMsV0FBV1gsTUFBTSxDQUFDLFNBQVNjLFNBQVMsRUFBRUMsS0FBSztZQUN2RSw4REFBOEQ7WUFDOUQsa0NBQWtDO1lBQ2xDLElBQUloQixRQUFRLENBQUNnQixNQUFNLEVBQUU7Z0JBQ2pCRCxVQUFVRSxJQUFJLENBQUNqQixRQUFRLENBQUNnQixNQUFNLENBQUNaLEVBQUU7WUFDckM7WUFDQSxPQUFPVztRQUNYLEdBQUcsRUFBRTtRQUVMLElBQUksQ0FBQ2xCLGtEQUFPQSxDQUFDaUIsU0FBUztZQUNsQlQsTUFBTVEsR0FBRyxDQUFDLFVBQVVDO1FBQ3hCO0lBQ0o7SUFFQSxPQUFPZDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC9jbG9uZUNlbGxzLm1qcz9mYTlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuaXEsIHRvQXJyYXksIGlzRW1wdHkgfSBmcm9tICcuL3V0aWwubWpzJztcblxuLy8gQ2xvbmUgYGNlbGxzYCByZXR1cm5pbmcgYW4gb2JqZWN0IHRoYXQgbWFwcyB0aGUgb3JpZ2luYWwgY2VsbCBJRCB0byB0aGUgY2xvbmUuIFRoZSBudW1iZXJcbi8vIG9mIGNsb25lcyBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBgY2VsbHMubGVuZ3RoYC5cbi8vIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbGwgdGhlIGBjZWxsc2AuIEhvd2V2ZXIsIGl0IGFsc28gcmVjb25zdHJ1Y3RzXG4vLyBhbGwgdGhlIGBzb3VyY2UvdGFyZ2V0YCBhbmQgYHBhcmVudC9lbWJlZGAgcmVmZXJlbmNlcyB3aXRoaW4gdGhlIGBjZWxsc2AuXG4vLyBUaGlzIGlzIHRoZSBtYWluIGRpZmZlcmVuY2UgZnJvbSB0aGUgYGNlbGwuY2xvbmUoKWAgbWV0aG9kLiBUaGVcbi8vIGBjZWxsLmNsb25lKClgIG1ldGhvZCB3b3JrcyBvbiBvbmUgc2luZ2xlIGNlbGwgb25seS5cbi8vIEZvciBleGFtcGxlLCBmb3IgYSBncmFwaDogYEEgLS0tIEwgLS0tPiBCYCwgYGNsb25lQ2VsbHMoW0EsIEwsIEJdKWBcbi8vIHJldHVybnMgYFtBMiwgTDIsIEIyXWAgcmVzdWx0aW5nIHRvIGEgZ3JhcGg6IGBBMiAtLS0gTDIgLS0tPiBCMmAsIGkuZS5cbi8vIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBvZiB0aGUgbGluayBgTDJgIGlzIGNoYW5nZWQgdG8gcG9pbnQgdG8gYEEyYCBhbmQgYEIyYC5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUNlbGxzKGNlbGxzKSB7XG5cbiAgICBjZWxscyA9IHVuaXEoY2VsbHMpO1xuXG4gICAgLy8gQSBtYXAgb2YgdGhlIGZvcm0gW29yaWdpbmFsIGNlbGwgSURdIC0+IFtjbG9uZV0gaGVscGluZ1xuICAgIC8vIHVzIHRvIHJlY29uc3RydWN0IHJlZmVyZW5jZXMgZm9yIHNvdXJjZS90YXJnZXQgYW5kIHBhcmVudC9lbWJlZHMuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICBjb25zdCBjbG9uZU1hcCA9IHRvQXJyYXkoY2VsbHMpLnJlZHVjZShmdW5jdGlvbihtYXAsIGNlbGwpIHtcbiAgICAgICAgbWFwW2NlbGwuaWRdID0gY2VsbC5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcblxuICAgIHRvQXJyYXkoY2VsbHMpLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIGNvbnN0IGNsb25lID0gY2xvbmVNYXBbY2VsbC5pZF07XG4gICAgICAgIC8vIGFzc2VydChjbG9uZSBleGlzdHMpXG5cbiAgICAgICAgaWYgKGNsb25lLmlzTGluaygpKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjbG9uZS5zb3VyY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGNsb25lLnRhcmdldCgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCAmJiBjbG9uZU1hcFtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgICAgICAgLy8gU291cmNlIHBvaW50cyB0byBhbiBlbGVtZW50IGFuZCB0aGUgZWxlbWVudCBpcyBhbW9uZyB0aGUgY2xvbmVzLlxuICAgICAgICAgICAgICAgIC8vID0+IFVwZGF0ZSB0aGUgc291cmNlIG9mIHRoZSBjbG9uZWQgbGluay5cbiAgICAgICAgICAgICAgICBjbG9uZS5wcm9wKCdzb3VyY2UvaWQnLCBjbG9uZU1hcFtzb3VyY2UuaWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWQgJiYgY2xvbmVNYXBbdGFyZ2V0LmlkXSkge1xuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBwb2ludHMgdG8gYW4gZWxlbWVudCBhbmQgdGhlIGVsZW1lbnQgaXMgYW1vbmcgdGhlIGNsb25lcy5cbiAgICAgICAgICAgICAgICAvLyA9PiBVcGRhdGUgdGhlIHRhcmdldCBvZiB0aGUgY2xvbmVkIGxpbmsuXG4gICAgICAgICAgICAgICAgY2xvbmUucHJvcCgndGFyZ2V0L2lkJywgY2xvbmVNYXBbdGFyZ2V0LmlkXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIGNlbGxcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2VsbC5nZXQoJ3BhcmVudCcpO1xuICAgICAgICBpZiAocGFyZW50ICYmIGNsb25lTWFwW3BhcmVudF0pIHtcbiAgICAgICAgICAgIGNsb25lLnNldCgncGFyZW50JywgY2xvbmVNYXBbcGFyZW50XS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBlbWJlZHMgb2YgdGhlIG9yaWdpbmFsIGNlbGxcbiAgICAgICAgY29uc3QgZW1iZWRzID0gdG9BcnJheShjZWxsLmdldCgnZW1iZWRzJykpLnJlZHVjZShmdW5jdGlvbihuZXdFbWJlZHMsIGVtYmVkKSB7XG4gICAgICAgICAgICAvLyBFbWJlZGRlZCBjZWxscyB0aGF0IGFyZSBub3QgYmVpbmcgY2xvbmVkIGNhbiBub3QgYmUgY2FycmllZFxuICAgICAgICAgICAgLy8gb3ZlciB3aXRoIG90aGVyIGVtYmVkZGVkIGNlbGxzLlxuICAgICAgICAgICAgaWYgKGNsb25lTWFwW2VtYmVkXSkge1xuICAgICAgICAgICAgICAgIG5ld0VtYmVkcy5wdXNoKGNsb25lTWFwW2VtYmVkXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RW1iZWRzO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGVtYmVkcykpIHtcbiAgICAgICAgICAgIGNsb25lLnNldCgnZW1iZWRzJywgZW1iZWRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNsb25lTWFwO1xufVxuXG4iXSwibmFtZXMiOlsidW5pcSIsInRvQXJyYXkiLCJpc0VtcHR5IiwiY2xvbmVDZWxscyIsImNlbGxzIiwiY2xvbmVNYXAiLCJyZWR1Y2UiLCJtYXAiLCJjZWxsIiwiaWQiLCJjbG9uZSIsImZvckVhY2giLCJpc0xpbmsiLCJzb3VyY2UiLCJ0YXJnZXQiLCJwcm9wIiwicGFyZW50IiwiZ2V0Iiwic2V0IiwiZW1iZWRzIiwibmV3RW1iZWRzIiwiZW1iZWQiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/util/cloneCells.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/util/getRectPoint.mjs":
/*!********************************************************!*\
  !*** ./node_modules/jointjs/src/util/getRectPoint.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Positions: () => (/* binding */ Positions),\n/* harmony export */   getRectPoint: () => (/* binding */ getRectPoint)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/jointjs/src/g/rect.mjs\");\n\nconst Positions = {\n    TOP: \"top\",\n    RIGHT: \"right\",\n    BOTTOM: \"bottom\",\n    LEFT: \"left\",\n    TOP_LEFT: \"top-left\",\n    TOP_RIGHT: \"top-right\",\n    BOTTOM_LEFT: \"bottom-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    CENTER: \"center\"\n};\nfunction getRectPoint(rect, position) {\n    const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect);\n    switch(position){\n        case undefined:\n            throw new Error(\"Position required\");\n        // Middle Points\n        case Positions.LEFT:\n        case \"leftMiddle\":\n            return r.leftMiddle();\n        case Positions.RIGHT:\n        case \"rightMiddle\":\n            return r.rightMiddle();\n        case Positions.TOP:\n        case \"topMiddle\":\n            return r.topMiddle();\n        case Positions.BOTTOM:\n        case \"bottomMiddle\":\n            return r.bottomMiddle();\n        // Corners\n        case Positions.TOP_LEFT:\n        case \"topLeft\":\n        case \"origin\":\n            return r.topLeft();\n        case Positions.TOP_RIGHT:\n        case \"topRight\":\n            return r.topRight();\n        case Positions.BOTTOM_LEFT:\n        case \"bottomLeft\":\n            return r.bottomLeft();\n        case Positions.BOTTOM_RIGHT:\n        case \"bottomRight\":\n        case \"corner\":\n            return r.bottomRight();\n        // Center\n        case Positions.CENTER:\n            return r.center();\n        // TODO: calc(), percentage etc.\n        default:\n            throw new Error(`Unknown position: ${position}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC9nZXRSZWN0UG9pbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUU3QixNQUFNQyxZQUFZO0lBQ3JCQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsUUFBUTtBQUNaLEVBQUU7QUFFSyxTQUFTQyxhQUFhQyxJQUFJLEVBQUVDLFFBQVE7SUFDdkMsTUFBTUMsSUFBSSxJQUFJZCw4Q0FBTSxDQUFDWTtJQUNyQixPQUFRQztRQUNKLEtBQUtHO1lBQ0QsTUFBTSxJQUFJQyxNQUFNO1FBRXBCLGdCQUFnQjtRQUNoQixLQUFLaEIsVUFBVUksSUFBSTtRQUNuQixLQUFLO1lBQ0QsT0FBT1MsRUFBRUksVUFBVTtRQUV2QixLQUFLakIsVUFBVUUsS0FBSztRQUNwQixLQUFLO1lBQ0QsT0FBT1csRUFBRUssV0FBVztRQUV4QixLQUFLbEIsVUFBVUMsR0FBRztRQUNsQixLQUFLO1lBQ0QsT0FBT1ksRUFBRU0sU0FBUztRQUV0QixLQUFLbkIsVUFBVUcsTUFBTTtRQUNyQixLQUFLO1lBQ0QsT0FBT1UsRUFBRU8sWUFBWTtRQUV6QixVQUFVO1FBQ1YsS0FBS3BCLFVBQVVLLFFBQVE7UUFDdkIsS0FBSztRQUNMLEtBQUs7WUFDRCxPQUFPUSxFQUFFUSxPQUFPO1FBRXBCLEtBQUtyQixVQUFVTSxTQUFTO1FBQ3hCLEtBQUs7WUFDRCxPQUFPTyxFQUFFUyxRQUFRO1FBRXJCLEtBQUt0QixVQUFVTyxXQUFXO1FBQzFCLEtBQUs7WUFDRCxPQUFPTSxFQUFFVSxVQUFVO1FBRXZCLEtBQUt2QixVQUFVUSxZQUFZO1FBQzNCLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBT0ssRUFBRVcsV0FBVztRQUV4QixTQUFTO1FBQ1QsS0FBS3hCLFVBQVVTLE1BQU07WUFDakIsT0FBT0ksRUFBRVksTUFBTTtRQUVuQixnQ0FBZ0M7UUFDaEM7WUFDSSxNQUFNLElBQUlULE1BQU0sQ0FBQyxrQkFBa0IsRUFBRUosU0FBUyxDQUFDO0lBQ3ZEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9qb2ludGpzL3NyYy91dGlsL2dldFJlY3RQb2ludC5tanM/YjczNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IFBvc2l0aW9ucyA9IHtcbiAgICBUT1A6ICd0b3AnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICAgIFRPUF9SSUdIVDogJ3RvcC1yaWdodCcsXG4gICAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gICAgQk9UVE9NX1JJR0hUOiAnYm90dG9tLXJpZ2h0JyxcbiAgICBDRU5URVI6ICdjZW50ZXInLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3RQb2ludChyZWN0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHIgPSBuZXcgZy5SZWN0KHJlY3QpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgLy8gTWlkZGxlIFBvaW50c1xuICAgICAgICBjYXNlIFBvc2l0aW9ucy5MRUZUOlxuICAgICAgICBjYXNlICdsZWZ0TWlkZGxlJzpcbiAgICAgICAgICAgIHJldHVybiByLmxlZnRNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5SSUdIVDpcbiAgICAgICAgY2FzZSAncmlnaHRNaWRkbGUnOlxuICAgICAgICAgICAgcmV0dXJuIHIucmlnaHRNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1A6XG4gICAgICAgIGNhc2UgJ3RvcE1pZGRsZSc6XG4gICAgICAgICAgICByZXR1cm4gci50b3BNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT006XG4gICAgICAgIGNhc2UgJ2JvdHRvbU1pZGRsZSc6XG4gICAgICAgICAgICByZXR1cm4gci5ib3R0b21NaWRkbGUoKTtcblxuICAgICAgICAvLyBDb3JuZXJzXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUF9MRUZUOlxuICAgICAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgICAgY2FzZSAnb3JpZ2luJzpcbiAgICAgICAgICAgIHJldHVybiByLnRvcExlZnQoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1BfUklHSFQ6XG4gICAgICAgIGNhc2UgJ3RvcFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiByLnRvcFJpZ2h0KCk7XG5cbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX0xFRlQ6XG4gICAgICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIuYm90dG9tTGVmdCgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgY2FzZSAnYm90dG9tUmlnaHQnOlxuICAgICAgICBjYXNlICdjb3JuZXInOlxuICAgICAgICAgICAgcmV0dXJuIHIuYm90dG9tUmlnaHQoKTtcblxuICAgICAgICAvLyBDZW50ZXJcbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuQ0VOVEVSOlxuICAgICAgICAgICAgcmV0dXJuIHIuY2VudGVyKCk7XG5cbiAgICAgICAgLy8gVE9ETzogY2FsYygpLCBwZXJjZW50YWdlIGV0Yy5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwb3NpdGlvbjogJHtwb3NpdGlvbn1gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiZyIsIlBvc2l0aW9ucyIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiTEVGVCIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJDRU5URVIiLCJnZXRSZWN0UG9pbnQiLCJyZWN0IiwicG9zaXRpb24iLCJyIiwiUmVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwibGVmdE1pZGRsZSIsInJpZ2h0TWlkZGxlIiwidG9wTWlkZGxlIiwiYm90dG9tTWlkZGxlIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiY2VudGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/util/getRectPoint.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/util/util.mjs":
/*!************************************************!*\
  !*** ./node_modules/jointjs/src/util/util.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClassNamePrefix: () => (/* binding */ addClassNamePrefix),\n/* harmony export */   assign: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.assign),\n/* harmony export */   bindAll: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.bindAll),\n/* harmony export */   breakText: () => (/* binding */ breakText),\n/* harmony export */   camelCase: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.camelCase),\n/* harmony export */   cancelFrame: () => (/* binding */ cancelFrame),\n/* harmony export */   cap: () => (/* binding */ cap),\n/* harmony export */   clone: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.clone),\n/* harmony export */   cloneDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneDeep),\n/* harmony export */   dataUriToBlob: () => (/* binding */ dataUriToBlob),\n/* harmony export */   debounce: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.debounce),\n/* harmony export */   deepMixin: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepMixin),\n/* harmony export */   deepSupplement: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepSupplement),\n/* harmony export */   defaults: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaults),\n/* harmony export */   defaultsDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultsDeep),\n/* harmony export */   difference: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.difference),\n/* harmony export */   downloadBlob: () => (/* binding */ downloadBlob),\n/* harmony export */   downloadDataUri: () => (/* binding */ downloadDataUri),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   flattenDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.flattenDeep),\n/* harmony export */   flattenObject: () => (/* binding */ flattenObject),\n/* harmony export */   forIn: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   getByPath: () => (/* binding */ getByPath),\n/* harmony export */   getElementBBox: () => (/* binding */ getElementBBox),\n/* harmony export */   groupBy: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.groupBy),\n/* harmony export */   guid: () => (/* binding */ guid),\n/* harmony export */   has: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has),\n/* harmony export */   hashCode: () => (/* binding */ hashCode),\n/* harmony export */   imageToDataUri: () => (/* binding */ imageToDataUri),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   intersection: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.intersection),\n/* harmony export */   invoke: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invoke),\n/* harmony export */   invokeProperty: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invokeProperty),\n/* harmony export */   isBoolean: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isBoolean),\n/* harmony export */   isEmpty: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEmpty),\n/* harmony export */   isEqual: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEqual),\n/* harmony export */   isFunction: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction),\n/* harmony export */   isNumber: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber),\n/* harmony export */   isObject: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject),\n/* harmony export */   isPercentage: () => (/* binding */ isPercentage),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isPlainObject),\n/* harmony export */   isString: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString),\n/* harmony export */   merge: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.merge),\n/* harmony export */   mixin: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.mixin),\n/* harmony export */   nextFrame: () => (/* binding */ nextFrame),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   normalizeEvent: () => (/* binding */ normalizeEvent),\n/* harmony export */   normalizeSides: () => (/* binding */ normalizeSides),\n/* harmony export */   normalizeWheel: () => (/* binding */ normalizeWheel),\n/* harmony export */   omit: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit),\n/* harmony export */   parseCssNumeric: () => (/* binding */ parseCssNumeric),\n/* harmony export */   parseDOMJSON: () => (/* binding */ parseDOMJSON),\n/* harmony export */   pick: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.pick),\n/* harmony export */   removeClassNamePrefix: () => (/* binding */ removeClassNamePrefix),\n/* harmony export */   result: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.result),\n/* harmony export */   sanitizeHTML: () => (/* binding */ sanitizeHTML),\n/* harmony export */   setAttributesBySelector: () => (/* binding */ setAttributesBySelector),\n/* harmony export */   setByPath: () => (/* binding */ setByPath),\n/* harmony export */   shapePerimeterConnectionPoint: () => (/* binding */ shapePerimeterConnectionPoint),\n/* harmony export */   sortBy: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortBy),\n/* harmony export */   sortElements: () => (/* binding */ sortElements),\n/* harmony export */   sortedIndex: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortedIndex),\n/* harmony export */   supplement: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.supplement),\n/* harmony export */   template: () => (/* binding */ template),\n/* harmony export */   timing: () => (/* binding */ timing),\n/* harmony export */   toArray: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray),\n/* harmony export */   toKebabCase: () => (/* binding */ toKebabCase),\n/* harmony export */   toggleFullScreen: () => (/* binding */ toggleFullScreen),\n/* harmony export */   union: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.union),\n/* harmony export */   uniq: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniq),\n/* harmony export */   uniqueId: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniqueId),\n/* harmony export */   unsetByPath: () => (/* binding */ unsetByPath),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   without: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.without)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/jointjs/src/V/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/jointjs/src/config/index.mjs\");\n/* harmony import */ var _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utilHelpers.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n\n\n\nconst addClassNamePrefix = function(className) {\n    if (!className) return className;\n    return className.toString().split(\" \").map(function(_className) {\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix.length) !== _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix) {\n            _className = _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix + _className;\n        }\n        return _className;\n    }).join(\" \");\n};\nconst removeClassNamePrefix = function(className) {\n    if (!className) return className;\n    return className.toString().split(\" \").map(function(_className) {\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix.length) === _config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix) {\n            _className = _className.substr(_config_index_mjs__WEBPACK_IMPORTED_MODULE_1__.config.classNamePrefix.length);\n        }\n        return _className;\n    }).join(\" \");\n};\nconst parseDOMJSON = function(json, namespace) {\n    const selectors = {};\n    const groupSelectors = {};\n    const svgNamespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].namespace.svg;\n    const ns = namespace || svgNamespace;\n    const fragment = document.createDocumentFragment();\n    const parseNode = function(siblingsDef, parentNode, ns) {\n        for(let i = 0; i < siblingsDef.length; i++){\n            const nodeDef = siblingsDef[i];\n            // Text node\n            if (typeof nodeDef === \"string\") {\n                const textNode = document.createTextNode(nodeDef);\n                parentNode.appendChild(textNode);\n                continue;\n            }\n            // TagName\n            if (!nodeDef.hasOwnProperty(\"tagName\")) throw new Error(\"json-dom-parser: missing tagName\");\n            const tagName = nodeDef.tagName;\n            let node;\n            // Namespace URI\n            if (nodeDef.hasOwnProperty(\"namespaceURI\")) ns = nodeDef.namespaceURI;\n            node = document.createElementNS(ns, tagName);\n            const svg = ns === svgNamespace;\n            const wrapper = svg ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : jquery__WEBPACK_IMPORTED_MODULE_0__;\n            // Attributes\n            const attributes = nodeDef.attributes;\n            if (attributes) wrapper(node).attr(attributes);\n            // Style\n            const style = nodeDef.style;\n            if (style) jquery__WEBPACK_IMPORTED_MODULE_0__(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty(\"className\")) {\n                const className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty(\"textContent\")) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty(\"selector\")) {\n                const nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error(\"json-dom-parser: selector must be unique\");\n                selectors[nodeSelector] = node;\n                wrapper(node).attr(\"joint-selector\", nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty(\"groupSelector\")) {\n                let nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [\n                    nodeGroups\n                ];\n                for(let j = 0; j < nodeGroups.length; j++){\n                    const nodeGroup = nodeGroups[j];\n                    let group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n            parentNode.appendChild(node);\n            // Children\n            const childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) {\n                parseNode(childrenDef, node, ns);\n            }\n        }\n    };\n    parseNode(json, fragment, ns);\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nconst hashCode = function(str) {\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        hash = (hash << 5) - hash + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\nconst getByPath = function(obj, path, delimiter) {\n    var keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while(i < length){\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (typeof key !== \"string\" && typeof key !== \"number\") {\n        key = String(key);\n    }\n    if (key === \"constructor\" && typeof obj[key] === \"function\") {\n        return false;\n    }\n    if (key === \"__proto__\") {\n        return false;\n    }\n    return true;\n};\nconst setByPath = function(obj, path, value, delimiter) {\n    const keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n    for(; i < last; i++){\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n    diver[keys[last]] = value;\n    return obj;\n};\nconst unsetByPath = function(obj, path, delimiter) {\n    const keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n    for(; i < last; i++){\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n    delete diver[keys[last]];\n    return obj;\n};\nconst flattenObject = function(obj, delim, stop) {\n    delim = delim || \"/\";\n    var ret = {};\n    for(var key in obj){\n        if (!obj.hasOwnProperty(key)) continue;\n        var shouldGoDeeper = typeof obj[key] === \"object\";\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n        if (shouldGoDeeper) {\n            var flatObject = flattenObject(obj[key], delim, stop);\n            for(var flatKey in flatObject){\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n        } else {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n};\nconst uuid = function() {\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0;\n        var v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n// Generates global unique id and stores it as a property of the object, if provided.\nconst guid = function(obj) {\n    guid.id = guid.id || 1;\n    if (obj === undefined) {\n        return \"j_\" + guid.id++;\n    }\n    obj.id = obj.id === undefined ? \"j_\" + guid.id++ : obj.id;\n    return obj.id;\n};\nconst toKebabCase = function(string) {\n    return string.replace(/[A-Z]/g, \"-$&\").toLowerCase();\n};\nconst normalizeEvent = function(evt) {\n    if (evt.normalized) return evt;\n    const { originalEvent, target } = evt;\n    // If the event is a touch event, normalize it to a mouse event.\n    const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n    if (touch) {\n        for(let property in touch){\n            // copy all the properties from the first touch that are not\n            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n            if (evt[property] === undefined) {\n                evt[property] = touch[property];\n            }\n        }\n    }\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    if (target) {\n        const useElement = target.correspondingUseElement;\n        if (useElement) evt.target = useElement;\n    }\n    evt.normalized = true;\n    return evt;\n};\nconst normalizeWheel = function(evt) {\n    // Sane values derived empirically\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0, sY = 0, pX = 0, pY = 0;\n    // Legacy\n    if (\"detail\" in evt) {\n        sY = evt.detail;\n    }\n    if (\"wheelDelta\" in evt) {\n        sY = -evt.wheelDelta / 120;\n    }\n    if (\"wheelDeltaY\" in evt) {\n        sY = -evt.wheelDeltaY / 120;\n    }\n    if (\"wheelDeltaX\" in evt) {\n        sX = -evt.wheelDeltaX / 120;\n    }\n    // side scrolling on FF with DOMMouseScroll\n    if (\"axis\" in evt && evt.axis === evt.HORIZONTAL_AXIS) {\n        sX = sY;\n        sY = 0;\n    }\n    pX = \"deltaX\" in evt ? evt.deltaX : sX * PIXEL_STEP;\n    pY = \"deltaY\" in evt ? evt.deltaY : sY * PIXEL_STEP;\n    if ((pX || pY) && evt.deltaMode) {\n        if (evt.deltaMode == 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n        } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n        }\n    }\n    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n        pX = pY;\n        pY = 0;\n        sX = sY;\n        sY = 0;\n    }\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n        sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n        sY = pY < 1 ? -1 : 1;\n    }\n    return {\n        spinX: sX,\n        spinY: sY,\n        deltaX: pX,\n        deltaY: pY\n    };\n};\nconst cap = function(val, max) {\n    return val > max ? max : val < -max ? -max : val;\n};\nconst nextFrame = function() {\n    var raf;\n    if (false) {}\n    if (!raf) {\n        var lastTime = 0;\n        raf = function(callback) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n    return function(callback, context, ...rest) {\n        return context !== undefined ? raf(callback.bind(context, ...rest)) : raf(callback);\n    };\n}();\nconst cancelFrame = function() {\n    var caf;\n    var client = \"undefined\" != \"undefined\";\n    if (client) {\n        caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;\n    }\n    caf = caf || clearTimeout;\n    return client ? caf.bind(window) : caf;\n}();\n/**\n * @deprecated\n */ const shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n    var bbox;\n    var spot;\n    if (!magnet) {\n        // There is no magnet, try to make the best guess what is the\n        // wrapping SVG element. This is because we want this \"smart\"\n        // connection points to work out of the box without the\n        // programmer to put magnet marks to any of the subelements.\n        // For example, we want the function to work on basic.Path elements\n        // without any special treatment of such elements.\n        // The code below guesses the wrapping element based on\n        // one simple assumption. The wrapping elemnet is the\n        // first child of the scalable group if such a group exists\n        // or the first child of the rotatable group if not.\n        // This makese sense because usually the wrapping element\n        // is below any other sub element in the shapes.\n        var scalable = view.$(\".scalable\")[0];\n        var rotatable = view.$(\".rotatable\")[0];\n        if (scalable && scalable.firstChild) {\n            magnet = scalable.firstChild;\n        } else if (rotatable && rotatable.firstChild) {\n            magnet = rotatable.firstChild;\n        }\n    }\n    if (magnet) {\n        spot = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(magnet).findIntersection(reference, linkView.paper.cells);\n        if (!spot) {\n            bbox = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(magnet).getBBox({\n                target: linkView.paper.cells\n            });\n        }\n    } else {\n        bbox = view.model.getBBox();\n        spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n    }\n    return spot || bbox.center();\n};\nconst isPercentage = function(val) {\n    return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(val) && val.slice(-1) === \"%\";\n};\nconst parseCssNumeric = function(val, restrictUnits) {\n    function getUnit(validUnitExp) {\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp(\"(?:\\\\d+(?:\\\\.\\\\d+)*)(\" + validUnitExp + \")$\").exec(val);\n        if (!matches) return null;\n        return matches[1];\n    }\n    var number = parseFloat(val);\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = \"[A-Za-z]*\";\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join(\"|\");\n    } else if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\nconst NO_SPACE = 0;\nfunction splitWordWithEOL(word, eol) {\n    const eolWords = word.split(eol);\n    let n = 1;\n    for(let j = 0, jl = eolWords.length - 1; j < jl; j++){\n        const replacement = [];\n        if (j > 0 || eolWords[0] !== \"\") replacement.push(NO_SPACE);\n        replacement.push(eol);\n        if (j < jl - 1 || eolWords[jl] !== \"\") replacement.push(NO_SPACE);\n        eolWords.splice(n, 0, ...replacement);\n        n += replacement.length + 1;\n    }\n    return eolWords.filter((word)=>word !== \"\");\n}\nfunction getLineHeight(heightValue, textElement) {\n    if (heightValue === null) {\n        // Default 1em lineHeight\n        return textElement.getBBox().height;\n    }\n    switch(heightValue.unit){\n        case \"em\":\n            return textElement.getBBox().height * heightValue.value;\n        case \"px\":\n        case \"\":\n            return heightValue.value;\n    }\n}\nconst breakText = function(text, size, styles = {}, opt = {}) {\n    var width = size.width;\n    var height = size.height;\n    var svgDocument = opt.svgDocument || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"svg\").node;\n    var textSpan = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"tspan\").node;\n    var textElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"text\").attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode(\"\");\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = \"block\";\n    textSpan.style.display = \"block\";\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n    if (!opt.svgDocument) {\n        document.body.appendChild(svgDocument);\n    }\n    const preserveSpaces = opt.preserveSpaces;\n    const space = \" \";\n    const separator = opt.separator || opt.separator === \"\" ? opt.separator : space;\n    // If separator is a RegExp, we use the space character to join words together again (not ideal)\n    const separatorChar = typeof separator === \"string\" ? separator : space;\n    var eol = opt.eol || \"\\n\";\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!(0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber)(maxLineCount)) maxLineCount = Infinity;\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n    if (preserveSpaces) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(textSpan).attr(\"xml:space\", \"preserve\");\n    }\n    for(var i = 0, l = 0, len = words.length; i < len; i++){\n        var word = words[i];\n        if (!word && !preserveSpaces) continue;\n        if (typeof word !== \"string\") continue;\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                const eolWords = splitWordWithEOL(words[i], eol);\n                words.splice(i, 1, ...eolWords);\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                if (preserveSpaces && typeof words[i - 1] === \"string\") {\n                    words.splice(i, NO_SPACE, \"\", NO_SPACE);\n                    len += 2;\n                    i--;\n                    continue;\n                }\n                lines[++l] = !preserveSpaces || typeof words[i + 1] === \"string\" ? \"\" : undefined;\n                isEol = true;\n            }\n        }\n        if (!isEol) {\n            let data;\n            if (preserveSpaces) {\n                data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n            } else {\n                data = lines[l] ? lines[l] + separatorChar + word : word;\n            }\n            textNode.data = data;\n            if (textSpan.getComputedTextLength() <= width) {\n                // the current line fits\n                lines[l] = data;\n                if (p || h) {\n                    // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n            } else {\n                if (!lines[l] || p) {\n                    var partition = !!p;\n                    p = word.length - 1;\n                    if (partition || !p) {\n                        // word has only one character.\n                        if (!p) {\n                            if (!lines[l]) {\n                                // we won't fit this text within our rect\n                                lines = [];\n                                break;\n                            }\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n                            // adjust word length\n                            len--;\n                            full[l++] = true;\n                            i--;\n                            continue;\n                        }\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        const nextWord = words[i + 1];\n                        words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? \"\" : nextWord);\n                    } else {\n                        if (h) {\n                            // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));\n                            // adjust words length\n                            len++;\n                        }\n                        if (l && !full[l - 1]) {\n                            // if the previous line is not full, try to fit max part of\n                            // the current word there\n                            l--;\n                        }\n                    }\n                    if (!preserveSpaces || lines[l] !== \"\") {\n                        i--;\n                    }\n                    continue;\n                }\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n        if (lines.length > maxLineCount) {\n            lastL = maxLineCount - 1;\n        } else if (height !== undefined) {\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n            if (lineHeight === undefined && textNode.data !== \"\") {\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === \"auto\") {\n                    lineHeight = getLineHeight({\n                        value: 1.5,\n                        unit: \"em\"\n                    }, textElement);\n                } else {\n                    const parsed = parseCssNumeric(styles.lineHeight, [\n                        \"em\",\n                        \"px\",\n                        \"\"\n                    ]);\n                    lineHeight = getLineHeight(parsed, textElement);\n                }\n            }\n            if (lineHeight * lines.length > height) {\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n        if (lastL !== null) {\n            lines.splice(lastL + 1);\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== \"string\") ellipsis = \"\";\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            }while (k >= 0);\n            break;\n        }\n    }\n    if (opt.svgDocument) {\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n    } else {\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n    return lines.join(eol);\n};\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nconst sanitizeHTML = function(html) {\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n    // If keepScripts (last parameter) is `false`, scripts are not executed.\n    var output = jquery__WEBPACK_IMPORTED_MODULE_0__(jquery__WEBPACK_IMPORTED_MODULE_0__.parseHTML(\"<div>\" + html + \"</div>\", null, false));\n    output.find(\"*\").each(function() {\n        var currentNode = this;\n        jquery__WEBPACK_IMPORTED_MODULE_0__.each(currentNode.attributes, function() {\n            var currentAttribute = this;\n            var attrName = currentAttribute.name;\n            var attrValue = currentAttribute.value;\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (attrName.startsWith(\"on\") || attrValue.startsWith(\"javascript:\") || attrValue.startsWith(\"data:\") || attrValue.startsWith(\"vbscript:\")) {\n                jquery__WEBPACK_IMPORTED_MODULE_0__(currentNode).removeAttr(attrName);\n            }\n        });\n    });\n    return output.html();\n};\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nconst downloadBlob = function(blob, fileName) {\n    if (window.navigator.msSaveBlob) {\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n    } else {\n        // downloads directly in Chrome and Safari\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement(\"a\");\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nconst downloadDataUri = function(dataUri, fileName) {\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nconst dataUriToBlob = function(dataUri) {\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, \"\");\n    dataUri = decodeURIComponent(dataUri);\n    var firstCommaIndex = dataUri.indexOf(\",\"); // split dataUri as `dataTypeString`,`data`\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(\":\")[1].split(\";\")[0]; // e.g. 'image/jpeg'\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf(\"base64\") >= 0) {\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for(var i = 0; i < decodedString.length; i++){\n        ia[i] = decodedString.charCodeAt(i);\n    }\n    return new Blob([\n        ia\n    ], {\n        type: mimeString\n    }); // return the typed array as Blob\n};\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nconst imageToDataUri = function(url, callback) {\n    if (!url || url.substr(0, \"data:\".length) === \"data:\") {\n        // No need to convert to data uri if it is already in data uri.\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n        if (xhr.status === 200) {\n            var reader = new FileReader();\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n            reader.onerror = function() {\n                callback(new Error(\"Failed to load image \" + url));\n            };\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error(\"Failed to load image \" + url));\n        }\n    };\n    var legacyHandler = function(xhr, callback) {\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for(var i = 0; i < u8a.length; i += CHUNK_SZ){\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join(\"\");\n        };\n        if (xhr.status === 200) {\n            var bytes = new Uint8Array(xhr.response);\n            var suffix = url.split(\".\").pop() || \"png\";\n            var map = {\n                \"svg\": \"svg+xml\"\n            };\n            var meta = \"data:image/\" + (map[suffix] || suffix) + \";base64,\";\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error(\"Failed to load image \" + url));\n        }\n    };\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, true);\n    xhr.addEventListener(\"error\", function() {\n        callback(new Error(\"Failed to load image \" + url));\n    });\n    xhr.responseType = window.FileReader ? \"blob\" : \"arraybuffer\";\n    xhr.addEventListener(\"load\", function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n    xhr.send();\n};\nconst getElementBBox = function(el) {\n    var $el = jquery__WEBPACK_IMPORTED_MODULE_0__(el);\n    if ($el.length === 0) {\n        throw new Error(\"Element not found\");\n    }\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n    // Firefox correction\n    if (element.ownerSVGElement) {\n        var vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element);\n        var bbox = vel.getBBox({\n            target: vel.svg()\n        });\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = clientBBox.width - bbox.width;\n        strokeWidthY = clientBBox.height - bbox.height;\n    }\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nconst sortElements = function(elements, comparator) {\n    var $elements = jquery__WEBPACK_IMPORTED_MODULE_0__(elements);\n    var placements = $elements.map(function() {\n        var sortElement = this;\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(\"\"), sortElement.nextSibling);\n        return function() {\n            if (parentNode === this) {\n                throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n            }\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n    return Array.prototype.sort.call($elements, comparator).each(function(i) {\n        placements[i].call(this);\n    });\n};\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nconst setAttributesBySelector = function(element, attrs) {\n    var $element = jquery__WEBPACK_IMPORTED_MODULE_0__(element);\n    (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn)(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has)(attrs, \"class\")) {\n            $elements.addClass(attrs[\"class\"]);\n            attrs = (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit)(attrs, \"class\");\n        }\n        $elements.attr(attrs);\n    });\n};\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nconst normalizeSides = function(box) {\n    if (Object(box) !== box) {\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n        return {\n            top: val,\n            right: val,\n            bottom: val,\n            left: val\n        };\n    }\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n    return {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left\n    };\n};\nconst timing = {\n    linear: function(t) {\n        return t;\n    },\n    quad: function(t) {\n        return t * t;\n    },\n    cubic: function(t) {\n        return t * t * t;\n    },\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n    bounce: function(t) {\n        for(var a = 0, b = 1; 1; a += b, b /= 2){\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n        };\n    },\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\nconst interpolate = {\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for(i = s.length - 1; i != -1; i--){\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n    hexColor: function(a, b) {\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n        return function(t) {\n            var r = ra + rd * t & 0x000000ff;\n            var g = ga + gd * t & 0x0000ff00;\n            var b = ba + bd * t & 0x00ff0000;\n            return \"#\" + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n    unit: function(a, b) {\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf(\".\");\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n// SVG filters.\n// (values in parentheses are default values)\nconst filter = {\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n        return template(tpl)({\n            color: args.color || \"blue\",\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n        return template(tpl)({\n            color: args.color || \"red\",\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n        var x = Number.isFinite(args.x) ? args.x : 2;\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [\n                x,\n                args.y\n            ] : x\n        });\n    },\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n        var tpl = \"SVGFEDropShadowElement\" in window ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>' : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || \"black\",\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\nconst format = {\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n        locale = locale || {\n            currency: [\n                \"$\",\n                \"\"\n            ],\n            decimal: \".\",\n            thousands: \",\",\n            grouping: [\n                3\n            ]\n        };\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n        var match = re.exec(specifier);\n        var fill = match[1] || \" \";\n        var align = match[2] || \">\";\n        var sign = match[3] || \"\";\n        var symbol = match[4] || \"\";\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = \"\";\n        var suffix = \"\";\n        var integer = false;\n        if (precision) precision = +precision.substring(1);\n        if (zfill || fill === \"0\" && align === \"=\") {\n            zfill = fill = \"0\";\n            align = \"=\";\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n        switch(type){\n            case \"n\":\n                comma = true;\n                type = \"g\";\n                break;\n            case \"%\":\n                scale = 100;\n                suffix = \"%\";\n                type = \"f\";\n                break;\n            case \"p\":\n                scale = 100;\n                suffix = \"%\";\n                type = \"r\";\n                break;\n            case \"b\":\n            case \"o\":\n            case \"x\":\n            case \"X\":\n                if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n                break;\n            case \"c\":\n            case \"d\":\n                integer = true;\n                precision = 0;\n                break;\n            case \"s\":\n                scale = -1;\n                type = \"r\";\n                break;\n        }\n        if (symbol === \"$\") {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == \"r\" && !precision) type = \"g\";\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == \"g\") precision = Math.max(1, Math.min(21, precision));\n            else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n        }\n        var zcomma = zfill && comma;\n        // Return the empty string for floats formatted as ints.\n        if (integer && value % 1) return \"\";\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign;\n        var fullSuffix = suffix;\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf(\".\");\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? \"\" : locale.decimal + value.substring(i + 1);\n        function formatGroup(value) {\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while(i > 0 && g > 0){\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n            before = formatGroup(before);\n        }\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n        // Apply prefix.\n        negative += prefix;\n        // Rejoin integer and decimal parts.\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n        var fieldDelimiterIndex;\n        var fieldDelimiter = \"{\";\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n        while((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1){\n            var pieceFormattedString, formatSpec, fieldName;\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(\":\");\n                fieldName = formatSpec.shift().split(\".\");\n                pieceFormattedString = value;\n                for(var i = 0; i < fieldName.length; i++)pieceFormattedString = pieceFormattedString[fieldName[i]];\n                if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n            formattedStringArray.push(pieceFormattedString);\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = endPlaceholder ? \"}\" : \"{\";\n        }\n        formattedStringArray.push(formatString);\n        return formattedStringArray.join(\"\");\n    },\n    convert: function(type, value, precision) {\n        switch(type){\n            case \"b\":\n                return value.toString(2);\n            case \"c\":\n                return String.fromCharCode(value);\n            case \"o\":\n                return value.toString(8);\n            case \"x\":\n                return value.toString(16);\n            case \"X\":\n                return value.toString(16).toUpperCase();\n            case \"g\":\n                return value.toPrecision(precision);\n            case \"e\":\n                return value.toExponential(precision);\n            case \"f\":\n                return value.toFixed(precision);\n            case \"r\":\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + \"\";\n        }\n    },\n    round: function(value, precision) {\n        return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);\n    },\n    precision: function(value, precision) {\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n    prefix: function(value, precision) {\n        var prefixes = [\n            \"y\",\n            \"z\",\n            \"a\",\n            \"f\",\n            \"p\",\n            \"n\",\n            \"\\xb5\",\n            \"m\",\n            \"\",\n            \"k\",\n            \"M\",\n            \"G\",\n            \"T\",\n            \"P\",\n            \"E\",\n            \"Z\",\n            \"Y\"\n        ].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n/*\n    Pre-compile the HTML to be used as a template.\n*/ const template = function(html) {\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */ var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n    return function(data) {\n        data = data || {};\n        return html.replace(regex, function(match) {\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n            var attrArray = attr.split(\".\");\n            var value = data[attrArray.shift()];\n            while(value !== undefined && attrArray.length){\n                value = value[attrArray.shift()];\n            }\n            return value !== undefined ? value : \"\";\n        });\n    };\n};\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */ const toggleFullScreen = function(el) {\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n    function prefixedResult(el, prop) {\n        var prefixes = [\n            \"webkit\",\n            \"moz\",\n            \"ms\",\n            \"o\",\n            \"\"\n        ];\n        for(var i = 0; i < prefixes.length; i++){\n            var prefix = prefixes[i];\n            var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);\n            if (el[propName] !== undefined) {\n                return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n    if (prefixedResult(topDocument, \"FullscreenElement\") || prefixedResult(topDocument, \"FullScreenElement\")) {\n        prefixedResult(topDocument, \"ExitFullscreen\") || // Spec.\n        prefixedResult(topDocument, \"CancelFullScreen\"); // Firefox\n    } else {\n        prefixedResult(el, \"RequestFullscreen\") || // Spec.\n        prefixedResult(el, \"RequestFullScreen\"); // Firefox\n    }\n};\n\nconst noop = function() {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC91dGlsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVCO0FBQ1E7QUFDYztBQXlDbEI7QUFFcEIsTUFBTTBDLHFCQUFxQixTQUFTQyxTQUFTO0lBRWhELElBQUksQ0FBQ0EsV0FBVyxPQUFPQTtJQUV2QixPQUFPQSxVQUFVQyxRQUFRLEdBQUdDLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsU0FBU0MsVUFBVTtRQUUxRCxJQUFJQSxXQUFXQyxNQUFNLENBQUMsR0FBRzlDLHFEQUFNQSxDQUFDK0MsZUFBZSxDQUFDQyxNQUFNLE1BQU1oRCxxREFBTUEsQ0FBQytDLGVBQWUsRUFBRTtZQUNoRkYsYUFBYTdDLHFEQUFNQSxDQUFDK0MsZUFBZSxHQUFHRjtRQUMxQztRQUVBLE9BQU9BO0lBRVgsR0FBR0ksSUFBSSxDQUFDO0FBQ1osRUFBRTtBQUVLLE1BQU1DLHdCQUF3QixTQUFTVCxTQUFTO0lBRW5ELElBQUksQ0FBQ0EsV0FBVyxPQUFPQTtJQUV2QixPQUFPQSxVQUFVQyxRQUFRLEdBQUdDLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsU0FBU0MsVUFBVTtRQUUxRCxJQUFJQSxXQUFXQyxNQUFNLENBQUMsR0FBRzlDLHFEQUFNQSxDQUFDK0MsZUFBZSxDQUFDQyxNQUFNLE1BQU1oRCxxREFBTUEsQ0FBQytDLGVBQWUsRUFBRTtZQUNoRkYsYUFBYUEsV0FBV0MsTUFBTSxDQUFDOUMscURBQU1BLENBQUMrQyxlQUFlLENBQUNDLE1BQU07UUFDaEU7UUFFQSxPQUFPSDtJQUVYLEdBQUdJLElBQUksQ0FBQztBQUNaLEVBQUU7QUFFSyxNQUFNRSxlQUFlLFNBQVNDLElBQUksRUFBRUMsU0FBUztJQUVoRCxNQUFNQyxZQUFZLENBQUM7SUFDbkIsTUFBTUMsaUJBQWlC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LHdCQUF3QixRQUFRO1FBQ25Ea0ssZUFBZWxLLElBQUksc0JBQXNCLFVBQVU7SUFDdkQ7QUFDSixFQUFFO0FBMENBO0FBRUssTUFBTXFLLE9BQU8sWUFDcEIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL3V0aWwvdXRpbC5tanM/OTZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5pbXBvcnQge1xuICAgIGlzQm9vbGVhbixcbiAgICBpc09iamVjdCxcbiAgICBpc051bWJlcixcbiAgICBpc1N0cmluZyxcbiAgICBtaXhpbixcbiAgICBkZWVwTWl4aW4sXG4gICAgc3VwcGxlbWVudCxcbiAgICBkZWZhdWx0cyxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgZGVlcFN1cHBsZW1lbnQsXG4gICAgYXNzaWduLFxuICAgIGludm9rZSxcbiAgICBpbnZva2VQcm9wZXJ0eSxcbiAgICBzb3J0ZWRJbmRleCxcbiAgICB1bmlxLFxuICAgIGNsb25lLFxuICAgIGNsb25lRGVlcCxcbiAgICBpc0VtcHR5LFxuICAgIGlzRXF1YWwsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1BsYWluT2JqZWN0LFxuICAgIHRvQXJyYXksXG4gICAgZGVib3VuY2UsXG4gICAgZ3JvdXBCeSxcbiAgICBzb3J0QnksXG4gICAgZmxhdHRlbkRlZXAsXG4gICAgd2l0aG91dCxcbiAgICBkaWZmZXJlbmNlLFxuICAgIGludGVyc2VjdGlvbixcbiAgICB1bmlvbixcbiAgICBoYXMsXG4gICAgcmVzdWx0LFxuICAgIG9taXQsXG4gICAgcGljayxcbiAgICBiaW5kQWxsLFxuICAgIGZvckluLFxuICAgIGNhbWVsQ2FzZSxcbiAgICB1bmlxdWVJZCxcbiAgICBtZXJnZVxufSBmcm9tICcuL3V0aWxIZWxwZXJzLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzc05hbWVQcmVmaXggPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcblxuICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm4gY2xhc3NOYW1lO1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZS50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKF9jbGFzc05hbWUpIHtcblxuICAgICAgICBpZiAoX2NsYXNzTmFtZS5zdWJzdHIoMCwgY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpICE9PSBjb25maWcuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzTmFtZVByZWZpeCArIF9jbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NsYXNzTmFtZTtcblxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVDbGFzc05hbWVQcmVmaXggPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcblxuICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm4gY2xhc3NOYW1lO1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZS50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKF9jbGFzc05hbWUpIHtcblxuICAgICAgICBpZiAoX2NsYXNzTmFtZS5zdWJzdHIoMCwgY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpID09PSBjb25maWcuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lID0gX2NsYXNzTmFtZS5zdWJzdHIoY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jbGFzc05hbWU7XG5cbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VET01KU09OID0gZnVuY3Rpb24oanNvbiwgbmFtZXNwYWNlKSB7XG5cbiAgICBjb25zdCBzZWxlY3RvcnMgPSB7fTtcbiAgICBjb25zdCBncm91cFNlbGVjdG9ycyA9IHt9O1xuICAgIGNvbnN0IHN2Z05hbWVzcGFjZSA9IFYubmFtZXNwYWNlLnN2ZztcblxuICAgIGNvbnN0IG5zID0gbmFtZXNwYWNlIHx8IHN2Z05hbWVzcGFjZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGNvbnN0IHBhcnNlTm9kZSA9IGZ1bmN0aW9uKHNpYmxpbmdzRGVmLCBwYXJlbnROb2RlLCBucykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzRGVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlRGVmID0gc2libGluZ3NEZWZbaV07XG5cbiAgICAgICAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlRGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZURlZik7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhZ05hbWVcbiAgICAgICAgICAgIGlmICghbm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgndGFnTmFtZScpKSB0aHJvdyBuZXcgRXJyb3IoJ2pzb24tZG9tLXBhcnNlcjogbWlzc2luZyB0YWdOYW1lJyk7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gbm9kZURlZi50YWdOYW1lO1xuXG4gICAgICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICAgICAgLy8gTmFtZXNwYWNlIFVSSVxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ25hbWVzcGFjZVVSSScpKSBucyA9IG5vZGVEZWYubmFtZXNwYWNlVVJJO1xuICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzdmcgPSAobnMgPT09IHN2Z05hbWVzcGFjZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoc3ZnKSA/IFYgOiAkO1xuICAgICAgICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGVEZWYuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB3cmFwcGVyKG5vZGUpLmF0dHIoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyBTdHlsZVxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBub2RlRGVmLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSAkKG5vZGUpLmNzcyhzdHlsZSk7XG4gICAgICAgICAgICAvLyBDbGFzc05hbWVcbiAgICAgICAgICAgIGlmIChub2RlRGVmLmhhc093blByb3BlcnR5KCdjbGFzc05hbWUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG5vZGVEZWYuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUZXh0Q29udGVudFxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ3RleHRDb250ZW50JykpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gbm9kZURlZi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbGVjdG9yXG4gICAgICAgICAgICBpZiAobm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0b3InKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTZWxlY3RvciA9IG5vZGVEZWYuc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tub2RlU2VsZWN0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ2pzb24tZG9tLXBhcnNlcjogc2VsZWN0b3IgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNbbm9kZVNlbGVjdG9yXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgd3JhcHBlcihub2RlKS5hdHRyKCdqb2ludC1zZWxlY3RvcicsIG5vZGVTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm91cHNcbiAgICAgICAgICAgIGlmIChub2RlRGVmLmhhc093blByb3BlcnR5KCdncm91cFNlbGVjdG9yJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUdyb3VwcyA9IG5vZGVEZWYuZ3JvdXBTZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZUdyb3VwcykpIG5vZGVHcm91cHMgPSBbbm9kZUdyb3Vwc107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlR3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVHcm91cCA9IG5vZGVHcm91cHNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGdyb3VwU2VsZWN0b3JzW25vZGVHcm91cF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JvdXApIGdyb3VwID0gZ3JvdXBTZWxlY3RvcnNbbm9kZUdyb3VwXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgICAgICAgLy8gQ2hpbGRyZW5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuRGVmKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlTm9kZShjaGlsZHJlbkRlZiwgbm9kZSwgbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwYXJzZU5vZGUoanNvbiwgZnJhZ21lbnQsIG5zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgICAgICBncm91cFNlbGVjdG9yczogZ3JvdXBTZWxlY3RvcnNcbiAgICB9O1xufTtcblxuLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggY29kZSBmcm9tIGEgc3RyaW5nLiBTZWUgaHR0cDovL3dlcnhsdGQuY29tL3dwLzIwMTAvMDUvMTMvamF2YXNjcmlwdC1pbXBsZW1lbnRhdGlvbi1vZi1qYXZhcy1zdHJpbmctaGFzaGNvZGUtbWV0aG9kLy5cbmV4cG9ydCBjb25zdCBoYXNoQ29kZSA9IGZ1bmN0aW9uKHN0cikge1xuXG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGM7XG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZGVsaW1pdGVyKSB7XG5cbiAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChkZWxpbWl0ZXIgfHwgJy8nKTtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgICBpZiAoT2JqZWN0KG9iaikgPT09IG9iaiAmJiBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGlzR2V0U2FmZSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgLy8gUHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgLy8gaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1KU09OOE1FUkdFUEFUQ0gtMTAzODM5OVxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgdmFsdWUsIGRlbGltaXRlcikge1xuXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChkZWxpbWl0ZXIgfHwgJy8nKTtcbiAgICBjb25zdCBsYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgIGxldCBkaXZlciA9IG9iajtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWlzR2V0U2FmZShkaXZlciwga2V5KSkgcmV0dXJuIG9iajtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkaXZlcltrZXldO1xuICAgICAgICAvLyBkaXZlciBjcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBpZiB0aGVyZSBpcyBubyBuZXN0ZWQgb2JqZWN0IHVuZGVyIHN1Y2ggYSBrZXkuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvbmUgY2FuIHBvcHVsYXRlIGFuIGVtcHR5IG5lc3RlZCBvYmplY3Qgd2l0aCBzZXRCeVBhdGgoKS5cbiAgICAgICAgZGl2ZXIgPSB2YWx1ZSB8fCAoZGl2ZXJba2V5XSA9IHt9KTtcbiAgICB9XG5cbiAgICBkaXZlcltrZXlzW2xhc3RdXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBjb25zdCB1bnNldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZGVsaW1pdGVyKSB7XG5cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KGRlbGltaXRlciB8fCAnLycpO1xuICAgIGNvbnN0IGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGRpdmVyID0gb2JqO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghaXNHZXRTYWZlKGRpdmVyLCBrZXkpKSByZXR1cm4gb2JqO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRpdmVyW2tleV07XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBvYmo7XG4gICAgICAgIGRpdmVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZGVsZXRlIGRpdmVyW2tleXNbbGFzdF1dO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBkZWxpbSwgc3RvcCkge1xuXG4gICAgZGVsaW0gPSBkZWxpbSB8fCAnLyc7XG4gICAgdmFyIHJldCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBzaG91bGRHb0RlZXBlciA9IHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmIChzaG91bGRHb0RlZXBlciAmJiBzdG9wICYmIHN0b3Aob2JqW2tleV0pKSB7XG4gICAgICAgICAgICBzaG91bGRHb0RlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEdvRGVlcGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBmbGF0T2JqZWN0ID0gZmxhdHRlbk9iamVjdChvYmpba2V5XSwgZGVsaW0sIHN0b3ApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBmbGF0S2V5IGluIGZsYXRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZsYXRPYmplY3QuaGFzT3duUHJvcGVydHkoZmxhdEtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldFtrZXkgKyBkZWxpbSArIGZsYXRLZXldID0gZmxhdE9iamVjdFtmbGF0S2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBjb25zdCB1dWlkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBjcmVkaXQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yMTE3NTIzL3JldmlzaW9uc1xuXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICAgICAgdmFyIHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG5cbi8vIEdlbmVyYXRlcyBnbG9iYWwgdW5pcXVlIGlkIGFuZCBzdG9yZXMgaXQgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LCBpZiBwcm92aWRlZC5cbmV4cG9ydCBjb25zdCBndWlkID0gZnVuY3Rpb24ob2JqKSB7XG5cbiAgICBndWlkLmlkID0gZ3VpZC5pZCB8fCAxO1xuXG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnal8nICsgZ3VpZC5pZCsrO1xuICAgIH1cblxuICAgIG9iai5pZCA9IChvYmouaWQgPT09IHVuZGVmaW5lZCA/ICdqXycgKyBndWlkLmlkKysgOiBvYmouaWQpO1xuICAgIHJldHVybiBvYmouaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgdG9LZWJhYkNhc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW0EtWl0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblxuICAgIGlmIChldnQubm9ybWFsaXplZCkgcmV0dXJuIGV2dDtcblxuICAgIGNvbnN0IHsgb3JpZ2luYWxFdmVudCwgdGFyZ2V0IH0gPSBldnQ7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgbm9ybWFsaXplIGl0IHRvIGEgbW91c2UgZXZlbnQuXG4gICAgY29uc3QgdG91Y2ggPSBvcmlnaW5hbEV2ZW50ICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBpZiAodG91Y2gpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdG91Y2gpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGZpcnN0IHRvdWNoIHRoYXQgYXJlIG5vdFxuICAgICAgICAgICAgLy8gZGVmaW5lZCBvbiBUb3VjaEV2ZW50IChjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIGlkZW50aWZpZXIsIC4uLilcbiAgICAgICAgICAgIGlmIChldnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBldnRbcHJvcGVydHldID0gdG91Y2hbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFOiBldnQudGFyZ2V0IGNvdWxkIGJlIHNldCB0byBTVkdFbGVtZW50SW5zdGFuY2UgZm9yIFNWR1VzZUVsZW1lbnRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHVzZUVsZW1lbnQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgIGlmICh1c2VFbGVtZW50KSBldnQudGFyZ2V0ID0gdXNlRWxlbWVudDtcbiAgICB9XG5cbiAgICBldnQubm9ybWFsaXplZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZXZ0O1xufTtcblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVdoZWVsID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgLy8gU2FuZSB2YWx1ZXMgZGVyaXZlZCBlbXBpcmljYWxseVxuICAgIGNvbnN0IFBJWEVMX1NURVAgID0gMTA7XG4gICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICBjb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcblxuICAgIGxldCBzWCA9IDAsIHNZID0gMCwgcFggPSAwLCBwWSA9IDA7XG5cbiAgICAvLyBMZWdhY3lcbiAgICBpZiAoJ2RldGFpbCcgICAgICBpbiBldnQpIHsgc1kgPSBldnQuZGV0YWlsOyB9XG4gICAgaWYgKCd3aGVlbERlbHRhJyAgaW4gZXZ0KSB7IHNZID0gLWV2dC53aGVlbERlbHRhIC8gMTIwOyB9XG4gICAgaWYgKCd3aGVlbERlbHRhWScgaW4gZXZ0KSB7IHNZID0gLWV2dC53aGVlbERlbHRhWSAvIDEyMDsgfVxuICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGV2dCkgeyBzWCA9IC1ldnQud2hlZWxEZWx0YVggLyAxMjA7IH1cblxuICAgIC8vIHNpZGUgc2Nyb2xsaW5nIG9uIEZGIHdpdGggRE9NTW91c2VTY3JvbGxcbiAgICBpZiAoICdheGlzJyBpbiBldnQgJiYgZXZ0LmF4aXMgPT09IGV2dC5IT1JJWk9OVEFMX0FYSVMgKSB7XG4gICAgICAgIHNYID0gc1k7XG4gICAgICAgIHNZID0gMDtcbiAgICB9XG5cbiAgICBwWCA9ICdkZWx0YVgnIGluIGV2dCA/IGV2dC5kZWx0YVggOiBzWCAqIFBJWEVMX1NURVA7XG4gICAgcFkgPSAnZGVsdGFZJyBpbiBldnQgPyBldnQuZGVsdGFZIDogc1kgKiBQSVhFTF9TVEVQO1xuXG4gICAgaWYgKChwWCB8fCBwWSkgJiYgZXZ0LmRlbHRhTW9kZSkge1xuICAgICAgICBpZiAoZXZ0LmRlbHRhTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICBwWCAqPSBMSU5FX0hFSUdIVDtcbiAgICAgICAgICAgIHBZICo9IExJTkVfSEVJR0hUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcFggKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgICAgICBwWSAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hY09TIHN3aXRjaGVzIGRlbHRhWCBhbmQgZGVsdGFZIGF1dG9tYXRpY2FsbHkgd2hlbiBzY3JvbGxpbmcgd2l0aCBzaGlmdCBrZXksIHNvIHRoaXMgaXMgbmVlZGVkIGluIG90aGVyIGNhc2VzXG4gICAgaWYgKGV2dC5kZWx0YVggPT09IDAgJiYgZXZ0LmRlbHRhWSAhPT0gMCAmJiBldnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcFggPSBwWTtcbiAgICAgICAgcFkgPSAwO1xuICAgICAgICBzWCA9IHNZO1xuICAgICAgICBzWSA9IDA7XG4gICAgfVxuXG4gICAgLy8gRmFsbC1iYWNrIGlmIHNwaW4gY2Fubm90IGJlIGRldGVybWluZWRcbiAgICBpZiAocFggJiYgIXNYKSB7IHNYID0gKHBYIDwgMSkgPyAtMSA6IDE7IH1cbiAgICBpZiAocFkgJiYgIXNZKSB7IHNZID0gKHBZIDwgMSkgPyAtMSA6IDE7IH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNwaW5YICA6IHNYLFxuICAgICAgICBzcGluWSAgOiBzWSxcbiAgICAgICAgZGVsdGFYIDogcFgsXG4gICAgICAgIGRlbHRhWSA6IHBZLFxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3QgY2FwID0gZnVuY3Rpb24odmFsLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsID4gbWF4ID8gbWF4IDogdmFsIDwgLW1heCA/IC1tYXggOiB2YWw7XG59O1xuXG5leHBvcnQgY29uc3QgbmV4dEZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHJhZjtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKCFyYWYpIHtcblxuICAgICAgICB2YXIgbGFzdFRpbWUgPSAwO1xuXG4gICAgICAgIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICB9LCB0aW1lVG9DYWxsKTtcblxuICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQsIC4uLnJlc3QpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICA/IHJhZihjYWxsYmFjay5iaW5kKGNvbnRleHQsIC4uLnJlc3QpKVxuICAgICAgICAgICAgOiByYWYoY2FsbGJhY2spO1xuICAgIH07XG5cbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBjYW5jZWxGcmFtZSA9IChmdW5jdGlvbigpIHtcblxuICAgIHZhciBjYWY7XG4gICAgdmFyIGNsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICBpZiAoY2xpZW50KSB7XG5cbiAgICAgICAgY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgY2FmID0gY2FmIHx8IGNsZWFyVGltZW91dDtcblxuICAgIHJldHVybiBjbGllbnQgPyBjYWYuYmluZCh3aW5kb3cpIDogY2FmO1xuXG59KSgpO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGFwZVBlcmltZXRlckNvbm5lY3Rpb25Qb2ludCA9IGZ1bmN0aW9uKGxpbmtWaWV3LCB2aWV3LCBtYWduZXQsIHJlZmVyZW5jZSkge1xuXG4gICAgdmFyIGJib3g7XG4gICAgdmFyIHNwb3Q7XG5cbiAgICBpZiAoIW1hZ25ldCkge1xuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG1hZ25ldCwgdHJ5IHRvIG1ha2UgdGhlIGJlc3QgZ3Vlc3Mgd2hhdCBpcyB0aGVcbiAgICAgICAgLy8gd3JhcHBpbmcgU1ZHIGVsZW1lbnQuIFRoaXMgaXMgYmVjYXVzZSB3ZSB3YW50IHRoaXMgXCJzbWFydFwiXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gcG9pbnRzIHRvIHdvcmsgb3V0IG9mIHRoZSBib3ggd2l0aG91dCB0aGVcbiAgICAgICAgLy8gcHJvZ3JhbW1lciB0byBwdXQgbWFnbmV0IG1hcmtzIHRvIGFueSBvZiB0aGUgc3ViZWxlbWVudHMuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCB3ZSB3YW50IHRoZSBmdW5jdGlvbiB0byB3b3JrIG9uIGJhc2ljLlBhdGggZWxlbWVudHNcbiAgICAgICAgLy8gd2l0aG91dCBhbnkgc3BlY2lhbCB0cmVhdG1lbnQgb2Ygc3VjaCBlbGVtZW50cy5cbiAgICAgICAgLy8gVGhlIGNvZGUgYmVsb3cgZ3Vlc3NlcyB0aGUgd3JhcHBpbmcgZWxlbWVudCBiYXNlZCBvblxuICAgICAgICAvLyBvbmUgc2ltcGxlIGFzc3VtcHRpb24uIFRoZSB3cmFwcGluZyBlbGVtbmV0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCBjaGlsZCBvZiB0aGUgc2NhbGFibGUgZ3JvdXAgaWYgc3VjaCBhIGdyb3VwIGV4aXN0c1xuICAgICAgICAvLyBvciB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHJvdGF0YWJsZSBncm91cCBpZiBub3QuXG4gICAgICAgIC8vIFRoaXMgbWFrZXNlIHNlbnNlIGJlY2F1c2UgdXN1YWxseSB0aGUgd3JhcHBpbmcgZWxlbWVudFxuICAgICAgICAvLyBpcyBiZWxvdyBhbnkgb3RoZXIgc3ViIGVsZW1lbnQgaW4gdGhlIHNoYXBlcy5cbiAgICAgICAgdmFyIHNjYWxhYmxlID0gdmlldy4kKCcuc2NhbGFibGUnKVswXTtcbiAgICAgICAgdmFyIHJvdGF0YWJsZSA9IHZpZXcuJCgnLnJvdGF0YWJsZScpWzBdO1xuXG4gICAgICAgIGlmIChzY2FsYWJsZSAmJiBzY2FsYWJsZS5maXJzdENoaWxkKSB7XG5cbiAgICAgICAgICAgIG1hZ25ldCA9IHNjYWxhYmxlLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyb3RhdGFibGUgJiYgcm90YXRhYmxlLmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgbWFnbmV0ID0gcm90YXRhYmxlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFnbmV0KSB7XG5cbiAgICAgICAgc3BvdCA9IFYobWFnbmV0KS5maW5kSW50ZXJzZWN0aW9uKHJlZmVyZW5jZSwgbGlua1ZpZXcucGFwZXIuY2VsbHMpO1xuICAgICAgICBpZiAoIXNwb3QpIHtcbiAgICAgICAgICAgIGJib3ggPSBWKG1hZ25ldCkuZ2V0QkJveCh7IHRhcmdldDogbGlua1ZpZXcucGFwZXIuY2VsbHMgfSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYmJveCA9IHZpZXcubW9kZWwuZ2V0QkJveCgpO1xuICAgICAgICBzcG90ID0gYmJveC5pbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50KHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBzcG90IHx8IGJib3guY2VudGVyKCk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNQZXJjZW50YWdlID0gZnVuY3Rpb24odmFsKSB7XG5cbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKSAmJiB2YWwuc2xpY2UoLTEpID09PSAnJSc7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDc3NOdW1lcmljID0gZnVuY3Rpb24odmFsLCByZXN0cmljdFVuaXRzKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRVbml0KHZhbGlkVW5pdEV4cCkge1xuXG4gICAgICAgIC8vIG9uZSBvciBtb3JlIG51bWJlcnMsIGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vIGFueSBudW1iZXIgb2YgKFxuICAgICAgICAvLyAgYC5gLCBmb2xsb3dlZCBieVxuICAgICAgICAvLyAgb25lIG9yIG1vcmUgbnVtYmVyc1xuICAgICAgICAvLyApLCBmb2xsb3dlZCBieVxuICAgICAgICAvLyBgdmFsaWRVbml0RXhwYCwgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gZW5kIG9mIHN0cmluZ1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJyg/OlxcXFxkKyg/OlxcXFwuXFxcXGQrKSopKCcgKyB2YWxpZFVuaXRFeHAgKyAnKSQnKS5leGVjKHZhbCk7XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgfVxuXG4gICAgdmFyIG51bWJlciA9IHBhcnNlRmxvYXQodmFsKTtcblxuICAgIC8vIGlmIGB2YWxgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBudW1iZXIsIHJldHVybiBgbnVsbGBcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG51bWJlcikpIHJldHVybiBudWxsO1xuXG4gICAgLy8gZWxzZTogd2Uga25vdyBgb3V0cHV0LnZhbHVlYFxuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBvdXRwdXQudmFsdWUgPSBudW1iZXI7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHVuaXRcbiAgICB2YXIgdmFsaWRVbml0RXhwO1xuICAgIGlmIChyZXN0cmljdFVuaXRzID09IG51bGwpIHtcbiAgICAgICAgLy8gbm8gcmVzdHJpY3Rpb25cbiAgICAgICAgLy8gYWNjZXB0IGFueSB1bml0LCBhcyB3ZWxsIGFzIG5vIHVuaXRcbiAgICAgICAgdmFsaWRVbml0RXhwID0gJ1tBLVphLXpdKic7XG5cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdHJpY3RVbml0cykpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBlbXB0eSBhcnJheSwgdG9wIHJlc3RyaWN0aW9uIC0gcmV0dXJuIGBudWxsYFxuICAgICAgICBpZiAocmVzdHJpY3RVbml0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIGVsc2U6IHJlc3RyaWN0aW9uIC0gYW4gYXJyYXkgb2YgdmFsaWQgdW5pdCBzdHJpbmdzXG4gICAgICAgIHZhbGlkVW5pdEV4cCA9IHJlc3RyaWN0VW5pdHMuam9pbignfCcpO1xuXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhyZXN0cmljdFVuaXRzKSkge1xuICAgICAgICAvLyByZXN0cmljdGlvbiAtIGEgc2luZ2xlIHZhbGlkIHVuaXQgc3RyaW5nXG4gICAgICAgIHZhbGlkVW5pdEV4cCA9IHJlc3RyaWN0VW5pdHM7XG4gICAgfVxuICAgIHZhciB1bml0ID0gZ2V0VW5pdCh2YWxpZFVuaXRFeHApO1xuXG4gICAgLy8gaWYgd2UgZm91bmQgbm8gbWF0Y2hlcyBmb3IgYHJlc3RyaWN0VW5pdHNgLCByZXR1cm4gYG51bGxgXG4gICAgaWYgKHVuaXQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgLy8gZWxzZTogd2Uga25vdyB0aGUgdW5pdFxuICAgIG91dHB1dC51bml0ID0gdW5pdDtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgTk9fU1BBQ0UgPSAwO1xuXG5mdW5jdGlvbiBzcGxpdFdvcmRXaXRoRU9MKHdvcmQsIGVvbCkge1xuICAgIGNvbnN0IGVvbFdvcmRzID0gd29yZC5zcGxpdChlb2wpO1xuICAgIGxldCBuID0gMTtcbiAgICBmb3IgKGxldCBqID0gMCwgamwgPSBlb2xXb3Jkcy5sZW5ndGggLSAxOyBqIDwgamw7IGorKykge1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IFtdO1xuICAgICAgICBpZiAoaiA+IDAgfHwgZW9sV29yZHNbMF0gIT09ICcnKSByZXBsYWNlbWVudC5wdXNoKE5PX1NQQUNFKTtcbiAgICAgICAgcmVwbGFjZW1lbnQucHVzaChlb2wpO1xuICAgICAgICBpZiAoaiA8IGpsIC0gMSB8fCBlb2xXb3Jkc1tqbF0gIT09ICcnKSByZXBsYWNlbWVudC5wdXNoKE5PX1NQQUNFKTtcbiAgICAgICAgZW9sV29yZHMuc3BsaWNlKG4sIDAsIC4uLnJlcGxhY2VtZW50KTtcbiAgICAgICAgbiArPSByZXBsYWNlbWVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZW9sV29yZHMuZmlsdGVyKHdvcmQgPT4gd29yZCAhPT0gJycpO1xufVxuXG5cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHQoaGVpZ2h0VmFsdWUsIHRleHRFbGVtZW50KSB7XG4gICAgaWYgKGhlaWdodFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIERlZmF1bHQgMWVtIGxpbmVIZWlnaHRcbiAgICAgICAgcmV0dXJuIHRleHRFbGVtZW50LmdldEJCb3goKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChoZWlnaHRWYWx1ZS51bml0KSB7XG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RWxlbWVudC5nZXRCQm94KCkuaGVpZ2h0ICogaGVpZ2h0VmFsdWUudmFsdWU7XG4gICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHRWYWx1ZS52YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBicmVha1RleHQgPSBmdW5jdGlvbih0ZXh0LCBzaXplLCBzdHlsZXMgPSB7fSwgb3B0ID0ge30pIHtcblxuICAgIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgdmFyIHN2Z0RvY3VtZW50ID0gb3B0LnN2Z0RvY3VtZW50IHx8IFYoJ3N2ZycpLm5vZGU7XG4gICAgdmFyIHRleHRTcGFuID0gVigndHNwYW4nKS5ub2RlO1xuICAgIHZhciB0ZXh0RWxlbWVudCA9IFYoJ3RleHQnKS5hdHRyKHN0eWxlcykuYXBwZW5kKHRleHRTcGFuKS5ub2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblxuICAgIC8vIFByZXZlbnQgZmxpY2tlcmluZ1xuICAgIHRleHRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIC8vIFByZXZlbnQgRkYgZnJvbSB0aHJvd2luZyBhbiB1bmNhdWdodCBleGNlcHRpb24gd2hlbiBgZ2V0QkJveCgpYFxuICAgIC8vIGNhbGxlZCBvbiBlbGVtZW50IHRoYXQgaXMgbm90IGluIHRoZSByZW5kZXIgdHJlZSAoaXMgbm90IG1lYXN1cmFibGUpLlxuICAgIC8vIDx0c3Bhbj4uZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgcmV0dXJucyBhbHdheXMgMCBpbiB0aGlzIGNhc2UuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBgdGV4dEVsZW1lbnRgIHJlc3AuIGB0ZXh0U3BhbmAgY2FuIGJlY29tZSBoaWRkZW5cbiAgICAvLyB3aGVuIGl0J3MgYXBwZW5kZWQgdG8gdGhlIERPTSBhbmQgYSBgZGlzcGxheTogbm9uZWAgQ1NTIHN0eWxlc2hlZXRcbiAgICAvLyBydWxlIGdldHMgYXBwbGllZC5cbiAgICB0ZXh0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0ZXh0U3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRleHRTcGFuLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICBzdmdEb2N1bWVudC5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudCk7IC8vIGxndG0gW2pzL3hzcy10aHJvdWdoLWRvbV1cblxuICAgIGlmICghb3B0LnN2Z0RvY3VtZW50KSB7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdEb2N1bWVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlc2VydmVTcGFjZXMgPSBvcHQucHJlc2VydmVTcGFjZXM7XG4gICAgY29uc3Qgc3BhY2UgPSAnICc7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gKG9wdC5zZXBhcmF0b3IgfHwgb3B0LnNlcGFyYXRvciA9PT0gJycpID8gb3B0LnNlcGFyYXRvciA6IHNwYWNlO1xuICAgIC8vIElmIHNlcGFyYXRvciBpcyBhIFJlZ0V4cCwgd2UgdXNlIHRoZSBzcGFjZSBjaGFyYWN0ZXIgdG8gam9pbiB3b3JkcyB0b2dldGhlciBhZ2FpbiAobm90IGlkZWFsKVxuICAgIGNvbnN0IHNlcGFyYXRvckNoYXIgPSAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpID8gc2VwYXJhdG9yIDogc3BhY2U7XG4gICAgdmFyIGVvbCA9IG9wdC5lb2wgfHwgJ1xcbic7XG4gICAgdmFyIGh5cGhlbiA9IG9wdC5oeXBoZW4gPyBuZXcgUmVnRXhwKG9wdC5oeXBoZW4pIDogL1teXFx3XFxkXFx1MDBDMC1cXHUxRkZGXFx1MjgwMC1cXHVGRkZEXS87XG4gICAgdmFyIG1heExpbmVDb3VudCA9IG9wdC5tYXhMaW5lQ291bnQ7XG4gICAgaWYgKCFpc051bWJlcihtYXhMaW5lQ291bnQpKSBtYXhMaW5lQ291bnQgPSBJbmZpbml0eTtcblxuICAgIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB2YXIgZnVsbCA9IFtdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBwLCBoO1xuICAgIHZhciBsaW5lSGVpZ2h0O1xuXG4gICAgaWYgKHByZXNlcnZlU3BhY2VzKSB7XG4gICAgICAgIFYodGV4dFNwYW4pLmF0dHIoJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gMCwgbGVuID0gd29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICB2YXIgd29yZCA9IHdvcmRzW2ldO1xuXG4gICAgICAgIGlmICghd29yZCAmJiAhcHJlc2VydmVTcGFjZXMpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHdvcmQgIT09ICdzdHJpbmcnKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaXNFb2wgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVvbCAmJiB3b3JkLmluZGV4T2YoZW9sKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyB3b3JkIGNvbnRhaW5zIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlIHdvcmQgYW5kIGNvbnRpbnVlIGN5Y2xlXG4gICAgICAgICAgICAgICAgY29uc3QgZW9sV29yZHMgPSBzcGxpdFdvcmRXaXRoRU9MKHdvcmRzW2ldLCBlb2wpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpLCAxLCAuLi5lb2xXb3Jkcyk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGxlbiA9IHdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlU3BhY2VzICYmIHR5cGVvZiB3b3Jkc1tpIC0gMV0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgTk9fU1BBQ0UsICcnLCBOT19TUEFDRSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lc1srK2xdID0gKCFwcmVzZXJ2ZVNwYWNlcyB8fCB0eXBlb2Ygd29yZHNbaSArIDFdID09PSAnc3RyaW5nJykgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc0VvbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRW9sKSB7XG5cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpbmVzW2xdICE9PSB1bmRlZmluZWQgPyBsaW5lc1tsXSArIHNlcGFyYXRvckNoYXIgKyB3b3JkIDogd29yZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpbmVzW2xdID8gbGluZXNbbF0gKyBzZXBhcmF0b3JDaGFyICsgd29yZCA6IHdvcmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHROb2RlLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICBpZiAodGV4dFNwYW4uZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPD0gd2lkdGgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGxpbmUgZml0c1xuICAgICAgICAgICAgICAgIGxpbmVzW2xdID0gZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwIHx8IGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBwYXJ0aXRpb25pbmcuIFB1dCByZXN0IG9mIHRoZSB3b3JkIG9udG8gbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxbbCsrXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsIHBhcnRpdGlvbmluZyBhbmQgc3BsaXR0aW5nIGJ5IGh5cGhlbnNcbiAgICAgICAgICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICghbGluZXNbbF0gfHwgcCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aXRpb24gPSAhIXA7XG5cbiAgICAgICAgICAgICAgICAgICAgcCA9IHdvcmQubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGl0aW9uIHx8ICFwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmQgaGFzIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lc1tsXSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdvbid0IGZpdCB0aGlzIHRleHQgd2l0aGluIG91ciByZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFydGl0aW9uaW5nIGRpZG4ndCBoZWxwIG9uIHRoZSBub24tZW1wdHkgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBhZ2FpbiwgYnV0IHRoaXMgdGltZSBzdGFydCB3aXRoIGEgbmV3IGxpbmVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBwYXJ0aXRpb25zIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgMiwgd29yZCArIHdvcmRzW2kgKyAxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgd29yZCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4tLTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxbbCsrXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgbGFzdCBsZXR0ZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmQuc3Vic3RyaW5nKDAsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB3b3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpICsgMV0gPSB3b3JkLnN1YnN0cmluZyhwKSArIChuZXh0V29yZCA9PT0gdW5kZWZpbmVkIHx8IG5leHRXb3JkID09PSBOT19TUEFDRSA/ICcnIDogbmV4dFdvcmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWwgc3BsaXR0aW5nIGFuZCBwdXQgdGhlIHdvcmRzIHRvZ2V0aGVyIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGksIDIsIHdvcmRzW2ldICsgd29yZHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh5cGhlbkluZGV4ID0gd29yZC5zZWFyY2goaHlwaGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHlwaGVuSW5kZXggPiAtMSAmJiBoeXBoZW5JbmRleCAhPT0gd29yZC5sZW5ndGggLSAxICYmIGh5cGhlbkluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBoeXBoZW5JbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGluaXRpYXRlIHBhcnRpdGlvbmluZyBvciBzcGxpdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgbG9uZyB3b3JkIGludG8gdHdvIHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGksIDEsIHdvcmQuc3Vic3RyaW5nKDAsIGggfHwgcCksIHdvcmQuc3Vic3RyaW5nKGh8fCBwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHdvcmRzIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbisrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsICYmICFmdWxsW2wgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIGxpbmUgaXMgbm90IGZ1bGwsIHRyeSB0byBmaXQgbWF4IHBhcnQgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlU3BhY2VzIHx8IGxpbmVzW2xdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEwgPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiBtYXhMaW5lQ291bnQpIHtcblxuICAgICAgICAgICAgbGFzdEwgPSBtYXhMaW5lQ291bnQgLSAxO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgLy8gaWYgc2l6ZS5oZWlnaHQgaXMgZGVmaW5lZCB3ZSBoYXZlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGhlaWdodCBvZiB0aGUgZW50aXJlXG4gICAgICAgICAgICAvLyB0ZXh0IGV4Y2VlZHMgdGhlIHJlY3QgaGVpZ2h0XG5cbiAgICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID09PSB1bmRlZmluZWQgJiYgdGV4dE5vZGUuZGF0YSAhPT0gJycpIHtcblxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgc2FtZSBkZWZhdWx0cyBhcyBpbiBWLnByb3RvdHlwZS50ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlcy5saW5lSGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoeyB2YWx1ZTogMS41LCB1bml0OiAnZW0nIH0sIHRleHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNzc051bWVyaWMoc3R5bGVzLmxpbmVIZWlnaHQsIFsnZW0nLCAncHgnLCAnJ10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KHBhcnNlZCwgdGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGggPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3ZlcmZsb3dpbmcgbGluZXNcbiAgICAgICAgICAgICAgICBsYXN0TCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gbGluZUhlaWdodCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RMICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGxpbmVzLnNwbGljZShsYXN0TCArIDEpO1xuXG4gICAgICAgICAgICAvLyBhZGQgZWxsaXBzaXNcbiAgICAgICAgICAgIHZhciBlbGxpcHNpcyA9IG9wdC5lbGxpcHNpcztcbiAgICAgICAgICAgIGlmICghZWxsaXBzaXMgfHwgbGFzdEwgPCAwKSBicmVhaztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxsaXBzaXMgIT09ICdzdHJpbmcnKSBlbGxpcHNpcyA9ICdcXHUyMDI2JztcblxuICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXNbbGFzdExdO1xuICAgICAgICAgICAgaWYgKCFsYXN0TGluZSAmJiAhaXNFb2wpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGsgPSBsYXN0TGluZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGFzdExpbmVXaXRoT21pc3Npb24sIGxhc3RDaGFyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxhc3RDaGFyID0gbGFzdExpbmVba107XG4gICAgICAgICAgICAgICAgbGFzdExpbmVXaXRoT21pc3Npb24gPSBsYXN0TGluZS5zdWJzdHJpbmcoMCwgayk7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiArPSBzZXBhcmF0b3JDaGFyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENoYXIubWF0Y2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiArPSBsYXN0Q2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdExpbmVXaXRoT21pc3Npb24gKz0gZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUuZGF0YSA9IGxhc3RMaW5lV2l0aE9taXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3Bhbi5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA8PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lc1tsYXN0TF0gPSBsYXN0TGluZVdpdGhPbWlzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGsgPj0gMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHQuc3ZnRG9jdW1lbnQpIHtcblxuICAgICAgICAvLyBzdmcgZG9jdW1lbnQgd2FzIHByb3ZpZGVkLCByZW1vdmUgdGhlIHRleHQgZWxlbWVudCBvbmx5XG4gICAgICAgIHN2Z0RvY3VtZW50LnJlbW92ZUNoaWxkKHRleHRFbGVtZW50KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gY2xlYW4gc3ZnIGRvY3VtZW50XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnRG9jdW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKGVvbCk7XG59O1xuXG4vLyBTYW5pdGl6ZSBIVE1MXG4vLyBCYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS91Zm9sb2dpc3QvNWEwZGE1MWIyYjllZjFiODYxYzMwMjU0MTcyYWMzYzlcbi8vIFBhcnNlcyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIERPTSBub2Rlcy5cbi8vIFRoZW4gb3V0cHV0cyBpdCBiYWNrIGFzIGEgc3RyaW5nLlxuZXhwb3J0IGNvbnN0IHNhbml0aXplSFRNTCA9IGZ1bmN0aW9uKGh0bWwpIHtcblxuICAgIC8vIElnbm9yZXMgdGFncyB0aGF0IGFyZSBpbnZhbGlkIGluc2lkZSBhIDxkaXY+IHRhZyAoZS5nLiA8Ym9keT4sIDxoZWFkPilcblxuICAgIC8vIElmIGRvY3VtZW50Q29udGV4dCAoc2Vjb25kIHBhcmFtZXRlcikgaXMgbm90IHNwZWNpZmllZCBvciBnaXZlbiBhcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGEgbmV3IGRvY3VtZW50IGlzIHVzZWQuXG4gICAgLy8gSW5saW5lIGV2ZW50cyB3aWxsIG5vdCBleGVjdXRlIHdoZW4gdGhlIEhUTUwgaXMgcGFyc2VkOyB0aGlzIGluY2x1ZGVzLCBmb3IgZXhhbXBsZSwgc2VuZGluZyBHRVQgcmVxdWVzdHMgZm9yIGltYWdlcy5cblxuICAgIC8vIElmIGtlZXBTY3JpcHRzIChsYXN0IHBhcmFtZXRlcikgaXMgYGZhbHNlYCwgc2NyaXB0cyBhcmUgbm90IGV4ZWN1dGVkLlxuICAgIHZhciBvdXRwdXQgPSAkKCQucGFyc2VIVE1MKCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicsIG51bGwsIGZhbHNlKSk7XG5cbiAgICBvdXRwdXQuZmluZCgnKicpLmVhY2goZnVuY3Rpb24oKSB7IC8vIGZvciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcztcblxuICAgICAgICAkLmVhY2goY3VycmVudE5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oKSB7IC8vIGZvciBhbGwgYXR0cmlidXRlcyBpbiBlYWNoIG5vZGVcbiAgICAgICAgICAgIHZhciBjdXJyZW50QXR0cmlidXRlID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY3VycmVudEF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGN1cnJlbnRBdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzdGFydCB3aXRoIFwib25cIiAoZS5nLiBvbmxvYWQsIG9uZXJyb3IuLi4pLlxuICAgICAgICAgICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZSB2YWx1ZXMgdGhhdCBzdGFydCB3aXRoIFwiamF2YXNjcmlwdDpcIiBwc2V1ZG8gcHJvdG9jb2wgKGUuZy4gYGhyZWY9XCJqYXZhc2NyaXB0OmFsZXJ0KDEpXCJgKS5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZS5zdGFydHNXaXRoKCdvbicpIHx8IGF0dHJWYWx1ZS5zdGFydHNXaXRoKCdqYXZhc2NyaXB0OicpIHx8IGF0dHJWYWx1ZS5zdGFydHNXaXRoKCdkYXRhOicpIHx8IGF0dHJWYWx1ZS5zdGFydHNXaXRoKCd2YnNjcmlwdDonKSkge1xuICAgICAgICAgICAgICAgICQoY3VycmVudE5vZGUpLnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXQuaHRtbCgpO1xufTtcblxuLy8gRG93bmxvYWQgYGJsb2JgIGFzIGZpbGUgd2l0aCBgZmlsZU5hbWVgLlxuLy8gRG9lcyBub3Qgd29yayBpbiBJRTkuXG5leHBvcnQgY29uc3QgZG93bmxvYWRCbG9iID0gZnVuY3Rpb24oYmxvYiwgZmlsZU5hbWUpIHtcblxuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IpIHsgLy8gcmVxdWlyZXMgSUUgMTArXG4gICAgICAgIC8vIHB1bGxzIHVwIGEgc2F2ZSBkaWFsb2dcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVOYW1lKTtcblxuICAgIH0gZWxzZSB7IC8vIG90aGVyIGJyb3dzZXJzXG4gICAgICAgIC8vIGRvd25sb2FkcyBkaXJlY3RseSBpbiBDaHJvbWUgYW5kIFNhZmFyaVxuXG4gICAgICAgIC8vIHByZXNlbnRzIGEgc2F2ZS9vcGVuIGRpYWxvZyBpbiBGaXJlZm94XG4gICAgICAgIC8vIEZpcmVmb3ggYnVnOiBgZnJvbWAgZmllbGQgaW4gc2F2ZSBkaWFsb2cgYWx3YXlzIHNob3dzIGBmcm9tOmJsb2I6YFxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDUzMzI3XG5cbiAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblxuICAgICAgICBsaW5rLmNsaWNrKCk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTsgLy8gbWFyayB0aGUgdXJsIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG59O1xuXG4vLyBEb3dubG9hZCBgZGF0YVVyaWAgYXMgZmlsZSB3aXRoIGBmaWxlTmFtZWAuXG4vLyBEb2VzIG5vdCB3b3JrIGluIElFOS5cbmV4cG9ydCBjb25zdCBkb3dubG9hZERhdGFVcmkgPSBmdW5jdGlvbihkYXRhVXJpLCBmaWxlTmFtZSkge1xuXG4gICAgY29uc3QgYmxvYiA9IGRhdGFVcmlUb0Jsb2IoZGF0YVVyaSk7XG4gICAgZG93bmxvYWRCbG9iKGJsb2IsIGZpbGVOYW1lKTtcbn07XG5cbi8vIENvbnZlcnQgYW4gdXJpLWVuY29kZWQgZGF0YSBjb21wb25lbnQgKHBvc3NpYmx5IGFsc28gYmFzZTY0LWVuY29kZWQpIHRvIGEgYmxvYi5cbmV4cG9ydCBjb25zdCBkYXRhVXJpVG9CbG9iID0gZnVuY3Rpb24oZGF0YVVyaSkge1xuXG4gICAgLy8gZmlyc3QsIG1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gbmV3bGluZXMgaW4gdGhlIGRhdGEgdXJpXG4gICAgZGF0YVVyaSA9IGRhdGFVcmkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBkYXRhVXJpID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFVcmkpO1xuXG4gICAgdmFyIGZpcnN0Q29tbWFJbmRleCA9IGRhdGFVcmkuaW5kZXhPZignLCcpOyAvLyBzcGxpdCBkYXRhVXJpIGFzIGBkYXRhVHlwZVN0cmluZ2AsYGRhdGFgXG5cbiAgICB2YXIgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVXJpLnNsaWNlKDAsIGZpcnN0Q29tbWFJbmRleCk7IC8vIGUuZy4gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQnXG4gICAgdmFyIG1pbWVTdHJpbmcgPSBkYXRhVHlwZVN0cmluZy5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07IC8vIGUuZy4gJ2ltYWdlL2pwZWcnXG5cbiAgICB2YXIgZGF0YSA9IGRhdGFVcmkuc2xpY2UoZmlyc3RDb21tYUluZGV4ICsgMSk7XG4gICAgdmFyIGRlY29kZWRTdHJpbmc7XG4gICAgaWYgKGRhdGFUeXBlU3RyaW5nLmluZGV4T2YoJ2Jhc2U2NCcpID49IDApIHsgLy8gZGF0YSBtYXkgYmUgZW5jb2RlZCBpbiBiYXNlNjRcbiAgICAgICAgZGVjb2RlZFN0cmluZyA9IGF0b2IoZGF0YSk7IC8vIGRlY29kZSBkYXRhXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgZGVjb2RlZCBzdHJpbmcgdG8gVVRGLThcbiAgICAgICAgZGVjb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGEgdHlwZWQgYXJyYXlcbiAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShkZWNvZGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGVkU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlhW2ldID0gZGVjb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmxvYihbaWFdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7IC8vIHJldHVybiB0aGUgdHlwZWQgYXJyYXkgYXMgQmxvYlxufTtcblxuLy8gUmVhZCBhbiBpbWFnZSBhdCBgdXJsYCBhbmQgcmV0dXJuIGl0IGFzIGJhc2U2NC1lbmNvZGVkIGRhdGEgdXJpLlxuLy8gVGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgaXMgaW5mZXJyZWQgZnJvbSB0aGUgYHVybGAgZmlsZSBleHRlbnNpb24uXG4vLyBJZiBkYXRhIHVyaSBpcyBwcm92aWRlZCBhcyBgdXJsYCwgaXQgaXMgcmV0dXJuZWQgYmFjayB1bmNoYW5nZWQuXG4vLyBgY2FsbGJhY2tgIGlzIGEgbWV0aG9kIHdpdGggYGVycmAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIGBkYXRhVXJpYCBhcyBzZWNvbmQgYXJndW1lbnQuXG4vLyBXb3JrcyB3aXRoIElFOS5cbmV4cG9ydCBjb25zdCBpbWFnZVRvRGF0YVVyaSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghdXJsIHx8IHVybC5zdWJzdHIoMCwgJ2RhdGE6Jy5sZW5ndGgpID09PSAnZGF0YTonKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY29udmVydCB0byBkYXRhIHVyaSBpZiBpdCBpcyBhbHJlYWR5IGluIGRhdGEgdXJpLlxuXG4gICAgICAgIC8vIFRoaXMgbm90IG9ubHkgY29udmVuaWVudCBidXQgZGVzaXJlZC4gRm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIElFIHRocm93cyBhIHNlY3VyaXR5IGVycm9yIGlmIGRhdGE6aW1hZ2Uvc3ZnK3htbCBpcyB1c2VkIHRvIHJlbmRlclxuICAgICAgICAvLyBhbiBpbWFnZSB0byB0aGUgY2FudmFzIGFuZCBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gcmVhZCBvdXQgZGF0YSB1cmkuXG4gICAgICAgIC8vIE5vdyBpZiBvdXIgaW1hZ2UgaXMgYWxyZWFkeSBpbiBkYXRhIHVyaSwgdGhlcmUgaXMgbm8gbmVlZCB0byByZW5kZXIgaXQgdG8gdGhlIGNhbnZhc1xuICAgICAgICAvLyBhbmQgc28gd2UgY2FuIGJ5cGFzcyB0aGlzIGVycm9yLlxuXG4gICAgICAgIC8vIEtlZXAgdGhlIGFzeW5jIG5hdHVyZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdXJsKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLy8gY2hyb21lLCBJRTEwK1xuICAgIHZhciBtb2Rlcm5IYW5kbGVyID0gZnVuY3Rpb24oeGhyLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcblxuICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVVyaSA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGFVcmkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICcgKyB1cmwpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKHhoci5yZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICcgKyB1cmwpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGVnYWN5SGFuZGxlciA9IGZ1bmN0aW9uKHhociwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgVWludDhUb1N0cmluZyA9IGZ1bmN0aW9uKHU4YSkge1xuICAgICAgICAgICAgdmFyIENIVU5LX1NaID0gMHg4MDAwO1xuICAgICAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdThhLmxlbmd0aDsgaSArPSBDSFVOS19TWikge1xuICAgICAgICAgICAgICAgIGMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgQ0hVTktfU1opKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYy5qb2luKCcnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG5cbiAgICAgICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG5cbiAgICAgICAgICAgIHZhciBzdWZmaXggPSAodXJsLnNwbGl0KCcuJykucG9wKCkpIHx8ICdwbmcnO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgICAgICAgICAnc3ZnJzogJ3N2Zyt4bWwnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1ldGEgPSAnZGF0YTppbWFnZS8nICsgKG1hcFtzdWZmaXhdIHx8IHN1ZmZpeCkgKyAnO2Jhc2U2NCwnO1xuICAgICAgICAgICAgdmFyIGI2NGVuY29kZWQgPSBtZXRhICsgYnRvYShVaW50OFRvU3RyaW5nKGJ5dGVzKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiNjRlbmNvZGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgJyArIHVybCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICcgKyB1cmwpKTtcbiAgICB9KTtcblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSB3aW5kb3cuRmlsZVJlYWRlciA/ICdibG9iJyA6ICdhcnJheWJ1ZmZlcic7XG5cbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93LkZpbGVSZWFkZXIpIHtcbiAgICAgICAgICAgIG1vZGVybkhhbmRsZXIoeGhyLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdhY3lIYW5kbGVyKHhociwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB4aHIuc2VuZCgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRCQm94ID0gZnVuY3Rpb24oZWwpIHtcblxuICAgIHZhciAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSAkZWxbMF07XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB2YXIgY2xpZW50QkJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgc3Ryb2tlV2lkdGhYID0gMDtcbiAgICB2YXIgc3Ryb2tlV2lkdGhZID0gMDtcblxuICAgIC8vIEZpcmVmb3ggY29ycmVjdGlvblxuICAgIGlmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xuXG4gICAgICAgIHZhciB2ZWwgPSBWKGVsZW1lbnQpO1xuICAgICAgICB2YXIgYmJveCA9IHZlbC5nZXRCQm94KHsgdGFyZ2V0OiB2ZWwuc3ZnKCkgfSk7XG5cbiAgICAgICAgLy8gaWYgRkYgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluY2x1ZGVzIHN0cm9rZS13aWR0aCwgZ2V0QkJveCBkb2Vzbid0LlxuICAgICAgICAvLyBUbyB1bmlmeSB0aGlzIGFjcm9zcyBhbGwgYnJvd3NlcnMgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGZpbmFsIGJCb3ggd2l0aCBgc3Ryb2tlLXdpZHRoYCB2YWx1ZS5cbiAgICAgICAgc3Ryb2tlV2lkdGhYID0gKGNsaWVudEJCb3gud2lkdGggLSBiYm94LndpZHRoKTtcbiAgICAgICAgc3Ryb2tlV2lkdGhZID0gKGNsaWVudEJCb3guaGVpZ2h0IC0gYmJveC5oZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNsaWVudEJCb3gubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCAtIGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0TGVmdCArIHN0cm9rZVdpZHRoWCAvIDIsXG4gICAgICAgIHk6IGNsaWVudEJCb3gudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRUb3AgKyBzdHJva2VXaWR0aFkgLyAyLFxuICAgICAgICB3aWR0aDogY2xpZW50QkJveC53aWR0aCAtIHN0cm9rZVdpZHRoWCxcbiAgICAgICAgaGVpZ2h0OiBjbGllbnRCQm94LmhlaWdodCAtIHN0cm9rZVdpZHRoWVxuICAgIH07XG59O1xuXG5cbi8vIEhpZ2hseSBpbnNwaXJlZCBieSB0aGUganF1ZXJ5LnNvcnRFbGVtZW50cyBwbHVnaW4gYnkgUGFkb2xzZXkuXG4vLyBTZWUgaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbS9qYXZhc2NyaXB0L3NvcnRpbmctZWxlbWVudHMtd2l0aC1qcXVlcnkvLlxuZXhwb3J0IGNvbnN0IHNvcnRFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjb21wYXJhdG9yKSB7XG5cbiAgICB2YXIgJGVsZW1lbnRzID0gJChlbGVtZW50cyk7XG4gICAgdmFyIHBsYWNlbWVudHMgPSAkZWxlbWVudHMubWFwKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzb3J0RWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gc29ydEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgLy8gU2luY2UgdGhlIGVsZW1lbnQgaXRzZWxmIHdpbGwgY2hhbmdlIHBvc2l0aW9uLCB3ZSBoYXZlXG4gICAgICAgIC8vIHRvIGhhdmUgc29tZSB3YXkgb2Ygc3RvcmluZyBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uIGluXG4gICAgICAgIC8vIHRoZSBET00uIFRoZSBlYXNpZXN0IHdheSBpcyB0byBoYXZlIGEgJ2ZsYWcnIG5vZGU6XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSwgc29ydEVsZW1lbnQubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5cXCd0IHNvcnQgZWxlbWVudHMgaWYgYW55IG9uZSBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5zZXJ0IGJlZm9yZSBmbGFnOlxuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZsYWc6XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc29ydC5jYWxsKCRlbGVtZW50cywgY29tcGFyYXRvcikuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIHBsYWNlbWVudHNbaV0uY2FsbCh0aGlzKTtcbiAgICB9KTtcbn07XG5cbi8vIFNldHMgYXR0cmlidXRlcyBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgaXRzIGRlc2NlbmRhbnRzIGJhc2VkIG9uIHRoZSBzZWxlY3Rvci5cbi8vIGBhdHRyc2Agb2JqZWN0OiB7IFtTRUxFQ1RPUjFdOiB7IGF0dHJzMSB9LCBbU0VMRUNUT1IyXTogeyBhdHRyczJ9LCAuLi4gfSBlLmcuIHsgJ2lucHV0JzogeyBjb2xvciA6ICdyZWQnIH19XG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlc0J5U2VsZWN0b3IgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuXG4gICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcblxuICAgIGZvckluKGF0dHJzLCBmdW5jdGlvbihhdHRycywgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyICRlbGVtZW50cyA9ICRlbGVtZW50LmZpbmQoc2VsZWN0b3IpLmFkZEJhY2soKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgICAvLyBNYWtlIGEgc3BlY2lhbCBjYXNlIGZvciBzZXR0aW5nIGNsYXNzZXMuXG4gICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgY2xhc3MuXG4gICAgICAgIGlmIChoYXMoYXR0cnMsICdjbGFzcycpKSB7XG4gICAgICAgICAgICAkZWxlbWVudHMuYWRkQ2xhc3MoYXR0cnNbJ2NsYXNzJ10pO1xuICAgICAgICAgICAgYXR0cnMgPSBvbWl0KGF0dHJzLCAnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgICAgICAkZWxlbWVudHMuYXR0cihhdHRycyk7XG4gICAgfSk7XG59O1xuXG4vLyBSZXR1cm4gYSBuZXcgb2JqZWN0IHdpdGggYWxsIGZvdXIgc2lkZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkgaW4gaXQuXG4vLyBWYWx1ZSBvZiBlYWNoIHNpZGUgaXMgdGFrZW4gZnJvbSB0aGUgZ2l2ZW4gYXJndW1lbnQgKGVpdGhlciBudW1iZXIgb3Igb2JqZWN0KS5cbi8vIERlZmF1bHQgdmFsdWUgZm9yIGEgc2lkZSBpcyAwLlxuLy8gRXhhbXBsZXM6XG4vLyBub3JtYWxpemVTaWRlcyg1KSAtLT4geyB0b3A6IDUsIHJpZ2h0OiA1LCBib3R0b206IDUsIGxlZnQ6IDUgfVxuLy8gbm9ybWFsaXplU2lkZXMoeyBob3Jpem9udGFsOiA1IH0pIC0tPiB7IHRvcDogMCwgcmlnaHQ6IDUsIGJvdHRvbTogMCwgbGVmdDogNSB9XG4vLyBub3JtYWxpemVTaWRlcyh7IGxlZnQ6IDUgfSkgLS0+IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiA1IH1cbi8vIG5vcm1hbGl6ZVNpZGVzKHsgaG9yaXpvbnRhbDogMTAsIGxlZnQ6IDUgfSkgLS0+IHsgdG9wOiAwLCByaWdodDogMTAsIGJvdHRvbTogMCwgbGVmdDogNSB9XG4vLyBub3JtYWxpemVTaWRlcyh7IGhvcml6b250YWw6IDAsIGxlZnQ6IDUgfSkgLS0+IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiA1IH1cbmV4cG9ydCBjb25zdCBub3JtYWxpemVTaWRlcyA9IGZ1bmN0aW9uKGJveCkge1xuXG4gICAgaWYgKE9iamVjdChib3gpICE9PSBib3gpIHsgLy8gYGJveGAgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICB2YXIgdmFsID0gMDsgLy8gYHZhbGAgbGVmdCBhcyAwIGlmIGBib3hgIGNhbm5vdCBiZSB1bmRlcnN0b29kIGFzIGZpbml0ZSBudW1iZXJcbiAgICAgICAgaWYgKGlzRmluaXRlKGJveCkpIHZhbCA9ICtib3g7IC8vIGFjdHVhbGx5IGFsc28gYWNjZXB0cyBzdHJpbmcgbnVtYmVycyAoZS5nLiAnMTAwJylcblxuICAgICAgICByZXR1cm4geyB0b3A6IHZhbCwgcmlnaHQ6IHZhbCwgYm90dG9tOiB2YWwsIGxlZnQ6IHZhbCB9O1xuICAgIH1cblxuICAgIC8vIGBib3hgIGlzIGFuIG9iamVjdFxuICAgIHZhciB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQ7XG4gICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gMDtcblxuICAgIGlmIChpc0Zpbml0ZShib3gudmVydGljYWwpKSB0b3AgPSBib3R0b20gPSArYm94LnZlcnRpY2FsO1xuICAgIGlmIChpc0Zpbml0ZShib3guaG9yaXpvbnRhbCkpIHJpZ2h0ID0gbGVmdCA9ICtib3guaG9yaXpvbnRhbDtcblxuICAgIGlmIChpc0Zpbml0ZShib3gudG9wKSkgdG9wID0gK2JveC50b3A7IC8vIG92ZXJ3cml0ZSB2ZXJ0aWNhbFxuICAgIGlmIChpc0Zpbml0ZShib3gucmlnaHQpKSByaWdodCA9ICtib3gucmlnaHQ7IC8vIG92ZXJ3cml0ZSBob3Jpem9udGFsXG4gICAgaWYgKGlzRmluaXRlKGJveC5ib3R0b20pKSBib3R0b20gPSArYm94LmJvdHRvbTsgLy8gb3ZlcndyaXRlIHZlcnRpY2FsXG4gICAgaWYgKGlzRmluaXRlKGJveC5sZWZ0KSkgbGVmdCA9ICtib3gubGVmdDsgLy8gb3ZlcndyaXRlIGhvcml6b250YWxcblxuICAgIHJldHVybiB7IHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0IH07XG59O1xuXG5leHBvcnQgY29uc3QgdGltaW5nID0ge1xuXG4gICAgbGluZWFyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICBxdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ICogdDtcbiAgICB9LFxuXG4gICAgY3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICB9LFxuXG4gICAgaW5vdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgdmFyIHQzID0gdDIgKiB0O1xuICAgICAgICByZXR1cm4gNCAqICh0IDwgLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gLjc1KTtcbiAgICB9LFxuXG4gICAgZXhwb25lbnRpYWw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgfSxcblxuICAgIGJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBhID0gMCwgYiA9IDE7IDE7IGEgKz0gYiwgYiAvPSAyKSB7XG4gICAgICAgICAgICBpZiAodCA+PSAoNyAtIDQgKiBhKSAvIDExKSB7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSAoMTEgLSA2ICogYSAtIDExICogdCkgLyA0O1xuICAgICAgICAgICAgICAgIHJldHVybiAtcSAqIHEgKyBiICogYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIGYoMSAtIHQpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZWZsZWN0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gLjUgKiAodCA8IC41ID8gZigyICogdCkgOiAoMiAtIGYoMiAtIDIgKiB0KSkpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjbGFtcDogZnVuY3Rpb24oZiwgbiwgeCkge1xuICAgICAgICBuID0gbiB8fCAwO1xuICAgICAgICB4ID0geCB8fCAxO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIHIgPSBmKHQpO1xuICAgICAgICAgICAgcmV0dXJuIHIgPCBuID8gbiA6IHIgPiB4ID8geCA6IHI7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGJhY2s6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKCFzKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBlbGFzdGljOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICgheCkgeCA9IDEuNTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICogTWF0aC5jb3MoMjAgKiBNYXRoLlBJICogeCAvIDMgKiB0KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW50ZXJwb2xhdGUgPSB7XG5cbiAgICBudW1iZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgdmFyIGQgPSBiIC0gYTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgZCAqIHQ7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG9iamVjdDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB2YXIgcyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIGksIHA7XG4gICAgICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gcy5sZW5ndGggLSAxOyBpICE9IC0xOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBwID0gc1tpXTtcbiAgICAgICAgICAgICAgICByW3BdID0gYVtwXSArIChiW3BdIC0gYVtwXSkgKiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGhleENvbG9yOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgICAgdmFyIGNhID0gcGFyc2VJbnQoYS5zbGljZSgxKSwgMTYpO1xuICAgICAgICB2YXIgY2IgPSBwYXJzZUludChiLnNsaWNlKDEpLCAxNik7XG4gICAgICAgIHZhciByYSA9IGNhICYgMHgwMDAwZmY7XG4gICAgICAgIHZhciByZCA9IChjYiAmIDB4MDAwMGZmKSAtIHJhO1xuICAgICAgICB2YXIgZ2EgPSBjYSAmIDB4MDBmZjAwO1xuICAgICAgICB2YXIgZ2QgPSAoY2IgJiAweDAwZmYwMCkgLSBnYTtcbiAgICAgICAgdmFyIGJhID0gY2EgJiAweGZmMDAwMDtcbiAgICAgICAgdmFyIGJkID0gKGNiICYgMHhmZjAwMDApIC0gYmE7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICAgICAgdmFyIHIgPSAocmEgKyByZCAqIHQpICYgMHgwMDAwMDBmZjtcbiAgICAgICAgICAgIHZhciBnID0gKGdhICsgZ2QgKiB0KSAmIDB4MDAwMGZmMDA7XG4gICAgICAgICAgICB2YXIgYiA9IChiYSArIGJkICogdCkgJiAweDAwZmYwMDAwO1xuXG4gICAgICAgICAgICByZXR1cm4gJyMnICsgKDEgPDwgMjQgfCByIHwgZyB8IGIpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgdW5pdDogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICAgIHZhciByID0gLygtP1swLTldKi5bMC05XSopKHB4fGVtfGNtfG1tfGlufHB0fHBjfCUpLztcbiAgICAgICAgdmFyIG1hID0gci5leGVjKGEpO1xuICAgICAgICB2YXIgbWIgPSByLmV4ZWMoYik7XG4gICAgICAgIHZhciBwID0gbWJbMV0uaW5kZXhPZignLicpO1xuICAgICAgICB2YXIgZiA9IHAgPiAwID8gbWJbMV0ubGVuZ3RoIC0gcCAtIDEgOiAwO1xuICAgICAgICBhID0gK21hWzFdO1xuICAgICAgICB2YXIgZCA9ICttYlsxXSAtIGE7XG4gICAgICAgIHZhciB1ID0gbWFbMl07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSArIGQgKiB0KS50b0ZpeGVkKGYpICsgdTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vLyBTVkcgZmlsdGVycy5cbi8vICh2YWx1ZXMgaW4gcGFyZW50aGVzZXMgYXJlIGRlZmF1bHQgdmFsdWVzKVxuZXhwb3J0IGNvbnN0IGZpbHRlciA9IHtcblxuICAgIC8vIGBjb2xvcmAgLi4uIG91dGxpbmUgY29sb3IgKCdibHVlJylcbiAgICAvLyBgd2lkdGhgLi4uIG91dGxpbmUgd2lkdGggKDEpXG4gICAgLy8gYG9wYWNpdHlgIC4uLiBvdXRsaW5lIG9wYWNpdHkgKDEpXG4gICAgLy8gYG1hcmdpbmAgLi4uIGdhcCBiZXR3ZWVuIG91dGxpbmUgYW5kIHRoZSBlbGVtZW50ICgyKVxuICAgIG91dGxpbmU6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgdHBsID0gJzxmaWx0ZXI+PGZlRmxvb2QgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiIGZsb29kLW9wYWNpdHk9XCIke29wYWNpdHl9XCIgcmVzdWx0PVwiY29sb3JlZFwiLz48ZmVNb3JwaG9sb2d5IGluPVwiU291cmNlQWxwaGFcIiByZXN1bHQ9XCJtb3JwaGVkT3V0ZXJcIiBvcGVyYXRvcj1cImRpbGF0ZVwiIHJhZGl1cz1cIiR7b3V0ZXJSYWRpdXN9XCIgLz48ZmVNb3JwaG9sb2d5IGluPVwiU291cmNlQWxwaGFcIiByZXN1bHQ9XCJtb3JwaGVkSW5uZXJcIiBvcGVyYXRvcj1cImRpbGF0ZVwiIHJhZGl1cz1cIiR7aW5uZXJSYWRpdXN9XCIgLz48ZmVDb21wb3NpdGUgcmVzdWx0PVwibW9ycGhlZE91dGVyQ29sb3JlZFwiIGluPVwiY29sb3JlZFwiIGluMj1cIm1vcnBoZWRPdXRlclwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9zaXRlIG9wZXJhdG9yPVwieG9yXCIgaW49XCJtb3JwaGVkT3V0ZXJDb2xvcmVkXCIgaW4yPVwibW9ycGhlZElubmVyXCIgcmVzdWx0PVwib3V0bGluZVwiLz48ZmVNZXJnZT48ZmVNZXJnZU5vZGUgaW49XCJvdXRsaW5lXCIvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPjwvZmlsdGVyPic7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IE51bWJlci5pc0Zpbml0ZShhcmdzLm1hcmdpbikgPyBhcmdzLm1hcmdpbiA6IDI7XG4gICAgICAgIHZhciB3aWR0aCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLndpZHRoKSA/IGFyZ3Mud2lkdGggOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0cGwpKHtcbiAgICAgICAgICAgIGNvbG9yOiBhcmdzLmNvbG9yIHx8ICdibHVlJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IE51bWJlci5pc0Zpbml0ZShhcmdzLm9wYWNpdHkpID8gYXJncy5vcGFjaXR5IDogMSxcbiAgICAgICAgICAgIG91dGVyUmFkaXVzOiBtYXJnaW4gKyB3aWR0aCxcbiAgICAgICAgICAgIGlubmVyUmFkaXVzOiBtYXJnaW5cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBjb2xvcmAgLi4uIGNvbG9yICgncmVkJylcbiAgICAvLyBgd2lkdGhgLi4uIHdpZHRoICgxKVxuICAgIC8vIGBibHVyYCAuLi4gYmx1ciAoMClcbiAgICAvLyBgb3BhY2l0eWAgLi4uIG9wYWNpdHkgKDEpXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIHRwbCA9ICc8ZmlsdGVyPjxmZUZsb29kIGZsb29kLWNvbG9yPVwiJHtjb2xvcn1cIiBmbG9vZC1vcGFjaXR5PVwiJHtvcGFjaXR5fVwiIHJlc3VsdD1cImNvbG9yZWRcIi8+PGZlTW9ycGhvbG9neSByZXN1bHQ9XCJtb3JwaGVkXCIgaW49XCJTb3VyY2VHcmFwaGljXCIgb3BlcmF0b3I9XCJkaWxhdGVcIiByYWRpdXM9XCIke3dpZHRofVwiLz48ZmVDb21wb3NpdGUgcmVzdWx0PVwiY29tcG9zZWRcIiBpbj1cImNvbG9yZWRcIiBpbjI9XCJtb3JwaGVkXCIgb3BlcmF0b3I9XCJpblwiLz48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PVwiYmx1cmVkXCIgaW49XCJjb21wb3NlZFwiIHN0ZERldmlhdGlvbj1cIiR7Ymx1cn1cIi8+PGZlQmxlbmQgaW49XCJTb3VyY2VHcmFwaGljXCIgaW4yPVwiYmx1cmVkXCIgbW9kZT1cIm5vcm1hbFwiLz48L2ZpbHRlcj4nO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0cGwpKHtcbiAgICAgICAgICAgIGNvbG9yOiBhcmdzLmNvbG9yIHx8ICdyZWQnLFxuICAgICAgICAgICAgd2lkdGg6IE51bWJlci5pc0Zpbml0ZShhcmdzLndpZHRoKSA/IGFyZ3Mud2lkdGggOiAxLFxuICAgICAgICAgICAgYmx1cjogTnVtYmVyLmlzRmluaXRlKGFyZ3MuYmx1cikgPyBhcmdzLmJsdXIgOiAwLFxuICAgICAgICAgICAgb3BhY2l0eTogTnVtYmVyLmlzRmluaXRlKGFyZ3Mub3BhY2l0eSkgPyBhcmdzLm9wYWNpdHkgOiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgeGAgLi4uIGhvcml6b250YWwgYmx1ciAoMilcbiAgICAvLyBgeWAgLi4uIHZlcnRpY2FsIGJsdXIgKG9wdGlvbmFsKVxuICAgIGJsdXI6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgeCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLngpID8gYXJncy54IDogMjtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIiR7c3RkRGV2aWF0aW9ufVwiLz48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBzdGREZXZpYXRpb246IE51bWJlci5pc0Zpbml0ZShhcmdzLnkpID8gW3gsIGFyZ3MueV0gOiB4XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgZHhgIC4uLiBob3Jpem9udGFsIHNoaWZ0ICgwKVxuICAgIC8vIGBkeWAgLi4uIHZlcnRpY2FsIHNoaWZ0ICgwKVxuICAgIC8vIGBibHVyYCAuLi4gYmx1ciAoNClcbiAgICAvLyBgY29sb3JgIC4uLiBjb2xvciAoJ2JsYWNrJylcbiAgICAvLyBgb3BhY2l0eWAgLi4uIG9wYWNpdHkgKDEpXG4gICAgZHJvcFNoYWRvdzogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciB0cGwgPSAnU1ZHRkVEcm9wU2hhZG93RWxlbWVudCcgaW4gd2luZG93XG4gICAgICAgICAgICA/ICc8ZmlsdGVyPjxmZURyb3BTaGFkb3cgc3RkRGV2aWF0aW9uPVwiJHtibHVyfVwiIGR4PVwiJHtkeH1cIiBkeT1cIiR7ZHl9XCIgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiIGZsb29kLW9wYWNpdHk9XCIke29wYWNpdHl9XCIvPjwvZmlsdGVyPidcbiAgICAgICAgICAgIDogJzxmaWx0ZXI+PGZlR2F1c3NpYW5CbHVyIGluPVwiU291cmNlQWxwaGFcIiBzdGREZXZpYXRpb249XCIke2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIiR7ZHh9XCIgZHk9XCIke2R5fVwiIHJlc3VsdD1cIm9mZnNldGJsdXJcIi8+PGZlRmxvb2QgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHtvcGFjaXR5fVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+PGZlTWVyZ2U+PGZlTWVyZ2VOb2RlLz48ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIvPjwvZmVNZXJnZT48L2ZpbHRlcj4nO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0cGwpKHtcbiAgICAgICAgICAgIGR4OiBhcmdzLmR4IHx8IDAsXG4gICAgICAgICAgICBkeTogYXJncy5keSB8fCAwLFxuICAgICAgICAgICAgb3BhY2l0eTogTnVtYmVyLmlzRmluaXRlKGFyZ3Mub3BhY2l0eSkgPyBhcmdzLm9wYWNpdHkgOiAxLFxuICAgICAgICAgICAgY29sb3I6IGFyZ3MuY29sb3IgfHwgJ2JsYWNrJyxcbiAgICAgICAgICAgIGJsdXI6IE51bWJlci5pc0Zpbml0ZShhcmdzLmJsdXIpID8gYXJncy5ibHVyIDogNFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBpcyBjb21wbGV0ZWx5IGdyYXlzY2FsZS4gQSB2YWx1ZSBvZiAwIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIGdyYXlzY2FsZTogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiJHthfSAke2J9ICR7Y30gMCAwICR7ZH0gJHtlfSAke2Z9IDAgMCAke2d9ICR7Yn0gJHtofSAwIDAgMCAwIDAgMSAwXCIvPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGE6IDAuMjEyNiArIDAuNzg3NCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzE1MiAtIDAuNzE1MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGM6IDAuMDcyMiAtIDAuMDcyMiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGQ6IDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNzE1MiArIDAuMjg0OCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGY6IDAuMDcyMiAtIDAuMDcyMiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGc6IDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuMDcyMiArIDAuOTI3OCAqICgxIC0gYW1vdW50KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBpcyBjb21wbGV0ZWx5IHNlcGlhLiBBIHZhbHVlIG9mIDAgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgc2VwaWE6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgYW1vdW50ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIHZhbHVlcz1cIiR7YX0gJHtifSAke2N9IDAgMCAke2R9ICR7ZX0gJHtmfSAwIDAgJHtnfSAke2h9ICR7aX0gMCAwIDAgMCAwIDEgMFwiLz48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhOiAwLjM5MyArIDAuNjA3ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43NjkgLSAwLjc2OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGM6IDAuMTg5IC0gMC4xODkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBkOiAwLjM0OSAtIDAuMzQ5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC42ODYgKyAwLjMxNCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGY6IDAuMTY4IC0gMC4xNjggKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBnOiAwLjI3MiAtIDAuMjcyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC41MzQgLSAwLjUzNCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGk6IDAuMTMxICsgMC44NjkgKiAoMSAtIGFtb3VudClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMCBpcyBjb21wbGV0ZWx5IHVuLXNhdHVyYXRlZC4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBzYXR1cmF0ZTogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb2xvck1hdHJpeCB0eXBlPVwic2F0dXJhdGVcIiB2YWx1ZXM9XCIke2Ftb3VudH1cIi8+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW5nbGVgIC4uLiAgdGhlIG51bWJlciBvZiBkZWdyZWVzIGFyb3VuZCB0aGUgY29sb3IgY2lyY2xlIHRoZSBpbnB1dCBzYW1wbGVzIHdpbGwgYmUgYWRqdXN0ZWQgKDApLlxuICAgIGh1ZVJvdGF0ZTogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb2xvck1hdHJpeCB0eXBlPVwiaHVlUm90YXRlXCIgdmFsdWVzPVwiJHthbmdsZX1cIi8+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYW5nbGU6IGFyZ3MuYW5nbGUgfHwgMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBpcyBjb21wbGV0ZWx5IGludmVydGVkLiBBIHZhbHVlIG9mIDAgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgaW52ZXJ0OiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwiJHthbW91bnR9ICR7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cInRhYmxlXCIgdGFibGVWYWx1ZXM9XCIke2Ftb3VudH0gJHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cIiR7YW1vdW50fSAke2Ftb3VudDJ9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgIGFtb3VudDI6IDEgLSBhbW91bnRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAwIHdpbGwgY3JlYXRlIGFuIGltYWdlIHRoYXQgaXMgY29tcGxldGVseSBibGFjay4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBicmlnaHRuZXNzOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiLz48ZmVGdW5jRyB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhbW91bnQ6IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDFcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAwIHdpbGwgY3JlYXRlIGFuIGltYWdlIHRoYXQgaXMgY29tcGxldGVseSBibGFjay4gQSB2YWx1ZSBvZiAxIChkZWZhdWx0KSBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBjb250cmFzdDogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCIke2Ftb3VudDJ9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiIGludGVyY2VwdD1cIiR7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIgaW50ZXJjZXB0PVwiJHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAuNSAtIGFtb3VudCAvIDJcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHtcblxuICAgIC8vIEZvcm1hdHRpbmcgbnVtYmVycyB2aWEgdGhlIFB5dGhvbiBGb3JtYXQgU3BlY2lmaWNhdGlvbiBNaW5pLWxhbmd1YWdlLlxuICAgIC8vIFNlZSBodHRwOi8vZG9jcy5weXRob24ub3JnL3JlbGVhc2UvMy4xLjMvbGlicmFyeS9zdHJpbmcuaHRtbCNmb3JtYXQtc3BlY2lmaWNhdGlvbi1taW5pLWxhbmd1YWdlLlxuICAgIC8vIEhlYXZpbGx5IGluc3BpcmVkIGJ5IHRoZSBEMy5qcyBsaWJyYXJ5IGltcGxlbWVudGF0aW9uLlxuICAgIG51bWJlcjogZnVuY3Rpb24oc3BlY2lmaWVyLCB2YWx1ZSwgbG9jYWxlKSB7XG5cbiAgICAgICAgbG9jYWxlID0gbG9jYWxlIHx8IHtcblxuICAgICAgICAgICAgY3VycmVuY3k6IFsnJCcsICcnXSxcbiAgICAgICAgICAgIGRlY2ltYWw6ICcuJyxcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZ3JvdXBpbmc6IFszXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNlZSBQeXRob24gZm9ybWF0IHNwZWNpZmljYXRpb24gbWluaS1sYW5ndWFnZTogaHR0cDovL2RvY3MucHl0aG9uLm9yZy9yZWxlYXNlLzMuMS4zL2xpYnJhcnkvc3RyaW5nLmh0bWwjZm9ybWF0LXNwZWNpZmljYXRpb24tbWluaS1sYW5ndWFnZS5cbiAgICAgICAgLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxuICAgICAgICB2YXIgcmUgPSAvKD86KFtee10pPyhbPD49Xl0pKT8oWytcXC0gXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC4tP1xcZCspPyhbYS16JV0pPy9pO1xuXG4gICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKTtcbiAgICAgICAgdmFyIGZpbGwgPSBtYXRjaFsxXSB8fCAnICc7XG4gICAgICAgIHZhciBhbGlnbiA9IG1hdGNoWzJdIHx8ICc+JztcbiAgICAgICAgdmFyIHNpZ24gPSBtYXRjaFszXSB8fCAnJztcbiAgICAgICAgdmFyIHN5bWJvbCA9IG1hdGNoWzRdIHx8ICcnO1xuICAgICAgICB2YXIgemZpbGwgPSBtYXRjaFs1XTtcbiAgICAgICAgdmFyIHdpZHRoID0gK21hdGNoWzZdO1xuICAgICAgICB2YXIgY29tbWEgPSBtYXRjaFs3XTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IG1hdGNoWzhdO1xuICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzldO1xuICAgICAgICB2YXIgc2NhbGUgPSAxO1xuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG4gICAgICAgIHZhciBzdWZmaXggPSAnJztcbiAgICAgICAgdmFyIGludGVnZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJlY2lzaW9uKSBwcmVjaXNpb24gPSArcHJlY2lzaW9uLnN1YnN0cmluZygxKTtcblxuICAgICAgICBpZiAoemZpbGwgfHwgZmlsbCA9PT0gJzAnICYmIGFsaWduID09PSAnPScpIHtcbiAgICAgICAgICAgIHpmaWxsID0gZmlsbCA9ICcwJztcbiAgICAgICAgICAgIGFsaWduID0gJz0nO1xuICAgICAgICAgICAgaWYgKGNvbW1hKSB3aWR0aCAtPSBNYXRoLmZsb29yKCh3aWR0aCAtIDEpIC8gNCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIGNvbW1hID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2cnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gJyUnO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnZic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSAnJSc7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09ICcjJykgcHJlZml4ID0gJzAnICsgdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBpbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAtMTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3InO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gJyQnKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBsb2NhbGUuY3VycmVuY3lbMF07XG4gICAgICAgICAgICBzdWZmaXggPSBsb2NhbGUuY3VycmVuY3lbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBwcmVjaXNpb24gaXMgc3BlY2lmaWVkIGZvciBgJ3InYCwgZmFsbGJhY2sgdG8gZ2VuZXJhbCBub3RhdGlvbi5cbiAgICAgICAgaWYgKHR5cGUgPT0gJ3InICYmICFwcmVjaXNpb24pIHR5cGUgPSAnZyc7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHJlcXVlc3RlZCBwcmVjaXNpb24gaXMgaW4gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAnZycpIHByZWNpc2lvbiA9IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ2UnIHx8IHR5cGUgPT0gJ2YnKSBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgemNvbW1hID0gemZpbGwgJiYgY29tbWE7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgZm9yIGZsb2F0cyBmb3JtYXR0ZWQgYXMgaW50cy5cbiAgICAgICAgaWYgKGludGVnZXIgJiYgKHZhbHVlICUgMSkpIHJldHVybiAnJztcblxuICAgICAgICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHRvIHBvc2l0aXZlLCBhbmQgcmVjb3JkIHRoZSBzaWduIHByZWZpeC5cbiAgICAgICAgdmFyIG5lZ2F0aXZlID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAodmFsdWUgPSAtdmFsdWUsICctJykgOiBzaWduO1xuXG4gICAgICAgIHZhciBmdWxsU3VmZml4ID0gc3VmZml4O1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBzY2FsZSwgY29tcHV0aW5nIGl0IGZyb20gdGhlIHZhbHVlJ3MgZXhwb25lbnQgZm9yIHNpIGZvcm1hdC5cbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIGV4aXN0aW5nIHN1ZmZpeCwgaWYgYW55LCBzdWNoIGFzIHRoZSBjdXJyZW5jeSBzeW1ib2wuXG4gICAgICAgIGlmIChzY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHZhciB1bml0ID0gdGhpcy5wcmVmaXgodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuaXQuc2NhbGUodmFsdWUpO1xuICAgICAgICAgICAgZnVsbFN1ZmZpeCA9IHVuaXQuc3ltYm9sICsgc3VmZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKj0gc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHRvIHRoZSBkZXNpcmVkIHByZWNpc2lvbi5cbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnZlcnQodHlwZSwgdmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIHZhbHVlIGludG8gdGhlIGludGVnZXIgcGFydCAoYmVmb3JlKSBhbmQgZGVjaW1hbCBwYXJ0IChhZnRlcikuXG4gICAgICAgIHZhciBpID0gdmFsdWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IGkgPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIHZhciBhZnRlciA9IGkgPCAwID8gJycgOiBsb2NhbGUuZGVjaW1hbCArIHZhbHVlLnN1YnN0cmluZyhpICsgMSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0R3JvdXAodmFsdWUpIHtcblxuICAgICAgICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgdmFyIGcgPSBsb2NhbGUuZ3JvdXBpbmdbMF07XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgICAgICAgICBnID0gbG9jYWxlLmdyb3VwaW5nW2ogPSAoaiArIDEpICUgbG9jYWxlLmdyb3VwaW5nLmxlbmd0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbihsb2NhbGUudGhvdXNhbmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgYCcwJ2AsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmICghemZpbGwgJiYgY29tbWEgJiYgbG9jYWxlLmdyb3VwaW5nKSB7XG5cbiAgICAgICAgICAgIGJlZm9yZSA9IGZvcm1hdEdyb3VwKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIGJlZm9yZS5sZW5ndGggKyBhZnRlci5sZW5ndGggKyAoemNvbW1hID8gMCA6IG5lZ2F0aXZlLmxlbmd0aCk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkobGVuZ3RoID0gd2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogJyc7XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIGAnMCdgLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICAgIGlmICh6Y29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKHBhZGRpbmcgKyBiZWZvcmUpO1xuXG4gICAgICAgIC8vIEFwcGx5IHByZWZpeC5cbiAgICAgICAgbmVnYXRpdmUgKz0gcHJlZml4O1xuXG4gICAgICAgIC8vIFJlam9pbiBpbnRlZ2VyIGFuZCBkZWNpbWFsIHBhcnRzLlxuICAgICAgICB2YWx1ZSA9IGJlZm9yZSArIGFmdGVyO1xuXG4gICAgICAgIHJldHVybiAoYWxpZ24gPT09ICc8JyA/IG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nXG4gICAgICAgICAgICA6IGFsaWduID09PSAnPicgPyBwYWRkaW5nICsgbmVnYXRpdmUgKyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogYWxpZ24gPT09ICdeJyA/IHBhZGRpbmcuc3Vic3RyaW5nKDAsIGxlbmd0aCA+Pj0gMSkgKyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZy5zdWJzdHJpbmcobGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICA6IG5lZ2F0aXZlICsgKHpjb21tYSA/IHZhbHVlIDogcGFkZGluZyArIHZhbHVlKSkgKyBmdWxsU3VmZml4O1xuICAgIH0sXG5cbiAgICAvLyBGb3JtYXR0aW5nIHN0cmluZyB2aWEgdGhlIFB5dGhvbiBGb3JtYXQgc3RyaW5nLlxuICAgIC8vIFNlZSBodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvc3RyaW5nLmh0bWwjZm9ybWF0LXN0cmluZy1zeW50YXgpXG4gICAgc3RyaW5nOiBmdW5jdGlvbihmb3JtYXRTdHJpbmcsIHZhbHVlKSB7XG5cbiAgICAgICAgdmFyIGZpZWxkRGVsaW1pdGVySW5kZXg7XG4gICAgICAgIHZhciBmaWVsZERlbGltaXRlciA9ICd7JztcbiAgICAgICAgdmFyIGVuZFBsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRTdHJpbmdBcnJheSA9IFtdO1xuXG4gICAgICAgIHdoaWxlICgoZmllbGREZWxpbWl0ZXJJbmRleCA9IGZvcm1hdFN0cmluZy5pbmRleE9mKGZpZWxkRGVsaW1pdGVyKSkgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIHZhciBwaWVjZUZvcm1hdHRlZFN0cmluZywgZm9ybWF0U3BlYywgZmllbGROYW1lO1xuXG4gICAgICAgICAgICBwaWVjZUZvcm1hdHRlZFN0cmluZyA9IGZvcm1hdFN0cmluZy5zbGljZSgwLCBmaWVsZERlbGltaXRlckluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGVuZFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0U3BlYyA9IHBpZWNlRm9ybWF0dGVkU3RyaW5nLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gZm9ybWF0U3BlYy5zaGlmdCgpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgcGllY2VGb3JtYXR0ZWRTdHJpbmcgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBwaWVjZUZvcm1hdHRlZFN0cmluZyA9IHBpZWNlRm9ybWF0dGVkU3RyaW5nW2ZpZWxkTmFtZVtpXV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0U3BlYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlRm9ybWF0dGVkU3RyaW5nID0gdGhpcy5udW1iZXIoZm9ybWF0U3BlYywgcGllY2VGb3JtYXR0ZWRTdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmdBcnJheS5wdXNoKHBpZWNlRm9ybWF0dGVkU3RyaW5nKTtcblxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnNsaWNlKGZpZWxkRGVsaW1pdGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgIGVuZFBsYWNlaG9sZGVyID0gIWVuZFBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgZmllbGREZWxpbWl0ZXIgPSAoZW5kUGxhY2Vob2xkZXIpID8gJ30nIDogJ3snO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdHRlZFN0cmluZ0FycmF5LnB1c2goZm9ybWF0U3RyaW5nKTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nQXJyYXkuam9pbignJyk7XG4gICAgfSxcblxuICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlLCBwcmVjaXNpb24pIHtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygyKTtcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyg4KTtcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9QcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0V4cG9uZW50aWFsKHByZWNpc2lvbik7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9GaXhlZChwcmVjaXNpb24pO1xuICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9IHRoaXMucm91bmQodmFsdWUsIHRoaXMucHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pKSkudG9GaXhlZChNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgdGhpcy5wcmVjaXNpb24odmFsdWUgKiAoMSArIDFlLTE1KSwgcHJlY2lzaW9uKSkpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcblxuICAgICAgICByZXR1cm4gcHJlY2lzaW9uXG4gICAgICAgICAgICA/IE1hdGgucm91bmQodmFsdWUgKiAocHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbikpKSAvIHByZWNpc2lvblxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgcHJlY2lzaW9uOiBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbiAtICh2YWx1ZSA/IE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApIDogMSk7XG4gICAgfSxcblxuICAgIHByZWZpeDogZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuXG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFsneScsICd6JywgJ2EnLCAnZicsICdwJywgJ24nLCAnwrUnLCAnbScsICcnLCAnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnLCAnWicsICdZJ10ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5wb3coMTAsIE1hdGguYWJzKDggLSBpKSAqIDMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2FsZTogaSA+IDggPyBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkIC8gaztcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCAqIGs7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSAqPSAtMTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHZhbHVlID0gdGhpcy5yb3VuZCh2YWx1ZSwgdGhpcy5wcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgaSA9IDEgKyBNYXRoLmZsb29yKDFlLTEyICsgTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwKTtcbiAgICAgICAgICAgIGkgPSBNYXRoLm1heCgtMjQsIE1hdGgubWluKDI0LCBNYXRoLmZsb29yKChpIDw9IDAgPyBpICsgMSA6IGkgLSAxKSAvIDMpICogMykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmaXhlc1s4ICsgaSAvIDNdO1xuICAgIH1cbn07XG5cbi8qXG4gICAgUHJlLWNvbXBpbGUgdGhlIEhUTUwgdG8gYmUgdXNlZCBhcyBhIHRlbXBsYXRlLlxuKi9cbmV4cG9ydCBjb25zdCB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGh0bWwpIHtcblxuICAgIC8qXG4gICAgICAgIE11c3Qgc3VwcG9ydCB0aGUgdmFyaWF0aW9uIGluIHRlbXBsYXRpbmcgc3ludGF4IGZvdW5kIGhlcmU6XG4gICAgICAgIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzI3RlbXBsYXRlXG4gICAgKi9cbiAgICB2YXIgcmVnZXggPSAvPCU9IChbXiBdKykgJT58XFwkXFx7ID8oW157fSBdKykgP1xcfXxcXHtcXHsoW157fSBdKylcXH1cXH0vZztcblxuICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2gpIHtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IGFyZ3Muc2xpY2UoMSwgNCkuZmluZChmdW5jdGlvbihfYXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIV9hdHRyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyQXJyYXkgPSBhdHRyLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2F0dHJBcnJheS5zaGlmdCgpXTtcblxuICAgICAgICAgICAgd2hpbGUgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXR0ckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbYXR0ckFycmF5LnNoaWZ0KCldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogJyc7XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCwgd2hpY2ggY29udGVudCBpcyBpbnRlbnQgdG8gZGlzcGxheSBpbiBmdWxsLXNjcmVlbiBtb2RlLCAnd2luZG93LnRvcC5kb2N1bWVudC5ib2R5JyBpcyBkZWZhdWx0LlxuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRnVsbFNjcmVlbiA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICB2YXIgdG9wRG9jdW1lbnQgPSB3aW5kb3cudG9wLmRvY3VtZW50O1xuICAgIGVsID0gZWwgfHwgdG9wRG9jdW1lbnQuYm9keTtcblxuICAgIGZ1bmN0aW9uIHByZWZpeGVkUmVzdWx0KGVsLCBwcm9wKSB7XG5cbiAgICAgICAgdmFyIHByZWZpeGVzID0gWyd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nLCAnJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByZWZpeCA/IChwcmVmaXggKyBwcm9wKSA6IChwcm9wLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgcHJvcC5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgaWYgKGVsW3Byb3BOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZWxbcHJvcE5hbWVdKSA/IGVsW3Byb3BOYW1lXSgpIDogZWxbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeGVkUmVzdWx0KHRvcERvY3VtZW50LCAnRnVsbHNjcmVlbkVsZW1lbnQnKSB8fCBwcmVmaXhlZFJlc3VsdCh0b3BEb2N1bWVudCwgJ0Z1bGxTY3JlZW5FbGVtZW50JykpIHtcbiAgICAgICAgcHJlZml4ZWRSZXN1bHQodG9wRG9jdW1lbnQsICdFeGl0RnVsbHNjcmVlbicpIHx8IC8vIFNwZWMuXG4gICAgICAgIHByZWZpeGVkUmVzdWx0KHRvcERvY3VtZW50LCAnQ2FuY2VsRnVsbFNjcmVlbicpOyAvLyBGaXJlZm94XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4ZWRSZXN1bHQoZWwsICdSZXF1ZXN0RnVsbHNjcmVlbicpIHx8IC8vIFNwZWMuXG4gICAgICAgIHByZWZpeGVkUmVzdWx0KGVsLCAnUmVxdWVzdEZ1bGxTY3JlZW4nKTsgLy8gRmlyZWZveFxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgaXNCb29sZWFuLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzTnVtYmVyLFxuICAgIGlzU3RyaW5nLFxuICAgIG1peGluLFxuICAgIGRlZXBNaXhpbixcbiAgICBzdXBwbGVtZW50LFxuICAgIGRlZmF1bHRzLFxuICAgIGRlZXBTdXBwbGVtZW50LFxuICAgIGRlZmF1bHRzRGVlcCxcbiAgICBhc3NpZ24sXG4gICAgaW52b2tlLFxuICAgIGludm9rZVByb3BlcnR5LFxuICAgIHNvcnRlZEluZGV4LFxuICAgIHVuaXEsXG4gICAgY2xvbmUsXG4gICAgY2xvbmVEZWVwLFxuICAgIGlzRW1wdHksXG4gICAgaXNFcXVhbCxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzUGxhaW5PYmplY3QsXG4gICAgdG9BcnJheSxcbiAgICBkZWJvdW5jZSxcbiAgICBncm91cEJ5LFxuICAgIHNvcnRCeSxcbiAgICBmbGF0dGVuRGVlcCxcbiAgICB3aXRob3V0LFxuICAgIGRpZmZlcmVuY2UsXG4gICAgaW50ZXJzZWN0aW9uLFxuICAgIHVuaW9uLFxuICAgIGhhcyxcbiAgICByZXN1bHQsXG4gICAgb21pdCxcbiAgICBwaWNrLFxuICAgIGJpbmRBbGwsXG4gICAgZm9ySW4sXG4gICAgY2FtZWxDYXNlLFxuICAgIHVuaXF1ZUlkLFxuICAgIG1lcmdlXG59O1xuXG5leHBvcnQgY29uc3Qgbm9vcCA9IGZ1bmN0aW9uKCkge1xufTtcbiJdLCJuYW1lcyI6WyIkIiwiViIsImNvbmZpZyIsImlzQm9vbGVhbiIsImlzT2JqZWN0IiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsIm1peGluIiwiZGVlcE1peGluIiwic3VwcGxlbWVudCIsImRlZmF1bHRzIiwiZGVmYXVsdHNEZWVwIiwiZGVlcFN1cHBsZW1lbnQiLCJhc3NpZ24iLCJpbnZva2UiLCJpbnZva2VQcm9wZXJ0eSIsInNvcnRlZEluZGV4IiwidW5pcSIsImNsb25lIiwiY2xvbmVEZWVwIiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0Z1bmN0aW9uIiwiaXNQbGFpbk9iamVjdCIsInRvQXJyYXkiLCJkZWJvdW5jZSIsImdyb3VwQnkiLCJzb3J0QnkiLCJmbGF0dGVuRGVlcCIsIndpdGhvdXQiLCJkaWZmZXJlbmNlIiwiaW50ZXJzZWN0aW9uIiwidW5pb24iLCJoYXMiLCJyZXN1bHQiLCJvbWl0IiwicGljayIsImJpbmRBbGwiLCJmb3JJbiIsImNhbWVsQ2FzZSIsInVuaXF1ZUlkIiwibWVyZ2UiLCJhZGRDbGFzc05hbWVQcmVmaXgiLCJjbGFzc05hbWUiLCJ0b1N0cmluZyIsInNwbGl0IiwibWFwIiwiX2NsYXNzTmFtZSIsInN1YnN0ciIsImNsYXNzTmFtZVByZWZpeCIsImxlbmd0aCIsImpvaW4iLCJyZW1vdmVDbGFzc05hbWVQcmVmaXgiLCJwYXJzZURPTUpTT04iLCJqc29uIiwibmFtZXNwYWNlIiwic2VsZWN0b3JzIiwiZ3JvdXBTZWxlY3RvcnMiLCJzdmdOYW1lc3BhY2UiLCJzdmciLCJucyIsImZyYWdtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwicGFyc2VOb2RlIiwic2libGluZ3NEZWYiLCJwYXJlbnROb2RlIiwiaSIsIm5vZGVEZWYiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kQ2hpbGQiLCJoYXNPd25Qcm9wZXJ0eSIsIkVycm9yIiwidGFnTmFtZSIsIm5vZGUiLCJuYW1lc3BhY2VVUkkiLCJjcmVhdGVFbGVtZW50TlMiLCJ3cmFwcGVyIiwiYXR0cmlidXRlcyIsImF0dHIiLCJzdHlsZSIsImNzcyIsImJhc2VWYWwiLCJ0ZXh0Q29udGVudCIsIm5vZGVTZWxlY3RvciIsInNlbGVjdG9yIiwibm9kZUdyb3VwcyIsImdyb3VwU2VsZWN0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJqIiwibm9kZUdyb3VwIiwiZ3JvdXAiLCJwdXNoIiwiY2hpbGRyZW5EZWYiLCJjaGlsZHJlbiIsImhhc2hDb2RlIiwic3RyIiwiaGFzaCIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0QnlQYXRoIiwib2JqIiwicGF0aCIsImRlbGltaXRlciIsImtleXMiLCJrZXkiLCJPYmplY3QiLCJ1bmRlZmluZWQiLCJpc0dldFNhZmUiLCJTdHJpbmciLCJzZXRCeVBhdGgiLCJ2YWx1ZSIsImxhc3QiLCJkaXZlciIsInVuc2V0QnlQYXRoIiwiZmxhdHRlbk9iamVjdCIsImRlbGltIiwic3RvcCIsInJldCIsInNob3VsZEdvRGVlcGVyIiwiZmxhdE9iamVjdCIsImZsYXRLZXkiLCJ1dWlkIiwicmVwbGFjZSIsInIiLCJNYXRoIiwicmFuZG9tIiwidiIsImd1aWQiLCJpZCIsInRvS2ViYWJDYXNlIiwic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJub3JtYWxpemVFdmVudCIsImV2dCIsIm5vcm1hbGl6ZWQiLCJvcmlnaW5hbEV2ZW50IiwidGFyZ2V0IiwidG91Y2giLCJjaGFuZ2VkVG91Y2hlcyIsInByb3BlcnR5IiwidXNlRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50Iiwibm9ybWFsaXplV2hlZWwiLCJQSVhFTF9TVEVQIiwiTElORV9IRUlHSFQiLCJQQUdFX0hFSUdIVCIsInNYIiwic1kiLCJwWCIsInBZIiwiZGV0YWlsIiwid2hlZWxEZWx0YSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YVgiLCJheGlzIiwiSE9SSVpPTlRBTF9BWElTIiwiZGVsdGFYIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwic2hpZnRLZXkiLCJzcGluWCIsInNwaW5ZIiwiY2FwIiwidmFsIiwibWF4IiwibmV4dEZyYW1lIiwicmFmIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGFzdFRpbWUiLCJjYWxsYmFjayIsImN1cnJUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJ0aW1lVG9DYWxsIiwic2V0VGltZW91dCIsImNvbnRleHQiLCJyZXN0IiwiYmluZCIsImNhbmNlbEZyYW1lIiwiY2FmIiwiY2xpZW50IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9DYW5jZWxBbmltYXRpb25GcmFtZSIsIm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pDYW5jZWxBbmltYXRpb25GcmFtZSIsIm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsInNoYXBlUGVyaW1ldGVyQ29ubmVjdGlvblBvaW50IiwibGlua1ZpZXciLCJ2aWV3IiwibWFnbmV0IiwicmVmZXJlbmNlIiwiYmJveCIsInNwb3QiLCJzY2FsYWJsZSIsInJvdGF0YWJsZSIsImZpcnN0Q2hpbGQiLCJmaW5kSW50ZXJzZWN0aW9uIiwicGFwZXIiLCJjZWxscyIsImdldEJCb3giLCJtb2RlbCIsImludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQiLCJjZW50ZXIiLCJpc1BlcmNlbnRhZ2UiLCJzbGljZSIsInBhcnNlQ3NzTnVtZXJpYyIsInJlc3RyaWN0VW5pdHMiLCJnZXRVbml0IiwidmFsaWRVbml0RXhwIiwibWF0Y2hlcyIsIlJlZ0V4cCIsImV4ZWMiLCJudW1iZXIiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwiaXNOYU4iLCJvdXRwdXQiLCJ1bml0IiwiTk9fU1BBQ0UiLCJzcGxpdFdvcmRXaXRoRU9MIiwid29yZCIsImVvbCIsImVvbFdvcmRzIiwibiIsImpsIiwicmVwbGFjZW1lbnQiLCJzcGxpY2UiLCJmaWx0ZXIiLCJnZXRMaW5lSGVpZ2h0IiwiaGVpZ2h0VmFsdWUiLCJ0ZXh0RWxlbWVudCIsImhlaWdodCIsImJyZWFrVGV4dCIsInRleHQiLCJzaXplIiwic3R5bGVzIiwib3B0Iiwid2lkdGgiLCJzdmdEb2N1bWVudCIsInRleHRTcGFuIiwiYXBwZW5kIiwib3BhY2l0eSIsImRpc3BsYXkiLCJib2R5IiwicHJlc2VydmVTcGFjZXMiLCJzcGFjZSIsInNlcGFyYXRvciIsInNlcGFyYXRvckNoYXIiLCJoeXBoZW4iLCJtYXhMaW5lQ291bnQiLCJJbmZpbml0eSIsIndvcmRzIiwiZnVsbCIsImxpbmVzIiwicCIsImgiLCJsaW5lSGVpZ2h0IiwibCIsImxlbiIsImlzRW9sIiwiaW5kZXhPZiIsImRhdGEiLCJnZXRDb21wdXRlZFRleHRMZW5ndGgiLCJwYXJ0aXRpb24iLCJzdWJzdHJpbmciLCJuZXh0V29yZCIsImh5cGhlbkluZGV4Iiwic2VhcmNoIiwibGFzdEwiLCJwYXJzZWQiLCJmbG9vciIsImVsbGlwc2lzIiwibGFzdExpbmUiLCJrIiwibGFzdExpbmVXaXRoT21pc3Npb24iLCJsYXN0Q2hhciIsIm1hdGNoIiwicmVtb3ZlQ2hpbGQiLCJzYW5pdGl6ZUhUTUwiLCJodG1sIiwicGFyc2VIVE1MIiwiZmluZCIsImVhY2giLCJjdXJyZW50Tm9kZSIsImN1cnJlbnRBdHRyaWJ1dGUiLCJhdHRyTmFtZSIsIm5hbWUiLCJhdHRyVmFsdWUiLCJzdGFydHNXaXRoIiwicmVtb3ZlQXR0ciIsImRvd25sb2FkQmxvYiIsImJsb2IiLCJmaWxlTmFtZSIsIm5hdmlnYXRvciIsIm1zU2F2ZUJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImNsaWNrIiwicmV2b2tlT2JqZWN0VVJMIiwiZG93bmxvYWREYXRhVXJpIiwiZGF0YVVyaSIsImRhdGFVcmlUb0Jsb2IiLCJkZWNvZGVVUklDb21wb25lbnQiLCJmaXJzdENvbW1hSW5kZXgiLCJkYXRhVHlwZVN0cmluZyIsIm1pbWVTdHJpbmciLCJkZWNvZGVkU3RyaW5nIiwiYXRvYiIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaWEiLCJVaW50OEFycmF5IiwiQmxvYiIsInR5cGUiLCJpbWFnZVRvRGF0YVVyaSIsIm1vZGVybkhhbmRsZXIiLCJ4aHIiLCJzdGF0dXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJyZXNwb25zZSIsImxlZ2FjeUhhbmRsZXIiLCJVaW50OFRvU3RyaW5nIiwidThhIiwiQ0hVTktfU1oiLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN1YmFycmF5IiwiYnl0ZXMiLCJzdWZmaXgiLCJwb3AiLCJtZXRhIiwiYjY0ZW5jb2RlZCIsImJ0b2EiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVzcG9uc2VUeXBlIiwic2VuZCIsImdldEVsZW1lbnRCQm94IiwiZWwiLCIkZWwiLCJlbGVtZW50IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImNsaWVudEJCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzdHJva2VXaWR0aFgiLCJzdHJva2VXaWR0aFkiLCJvd25lclNWR0VsZW1lbnQiLCJ2ZWwiLCJ4IiwibGVmdCIsInBhZ2VYT2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJwYWdlWU9mZnNldCIsIm9mZnNldFRvcCIsInNvcnRFbGVtZW50cyIsImVsZW1lbnRzIiwiY29tcGFyYXRvciIsIiRlbGVtZW50cyIsInBsYWNlbWVudHMiLCJzb3J0RWxlbWVudCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwicHJvdG90eXBlIiwic29ydCIsImNhbGwiLCJzZXRBdHRyaWJ1dGVzQnlTZWxlY3RvciIsImF0dHJzIiwiJGVsZW1lbnQiLCJhZGRCYWNrIiwiYWRkQ2xhc3MiLCJub3JtYWxpemVTaWRlcyIsImJveCIsImlzRmluaXRlIiwicmlnaHQiLCJib3R0b20iLCJ2ZXJ0aWNhbCIsImhvcml6b250YWwiLCJ0aW1pbmciLCJsaW5lYXIiLCJ0IiwicXVhZCIsImN1YmljIiwiaW5vdXQiLCJ0MiIsInQzIiwiZXhwb25lbnRpYWwiLCJwb3ciLCJib3VuY2UiLCJhIiwiYiIsInEiLCJyZXZlcnNlIiwiZiIsInJlZmxlY3QiLCJjbGFtcCIsImJhY2siLCJzIiwiZWxhc3RpYyIsImNvcyIsIlBJIiwiaW50ZXJwb2xhdGUiLCJkIiwib2JqZWN0IiwiaGV4Q29sb3IiLCJjYSIsInBhcnNlSW50IiwiY2IiLCJyYSIsInJkIiwiZ2EiLCJnZCIsImJhIiwiYmQiLCJnIiwibWEiLCJtYiIsInUiLCJ0b0ZpeGVkIiwib3V0bGluZSIsImFyZ3MiLCJ0cGwiLCJtYXJnaW4iLCJ0ZW1wbGF0ZSIsImNvbG9yIiwib3V0ZXJSYWRpdXMiLCJpbm5lclJhZGl1cyIsImhpZ2hsaWdodCIsImJsdXIiLCJzdGREZXZpYXRpb24iLCJkcm9wU2hhZG93IiwiZHgiLCJkeSIsImdyYXlzY2FsZSIsImFtb3VudCIsImUiLCJzZXBpYSIsInNhdHVyYXRlIiwiaHVlUm90YXRlIiwiYW5nbGUiLCJpbnZlcnQiLCJhbW91bnQyIiwiYnJpZ2h0bmVzcyIsImNvbnRyYXN0IiwiZm9ybWF0Iiwic3BlY2lmaWVyIiwibG9jYWxlIiwiY3VycmVuY3kiLCJkZWNpbWFsIiwidGhvdXNhbmRzIiwiZ3JvdXBpbmciLCJyZSIsImZpbGwiLCJhbGlnbiIsInNpZ24iLCJzeW1ib2wiLCJ6ZmlsbCIsImNvbW1hIiwicHJlY2lzaW9uIiwic2NhbGUiLCJwcmVmaXgiLCJpbnRlZ2VyIiwibWluIiwiemNvbW1hIiwibmVnYXRpdmUiLCJmdWxsU3VmZml4IiwiY29udmVydCIsImxhc3RJbmRleE9mIiwiYmVmb3JlIiwiYWZ0ZXIiLCJmb3JtYXRHcm91cCIsInBhZGRpbmciLCJmb3JtYXRTdHJpbmciLCJmaWVsZERlbGltaXRlckluZGV4IiwiZmllbGREZWxpbWl0ZXIiLCJlbmRQbGFjZWhvbGRlciIsImZvcm1hdHRlZFN0cmluZ0FycmF5IiwicGllY2VGb3JtYXR0ZWRTdHJpbmciLCJmb3JtYXRTcGVjIiwiZmllbGROYW1lIiwic2hpZnQiLCJ0b1VwcGVyQ2FzZSIsInRvUHJlY2lzaW9uIiwidG9FeHBvbmVudGlhbCIsInJvdW5kIiwiY2VpbCIsImxvZyIsIkxOMTAiLCJwcmVmaXhlcyIsImFicyIsInJlZ2V4IiwiZnJvbSIsImFyZ3VtZW50cyIsIl9hdHRyIiwiYXR0ckFycmF5IiwidG9nZ2xlRnVsbFNjcmVlbiIsInRvcERvY3VtZW50IiwicHJlZml4ZWRSZXN1bHQiLCJwcm9wIiwicHJvcE5hbWUiLCJub29wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/util/util.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/jointjs/src/util/utilHelpers.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bindAll: () => (/* binding */ bindAll),\n/* harmony export */   camelCase: () => (/* binding */ camelCase),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   deepMixin: () => (/* binding */ deepMixin),\n/* harmony export */   deepSupplement: () => (/* binding */ deepSupplement),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   defaultsDeep: () => (/* binding */ defaultsDeep),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   flattenDeep: () => (/* binding */ flattenDeep),\n/* harmony export */   forIn: () => (/* binding */ forIn),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   invoke: () => (/* binding */ invoke),\n/* harmony export */   invokeProperty: () => (/* binding */ invokeProperty),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mixin: () => (/* binding */ mixin),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   result: () => (/* binding */ result),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   sortedIndex: () => (/* binding */ sortedIndex),\n/* harmony export */   supplement: () => (/* binding */ supplement),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   uniqueId: () => (/* binding */ uniqueId),\n/* harmony export */   without: () => (/* binding */ without)\n/* harmony export */ });\n// code is inspired by https://github.com/lodash/lodash\n/* eslint-disable no-case-declarations */ // -- helper constants\nconst argsTag = \"[object Arguments]\";\nconst arrayTag = \"[object Array]\";\nconst boolTag = \"[object Boolean]\";\nconst dateTag = \"[object Date]\";\nconst errorTag = \"[object Error]\";\nconst funcTag = \"[object Function]\";\nconst mapTag = \"[object Map]\";\nconst numberTag = \"[object Number]\";\nconst nullTag = \"[object Null]\";\nconst objectTag = \"[object Object]\";\nconst regexpTag = \"[object RegExp]\";\nconst setTag = \"[object Set]\";\nconst stringTag = \"[object String]\";\nconst symbolTag = \"[object Symbol]\";\nconst undefinedTag = \"[object Undefined]\";\nconst weakMapTag = \"[object WeakMap]\";\nconst arrayBufferTag = \"[object ArrayBuffer]\";\nconst dataViewTag = \"[object DataView]\";\nconst float32Tag = \"[object Float32Array]\";\nconst float64Tag = \"[object Float64Array]\";\nconst int8Tag = \"[object Int8Array]\";\nconst int16Tag = \"[object Int16Array]\";\nconst int32Tag = \"[object Int32Array]\";\nconst uint8Tag = \"[object Uint8Array]\";\nconst uint8ClampedTag = \"[object Uint8ClampedArray]\";\nconst uint16Tag = \"[object Uint16Array]\";\nconst uint32Tag = \"[object Uint32Array]\";\nconst CLONEABLE_TAGS = {\n    [argsTag]: true,\n    [arrayTag]: true,\n    [arrayBufferTag]: true,\n    [dataViewTag]: true,\n    [boolTag]: true,\n    [dateTag]: true,\n    [float32Tag]: true,\n    [float64Tag]: true,\n    [int8Tag]: true,\n    [int16Tag]: true,\n    [int32Tag]: true,\n    [mapTag]: true,\n    [numberTag]: true,\n    [objectTag]: true,\n    [regexpTag]: true,\n    [setTag]: true,\n    [stringTag]: true,\n    [symbolTag]: true,\n    [uint8Tag]: true,\n    [uint8ClampedTag]: true,\n    [uint16Tag]: true,\n    [uint32Tag]: true,\n    [errorTag]: false,\n    [funcTag]: false,\n    [weakMapTag]: false\n};\n/** Used to compose unicode character classes. */ const rsAstralRange = \"\\ud800-\\udfff\";\nconst rsComboMarksRange = \"\\\\u0300-\\\\u036f\";\nconst reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\";\nconst rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\";\nconst rsComboMarksExtendedRange = \"\\\\u1ab0-\\\\u1aff\";\nconst rsComboMarksSupplementRange = \"\\\\u1dc0-\\\\u1dff\";\nconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\nconst rsDingbatRange = \"\\\\u2700-\\\\u27bf\";\nconst rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\";\nconst rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\";\nconst rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\";\nconst rsPunctuationRange = \"\\\\u2000-\\\\u206f\";\nconst rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\";\nconst rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\";\nconst rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\nconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n/** Used to compose unicode capture groups. */ const rsApos = \"[']\";\nconst rsBreak = `[${rsBreakRange}]`;\nconst rsCombo = `[${rsComboRange}]`;\nconst rsDigit = \"\\\\d\";\nconst rsDingbat = `[${rsDingbatRange}]`;\nconst rsLower = `[${rsLowerRange}]`;\nconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\nconst rsFitz = \"\\ud83c[\\udffb-\\udfff]\";\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\";\nconst rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\";\nconst rsUpper = `[${rsUpperRange}]`;\nconst rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ const rsMiscLower = `(?:${rsLower}|${rsMisc})`;\nconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\nconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\nconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = `(?:${rsZWJ}(?:${[\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\")})${rsOptVar + reOptMod})*`;\nconst rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\";\nconst rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\";\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsEmoji = `(?:${[\n    rsDingbat,\n    rsRegional,\n    rsSurrPair\n].join(\"|\")})${rsSeq}`;\nconst reUnicodeWords = RegExp([\n    `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[\n        rsBreak,\n        rsUpper,\n        \"$\"\n    ].join(\"|\")})`,\n    `${rsMiscUpper}+${rsOptContrUpper}(?=${[\n        rsBreak,\n        rsUpper + rsMiscLower,\n        \"$\"\n    ].join(\"|\")})`,\n    `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,\n    `${rsUpper}+${rsOptContrUpper}`,\n    rsOrdUpper,\n    rsOrdLower,\n    `${rsDigit}+`,\n    rsEmoji\n].join(\"|\"), \"g\");\nconst LARGE_ARRAY_SIZE = 200;\nconst HASH_UNDEFINED = \"__hash_undefined__\";\n// Used to match `toStringTag` values of typed arrays\nconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n// Used to compose unicode capture groups\nconst rsAstral = `[${rsAstralRange}]`;\n// Used to compose unicode regexes\nconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\nconst rsSymbol = `(?:${[\n    rsNonAstralCombo,\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\")})`;\n// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, \"g\");\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(// Match anything that isn't a dot or bracket.\n\"[^.[\\\\]]+\" + \"|\" + // Or match property names within brackets.\n\"\\\\[(?:\" + // Match a non-string expression.\n\"([^\\\"'][^[]*)\" + \"|\" + // Or match strings (supports escaping characters).\n\"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" + // Or match \"\" as the space between consecutive dots or empty brackets.\n\"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\nconst hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);\nconst MAX_ARRAY_INDEX = 4294967295 - 1;\n/** Used to match words composed of alphanumeric characters. */ // eslint-disable-next-line no-control-regex\nconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n// -- helper functions\nconst hasUnicode = (string)=>{\n    return reUnicode.test(string);\n};\nconst unicodeToArray = (string)=>{\n    return string.match(reUnicode) || [];\n};\nconst asciiToArray = (string)=>{\n    return string.split(\"\");\n};\nconst stringToArray = (string)=>{\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n};\nconst values = (object)=>{\n    if (object == null) {\n        return [];\n    }\n    return keys(object).map((key)=>object[key]);\n};\nconst keys = (object)=>{\n    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n};\nconst baseKeys = (object)=>{\n    if (!isPrototype(object)) {\n        return Object.keys(object);\n    }\n    var result = [];\n    for(var key in Object(object)){\n        if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n            result.push(key);\n        }\n    }\n    return result;\n};\nconst arrayLikeKeys = (value, inherited)=>{\n    const isArr = Array.isArray(value);\n    const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n    const isType = !isArr && !isArg && isTypedArray(value);\n    const skipIndexes = isArr || isArg || isType;\n    const length = value.length;\n    const result = new Array(skipIndexes ? length : 0);\n    let index = skipIndexes ? -1 : length;\n    while(++index < length){\n        result[index] = `${index}`;\n    }\n    for(const key in value){\n        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key === \"length\" || // Skip index properties.\n        isIndex(key, length)))) {\n            result.push(key);\n        }\n    }\n    return result;\n};\nconst assocIndexOf = (array, key)=>{\n    let { length } = array;\n    while(length--){\n        if (eq(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n};\nconst eq = (value, other)=>{\n    return value === other || value !== value && other !== other;\n};\nconst isObjectLike = (value)=>{\n    return value != null && typeof value == \"object\";\n};\nconst isIterateeCall = (value, index, object)=>{\n    if (!isObject(object)) {\n        return false;\n    }\n    const type = typeof index;\n    const isPossibleIteratee = type == \"number\" ? isArrayLike(object) && index > -1 && index < object.length : type == \"string\" && index in object;\n    if (isPossibleIteratee) {\n        return eq(object[index], value);\n    }\n    return false;\n};\nconst isSet = (value)=>{\n    return isObjectLike(value) && getTag(value) == setTag;\n};\nconst isMap = (value)=>{\n    return isObjectLike(value) && getTag(value) == mapTag;\n};\nconst isPrototype = (value)=>{\n    const Ctor = value && value.constructor;\n    const proto = typeof Ctor === \"function\" && Ctor.prototype || Object.prototype;\n    return value === proto;\n};\nconst assignValue = (object, key, value)=>{\n    const objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n        object[key] = value;\n    }\n};\nconst copyObject = (source, props, object)=>{\n    let index = -1;\n    const length = props.length;\n    while(++index < length){\n        const key = props[index];\n        assignValue(object, key, source[key]);\n    }\n    return object;\n};\nconst isArrayLike = (value)=>{\n    return value != null && typeof value !== \"function\" && typeof value.length === \"number\" && value.length > -1 && value.length % 1 === 0;\n};\nconst isSymbol = (value)=>{\n    return typeof value == \"symbol\" || isObjectLike(value) && getTag(value) === symbolTag;\n};\nconst initCloneArray = (array)=>{\n    const length = array.length;\n    let result = new array.constructor(length);\n    if (length && typeof array[0] == \"string\" && hasOwnProperty.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n    return result;\n};\nconst copyArray = (source, array)=>{\n    let index = -1;\n    const length = source.length;\n    array || (array = new Array(length));\n    while(++index < length){\n        array[index] = source[index];\n    }\n    return array;\n};\nconst getTag = (value)=>{\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return Object.prototype.toString.call(value);\n};\nconst cloneArrayBuffer = (arrayBuffer)=>{\n    const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n};\nconst cloneTypedArray = (typedArray, isDeep)=>{\n    const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n};\nconst cloneRegExp = (regexp)=>{\n    const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n};\nconst initCloneObject = (object)=>{\n    return typeof object.constructor == \"function\" && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};\n};\nconst getSymbols = (object)=>{\n    if (object == null) {\n        return [];\n    }\n    object = Object(object);\n    const symbols = Object.getOwnPropertySymbols(object);\n    return symbols.filter((symbol)=>propertyIsEnumerable.call(object, symbol));\n};\nconst copySymbols = (source, object)=>{\n    return copyObject(source, getSymbols(source), object);\n};\nfunction cloneDataView(dataView, isDeep) {\n    const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nconst initCloneByTag = (object, tag, isDeep)=>{\n    const Constructor = object.constructor;\n    switch(tag){\n        case arrayBufferTag:\n            return cloneArrayBuffer(object, isDeep);\n        case boolTag:\n        case dateTag:\n            return new Constructor(+object);\n        case dataViewTag:\n            return cloneDataView(object, isDeep);\n        case float32Tag:\n        case float64Tag:\n        case int8Tag:\n        case int16Tag:\n        case int32Tag:\n        case uint8Tag:\n        case uint8ClampedTag:\n        case uint16Tag:\n        case uint32Tag:\n            return cloneTypedArray(object, isDeep);\n        case mapTag:\n            return new Constructor(object);\n        case numberTag:\n        case stringTag:\n            return new Constructor(object);\n        case regexpTag:\n            return cloneRegExp(object);\n        case setTag:\n            return new Constructor;\n        case symbolTag:\n            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n    }\n};\nconst isTypedArray = (value)=>{\n    return isObjectLike(value) && reTypedTag.test(getTag(value));\n};\nconst getAllKeys = (object)=>{\n    const result = Object.keys(object);\n    if (!Array.isArray(object) && object != null) {\n        result.push(...getSymbols(Object(object)));\n    }\n    return result;\n};\nconst getSymbolsIn = (object)=>{\n    const result = [];\n    while(object){\n        result.push(...getSymbols(object));\n        object = Object.getPrototypeOf(Object(object));\n    }\n    return result;\n};\nconst getAllKeysIn = (object)=>{\n    const result = [];\n    for(const key in object){\n        result.push(key);\n    }\n    if (!Array.isArray(object)) {\n        result.push(...getSymbolsIn(object));\n    }\n    return result;\n};\nconst getMapData = ({ __data__ }, key)=>{\n    const data = __data__;\n    return isKeyable(key) ? data[typeof key === \"string\" ? \"string\" : \"hash\"] : data.map;\n};\nconst equalObjects = (object, other, equalFunc, stack)=>{\n    const objProps = getAllKeys(object);\n    const objLength = objProps.length;\n    const othProps = getAllKeys(other);\n    const othLength = othProps.length;\n    if (objLength != othLength) {\n        return false;\n    }\n    let key;\n    let index = objLength;\n    while(index--){\n        key = objProps[index];\n        if (!hasOwnProperty.call(other, key)) {\n            return false;\n        }\n    }\n    const objStacked = stack.get(object);\n    const othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    let result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    let compared;\n    let skipCtor;\n    while(++index < objLength){\n        key = objProps[index];\n        const objValue = object[key];\n        const othValue = other[key];\n        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n    }\n    if (result && !skipCtor) {\n        const objCtor = object.constructor;\n        const othCtor = other.constructor;\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor === \"function\" && objCtor instanceof objCtor && typeof othCtor === \"function\" && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack[\"delete\"](object);\n    stack[\"delete\"](other);\n    return result;\n};\nconst baseIsEqual = (value, other, stack)=>{\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, baseIsEqual, stack);\n};\nconst baseIsEqualDeep = (object, other, equalFunc, stack)=>{\n    let objIsArr = Array.isArray(object);\n    const othIsArr = Array.isArray(other);\n    let objTag = objIsArr ? arrayTag : getTag(object);\n    let othTag = othIsArr ? arrayTag : getTag(other);\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n    let objIsObj = objTag == objectTag;\n    const othIsObj = othTag == objectTag;\n    const isSameTag = objTag == othTag;\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);\n    }\n    const objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\");\n    const othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n    if (objIsWrapped || othIsWrapped) {\n        const objUnwrapped = objIsWrapped ? object.value() : object;\n        const othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, stack);\n    }\n    if (!isSameTag) {\n        return false;\n    }\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, stack);\n};\nconst equalArrays = (array, other, compareUnordered, equalFunc, stack)=>{\n    const isPartial = false;\n    const arrLength = array.length;\n    const othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Assume cyclic values are equal.\n    const arrStacked = stack.get(array);\n    const othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    let index = -1;\n    let result = true;\n    const seen = compareUnordered ? new SetCache : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    while(++index < arrLength){\n        let compared;\n        const arrValue = array[index];\n        const othValue = other[index];\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n        if (seen) {\n            if (!some(other, (othValue, othIndex)=>{\n                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n            result = false;\n            break;\n        }\n    }\n    stack[\"delete\"](array);\n    stack[\"delete\"](other);\n    return result;\n};\nconst some = (array, predicate)=>{\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n};\nconst cacheHas = (cache, key)=>{\n    return cache.has(key);\n};\nconst compareArrayBufferTag = (object, other, equalFunc, stack)=>{\n    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n        return false;\n    }\n    return true;\n};\nconst equalByTag = (object, other, tag, equalFunc, stack)=>{\n    switch(tag){\n        case dataViewTag:\n            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case arrayBufferTag:\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            return eq(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            return object == `${other}`;\n        case mapTag:\n            let convert = mapToArray;\n        // Intentional fallthrough\n        // eslint-disable-next-line no-fallthrough\n        case setTag:\n            convert || (convert = setToArray);\n            if (object.size != other.size) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            const stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n            stack[\"delete\"](object);\n            return result;\n        case symbolTag:\n            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n    }\n    return false;\n};\nconst mapToArray = (map)=>{\n    let index = -1;\n    let result = Array(map.size);\n    map.forEach((value, key)=>{\n        result[++index] = [\n            key,\n            value\n        ];\n    });\n    return result;\n};\nconst setToArray = (set)=>{\n    let index = -1;\n    const result = new Array(set.size);\n    set.forEach((value)=>{\n        result[++index] = value;\n    });\n    return result;\n};\nconst isKey = (value, object)=>{\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === \"number\" || type === \"boolean\" || value == null || isSymbol(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\nconst stringToPath = (string)=>{\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, (match, expression, quote, subString)=>{\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, \"$1\");\n        } else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\nconst castPath = (path, object)=>{\n    if (Array.isArray(path)) {\n        return path;\n    }\n    return isKey(path, object) ? [\n        path\n    ] : stringToPath(`${path}`);\n};\nconst get = (object, path)=>{\n    path = castPath(path, object);\n    let index = 0;\n    const length = path.length;\n    while(object != null && index < length){\n        object = object[toKey(path[index])];\n        index++;\n    }\n    return index && index == length ? object : undefined;\n};\nfunction compareAscending(value, other) {\n    if (value !== other) {\n        const valIsDefined = value !== undefined;\n        const valIsNull = value === null;\n        const valIsReflexive = value === value;\n        const valIsSymbol = isSymbol(value);\n        const othIsDefined = other !== undefined;\n        const othIsNull = other === null;\n        const othIsReflexive = other === other;\n        const othIsSymbol = isSymbol(other);\n        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n            return 1;\n        }\n        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\nfunction compareMultiple(object, other, orders) {\n    let index = -1;\n    const objCriteria = object.criteria;\n    const othCriteria = other.criteria;\n    const length = objCriteria.length;\n    const ordersLength = orders.length;\n    while(++index < length){\n        const order = index < ordersLength ? orders[index] : null;\n        const cmpFn = order && typeof order === \"function\" ? order : compareAscending;\n        const result = cmpFn(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (order && typeof order !== \"function\") {\n                return result * (order == \"desc\" ? -1 : 1);\n            }\n            return result;\n        }\n    }\n    return object.index - other.index;\n}\nconst diff = (array, values)=>{\n    let includes = (array, value)=>{\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    let isCommon = true;\n    const result = [];\n    const valuesLength = values.length;\n    if (!array.length) {\n        return result;\n    }\n    if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = (cache, key)=>cache.has(key);\n        isCommon = false;\n        values = new SetCache(values);\n    }\n    outer: for(let key in array){\n        let value = array[key];\n        const computed = value;\n        value = value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n            let valuesIndex = valuesLength;\n            while(valuesIndex--){\n                if (values[valuesIndex] === computed) {\n                    continue outer;\n                }\n            }\n            result.push(value);\n        } else if (!includes(values, computed)) {\n            result.push(value);\n        }\n    }\n    return result;\n};\nconst intersect = (arrays)=>{\n    const includes = (array, value)=>{\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    const cacheHas = (cache, key)=>cache.has(key);\n    const length = arrays[0].length;\n    const othLength = arrays.length;\n    const caches = new Array(othLength);\n    const result = [];\n    let array;\n    let maxLength = Infinity;\n    let othIndex = othLength;\n    while(othIndex--){\n        array = arrays[othIndex];\n        maxLength = Math.min(array.length, maxLength);\n        caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;\n    }\n    array = arrays[0];\n    let index = -1;\n    const seen = caches[0];\n    outer: while(++index < length && result.length < maxLength){\n        let value = array[index];\n        const computed = value;\n        value = value !== 0 ? value : 0;\n        if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {\n            othIndex = othLength;\n            while(--othIndex){\n                const cache = caches[othIndex];\n                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) {\n                    continue outer;\n                }\n            }\n            if (seen) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\nconst toKey = (value)=>{\n    if (typeof value === \"string\" || isSymbol(value)) {\n        return value;\n    }\n    const result = `${value}`;\n    return result == \"0\" && 1 / value == -Infinity ? \"-0\" : result;\n};\nconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack)=>{\n    let result;\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n        return result;\n    }\n    if (!isObject(value)) {\n        return value;\n    }\n    const isArr = Array.isArray(value);\n    const tag = getTag(value);\n    if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n            return copyArray(value, result);\n        }\n    } else {\n        const isFunc = typeof value === \"function\";\n        if (tag === objectTag || tag === argsTag || isFunc && !object) {\n            result = isFlat || isFunc ? {} : initCloneObject(value);\n            if (!isDeep) {\n                return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));\n            }\n        } else {\n            if (isFunc || !CLONEABLE_TAGS[tag]) {\n                return object ? value : {};\n            }\n            result = initCloneByTag(value, tag, isDeep);\n        }\n    }\n    stack || (stack = new Stack);\n    const stacked = stack.get(value);\n    if (stacked) {\n        return stacked;\n    }\n    stack.set(value, result);\n    if (isMap(value)) {\n        value.forEach((subValue, key)=>{\n            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n        });\n        return result;\n    }\n    if (isSet(value)) {\n        value.forEach((subValue)=>{\n            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n        });\n        return result;\n    }\n    if (isTypedArray(value)) {\n        return result;\n    }\n    const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n    const props = isArr ? undefined : keysFunc(value);\n    (props || value).forEach((subValue, key)=>{\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n    });\n    return result;\n};\nconst copySymbolsIn = (source, object)=>{\n    return copyObject(source, getSymbolsIn(source), object);\n};\nconst parent = (object, path)=>{\n    return path.length < 2 ? object : get(object, path.slice(0, -1));\n};\nconst set = (object, path, value)=>{\n    if (!isObject(object)) {\n        return object;\n    }\n    path = castPath(path, object);\n    const length = path.length;\n    const lastIndex = length - 1;\n    let index = -1;\n    let nested = object;\n    while(nested != null && ++index < length){\n        const key = toKey(path[index]);\n        let newValue = value;\n        if (index != lastIndex) {\n            const objValue = nested[key];\n            newValue = undefined;\n            if (newValue === undefined) {\n                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n            }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n    }\n    return object;\n};\nconst isIndex = (value, length)=>{\n    const type = typeof value;\n    length = length == null ? Number.MAX_SAFE_INTEGER : length;\n    return !!length && (type === \"number\" || type !== \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n};\nconst unset = (object, path)=>{\n    path = castPath(path, object);\n    object = parent(object, path);\n    const lastSegment = path[path.length - 1];\n    return object == null || delete object[toKey(lastSegment)];\n};\nconst isKeyable = (value)=>{\n    const type = typeof value;\n    return type === \"string\" || type === \"number\" || type === \"symbol\" || type === \"boolean\" ? value !== \"__proto__\" : value === null;\n};\nconst keysIn = (object)=>{\n    const result = [];\n    for(const key in object){\n        result.push(key);\n    }\n    return result;\n};\nconst toPlainObject = (value)=>{\n    value = Object(value);\n    const result = {};\n    for(const key in value){\n        result[key] = value[key];\n    }\n    return result;\n};\nconst safeGet = (object, key)=>{\n    if (key === \"constructor\" && typeof object[key] === \"function\") {\n        return;\n    }\n    if (key == \"__proto__\") {\n        return;\n    }\n    return object[key];\n};\nfunction createAssigner(assigner, isMerge = false) {\n    return (object, ...sources)=>{\n        let index = -1;\n        let length = sources.length;\n        let customizer = length > 1 ? sources[length - 1] : undefined;\n        const guard = length > 2 ? sources[2] : undefined;\n        customizer = assigner.length > 3 && typeof customizer === \"function\" ? (length--, customizer) : isMerge ? (a, b)=>{\n            if (Array.isArray(a) && !Array.isArray(b)) {\n                return b;\n            }\n        } : undefined;\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while(++index < length){\n            const source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    };\n}\nconst baseMerge = (object, source, srcIndex, customizer, stack)=>{\n    if (object === source) {\n        return;\n    }\n    forIn(source, (srcValue, key)=>{\n        if (isObject(srcValue)) {\n            stack || (stack = new Stack);\n            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        } else {\n            let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : undefined;\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n            assignMergeValue(object, key, newValue);\n        }\n    }, keysIn);\n};\nconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack)=>{\n    const objValue = safeGet(object, key);\n    const srcValue = safeGet(source, key);\n    const stacked = stack.get(srcValue);\n    if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n    }\n    let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : undefined;\n    let isCommon = newValue === undefined;\n    if (isCommon) {\n        const isArr = Array.isArray(srcValue);\n        const isTyped = !isArr && isTypedArray(srcValue);\n        newValue = srcValue;\n        if (isArr || isTyped) {\n            if (Array.isArray(objValue)) {\n                newValue = objValue;\n            } else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n                newValue = copyArray(objValue);\n            } else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            } else {\n                newValue = [];\n            }\n        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n            newValue = objValue;\n            if (isArguments(objValue)) {\n                newValue = toPlainObject(objValue);\n            } else if (typeof objValue === \"function\" || !isObject(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        } else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack[\"delete\"](srcValue);\n    }\n    assignMergeValue(object, key, newValue);\n};\nconst assignMergeValue = (object, key, value)=>{\n    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n        assignValue(object, key, value);\n    }\n};\nfunction baseFor(object, iteratee, keysFunc) {\n    const iterable = Object(object);\n    const props = keysFunc(object);\n    let { length } = props;\n    let index = -1;\n    while(length--){\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n    return object;\n}\nconst baseForOwn = (object, iteratee)=>{\n    return object && baseFor(object, iteratee, keys);\n};\nconst baseEach = (collection, iteratee)=>{\n    if (collection == null) {\n        return collection;\n    }\n    if (!isArrayLike(collection)) {\n        return baseForOwn(collection, iteratee);\n    }\n    const length = collection.length;\n    const iterable = Object(collection);\n    let index = -1;\n    while(++index < length){\n        if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n        }\n    }\n    return collection;\n};\nfunction last(array) {\n    const length = array == null ? 0 : array.length;\n    return length ? array[length - 1] : undefined;\n}\nconst createSet = Set && 1 / setToArray(new Set([\n    undefined,\n    -0\n]))[1] == 1 / 0 ? (values)=>new Set(values) : ()=>{};\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n    if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack[\"delete\"](srcValue);\n    }\n    return objValue;\n}\nfunction baseOrderBy(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = iteratees.map((iteratee)=>{\n            if (Array.isArray(iteratee)) {\n                return (value)=>get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n            return iteratee;\n        });\n    } else {\n        iteratees = [\n            (value)=>value\n        ];\n    }\n    let criteriaIndex = -1;\n    let eachIndex = -1;\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n    baseEach(collection, (value)=>{\n        const criteria = iteratees.map((iteratee)=>iteratee(value));\n        result[++eachIndex] = {\n            criteria,\n            index: ++criteriaIndex,\n            value\n        };\n    });\n    return baseSortBy(result, (object, other)=>compareMultiple(object, other, orders));\n}\nfunction baseSortBy(array, comparer) {\n    let { length } = array;\n    array.sort(comparer);\n    while(length--){\n        array[length] = array[length].value;\n    }\n    return array;\n}\nfunction isStrictComparable(value) {\n    return value === value && !isObject(value);\n}\nfunction matchesStrictComparable(key, srcValue) {\n    return (object)=>{\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n}\nfunction hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\nfunction baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return (object)=>{\n        const objValue = get(object, path);\n        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);\n    };\n}\nfunction baseMatches(source) {\n    const matchData = getMatchData(source);\n    if (matchData.length === 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return (object)=>object === source || baseIsMatch(object, source, matchData);\n}\nfunction getMatchData(object) {\n    const result = keys(object);\n    let length = result.length;\n    while(length--){\n        const key = result[length];\n        const value = object[key];\n        result[length] = [\n            key,\n            value,\n            isStrictComparable(value)\n        ];\n    }\n    return result;\n}\nfunction baseIsMatch(object, source, matchData, customizer) {\n    let index = matchData.length;\n    const length = index;\n    const noCustomizer = !customizer;\n    if (object == null) {\n        return !length;\n    }\n    let data;\n    let result;\n    object = Object(object);\n    while(index--){\n        data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n            return false;\n        }\n    }\n    while(++index < length){\n        data = matchData[index];\n        const key = data[0];\n        const objValue = object[key];\n        const srcValue = data[1];\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            const stack = new Stack;\n            if (customizer) {\n                result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\nfunction baseProperty(key) {\n    return (object)=>object == null ? undefined : object[key];\n}\nfunction basePropertyDeep(path) {\n    return (object)=>get(object, path);\n}\nfunction baseIteratee(value) {\n    if (typeof value == \"function\") {\n        return value;\n    }\n    if (value == null) {\n        return (val)=>val;\n    }\n    if (typeof value == \"object\") {\n        return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n}\nfunction getIteratee() {\n    const result = baseIteratee;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n}\nconst arrayReduce = (array, iteratee, accumulator, initAccum)=>{\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while(++index < length){\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n};\nconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc)=>{\n    eachFunc(collection, (value, index, collection)=>{\n        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n};\nfunction reduce(collection, iteratee, accumulator) {\n    const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n    const initAccum = arguments.length < 3;\n    return func(collection, iteratee, accumulator, initAccum, baseEach);\n}\nconst isFlattenable = (value)=>{\n    return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);\n};\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n    let index = -1;\n    const length = array.length;\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n    while(++index < length){\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n            } else {\n                result.push(...value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\nconst isArguments = (value)=>{\n    return isObjectLike(value) && getTag(value) == \"[object Arguments]\";\n};\nconst basePick = (object, paths)=>{\n    return basePickBy(object, paths, (value, path)=>hasIn(object, path));\n};\nconst basePickBy = (object, paths, predicate)=>{\n    let index = -1;\n    const length = paths.length;\n    const result = {};\n    while(++index < length){\n        const path = paths[index];\n        const value = get(object, path);\n        if (predicate(value, path)) {\n            set(result, castPath(path, object), value);\n        }\n    }\n    return result;\n};\nconst isLength = (value)=>{\n    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\nconst baseHasIn = (object, key)=>{\n    return object != null && key in Object(object);\n};\nconst hasPath = (object, path, hasFunc)=>{\n    path = castPath(path, object);\n    var index = -1, length = path.length, result = false;\n    while(++index < length){\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));\n};\nconst asciiWords = (string)=>{\n    return string.match(reAsciiWord);\n};\nconst unicodeWords = (string)=>{\n    return string.match(reUnicodeWords);\n};\nconst words = (string, pattern)=>{\n    if (pattern === undefined) {\n        const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n        return result || [];\n    }\n    return string.match(pattern) || [];\n};\nconst castSlice = (array, start, end)=>{\n    const { length } = array;\n    end = end === undefined ? length : end;\n    return !start && end >= length ? array : array.slice(start, end);\n};\nconst upperFirst = createCaseFirst(\"toUpperCase\");\nfunction createCaseFirst(methodName) {\n    return (string)=>{\n        if (!string) {\n            return \"\";\n        }\n        const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n        const chr = strSymbols ? strSymbols[0] : string[0];\n        const trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n        return chr[methodName]() + trailing;\n    };\n}\n// -- helper classes\nclass Stack {\n    constructor(entries){\n        const data = this.__data__ = new ListCache(entries);\n        this.size = data.size;\n    }\n    clear() {\n        this.__data__ = new ListCache;\n        this.size = 0;\n    }\n    delete(key) {\n        const data = this.__data__;\n        const result = data[\"delete\"](key);\n        this.size = data.size;\n        return result;\n    }\n    get(key) {\n        return this.__data__.get(key);\n    }\n    has(key) {\n        return this.__data__.has(key);\n    }\n    set(key, value) {\n        let data = this.__data__;\n        if (data instanceof ListCache) {\n            const pairs = data.__data__;\n            if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([\n                    key,\n                    value\n                ]);\n                this.size = ++data.size;\n                return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n        }\n        data.set(key, value);\n        this.size = data.size;\n        return this;\n    }\n}\nclass ListCache {\n    constructor(entries){\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    clear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n    delete(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        if (index < 0) {\n            return false;\n        }\n        const lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            data.splice(index, 1);\n        }\n        --this.size;\n        return true;\n    }\n    get(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n    has(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n    set(key, value) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n}\nclass MapCache {\n    constructor(entries){\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    clear() {\n        this.size = 0;\n        this.__data__ = {\n            \"hash\": new Hash,\n            \"map\": new Map,\n            \"string\": new Hash\n        };\n    }\n    delete(key) {\n        const result = getMapData(this, key)[\"delete\"](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    get(key) {\n        return getMapData(this, key).get(key);\n    }\n    has(key) {\n        return getMapData(this, key).has(key);\n    }\n    set(key, value) {\n        const data = getMapData(this, key);\n        const size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n}\nclass Hash {\n    constructor(entries){\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    clear() {\n        this.__data__ = Object.create(null);\n        this.size = 0;\n    }\n    delete(key) {\n        const result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    get(key) {\n        const data = this.__data__;\n        const result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    }\n    has(key) {\n        const data = this.__data__;\n        return data[key] !== undefined;\n    }\n    set(key, value) {\n        const data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n}\nclass SetCache {\n    constructor(values){\n        let index = -1;\n        const length = values == null ? 0 : values.length;\n        this.__data__ = new MapCache;\n        while(++index < length){\n            this.add(values[index]);\n        }\n    }\n    add(value) {\n        this.__data__.set(value, HASH_UNDEFINED);\n        return this;\n    }\n    has(value) {\n        return this.__data__.has(value);\n    }\n}\nSetCache.prototype.push = SetCache.prototype.add;\n// -- top level functions\nconst isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || !!value && typeof value === \"object\" && toString.call(value) === boolTag;\n};\nconst isObject = function(value) {\n    return !!value && (typeof value === \"object\" || typeof value === \"function\");\n};\nconst isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === \"number\" || !!value && typeof value === \"object\" && toString.call(value) === numberTag;\n};\nconst isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === \"string\" || !!value && typeof value === \"object\" && toString.call(value) === stringTag;\n};\nconst assign = createAssigner((object, source)=>{\n    if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n    }\n    for(var key in source){\n        if (hasOwnProperty.call(source, key)) {\n            assignValue(object, key, source[key]);\n        }\n    }\n});\nconst mixin = assign;\nconst deepMixin = mixin;\nconst supplement = (object, ...sources)=>{\n    let index = -1;\n    let length = sources.length;\n    const guard = length > 2 ? sources[2] : undefined;\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n    }\n    while(++index < length){\n        const source = sources[index];\n        if (source == null) {\n            continue;\n        }\n        const props = Object.keys(source);\n        const propsLength = props.length;\n        let propsIndex = -1;\n        while(++propsIndex < propsLength){\n            const key = props[propsIndex];\n            const value = object[key];\n            if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) {\n                object[key] = source[key];\n            }\n        }\n    }\n    return object;\n};\nconst defaults = supplement;\nconst deepSupplement = function defaultsDeep(...args) {\n    args.push(undefined, customDefaultsMerge);\n    return merge.apply(undefined, args);\n};\nconst defaultsDeep = deepSupplement;\n// _.invokeMap\nconst invoke = (collection, path, ...args)=>{\n    let index = -1;\n    const isFunc = typeof path === \"function\";\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n    baseEach(collection, (value)=>{\n        result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n    });\n    return result;\n};\n// _.invoke\nconst invokeProperty = (object, path, ...args)=>{\n    path = castPath(path, object);\n    object = parent(object, path);\n    const func = object == null ? object : object[toKey(last(path))];\n    return func == null ? undefined : func.apply(object, args);\n};\nconst sortedIndex = (array, value, iteratee)=>{\n    let low = 0;\n    let high = array == null ? 0 : array.length;\n    if (high == 0) {\n        return 0;\n    }\n    iteratee = getIteratee(iteratee, 2);\n    value = iteratee(value);\n    const valIsNaN = value !== value;\n    const valIsNull = value === null;\n    const valIsSymbol = isSymbol(value);\n    const valIsUndefined = value === undefined;\n    while(low < high){\n        let setLow;\n        const mid = Math.floor((low + high) / 2);\n        const computed = iteratee(array[mid]);\n        const othIsDefined = computed !== undefined;\n        const othIsNull = computed === null;\n        const othIsReflexive = computed === computed;\n        const othIsSymbol = isSymbol(computed);\n        if (valIsNaN) {\n            setLow = othIsReflexive;\n        } else if (valIsUndefined) {\n            setLow = othIsReflexive && othIsDefined;\n        } else if (valIsNull) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull;\n        } else if (valIsSymbol) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n        } else if (othIsNull || othIsSymbol) {\n            setLow = false;\n        } else {\n            setLow = computed < value;\n        }\n        if (setLow) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return Math.min(high, MAX_ARRAY_INDEX);\n};\nconst uniq = (array, iteratee)=>{\n    let index = -1;\n    let includes = (array, value)=>{\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    iteratee = getIteratee(iteratee, 2);\n    let isCommon = true;\n    const { length } = array;\n    const result = [];\n    let seen = result;\n    if (length >= LARGE_ARRAY_SIZE) {\n        const set = iteratee ? null : createSet(array);\n        if (set) {\n            return setToArray(set);\n        }\n        isCommon = false;\n        includes = (cache, key)=>cache.has(key);\n        seen = new SetCache;\n    } else {\n        seen = iteratee ? [] : result;\n    }\n    outer: while(++index < length){\n        let value = array[index];\n        const computed = iteratee ? iteratee(value) : value;\n        value = value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n            let seenIndex = seen.length;\n            while(seenIndex--){\n                if (seen[seenIndex] === computed) {\n                    continue outer;\n                }\n            }\n            if (iteratee) {\n                seen.push(computed);\n            }\n            result.push(value);\n        } else if (!includes(seen, computed)) {\n            if (seen !== result) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\nconst clone = (value)=>baseClone(value);\nconst cloneDeep = (value)=>baseClone(value, true);\nconst isEmpty = (value)=>{\n    if (value == null) {\n        return true;\n    }\n    if (isArrayLike(value) && (Array.isArray(value) || typeof value === \"string\" || typeof value.splice === \"function\" || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n    }\n    const tag = getTag(value);\n    if (tag == \"[object Map]\" || tag == \"[object Set]\") {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !baseKeys(value).length;\n    }\n    for(const key in value){\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n};\nconst isEqual = (object, other)=>baseIsEqual(object, other);\nconst isFunction = (value)=>typeof value === \"function\";\nconst isPlainObject = (value)=>{\n    if (!isObjectLike(value) || getTag(value) != \"[object Object]\") {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    let proto = value;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\nconst toArray = (value)=>{\n    if (!value) {\n        return [];\n    }\n    if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n    if (Symbol.iterator && Symbol.iterator in Object(value)) {\n        const iterator = value[Symbol.iterator]();\n        let data;\n        const result = [];\n        while(!(data = iterator.next()).done){\n            result.push(data.value);\n        }\n        return result;\n    }\n    const tag = getTag(value);\n    const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n    return func(value);\n};\nfunction debounce(func, wait, opt) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n    }\n    let lastArgs;\n    let lastThis;\n    let maxWait;\n    let result;\n    let timerId;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === \"function\";\n    wait = +wait || 0;\n    if (isObject(opt)) {\n        leading = !!opt.leading;\n        maxing = \"maxWait\" in opt;\n        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n        trailing = \"trailing\" in opt ? !!opt.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRaf) {\n            window.cancelAnimationFrame(timerId);\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRaf) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = ()=>{\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    };\n    debounced.flush = ()=>timerId === undefined ? result : trailingEdge(Date.now());\n    debounced.pending = ()=>timerId !== undefined;\n    return debounced;\n}\nconst groupBy = (collection, iteratee)=>{\n    iteratee = getIteratee(iteratee, 2);\n    return reduce(collection, (result, value, key)=>{\n        key = iteratee(value);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(value);\n        } else {\n            assignValue(result, key, [\n                value\n            ]);\n        }\n        return result;\n    }, {});\n};\nconst sortBy = (collection, iteratees = [])=>{\n    if (collection == null) {\n        return [];\n    }\n    const length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [\n            iteratees[0]\n        ];\n    }\n    if (!Array.isArray(iteratees)) {\n        iteratees = [\n            getIteratee(iteratees, 2)\n        ];\n    }\n    return baseOrderBy(collection, iteratees.flat(1), []);\n};\nconst flattenDeep = (array)=>{\n    const length = array == null ? 0 : array.length;\n    return length ? baseFlatten(array, Infinity) : [];\n};\nconst without = (array, ...values)=>isArrayLike(array) ? diff(array, values) : [];\nconst difference = (array, ...values)=>isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];\nconst intersection = (...arrays)=>{\n    const mapped = arrays.map((array)=>isObjectLike(array) && isArrayLike(array) ? array : []);\n    return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];\n};\nconst union = (...arrays)=>{\n    const array = arrays.flat(1);\n    return uniq(array);\n};\nconst has = (object, key)=>{\n    if (object == null) {\n        return false;\n    }\n    if (typeof key === \"string\") {\n        key = key.split(\".\");\n    }\n    let index = -1;\n    let value = object;\n    while(++index < key.length){\n        if (!value || !hasOwnProperty.call(value, key[index])) {\n            return false;\n        }\n        value = value[key[index]];\n    }\n    return true;\n};\nconst result = (object, path, defaultValue)=>{\n    path = castPath(path, object);\n    let index = -1;\n    let length = path.length;\n    if (!length) {\n        length = 1;\n        object = undefined;\n    }\n    while(++index < length){\n        let value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n            index = length;\n            value = defaultValue;\n        }\n        object = typeof value === \"function\" ? value.call(object) : value;\n    }\n    return object;\n};\nconst omit = (object, ...paths)=>{\n    let result = {};\n    if (object == null) {\n        return result;\n    }\n    let isDeep = false;\n    paths = paths.flat(1).map((path)=>{\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n    });\n    copyObject(object, getAllKeysIn(object), result);\n    if (isDeep) {\n        result = baseClone(result, true, true, true, (value)=>isPlainObject(value) ? undefined : value);\n    }\n    let length = paths.length;\n    while(length--){\n        unset(result, paths[length]);\n    }\n    return result;\n};\nconst pick = (object, ...paths)=>{\n    return object == null ? {} : basePick(object, paths.flat(Infinity));\n};\nconst bindAll = (object, ...methodNames)=>{\n    methodNames.flat(1).forEach((key)=>{\n        key = toKey(key);\n        assignValue(object, key, object[key].bind(object));\n    });\n    return object;\n};\nconst forIn = (object, iteratee = (value)=>value)=>{\n    let index = -1;\n    const iterable = Object(object);\n    const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n    let length = props.length;\n    while(length--){\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n};\nconst camelCase = (string = \"\")=>words(`${string}`.replace(/['\\u2019]/g, \"\")).reduce((result, word, index)=>{\n        word = word.toLowerCase();\n        return result + (index ? upperFirst(word) : word);\n    }, \"\");\nlet idCounter = 0;\nconst uniqueId = (prefix = \"\")=>{\n    const id = ++idCounter;\n    return `${prefix}` + id;\n};\nconst merge = createAssigner((object, source, srcIndex, customizer)=>{\n    baseMerge(object, source, srcIndex, customizer);\n}, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC91dGlsSGVscGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQXVEO0FBRXZELHVDQUF1QyxHQUN2QyxzQkFBc0I7QUFDdEIsTUFBTUEsVUFBVTtBQUNoQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsWUFBWTtBQUVsQixNQUFNQyxpQkFBaUI7SUFDbkIsQ0FBQzNCLFFBQVEsRUFBRTtJQUNYLENBQUNDLFNBQVMsRUFBRTtJQUNaLENBQUNlLGVBQWUsRUFBRTtJQUNsQixDQUFDQyxZQUFZLEVBQUU7SUFDZixDQUFDZixRQUFRLEVBQUU7SUFDWCxDQUFDQyxRQUFRLEVBQUU7SUFDWCxDQUFDZSxXQUFXLEVBQUU7SUFDZCxDQUFDQyxXQUFXLEVBQUU7SUFDZCxDQUFDQyxRQUFRLEVBQUU7SUFDWCxDQUFDQyxTQUFTLEVBQUU7SUFDWixDQUFDQyxTQUFTLEVBQUU7SUFDWixDQUFDaEIsT0FBTyxF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QUFFSyxNQUFNb0ssWUFBWSxDQUFDM1ksU0FBUyxFQUFFLEdBQ2pDMlIsTUFBTSxDQUFDLEVBQUUzUixPQUFPLENBQUMsQ0FBQ3VKLE9BQU8sQ0FBQyxjQUFjLEtBQ25Dc0gsTUFBTSxDQUFDLENBQUM3UCxRQUFRNFgsTUFBTTVXO1FBQ25CNFcsT0FBT0EsS0FBS0MsV0FBVztRQUN2QixPQUFPN1gsU0FBVWdCLENBQUFBLFFBQVFnUSxXQUFXNEcsUUFBUUEsSUFBRztJQUNuRCxHQUFHLElBQ1Q7QUFFRixJQUFJRSxZQUFZO0FBRVQsTUFBTUMsV0FBVyxDQUFDQyxTQUFTLEVBQUU7SUFDaEMsTUFBTXBDLEtBQUssRUFBRWtDO0lBQ2IsT0FBTyxDQUFDLEVBQUVFLE9BQU8sQ0FBQyxHQUFHcEM7QUFDekIsRUFBRTtBQUVLLE1BQU0vQyxRQUFRekcsZUFBZSxDQUFDN00sUUFBUTRDLFFBQVF5SyxVQUFVMUI7SUFDM0R5QixVQUFVcE4sUUFBUTRDLFFBQVF5SyxVQUFVMUI7QUFDeEMsR0FBRyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC91dGlsSGVscGVycy5tanM/MTdlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG4vLyAtLSBoZWxwZXIgY29uc3RhbnRzXG5jb25zdCBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5jb25zdCBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5jb25zdCBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuY29uc3QgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbmNvbnN0IGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuY29uc3QgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJztcbmNvbnN0IG51bGxUYWcgPSAnW29iamVjdCBOdWxsXSc7XG5jb25zdCBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3Qgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcbmNvbnN0IHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuY29uc3QgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5jb25zdCB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuY29uc3QgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xuY29uc3QgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuY29uc3QgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xuY29uc3QgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nO1xuY29uc3QgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xuY29uc3QgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7XG5jb25zdCBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJztcbmNvbnN0IHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xuY29uc3QgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJztcbmNvbnN0IHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7XG5jb25zdCB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG5jb25zdCBDTE9ORUFCTEVfVEFHUyA9IHtcbiAgICBbYXJnc1RhZ106IHRydWUsXG4gICAgW2FycmF5VGFnXTogdHJ1ZSxcbiAgICBbYXJyYXlCdWZmZXJUYWddOiB0cnVlLFxuICAgIFtkYXRhVmlld1RhZ106IHRydWUsXG4gICAgW2Jvb2xUYWddOiB0cnVlLFxuICAgIFtkYXRlVGFnXTogdHJ1ZSxcbiAgICBbZmxvYXQzMlRhZ106IHRydWUsXG4gICAgW2Zsb2F0NjRUYWddOiB0cnVlLFxuICAgIFtpbnQ4VGFnXTogdHJ1ZSxcbiAgICBbaW50MTZUYWddOiB0cnVlLFxuICAgIFtpbnQzMlRhZ106IHRydWUsXG4gICAgW21hcFRhZ106IHRydWUsXG4gICAgW251bWJlclRhZ106IHRydWUsXG4gICAgW29iamVjdFRhZ106IHRydWUsXG4gICAgW3JlZ2V4cFRhZ106IHRydWUsXG4gICAgW3NldFRhZ106IHRydWUsXG4gICAgW3N0cmluZ1RhZ106IHRydWUsXG4gICAgW3N5bWJvbFRhZ106IHRydWUsXG4gICAgW3VpbnQ4VGFnXTogdHJ1ZSxcbiAgICBbdWludDhDbGFtcGVkVGFnXTogdHJ1ZSxcbiAgICBbdWludDE2VGFnXTogdHJ1ZSxcbiAgICBbdWludDMyVGFnXTogdHJ1ZSxcbiAgICBbZXJyb3JUYWddOiBmYWxzZSxcbiAgICBbZnVuY1RhZ106IGZhbHNlLFxuICAgIFt3ZWFrTWFwVGFnXTogZmFsc2UsXG59O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG5jb25zdCByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnO1xuY29uc3QgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2Zic7XG5jb25zdCByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZic7XG5jb25zdCByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnO1xuY29uc3QgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSA9ICdcXFxcdTFhYjAtXFxcXHUxYWZmJztcbmNvbnN0IHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZSA9ICdcXFxcdTFkYzAtXFxcXHUxZGZmJztcbmNvbnN0IHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArIHJzQ29tYm9NYXJrc0V4dGVuZGVkUmFuZ2UgKyByc0NvbWJvTWFya3NTdXBwbGVtZW50UmFuZ2U7XG5jb25zdCByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJztcbmNvbnN0IHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnO1xuY29uc3QgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JztcbmNvbnN0IHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZic7XG5jb25zdCByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2Zic7XG5jb25zdCByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnO1xuY29uc3QgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZSc7XG5jb25zdCByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5jb25zdCByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbmNvbnN0IHJzQXBvcyA9ICdbXFwnXFx1MjAxOV0nO1xuY29uc3QgcnNCcmVhayA9IGBbJHtyc0JyZWFrUmFuZ2V9XWA7XG5jb25zdCByc0NvbWJvID0gYFske3JzQ29tYm9SYW5nZX1dYDtcbmNvbnN0IHJzRGlnaXQgPSAnXFxcXGQnO1xuY29uc3QgcnNEaW5nYmF0ID0gYFske3JzRGluZ2JhdFJhbmdlfV1gO1xuY29uc3QgcnNMb3dlciA9IGBbJHtyc0xvd2VyUmFuZ2V9XWA7XG5jb25zdCByc01pc2MgPSBgW14ke3JzQXN0cmFsUmFuZ2V9JHtyc0JyZWFrUmFuZ2UgKyByc0RpZ2l0ICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2V9XWA7XG5jb25zdCByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJztcbmNvbnN0IHJzTW9kaWZpZXIgPSBgKD86JHtyc0NvbWJvfXwke3JzRml0en0pYDtcbmNvbnN0IHJzTm9uQXN0cmFsID0gYFteJHtyc0FzdHJhbFJhbmdlfV1gO1xuY29uc3QgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JztcbmNvbnN0IHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJztcbmNvbnN0IHJzVXBwZXIgPSBgWyR7cnNVcHBlclJhbmdlfV1gO1xuY29uc3QgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG5jb25zdCByc01pc2NMb3dlciA9IGAoPzoke3JzTG93ZXJ9fCR7cnNNaXNjfSlgO1xuY29uc3QgcnNNaXNjVXBwZXIgPSBgKD86JHtyc1VwcGVyfXwke3JzTWlzY30pYDtcbmNvbnN0IHJzT3B0Q29udHJMb3dlciA9IGAoPzoke3JzQXBvc30oPzpkfGxsfG18cmV8c3x0fHZlKSk/YDtcbmNvbnN0IHJzT3B0Q29udHJVcHBlciA9IGAoPzoke3JzQXBvc30oPzpEfExMfE18UkV8U3xUfFZFKSk/YDtcbmNvbnN0IHJlT3B0TW9kID0gYCR7cnNNb2RpZmllcn0/YDtcbmNvbnN0IHJzT3B0VmFyID0gYFske3JzVmFyUmFuZ2V9XT9gO1xuY29uc3QgcnNPcHRKb2luID0gYCg/OiR7cnNaV0p9KD86JHtbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKX0pJHtyc09wdFZhciArIHJlT3B0TW9kfSkqYDtcbmNvbnN0IHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJztcbmNvbnN0IHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJztcbmNvbnN0IHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjtcbmNvbnN0IHJzRW1vamkgPSBgKD86JHtbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8Jyl9KSR7cnNTZXF9YDtcblxuY29uc3QgcmVVbmljb2RlV29yZHMgPSBSZWdFeHAoW1xuICAgIGAke3JzVXBwZXJ9PyR7cnNMb3dlcn0rJHtyc09wdENvbnRyTG93ZXJ9KD89JHtbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8Jyl9KWAsXG4gICAgYCR7cnNNaXNjVXBwZXJ9KyR7cnNPcHRDb250clVwcGVyfSg/PSR7W3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8Jyl9KWAsXG4gICAgYCR7cnNVcHBlcn0/JHtyc01pc2NMb3dlcn0rJHtyc09wdENvbnRyTG93ZXJ9YCxcbiAgICBgJHtyc1VwcGVyfSske3JzT3B0Q29udHJVcHBlcn1gLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICBgJHtyc0RpZ2l0fStgLFxuICAgIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG5jb25zdCBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuY29uc3QgSEFTSF9VTkRFRklORUQgPSAnX19oYXNoX3VuZGVmaW5lZF9fJztcblxuLy8gVXNlZCB0byBtYXRjaCBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXNcbmNvbnN0IHJlVHlwZWRUYWcgPSAvXlxcW29iamVjdCAoPzpGbG9hdCg/OjMyfDY0KXwoPzpJbnR8VWludCkoPzo4fDE2fDMyKXxVaW50OENsYW1wZWQpQXJyYXlcXF0kLztcblxuLy8gVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHNcbmNvbnN0IHJzQXN0cmFsID0gYFske3JzQXN0cmFsUmFuZ2V9XWA7XG5cbi8vIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXNcbmNvbnN0IHJzTm9uQXN0cmFsQ29tYm8gPSBgJHtyc05vbkFzdHJhbH0ke3JzQ29tYm99P2A7XG5jb25zdCByc1N5bWJvbCA9IGAoPzoke1tyc05vbkFzdHJhbENvbWJvLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpfSlgO1xuXG4vLyBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSlcbmNvbnN0IHJlVW5pY29kZSA9IFJlZ0V4cChgJHtyc0ZpdHp9KD89JHtyc0ZpdHp9KXwke3JzU3ltYm9sICsgcnNTZXF9YCwgJ2cnKTtcblxuY29uc3QgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLztcbmNvbnN0IHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuY29uc3QgY2hhckNvZGVPZkRvdCA9ICcuJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5jb25zdCByZVByb3BOYW1lID0gUmVnRXhwKFxuICAgIC8vIE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBkb3Qgb3IgYnJhY2tldC5cbiAgICAnW14uW1xcXFxdXSsnICsgJ3wnICtcbiAgLy8gT3IgbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIGJyYWNrZXRzLlxuICAnXFxcXFsoPzonICtcbiAgICAvLyBNYXRjaCBhIG5vbi1zdHJpbmcgZXhwcmVzc2lvbi5cbiAgICAnKFteXCJcXCddW15bXSopJyArICd8JyArXG4gICAgLy8gT3IgbWF0Y2ggc3RyaW5ncyAoc3VwcG9ydHMgZXNjYXBpbmcgY2hhcmFjdGVycykuXG4gICAgJyhbXCJcXCddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDInICtcbiAgJylcXFxcXScrICd8JyArXG4gIC8vIE9yIG1hdGNoIFwiXCIgYXMgdGhlIHNwYWNlIGJldHdlZW4gY29uc2VjdXRpdmUgZG90cyBvciBlbXB0eSBicmFja2V0cy5cbiAgJyg/PSg/OlxcXFwufFxcXFxbXFxcXF0pKD86XFxcXC58XFxcXFtcXFxcXXwkKSknXG4gICAgLCAnZycpO1xuY29uc3QgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG5jb25zdCBoYXNVbmljb2RlV29yZCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKFxuICAgIC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vXG4pO1xuXG5jb25zdCBNQVhfQVJSQVlfSU5ERVggPSA0Mjk0OTY3Mjk1IC0gMTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cblxuXG4vLyAtLSBoZWxwZXIgZnVuY3Rpb25zXG5jb25zdCBoYXNVbmljb2RlID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiByZVVuaWNvZGUudGVzdChzdHJpbmcpO1xufTtcblxuY29uc3QgdW5pY29kZVRvQXJyYXkgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufTtcblxuY29uc3QgYXNjaWlUb0FycmF5ID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufTtcblxuY29uc3Qgc3RyaW5nVG9BcnJheSA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufTtcblxuY29uc3QgdmFsdWVzID0gKG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4gb2JqZWN0W2tleV0pO1xufTtcblxuY29uc3Qga2V5cyA9IChvYmplY3QpID0+IHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IE9iamVjdC5rZXlzKE9iamVjdChvYmplY3QpKTtcbn07XG5cbmNvbnN0IGJhc2VLZXlzID0gKG9iamVjdCkgPT4ge1xuICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYXJyYXlMaWtlS2V5cyA9ICh2YWx1ZSwgaW5oZXJpdGVkKSA9PiB7XG4gICAgY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICBjb25zdCBpc0FyZyA9ICFpc0FyciAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT09IGFyZ3NUYWc7XG4gICAgY29uc3QgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc1R5cGVkQXJyYXkodmFsdWUpO1xuICAgIGNvbnN0IHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNUeXBlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoc2tpcEluZGV4ZXMgPyBsZW5ndGggOiAwKTtcbiAgICBsZXQgaW5kZXggPSBza2lwSW5kZXhlcyA/IC0xIDogbGVuZ3RoO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBgJHtpbmRleH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYXNzb2NJbmRleE9mID0gKGFycmF5LCBrZXkpID0+IHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGFycmF5O1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5jb25zdCBlcSA9ICh2YWx1ZSwgb3RoZXIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn07XG5cbmNvbnN0IGlzT2JqZWN0TGlrZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn07XG5cbmNvbnN0IGlzSXRlcmF0ZWVDYWxsID0gKHZhbHVlLCBpbmRleCwgb2JqZWN0KSA9PiB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbmRleDtcblxuICAgIGNvbnN0IGlzUG9zc2libGVJdGVyYXRlZSA9IHR5cGUgPT0gJ251bWJlcicgP1xuICAgICAgICAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpbmRleCA+IC0xICYmIGluZGV4IDwgb2JqZWN0Lmxlbmd0aCkgOlxuICAgICAgICAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpO1xuXG4gICAgaWYgKGlzUG9zc2libGVJdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufTtcblxuY29uc3QgaXNNYXAgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn07XG5cbmNvbnN0IGlzUHJvdG90eXBlID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IHByb3RvID0gKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn07XG5cbmNvbnN0IGFzc2lnblZhbHVlID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG59O1xuXG5jb25zdCBjb3B5T2JqZWN0ID0gKHNvdXJjZSwgcHJvcHMsIG9iamVjdCkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IGlzQXJyYXlMaWtlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCA+IC0xICYmIHZhbHVlLmxlbmd0aCAlIDEgPT09IDA7XG59O1xuXG5jb25zdCBpc1N5bWJvbCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PT0gc3ltYm9sVGFnKTtcbn07XG5cbmNvbnN0IGluaXRDbG9uZUFycmF5ID0gKGFycmF5KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGxldCByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY29weUFycmF5ID0gKHNvdXJjZSwgYXJyYXkpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgYXJyYXkgfHwgKGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCkpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5cbmNvbnN0IGdldFRhZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn07XG5cbmNvbnN0IGNsb25lQXJyYXlCdWZmZXIgPSAoYXJyYXlCdWZmZXIpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2xvbmVUeXBlZEFycmF5ID0gKHR5cGVkQXJyYXksIGlzRGVlcCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59O1xuXG5jb25zdCBjbG9uZVJlZ0V4cCA9IChyZWdleHApID0+e1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgL1xcdyokLy5leGVjKHJlZ2V4cCkpO1xuICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpbml0Q2xvbmVPYmplY3QgPSAob2JqZWN0KSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbn07XG5cbmNvbnN0IGdldFN5bWJvbHMgPSAob2JqZWN0KSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgcmV0dXJuIHN5bWJvbHMuZmlsdGVyKChzeW1ib2wpID0+IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpKTtcbn07XG5cbmNvbnN0IGNvcHlTeW1ib2xzID0gKHNvdXJjZSwgb2JqZWN0KSA9PiB7XG4gICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59O1xuXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICBjb25zdCBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5jb25zdCBpbml0Q2xvbmVCeVRhZyA9IChvYmplY3QsIHRhZywgaXNEZWVwKSA9PiB7XG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgc3dpdGNoKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0LCBpc0RlZXApO1xuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoK29iamVjdCk7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzpcbiAgICAgICAgY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6XG4gICAgICAgIGNhc2UgaW50MTZUYWc6XG4gICAgICAgIGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6XG4gICAgICAgIGNhc2UgdWludDhDbGFtcGVkVGFnOlxuICAgICAgICBjYXNlIHVpbnQxNlRhZzpcbiAgICAgICAgY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKG9iamVjdCk7XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqZWN0KTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yO1xuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YgPyBPYmplY3QoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwob2JqZWN0KSkgOiB7fTtcbiAgICB9XG59O1xuXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZVR5cGVkVGFnLnRlc3QoZ2V0VGFnKHZhbHVlKSk7XG59O1xuXG5jb25zdCBnZXRBbGxLZXlzID0gKG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaCguLi5nZXRTeW1ib2xzKE9iamVjdChvYmplY3QpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldFN5bWJvbHNJbiA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldEFsbEtleXNJbiA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmdldFN5bWJvbHNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0TWFwRGF0YSA9ICh7IF9fZGF0YV9fIH0sIGtleSkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBfX2RhdGFfXztcbiAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG59O1xuXG5jb25zdCBlcXVhbE9iamVjdHMgPSAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuICAgIGNvbnN0IG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpO1xuICAgIGNvbnN0IG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aDtcbiAgICBjb25zdCBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpO1xuICAgIGNvbnN0IG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGtleTtcbiAgICBsZXQgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgIGNvbnN0IG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICBsZXQgY29tcGFyZWQ7XG4gICAgbGV0IHNraXBDdG9yO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBjb25zdCBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIHN0YWNrKSlcbiAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgY29uc3Qgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYmFzZUlzRXF1YWwgPSAodmFsdWUsIG90aGVyLCBzdGFjaykgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn07XG5cbmNvbnN0IGJhc2VJc0VxdWFsRGVlcCA9IChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA9PiB7XG4gICAgbGV0IG9iaklzQXJyID0gQXJyYXkuaXNBcnJheShvYmplY3QpO1xuICAgIGNvbnN0IG90aElzQXJyID0gQXJyYXkuaXNBcnJheShvdGhlcik7XG4gICAgbGV0IG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KTtcbiAgICBsZXQgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgIGxldCBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWc7XG4gICAgY29uc3Qgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnO1xuICAgIGNvbnN0IGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBmYWxzZSwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKTtcbiAgICBjb25zdCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgIGNvbnN0IG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0O1xuICAgICAgICBjb25zdCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgc3RhY2spO1xuICAgIH1cblxuICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjayk7XG59O1xuXG5jb25zdCBlcXVhbEFycmF5cyA9IChhcnJheSwgb3RoZXIsIGNvbXBhcmVVbm9yZGVyZWQsIGVxdWFsRnVuYywgc3RhY2spID0+IHtcbiAgICBjb25zdCBpc1BhcnRpYWwgPSBmYWxzZTtcbiAgICBjb25zdCBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3Qgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICBjb25zdCBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICBjb25zdCBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGNvbnN0IHNlZW4gPSBjb21wYXJlVW5vcmRlcmVkID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICBsZXQgY29tcGFyZWQ7XG4gICAgICAgIGNvbnN0IGFyclZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBjb25zdCBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIGlmICghc29tZShvdGhlciwgKG90aFZhbHVlLCBvdGhJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHNvbWUgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGNhY2hlSGFzID0gKGNhY2hlLCBrZXkpID0+IHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59O1xuXG5jb25zdCBjb21wYXJlQXJyYXlCdWZmZXJUYWcgPSAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSwgc3RhY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBlcXVhbEJ5VGFnID0gKG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5QnVmZmVyVGFnKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheUJ1ZmZlclRhZyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IGAke290aGVyfWA7XG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgbGV0IGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuICAgICAgICAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgY29uc3Qgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCB0cnVlLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgbWFwVG9BcnJheSA9IChtYXApID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBzZXRUb0FycmF5ID0gKHNldCkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGlzS2V5ID0gKHZhbHVlLCBvYmplY3QpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufTtcblxuY29uc3Qgc3RyaW5nVG9QYXRoID0gKHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gY2hhckNvZGVPZkRvdCkge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgfVxuICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIChtYXRjaCwgZXhwcmVzc2lvbiwgcXVvdGUsIHN1YlN0cmluZykgPT4ge1xuICAgICAgICBsZXQga2V5ID0gbWF0Y2g7XG4gICAgICAgIGlmIChxdW90ZSkge1xuICAgICAgICAgICAga2V5ID0gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICBrZXkgPSBleHByZXNzaW9uLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBjYXN0UGF0aCA9IChwYXRoLCBvYmplY3QpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChgJHtwYXRofWApO1xufTtcblxuY29uc3QgZ2V0ID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGw7XG4gICAgICAgIGNvbnN0IHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlO1xuICAgICAgICBjb25zdCB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICBjb25zdCBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbDtcbiAgICAgICAgY29uc3Qgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG4gICAgICAgIGNvbnN0IG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYTtcbiAgICBjb25zdCBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhO1xuICAgIGNvbnN0IGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aDtcbiAgICBjb25zdCBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBpbmRleCA8IG9yZGVyc0xlbmd0aCA/IG9yZGVyc1tpbmRleF0gOiBudWxsO1xuICAgICAgICBjb25zdCBjbXBGbiA9IChvcmRlciAmJiB0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpID8gb3JkZXIgOiBjb21wYXJlQXNjZW5kaW5nO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjbXBGbihvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChvcmRlciAmJiB0eXBlb2Ygb3JkZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5jb25zdCBkaWZmID0gKGFycmF5LCB2YWx1ZXMpID0+IHtcbiAgICBsZXQgaW5jbHVkZXMgPSAoYXJyYXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICB9O1xuICAgIGxldCBpc0NvbW1vbiA9IHRydWU7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgIGlmICghYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IChjYWNoZSwga2V5KSA9PiBjYWNoZS5oYXMoa2V5KTtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgfVxuXG4gICAgb3V0ZXI6XG4gICAgZm9yIChsZXQga2V5IGluIGFycmF5KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5W2tleV07XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAodmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgaW50ZXJzZWN0ID0gKGFycmF5cykgPT4ge1xuICAgIGNvbnN0IGluY2x1ZGVzID0gKGFycmF5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGFycmF5LmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgfTtcbiAgICBjb25zdCBjYWNoZUhhcyA9IChjYWNoZSwga2V5KSA9PiBjYWNoZS5oYXMoa2V5KTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgY29uc3QgY2FjaGVzID0gbmV3IEFycmF5KG90aExlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBsZXQgYXJyYXk7XG4gICAgbGV0IG1heExlbmd0aCA9IEluZmluaXR5O1xuICAgIGxldCBvdGhJbmRleCA9IG90aExlbmd0aDtcblxuICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcblxuICAgICAgICBtYXhMZW5ndGggPSBNYXRoLm1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSBsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjBcbiAgICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3Qgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgIG91dGVyOlxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZClcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdG9LZXkgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBgJHt2YWx1ZX1gO1xuICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSW5maW5pdHkpID8gJy0wJyA6IHJlc3VsdDtcbn07XG5cbmNvbnN0IGJhc2VDbG9uZSA9ICh2YWx1ZSwgaXNEZWVwID0gZmFsc2UsIGlzRmxhdCA9IGZhbHNlLCBpc0Z1bGwgPSB0cnVlLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0FyciA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGNvbnN0IHRhZyA9IGdldFRhZyh2YWx1ZSk7XG5cbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIGlmICh0YWcgPT09IG9iamVjdFRhZyB8fCB0YWcgPT09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGbGF0ID9cbiAgICAgICAgICAgICAgICAgICAgY29weVN5bWJvbHNJbih2YWx1ZSwgY29weU9iamVjdCh2YWx1ZSwgT2JqZWN0LmtleXModmFsdWUpLCByZXN1bHQpKSA6XG4gICAgICAgICAgICAgICAgICAgIGNvcHlTeW1ib2xzKHZhbHVlLCBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMgfHwgIUNMT05FQUJMRV9UQUdTW3RhZ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuXG4gICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgfVxuXG4gICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChzdWJWYWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRmxhdCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChzdWJWYWx1ZSA9PiB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0ZsYXQsIGlzRnVsbCwgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgIGNvbnN0IHByb3BzID0gIGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuXG4gICAgKHByb3BzIHx8IHZhbHVlKS5mb3JFYWNoKChzdWJWYWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRmxhdCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGNvcHlTeW1ib2xzSW4gPSAoc291cmNlLCBvYmplY3QpID0+IHtcbiAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufTtcblxuY29uc3QgcGFyZW50ID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBnZXQob2JqZWN0LCBwYXRoLnNsaWNlKDAsIC0xKSk7XG59O1xuXG5jb25zdCBzZXQgPSAob2JqZWN0LCBwYXRoLCB2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBpc0luZGV4ID0gKHZhbHVlLCBsZW5ndGgpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgKHR5cGUgIT09ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufTtcblxuY29uc3QgdW5zZXQgPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdFNlZ21lbnQpXTtcbn07XG5cbmNvbnN0IGlzS2V5YWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnc3ltYm9sJyB8fCB0eXBlID09PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xufTtcblxuY29uc3Qga2V5c0luID0gKG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdG9QbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIHZhbHVlID0gT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBzYWZlR2V0ID0gKG9iamVjdCwga2V5KSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyLCBpc01lcmdlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gKG9iamVjdCwgLi4uc291cmNlcykgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgICBsZXQgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgICAgOiBpc01lcmdlID8gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cblxuY29uc3QgYmFzZU1lcmdlID0gKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spID0+IHtcbiAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvckluKHNvdXJjZSwgKHNyY1ZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc3JjVmFsdWUsIGAke2tleX1gLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwga2V5c0luKTtcbn07XG5cbmNvbnN0IGJhc2VNZXJnZURlZXAgPSAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spID0+IHtcbiAgICBjb25zdCBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgYCR7a2V5fWAsIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIGNvbnN0IGlzQXJyID0gQXJyYXkuaXNBcnJheShzcmNWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGlzVHlwZWQgPSAhaXNBcnIgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNUeXBlZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0TGlrZShvYmpWYWx1ZSkgJiYgaXNBcnJheUxpa2Uob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmpWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgfVxuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn07XG5cbmNvbnN0IGFzc2lnbk1lcmdlVmFsdWUgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICBjb25zdCBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpO1xuICAgIGNvbnN0IHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IHByb3BzO1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BzWysraW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG5jb25zdCBiYXNlRm9yT3duID0gKG9iamVjdCwgaXRlcmF0ZWUpID0+IHtcbiAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59O1xuXG5jb25zdCBiYXNlRWFjaCA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VGb3JPd24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICBjb25zdCBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IGNyZWF0ZVNldCA9IChTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoW3VuZGVmaW5lZCwtMF0pKVsxXSkgPT0gMSAvIDApXG4gICAgPyAodmFsdWVzKSA9PiBuZXcgU2V0KHZhbHVlcylcbiAgICA6ICgpID0+IHt9O1xuXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMubWFwKChpdGVyYXRlZSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbKHZhbHVlKSA9PiB2YWx1ZV07XG4gICAgfVxuXG4gICAgbGV0IGNyaXRlcmlhSW5kZXggPSAtMTtcbiAgICBsZXQgZWFjaEluZGV4ID0gLTE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IG5ldyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGl0ZXJhdGVlcy5tYXAoKGl0ZXJhdGVlKSA9PiBpdGVyYXRlZSh2YWx1ZSkpO1xuXG4gICAgICAgIHJlc3VsdFsrK2VhY2hJbmRleF0gPSB7XG4gICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgIGluZGV4OiArK2NyaXRlcmlhSW5kZXgsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCAob2JqZWN0LCBvdGhlcikgPT4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykpO1xufVxuXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gYXJyYXk7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgcmV0dXJuIChvYmplY3QpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gKG9iamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgY29uc3QgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgfVxuICAgIHJldHVybiAob2JqZWN0KSA9PiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGtleXMob2JqZWN0KTtcbiAgICBsZXQgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjb25zdCBrZXkgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IGluZGV4O1xuICAgIGNvbnN0IG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGNvbnN0IGtleSA9IGRhdGFbMF07XG4gICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGNvbnN0IHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gKG9iamVjdCkgPT4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgcmV0dXJuIChvYmplY3QpID0+IGdldChvYmplY3QsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4gdmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBiYXNlSXRlcmF0ZWU7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xufVxuXG5jb25zdCBhcnJheVJlZHVjZSA9IChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufTtcblxuY29uc3QgYmFzZVJlZHVjZSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpID0+IHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn07XG5cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICBjb25zdCBmdW5jID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZTtcbiAgICBjb25zdCBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5jb25zdCBpc0ZsYXR0ZW5hYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHZhbHVlICYmIHZhbHVlW1N5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVdKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc0FyZ3VtZW50cyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5jb25zdCBiYXNlUGljayA9IChvYmplY3QsIHBhdGhzKSA9PiB7XG4gICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgKHZhbHVlLCBwYXRoKSA9PiBoYXNJbihvYmplY3QsIHBhdGgpKTtcbn07XG5cbmNvbnN0IGJhc2VQaWNrQnkgPSAob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2luZGV4XTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICAgIHNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgaXNMZW5ndGggPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59O1xuXG5jb25zdCBiYXNlSGFzSW4gPSAob2JqZWN0LCBrZXkpID0+e1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59O1xuXG5jb25zdCBoYXNQYXRoID0gKG9iamVjdCwgcGF0aCwgaGFzRnVuYykgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufTtcblxuY29uc3QgYXNjaWlXb3JkcyA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKTtcbn07XG5cbmNvbnN0IHVuaWNvZGVXb3JkcyA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmRzKTtcbn07XG5cbmNvbnN0IHdvcmRzID0gKHN0cmluZywgcGF0dGVybikgPT4ge1xuICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufTtcblxuY29uc3QgY2FzdFNsaWNlID0gKGFycmF5LCBzdGFydCwgZW5kKSA9PiB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFycmF5O1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBhcnJheS5zbGljZShzdGFydCwgZW5kKTtcbn07XG5cbmNvbnN0IHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIChzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICAgIDogc3RyaW5nWzBdO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgIH07XG59XG5cbi8vIC0tIGhlbHBlciBjbGFzc2VzXG5jbGFzcyBTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIExpc3RDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGEucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLS10aGlzLnNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgTWFwQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgICAgICdtYXAnOiBuZXcgTWFwLFxuICAgICAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9fZGF0YV9fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBTZXRDYWNoZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG59XG5cblNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gU2V0Q2FjaGUucHJvdG90eXBlLmFkZDtcblxuLy8gLS0gdG9wIGxldmVsIGZ1bmN0aW9uc1xuXG5leHBvcnQgY29uc3QgaXNCb29sZWFuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYm9vbFRhZyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gbnVtYmVyVGFnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAoISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdUYWcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKChvYmplY3QsIHNvdXJjZSkgPT4ge1xuICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgbWl4aW4gPSBhc3NpZ247XG5cbmV4cG9ydCBjb25zdCBkZWVwTWl4aW4gPSBtaXhpbjtcblxuZXhwb3J0IGNvbnN0IHN1cHBsZW1lbnQgPSAob2JqZWN0LCAuLi5zb3VyY2VzKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGNvbnN0IGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgY29uc3QgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGxldCBwcm9wc0luZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKGVxKHZhbHVlLCBPYmplY3QucHJvdG90eXBlW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IHN1cHBsZW1lbnQ7XG5cbmV4cG9ydCBjb25zdCBkZWVwU3VwcGxlbWVudCA9IGZ1bmN0aW9uIGRlZmF1bHRzRGVlcCguLi5hcmdzKSB7XG4gICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgcmV0dXJuIG1lcmdlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdHNEZWVwID0gZGVlcFN1cHBsZW1lbnQ7XG5cbi8vIF8uaW52b2tlTWFwXG5leHBvcnQgY29uc3QgaW52b2tlID0gKGNvbGxlY3Rpb24sIHBhdGgsIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IG5ldyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBwYXRoLmFwcGx5KHZhbHVlLCBhcmdzKSA6IGludm9rZVByb3BlcnR5KHZhbHVlLCBwYXRoLCAuLi5hcmdzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBfLmludm9rZVxuZXhwb3J0IGNvbnN0IGludm9rZVByb3BlcnR5ID0gKG9iamVjdCwgcGF0aCwgLi4uYXJncykgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgIGNvbnN0IGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzb3J0ZWRJbmRleCA9IChhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSA9PiB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaGlnaCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgY29uc3QgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgY29uc3QgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGw7XG4gICAgY29uc3QgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG4gICAgY29uc3QgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgbGV0IHNldExvdztcbiAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKTtcbiAgICAgICAgY29uc3Qgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGw7XG4gICAgICAgIGNvbnN0IG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkO1xuICAgICAgICBjb25zdCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJm90aElzRGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldExvdyA9IGNvbXB1dGVkIDwgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5pcSA9IChhcnJheSwgaXRlcmF0ZWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgaW5jbHVkZXMgPSAoYXJyYXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICB9O1xuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuICAgIGxldCBpc0NvbW1vbiA9IHRydWU7XG5cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXJyYXk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHNlZW4gPSByZXN1bHQ7XG5cbiAgICBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IChjYWNoZSwga2V5KSA9PiBjYWNoZS5oYXMoa2V5KTtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICB9XG4gICAgb3V0ZXI6XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAodmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBsZXQgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgY2xvbmUgPSAodmFsdWUpID0+IGJhc2VDbG9uZSh2YWx1ZSk7XG5cbmV4cG9ydCBjb25zdCBjbG9uZURlZXAgPSAodmFsdWUpID0+IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSk7XG5cbmV4cG9ydCBjb25zdCBpc0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgIGlmICh0YWcgPT0gJ1tvYmplY3QgTWFwXScgfHwgdGFnID09ICdbb2JqZWN0IFNldF0nKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSAob2JqZWN0LCBvdGhlcikgPT4gYmFzZUlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGdldFRhZyh2YWx1ZSkgIT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG59O1xuXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgIGNvbnN0IGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0KSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBsZXQgbGFzdEFyZ3M7XG4gICAgbGV0IGxhc3RUaGlzO1xuICAgIGxldCBtYXhXYWl0O1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHRpbWVySWQ7XG4gICAgbGV0IGxhc3RDYWxsVGltZTtcbiAgICBsZXQgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxldCBsZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IG1heGluZyA9IGZhbHNlO1xuICAgIGxldCB0cmFpbGluZyA9IHRydWU7XG5cbiAgICBjb25zdCB1c2VSYWYgPSAoIXdhaXQgJiYgd2FpdCAhPT0gMCAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpO1xuXG4gICAgd2FpdCA9ICt3YWl0IHx8IDA7XG5cbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHQubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdDtcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IE1hdGgubWF4KCtvcHQubWF4V2FpdCB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHQgPyAhIW9wdC50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gbGFzdEFyZ3M7XG4gICAgICAgIGNvbnN0IHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lcihwZW5kaW5nRnVuYywgd2FpdCkge1xuICAgICAgICBpZiAodXNlUmFmKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGltZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShwZW5kaW5nRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocGVuZGluZ0Z1bmMsIHdhaXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbmNlbFRpbWVyKGlkKSB7XG4gICAgICAgIGlmICh1c2VSYWYpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHRpbWVySWQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lO1xuICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuICAgICAgICBjb25zdCB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nID8gTWF0aC5taW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHRpbWVXYWl0aW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fCAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fFxuICAgICAgICAgICAgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVySWQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVib3VuY2VkKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICB0aW1lcklkID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXJJZCA9IHN0YXJ0VGltZXIodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbFRpbWVyKHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSAoKSA9PiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2UoRGF0ZS5ub3coKSk7XG4gICAgZGVib3VuY2VkLnBlbmRpbmcgPSAoKSA9PiB0aW1lcklkICE9PSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBCeSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuXG4gICAgcmV0dXJuIHJlZHVjZShjb2xsZWN0aW9uLCAocmVzdWx0LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGtleSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBzb3J0QnkgPSAoY29sbGVjdGlvbiwgaXRlcmF0ZWVzID0gW10pID0+IHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2dldEl0ZXJhdGVlKGl0ZXJhdGVlcywgMildO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMuZmxhdCgxKSwgW10pO1xufTtcblxuZXhwb3J0IGNvbnN0IGZsYXR0ZW5EZWVwID0gKGFycmF5KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJbmZpbml0eSkgOiBbXTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aXRob3V0ID0gKGFycmF5LCAuLi52YWx1ZXMpID0+IGlzQXJyYXlMaWtlKGFycmF5KSA/IGRpZmYoYXJyYXksIHZhbHVlcykgOiBbXTtcblxuZXhwb3J0IGNvbnN0IGRpZmZlcmVuY2UgPSAoYXJyYXksIC4uLnZhbHVlcykgPT5cbiAgICBpc09iamVjdExpa2UoYXJyYXkpICYmIGlzQXJyYXlMaWtlKGFycmF5KSA/XG4gICAgICAgIGRpZmYoYXJyYXksIHZhbHVlcy5mbGF0KDEpKSA6IFtdO1xuXG5leHBvcnQgY29uc3QgaW50ZXJzZWN0aW9uID0gKC4uLmFycmF5cykgPT4ge1xuICAgIGNvbnN0IG1hcHBlZCA9IGFycmF5cy5tYXAoKGFycmF5KSA9PlxuICAgICAgICBpc09iamVjdExpa2UoYXJyYXkpICYmIGlzQXJyYXlMaWtlKGFycmF5KSA/XG4gICAgICAgICAgICBhcnJheSA6IFtdXG4gICAgKTtcblxuICAgIHJldHVybiBtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdID9cbiAgICAgICAgaW50ZXJzZWN0KG1hcHBlZCkgOiBbXTtcbn07XG5cbmV4cG9ydCBjb25zdCB1bmlvbiA9ICguLi5hcnJheXMpID0+IHtcbiAgICBjb25zdCBhcnJheSA9IGFycmF5cy5mbGF0KDEpO1xuICAgIHJldHVybiB1bmlxKGFycmF5KTtcbn07XG5cbmV4cG9ydCBjb25zdCBoYXMgPSAob2JqZWN0LCBrZXkpID0+IHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBrZXkgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgdmFsdWUgPSBvYmplY3Q7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGtleS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5W2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlW2tleVtpbmRleF1dO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlc3VsdCA9IChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBvbWl0ID0gKG9iamVjdCwgLi4ucGF0aHMpID0+IHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBpc0RlZXAgPSBmYWxzZTtcbiAgICBwYXRocyA9IHBhdGhzLmZsYXQoMSkubWFwKChwYXRoKSA9PiB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0pO1xuICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIHRydWUsIHRydWUsIHRydWUsICh2YWx1ZSkgPT4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZSk7XG4gICAgfVxuICAgIGxldCBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgcGljayA9IChvYmplY3QsIC4uLnBhdGhzKSA9PiB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzLmZsYXQoSW5maW5pdHkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaW5kQWxsID0gKG9iamVjdCwgLi4ubWV0aG9kTmFtZXMpID0+IHtcbiAgICBtZXRob2ROYW1lcy5mbGF0KDEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgb2JqZWN0W2tleV0uYmluZChvYmplY3QpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IGZvckluID0gKG9iamVjdCwgaXRlcmF0ZWUgPSAodmFsdWUpID0+IHZhbHVlKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KTtcbiAgICBjb25zdCBwcm9wcyA9IGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBrZXlzSW4ob2JqZWN0KTtcbiAgICBsZXQgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNbKytpbmRleF07XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNhbWVsQ2FzZSA9IChzdHJpbmcgPSAnJykgPT4gKFxuICAgIHdvcmRzKGAke3N0cmluZ31gLnJlcGxhY2UoL1snXFx1MjAxOV0vZywgJycpKVxuICAgICAgICAucmVkdWNlKChyZXN1bHQsIHdvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IHVwcGVyRmlyc3Qod29yZCkgOiB3b3JkKTtcbiAgICAgICAgfSwgJycpXG4pO1xuXG5sZXQgaWRDb3VudGVyID0gMDtcblxuZXhwb3J0IGNvbnN0IHVuaXF1ZUlkID0gKHByZWZpeCA9ICcnKSA9PiB7XG4gICAgY29uc3QgaWQgPSArK2lkQ291bnRlcjtcbiAgICByZXR1cm4gYCR7cHJlZml4fWAgKyBpZDtcbn07XG5cbmV4cG9ydCBjb25zdCBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKChvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpID0+IHtcbiAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0sIHRydWUpO1xuIl0sIm5hbWVzIjpbImFyZ3NUYWciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwibnVsbFRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsInVuZGVmaW5lZFRhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwiQ0xPTkVBQkxFX1RBR1MiLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSIsInJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZSIsInJzQ29tYm9SYW5nZSIsInJzRGluZ2JhdFJhbmdlIiwicnNMb3dlclJhbmdlIiwicnNNYXRoT3BSYW5nZSIsInJzTm9uQ2hhclJhbmdlIiwicnNQdW5jdHVhdGlvblJhbmdlIiwicnNTcGFjZVJhbmdlIiwicnNVcHBlclJhbmdlIiwicnNWYXJSYW5nZSIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyIsInJzQnJlYWsiLCJyc0NvbWJvIiwicnNEaWdpdCIsInJzRGluZ2JhdCIsInJzTG93ZXIiLCJyc01pc2MiLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJzVXBwZXIiLCJyc1pXSiIsInJzTWlzY0xvd2VyIiwicnNNaXNjVXBwZXIiLCJyc09wdENvbnRyTG93ZXIiLCJyc09wdENvbnRyVXBwZXIiLCJyZU9wdE1vZCIsInJzT3B0VmFyIiwicnNPcHRKb2luIiwiam9pbiIsInJzT3JkTG93ZXIiLCJyc09yZFVwcGVyIiwicnNTZXEiLCJyc0Vtb2ppIiwicmVVbmljb2RlV29yZHMiLCJSZWdFeHAiLCJMQVJHRV9BUlJBWV9TSVpFIiwiSEFTSF9VTkRFRklORUQiLCJyZVR5cGVkVGFnIiwicnNBc3RyYWwiLCJyc05vbkFzdHJhbENvbWJvIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiY2hhckNvZGVPZkRvdCIsImNoYXJDb2RlQXQiLCJyZUVzY2FwZUNoYXIiLCJyZVByb3BOYW1lIiwicmVJc1VpbnQiLCJoYXNVbmljb2RlV29yZCIsInByb3RvdHlwZSIsInRlc3QiLCJiaW5kIiwiTUFYX0FSUkFZX0lOREVYIiwicmVBc2NpaVdvcmQiLCJoYXNVbmljb2RlIiwic3RyaW5nIiwidW5pY29kZVRvQXJyYXkiLCJtYXRjaCIsImFzY2lpVG9BcnJheSIsInNwbGl0Iiwic3RyaW5nVG9BcnJheSIsInZhbHVlcyIsIm9iamVjdCIsImtleXMiLCJtYXAiLCJrZXkiLCJpc0FycmF5TGlrZSIsImFycmF5TGlrZUtleXMiLCJPYmplY3QiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwicmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHVzaCIsInZhbHVlIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJpc0FyZyIsImlzT2JqZWN0TGlrZSIsImdldFRhZyIsImlzVHlwZSIsImlzVHlwZWRBcnJheSIsInNraXBJbmRleGVzIiwibGVuZ3RoIiwiaW5kZXgiLCJpc0luZGV4IiwiYXNzb2NJbmRleE9mIiwiYXJyYXkiLCJlcSIsIm90aGVyIiwiaXNJdGVyYXRlZUNhbGwiLCJpc09iamVjdCIsInR5cGUiLCJpc1Bvc3NpYmxlSXRlcmF0ZWUiLCJpc1NldCIsImlzTWFwIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwidW5kZWZpbmVkIiwiY29weU9iamVjdCIsInNvdXJjZSIsInByb3BzIiwiaXNTeW1ib2wiLCJpbml0Q2xvbmVBcnJheSIsImlucHV0IiwiY29weUFycmF5IiwidG9TdHJpbmciLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiVWludDhBcnJheSIsInNldCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJpc0RlZXAiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJleGVjIiwibGFzdEluZGV4IiwiaW5pdENsb25lT2JqZWN0IiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRTeW1ib2xzIiwic3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bWJvbCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY29weVN5bWJvbHMiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJpbml0Q2xvbmVCeVRhZyIsInRhZyIsIkNvbnN0cnVjdG9yIiwiU3ltYm9sIiwidmFsdWVPZiIsImdldEFsbEtleXMiLCJnZXRTeW1ib2xzSW4iLCJnZXRBbGxLZXlzSW4iLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJkYXRhIiwiaXNLZXlhYmxlIiwiZXF1YWxPYmplY3RzIiwiZXF1YWxGdW5jIiwic3RhY2siLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib3RoTGVuZ3RoIiwib2JqU3RhY2tlZCIsImdldCIsIm90aFN0YWNrZWQiLCJjb21wYXJlZCIsInNraXBDdG9yIiwib3RoVmFsdWUiLCJvYmpDdG9yIiwib3RoQ3RvciIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJTdGFjayIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImNvbXBhcmVVbm9yZGVyZWQiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJhcnJTdGFja2VkIiwic2VlbiIsIlNldENhY2hlIiwiYXJyVmFsdWUiLCJzb21lIiwib3RoSW5kZXgiLCJjYWNoZUhhcyIsInByZWRpY2F0ZSIsImNhY2hlIiwiaGFzIiwiY29tcGFyZUFycmF5QnVmZmVyVGFnIiwibmFtZSIsIm1lc3NhZ2UiLCJjb252ZXJ0IiwibWFwVG9BcnJheSIsInNldFRvQXJyYXkiLCJzaXplIiwic3RhY2tlZCIsImZvckVhY2giLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInJlcGxhY2UiLCJleHByZXNzaW9uIiwicXVvdGUiLCJzdWJTdHJpbmciLCJ0cmltIiwiY2FzdFBhdGgiLCJwYXRoIiwidG9LZXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNOdWxsIiwidmFsSXNSZWZsZXhpdmUiLCJ2YWxJc1N5bWJvbCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJjb21wYXJlTXVsdGlwbGUiLCJvcmRlcnMiLCJvYmpDcml0ZXJpYSIsImNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsImNtcEZuIiwiZGlmZiIsImluY2x1ZGVzIiwiaW5kZXhPZiIsImlzQ29tbW9uIiwidmFsdWVzTGVuZ3RoIiwib3V0ZXIiLCJjb21wdXRlZCIsInZhbHVlc0luZGV4IiwiaW50ZXJzZWN0IiwiYXJyYXlzIiwiY2FjaGVzIiwibWF4TGVuZ3RoIiwiSW5maW5pdHkiLCJNYXRoIiwibWluIiwiYmFzZUNsb25lIiwiaXNGbGF0IiwiaXNGdWxsIiwiY3VzdG9taXplciIsImlzRnVuYyIsImNvcHlTeW1ib2xzSW4iLCJhc3NpZ24iLCJzdWJWYWx1ZSIsImFkZCIsImtleXNGdW5jIiwia2V5c0luIiwicGFyZW50Iiwic2xpY2UiLCJuZXN0ZWQiLCJuZXdWYWx1ZSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ1bnNldCIsImxhc3RTZWdtZW50IiwidG9QbGFpbk9iamVjdCIsInNhZmVHZXQiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwiaXNNZXJnZSIsInNvdXJjZXMiLCJndWFyZCIsImEiLCJiIiwiYmFzZU1lcmdlIiwic3JjSW5kZXgiLCJmb3JJbiIsInNyY1ZhbHVlIiwiYmFzZU1lcmdlRGVlcCIsImFzc2lnbk1lcmdlVmFsdWUiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNQbGFpbk9iamVjdCIsImlzQXJndW1lbnRzIiwiYmFzZUZvciIsIml0ZXJhdGVlIiwiaXRlcmFibGUiLCJiYXNlRm9yT3duIiwiYmFzZUVhY2giLCJjb2xsZWN0aW9uIiwibGFzdCIsImNyZWF0ZVNldCIsIlNldCIsImN1c3RvbURlZmF1bHRzTWVyZ2UiLCJiYXNlT3JkZXJCeSIsIml0ZXJhdGVlcyIsImNyaXRlcmlhSW5kZXgiLCJlYWNoSW5kZXgiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJoYXNJbiIsImhhc1BhdGgiLCJiYXNlSGFzSW4iLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJtYXRjaERhdGEiLCJnZXRNYXRjaERhdGEiLCJiYXNlSXNNYXRjaCIsIm5vQ3VzdG9taXplciIsInByb3BlcnR5IiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VJdGVyYXRlZSIsInZhbCIsImdldEl0ZXJhdGVlIiwiYXJndW1lbnRzIiwiYXJyYXlSZWR1Y2UiLCJhY2N1bXVsYXRvciIsImluaXRBY2N1bSIsImJhc2VSZWR1Y2UiLCJlYWNoRnVuYyIsInJlZHVjZSIsImZ1bmMiLCJpc0ZsYXR0ZW5hYmxlIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiYmFzZVBpY2siLCJwYXRocyIsImJhc2VQaWNrQnkiLCJpc0xlbmd0aCIsImhhc0Z1bmMiLCJhc2NpaVdvcmRzIiwidW5pY29kZVdvcmRzIiwid29yZHMiLCJwYXR0ZXJuIiwiY2FzdFNsaWNlIiwic3RhcnQiLCJlbmQiLCJ1cHBlckZpcnN0IiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsInN0clN5bWJvbHMiLCJjaHIiLCJ0cmFpbGluZyIsImVudHJpZXMiLCJMaXN0Q2FjaGUiLCJjbGVhciIsImRlbGV0ZSIsInBhaXJzIiwiTWFwQ2FjaGUiLCJlbnRyeSIsInBvcCIsInNwbGljZSIsIkhhc2giLCJNYXAiLCJpc0Jvb2xlYW4iLCJpc051bWJlciIsImlzU3RyaW5nIiwibWl4aW4iLCJkZWVwTWl4aW4iLCJzdXBwbGVtZW50IiwicHJvcHNMZW5ndGgiLCJwcm9wc0luZGV4IiwiZGVmYXVsdHMiLCJkZWVwU3VwcGxlbWVudCIsImRlZmF1bHRzRGVlcCIsImFyZ3MiLCJtZXJnZSIsImFwcGx5IiwiaW52b2tlIiwiaW52b2tlUHJvcGVydHkiLCJzb3J0ZWRJbmRleCIsImxvdyIsImhpZ2giLCJ2YWxJc05hTiIsInZhbElzVW5kZWZpbmVkIiwic2V0TG93IiwibWlkIiwiZmxvb3IiLCJ1bmlxIiwic2VlbkluZGV4IiwiY2xvbmUiLCJjbG9uZURlZXAiLCJpc0VtcHR5IiwiaXNFcXVhbCIsImlzRnVuY3Rpb24iLCJ0b0FycmF5IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsImRlYm91bmNlIiwid2FpdCIsIm9wdCIsIlR5cGVFcnJvciIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsInVzZVJhZiIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1heCIsImludm9rZUZ1bmMiLCJ0aW1lIiwidGhpc0FyZyIsInN0YXJ0VGltZXIiLCJwZW5kaW5nRnVuYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImNhbmNlbFRpbWVyIiwiaWQiLCJjbGVhclRpbWVvdXQiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsIkRhdGUiLCJub3ciLCJ0cmFpbGluZ0VkZ2UiLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiY2FuY2VsIiwiZmx1c2giLCJwZW5kaW5nIiwiZ3JvdXBCeSIsInNvcnRCeSIsImZsYXQiLCJmbGF0dGVuRGVlcCIsIndpdGhvdXQiLCJkaWZmZXJlbmNlIiwiaW50ZXJzZWN0aW9uIiwibWFwcGVkIiwidW5pb24iLCJkZWZhdWx0VmFsdWUiLCJvbWl0IiwicGljayIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNhbWVsQ2FzZSIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImlkQ291bnRlciIsInVuaXF1ZUlkIiwicHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jointjs/src/util/wrappers.mjs":
/*!****************************************************!*\
  !*** ./node_modules/jointjs/src/util/wrappers.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrapWith: () => (/* binding */ wrapWith),\n/* harmony export */   wrappers: () => (/* binding */ wrappers)\n/* harmony export */ });\n/* harmony import */ var _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/Cell.mjs */ \"(ssr)/./node_modules/jointjs/src/dia/Cell.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(ssr)/./node_modules/jointjs/src/util/utilHelpers.mjs\");\n\n\nconst wrapWith = function(object, methods, wrapper) {\n    if ((0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(wrapper)) {\n        if (!wrappers[wrapper]) {\n            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n        }\n        wrapper = wrappers[wrapper];\n    }\n    if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(wrapper)) {\n        throw new Error(\"Wrapper must be a function.\");\n    }\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(methods).forEach(function(method) {\n        object[method] = wrapper(object[method]);\n    });\n};\nconst wrappers = {\n    cells: function(fn) {\n        return function() {\n            var args = Array.from(arguments);\n            var n = args.length;\n            var cells = n > 0 && args[0] || [];\n            var opt = n > 1 && args[n - 1] || {};\n            if (!Array.isArray(cells)) {\n                if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    cells = args;\n                } else if (cells instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    if (args.length > 1) {\n                        args.pop();\n                    }\n                    cells = args;\n                }\n            }\n            if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                opt = {};\n            }\n            return fn.call(this, cells, opt);\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam9pbnRqcy9zcmMvdXRpbC93cmFwcGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUNvQjtBQUVwRCxNQUFNSSxXQUFXLFNBQVNDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBRXJELElBQUlMLG1EQUFRQSxDQUFDSyxVQUFVO1FBRW5CLElBQUksQ0FBQ0MsUUFBUSxDQUFDRCxRQUFRLEVBQUU7WUFDcEIsTUFBTSxJQUFJRSxNQUFNLHVCQUF1QkYsVUFBVTtRQUNyRDtRQUVBQSxVQUFVQyxRQUFRLENBQUNELFFBQVE7SUFDL0I7SUFFQSxJQUFJLENBQUNOLHFEQUFVQSxDQUFDTSxVQUFVO1FBQ3RCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUVBTixrREFBT0EsQ0FBQ0csU0FBU0ksT0FBTyxDQUFDLFNBQVNDLE1BQU07UUFDcENOLE1BQU0sQ0FBQ00sT0FBTyxHQUFHSixRQUFRRixNQUFNLENBQUNNLE9BQU87SUFDM0M7QUFDSixFQUFFO0FBRUssTUFBTUgsV0FBVztJQUVwQkksT0FBTyxTQUFTQyxFQUFFO1FBRWQsT0FBTztZQUVILElBQUlDLE9BQU9DLE1BQU1DLElBQUksQ0FBQ0M7WUFDdEIsSUFBSUMsSUFBSUosS0FBS0ssTUFBTTtZQUNuQixJQUFJUCxRQUFRTSxJQUFJLEtBQUtKLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRTtZQUNsQyxJQUFJTSxNQUFNRixJQUFJLEtBQUtKLElBQUksQ0FBQ0ksSUFBSSxFQUFFLElBQUksQ0FBQztZQUVuQyxJQUFJLENBQUNILE1BQU1NLE9BQU8sQ0FBQ1QsUUFBUTtnQkFFdkIsSUFBSVEsZUFBZXBCLCtDQUFJQSxFQUFFO29CQUNyQlksUUFBUUU7Z0JBQ1osT0FBTyxJQUFJRixpQkFBaUJaLCtDQUFJQSxFQUFFO29CQUM5QixJQUFJYyxLQUFLSyxNQUFNLEdBQUcsR0FBRzt3QkFDakJMLEtBQUtRLEdBQUc7b0JBQ1o7b0JBQ0FWLFFBQVFFO2dCQUNaO1lBQ0o7WUFFQSxJQUFJTSxlQUFlcEIsK0NBQUlBLEVBQUU7Z0JBQ3JCb0IsTUFBTSxDQUFDO1lBQ1g7WUFFQSxPQUFPUCxHQUFHVSxJQUFJLENBQUMsSUFBSSxFQUFFWCxPQUFPUTtRQUNoQztJQUNKO0FBRUosRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2pvaW50anMvc3JjL3V0aWwvd3JhcHBlcnMubWpzPzdiMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4uL2RpYS9DZWxsLm1qcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZywgdG9BcnJheSB9IGZyb20gJy4vdXRpbC5tanMnO1xuXG5leHBvcnQgY29uc3Qgd3JhcFdpdGggPSBmdW5jdGlvbihvYmplY3QsIG1ldGhvZHMsIHdyYXBwZXIpIHtcblxuICAgIGlmIChpc1N0cmluZyh3cmFwcGVyKSkge1xuXG4gICAgICAgIGlmICghd3JhcHBlcnNbd3JhcHBlcl0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB3cmFwcGVyOiBcIicgKyB3cmFwcGVyICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyID0gd3JhcHBlcnNbd3JhcHBlcl07XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHdyYXBwZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JhcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdG9BcnJheShtZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBvYmplY3RbbWV0aG9kXSA9IHdyYXBwZXIob2JqZWN0W21ldGhvZF0pO1xuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHdyYXBwZXJzID0ge1xuXG4gICAgY2VsbHM6IGZ1bmN0aW9uKGZuKSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBuID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBuID4gMCAmJiBhcmdzWzBdIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG9wdCA9IG4gPiAxICYmIGFyZ3NbbiAtIDFdIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2VsbHMpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0IGluc3RhbmNlb2YgQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjZWxscyBpbnN0YW5jZW9mIENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0IGluc3RhbmNlb2YgQ2VsbCkge1xuICAgICAgICAgICAgICAgIG9wdCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBjZWxscywgb3B0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn07XG5cbiJdLCJuYW1lcyI6WyJDZWxsIiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwidG9BcnJheSIsIndyYXBXaXRoIiwib2JqZWN0IiwibWV0aG9kcyIsIndyYXBwZXIiLCJ3cmFwcGVycyIsIkVycm9yIiwiZm9yRWFjaCIsIm1ldGhvZCIsImNlbGxzIiwiZm4iLCJhcmdzIiwiQXJyYXkiLCJmcm9tIiwiYXJndW1lbnRzIiwibiIsImxlbmd0aCIsIm9wdCIsImlzQXJyYXkiLCJwb3AiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jointjs/src/util/wrappers.mjs\n");

/***/ })

};
;