/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/backbone";
exports.ids = ["vendor-chunks/backbone"];
exports.modules = {

/***/ "(ssr)/./node_modules/backbone/backbone.js":
/*!*******************************************!*\
  !*** ./node_modules/backbone/backbone.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.4.1\n//     (c) 2010-2022 Jeremy Ashkenas and DocumentCloud\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n(function(factory) {\n    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\n    // We use `self` instead of `window` for `WebWorker` support.\n    var root = typeof self == \"object\" && self.self === self && self || typeof global == \"object\" && global.global === global && global;\n    // Set up Backbone appropriately for the environment. Start with AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! underscore */ \"(ssr)/./node_modules/underscore/modules/index-all.js\"),\n            __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"),\n            exports\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(_, $, exports1) {\n            // Export global even in AMD case in case this script is loaded with\n            // others that may still expect a global Backbone.\n            root.Backbone = factory(root, exports1, _, $);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n    } else { var _, $; }\n})(function(root, Backbone, _, $) {\n    // Initial Setup\n    // -------------\n    // Save the previous value of the `Backbone` variable, so that it can be\n    // restored later on, if `noConflict` is used.\n    var previousBackbone = root.Backbone;\n    // Create a local reference to a common array method we'll want to use later.\n    var slice = Array.prototype.slice;\n    // Current version of the library. Keep in sync with `package.json`.\n    Backbone.VERSION = \"1.4.1\";\n    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n    // the `$` variable.\n    Backbone.$ = $;\n    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n    // to its previous owner. Returns a reference to this Backbone object.\n    Backbone.noConflict = function() {\n        root.Backbone = previousBackbone;\n        return this;\n    };\n    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n    // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n    // set a `X-Http-Method-Override` header.\n    Backbone.emulateHTTP = false;\n    // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n    // `application/json` requests ... this will encode the body as\n    // `application/x-www-form-urlencoded` instead and will send the model in a\n    // form param named `model`.\n    Backbone.emulateJSON = false;\n    // Backbone.Events\n    // ---------------\n    // A module that can be mixed in to *any object* in order to provide it with\n    // a custom event channel. You may bind a callback to an event with `on` or\n    // remove with `off`; `trigger`-ing an event fires all callbacks in\n    // succession.\n    //\n    //     var object = {};\n    //     _.extend(object, Backbone.Events);\n    //     object.on('expand', function(){ alert('expanded'); });\n    //     object.trigger('expand');\n    //\n    var Events = Backbone.Events = {};\n    // Regular expression used to split event strings.\n    var eventSplitter = /\\s+/;\n    // A private global variable to share between listeners and listenees.\n    var _listening;\n    // Iterates over the standard `event, callback` (as well as the fancy multiple\n    // space-separated events `\"change blur\", callback` and jQuery-style event\n    // maps `{event: callback}`).\n    var eventsApi = function(iteratee, events, name, callback, opts) {\n        var i = 0, names;\n        if (name && typeof name === \"object\") {\n            // Handle event maps.\n            if (callback !== void 0 && \"context\" in opts && opts.context === void 0) opts.context = callback;\n            for(names = _.keys(name); i < names.length; i++){\n                events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n            }\n        } else if (name && eventSplitter.test(name)) {\n            // Handle space-separated event names by delegating them individually.\n            for(names = name.split(eventSplitter); i < names.length; i++){\n                events = iteratee(events, names[i], callback, opts);\n            }\n        } else {\n            // Finally, standard events.\n            events = iteratee(events, name, callback, opts);\n        }\n        return events;\n    };\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    Events.on = function(name, callback, context) {\n        this._events = eventsApi(onApi, this._events || {}, name, callback, {\n            context: context,\n            ctx: this,\n            listening: _listening\n        });\n        if (_listening) {\n            var listeners = this._listeners || (this._listeners = {});\n            listeners[_listening.id] = _listening;\n            // Allow the listening to use a counter, instead of tracking\n            // callbacks for library interop\n            _listening.interop = false;\n        }\n        return this;\n    };\n    // Inversion-of-control versions of `on`. Tell *this* object to listen to\n    // an event in another object... keeping track of what it's listening to\n    // for easier unbinding later.\n    Events.listenTo = function(obj, name, callback) {\n        if (!obj) return this;\n        var id = obj._listenId || (obj._listenId = _.uniqueId(\"l\"));\n        var listeningTo = this._listeningTo || (this._listeningTo = {});\n        var listening = _listening = listeningTo[id];\n        // This object is not listening to any other events on `obj` yet.\n        // Setup the necessary references to track the listening callbacks.\n        if (!listening) {\n            this._listenId || (this._listenId = _.uniqueId(\"l\"));\n            listening = _listening = listeningTo[id] = new Listening(this, obj);\n        }\n        // Bind callbacks on obj.\n        var error = tryCatchOn(obj, name, callback, this);\n        _listening = void 0;\n        if (error) throw error;\n        // If the target obj is not Backbone.Events, track events manually.\n        if (listening.interop) listening.on(name, callback);\n        return this;\n    };\n    // The reducing API that adds a callback to the `events` object.\n    var onApi = function(events, name, callback, options) {\n        if (callback) {\n            var handlers = events[name] || (events[name] = []);\n            var context = options.context, ctx = options.ctx, listening = options.listening;\n            if (listening) listening.count++;\n            handlers.push({\n                callback: callback,\n                context: context,\n                ctx: context || ctx,\n                listening: listening\n            });\n        }\n        return events;\n    };\n    // An try-catch guarded #on function, to prevent poisoning the global\n    // `_listening` variable.\n    var tryCatchOn = function(obj, name, callback, context) {\n        try {\n            obj.on(name, callback, context);\n        } catch (e) {\n            return e;\n        }\n    };\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    Events.off = function(name, callback, context) {\n        if (!this._events) return this;\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: context,\n            listeners: this._listeners\n        });\n        return this;\n    };\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    Events.stopListening = function(obj, name, callback) {\n        var listeningTo = this._listeningTo;\n        if (!listeningTo) return this;\n        var ids = obj ? [\n            obj._listenId\n        ] : _.keys(listeningTo);\n        for(var i = 0; i < ids.length; i++){\n            var listening = listeningTo[ids[i]];\n            // If listening doesn't exist, this object is not currently\n            // listening to obj. Break out early.\n            if (!listening) break;\n            listening.obj.off(name, callback, this);\n            if (listening.interop) listening.off(name, callback);\n        }\n        if (_.isEmpty(listeningTo)) this._listeningTo = void 0;\n        return this;\n    };\n    // The reducing API that removes a callback from the `events` object.\n    var offApi = function(events, name, callback, options) {\n        if (!events) return;\n        var context = options.context, listeners = options.listeners;\n        var i = 0, names;\n        // Delete all event listeners and \"drop\" events.\n        if (!name && !context && !callback) {\n            for(names = _.keys(listeners); i < names.length; i++){\n                listeners[names[i]].cleanup();\n            }\n            return;\n        }\n        names = name ? [\n            name\n        ] : _.keys(events);\n        for(; i < names.length; i++){\n            name = names[i];\n            var handlers = events[name];\n            // Bail out if there are no events stored.\n            if (!handlers) break;\n            // Find any remaining events.\n            var remaining = [];\n            for(var j = 0; j < handlers.length; j++){\n                var handler = handlers[j];\n                if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {\n                    remaining.push(handler);\n                } else {\n                    var listening = handler.listening;\n                    if (listening) listening.off(name, callback);\n                }\n            }\n            // Replace events if there are any remaining.  Otherwise, clean up.\n            if (remaining.length) {\n                events[name] = remaining;\n            } else {\n                delete events[name];\n            }\n        }\n        return events;\n    };\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, its listener will be removed. If multiple events\n    // are passed in using the space-separated syntax, the handler will fire\n    // once for each event, not once for a combination of all events.\n    Events.once = function(name, callback, context) {\n        // Map the event into a `{event: once}` object.\n        var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n        if (typeof name === \"string\" && context == null) callback = void 0;\n        return this.on(events, callback, context);\n    };\n    // Inversion-of-control versions of `once`.\n    Events.listenToOnce = function(obj, name, callback) {\n        // Map the event into a `{event: once}` object.\n        var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n        return this.listenTo(obj, events);\n    };\n    // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n    // `offer` unbinds the `onceWrapper` after it has been called.\n    var onceMap = function(map, name, callback, offer) {\n        if (callback) {\n            var once = map[name] = _.once(function() {\n                offer(name, once);\n                callback.apply(this, arguments);\n            });\n            once._callback = callback;\n        }\n        return map;\n    };\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    Events.trigger = function(name) {\n        if (!this._events) return this;\n        var length = Math.max(0, arguments.length - 1);\n        var args = Array(length);\n        for(var i = 0; i < length; i++)args[i] = arguments[i + 1];\n        eventsApi(triggerApi, this._events, name, void 0, args);\n        return this;\n    };\n    // Handles triggering the appropriate event callbacks.\n    var triggerApi = function(objEvents, name, callback, args) {\n        if (objEvents) {\n            var events = objEvents[name];\n            var allEvents = objEvents.all;\n            if (events && allEvents) allEvents = allEvents.slice();\n            if (events) triggerEvents(events, args);\n            if (allEvents) triggerEvents(allEvents, [\n                name\n            ].concat(args));\n        }\n        return objEvents;\n    };\n    // A difficult-to-believe, but optimized internal dispatch function for\n    // triggering events. Tries to keep the usual cases speedy (most internal\n    // Backbone events have 3 arguments).\n    var triggerEvents = function(events, args) {\n        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n        switch(args.length){\n            case 0:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx);\n                return;\n            case 1:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n                return;\n            case 2:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n                return;\n            case 3:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n                return;\n            default:\n                while(++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n                return;\n        }\n    };\n    // A listening class that tracks and cleans up memory bindings\n    // when all callbacks have been offed.\n    var Listening = function(listener, obj) {\n        this.id = listener._listenId;\n        this.listener = listener;\n        this.obj = obj;\n        this.interop = true;\n        this.count = 0;\n        this._events = void 0;\n    };\n    Listening.prototype.on = Events.on;\n    // Offs a callback (or several).\n    // Uses an optimized counter if the listenee uses Backbone.Events.\n    // Otherwise, falls back to manual tracking to support events\n    // library interop.\n    Listening.prototype.off = function(name, callback) {\n        var cleanup;\n        if (this.interop) {\n            this._events = eventsApi(offApi, this._events, name, callback, {\n                context: void 0,\n                listeners: void 0\n            });\n            cleanup = !this._events;\n        } else {\n            this.count--;\n            cleanup = this.count === 0;\n        }\n        if (cleanup) this.cleanup();\n    };\n    // Cleans up memory bindings between the listener and the listenee.\n    Listening.prototype.cleanup = function() {\n        delete this.listener._listeningTo[this.obj._listenId];\n        if (!this.interop) delete this.obj._listeners[this.id];\n    };\n    // Aliases for backwards compatibility.\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n    // Allow the `Backbone` object to serve as a global event bus, for folks who\n    // want global \"pubsub\" in a convenient place.\n    _.extend(Backbone, Events);\n    // Backbone.Model\n    // --------------\n    // Backbone **Models** are the basic data object in the framework --\n    // frequently representing a row in a table in a database on your server.\n    // A discrete chunk of data and a bunch of useful, related methods for\n    // performing computations and transformations on that data.\n    // Create a new model with the specified attributes. A client id (`cid`)\n    // is automatically generated and assigned for you.\n    var Model = Backbone.Model = function(attributes, options) {\n        var attrs = attributes || {};\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        this.cid = _.uniqueId(this.cidPrefix);\n        this.attributes = {};\n        if (options.collection) this.collection = options.collection;\n        if (options.parse) attrs = this.parse(attrs, options) || {};\n        var defaults = _.result(this, \"defaults\");\n        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    };\n    // Attach all inheritable methods to the Model prototype.\n    _.extend(Model.prototype, Events, {\n        // A hash of attributes whose current and previous value differ.\n        changed: null,\n        // The value returned during the last failed validation.\n        validationError: null,\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n        // CouchDB users may want to set this to `\"_id\"`.\n        idAttribute: \"id\",\n        // The prefix is used to create the client id which is used to identify models locally.\n        // You may want to override this if you're experiencing name clashes with model ids.\n        cidPrefix: \"c\",\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Model.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // Return a copy of the model's `attributes` object.\n        toJSON: function(options) {\n            return _.clone(this.attributes);\n        },\n        // Proxy `Backbone.sync` by default -- but override this if you need\n        // custom syncing semantics for *this* particular model.\n        sync: function() {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Get the value of an attribute.\n        get: function(attr) {\n            return this.attributes[attr];\n        },\n        // Get the HTML-escaped value of an attribute.\n        escape: function(attr) {\n            return _.escape(this.get(attr));\n        },\n        // Returns `true` if the attribute contains a value that is not null\n        // or undefined.\n        has: function(attr) {\n            return this.get(attr) != null;\n        },\n        // Special-cased proxy to underscore's `_.matches` method.\n        matches: function(attrs) {\n            return !!_.iteratee(attrs, this)(this.attributes);\n        },\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\n        // the core primitive operation of a model, updating the data and notifying\n        // anyone who needs to know about the change in state. The heart of the beast.\n        set: function(key, val, options) {\n            if (key == null) return this;\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            var attrs;\n            if (typeof key === \"object\") {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n            options || (options = {});\n            // Run validation.\n            if (!this._validate(attrs, options)) return false;\n            // Extract attributes and options.\n            var unset = options.unset;\n            var silent = options.silent;\n            var changes = [];\n            var changing = this._changing;\n            this._changing = true;\n            if (!changing) {\n                this._previousAttributes = _.clone(this.attributes);\n                this.changed = {};\n            }\n            var current = this.attributes;\n            var changed = this.changed;\n            var prev = this._previousAttributes;\n            // For each `set` attribute, update or delete the current value.\n            for(var attr in attrs){\n                val = attrs[attr];\n                if (!_.isEqual(current[attr], val)) changes.push(attr);\n                if (!_.isEqual(prev[attr], val)) {\n                    changed[attr] = val;\n                } else {\n                    delete changed[attr];\n                }\n                unset ? delete current[attr] : current[attr] = val;\n            }\n            // Update the `id`.\n            if (this.idAttribute in attrs) {\n                var prevId = this.id;\n                this.id = this.get(this.idAttribute);\n                this.trigger(\"changeId\", this, prevId, options);\n            }\n            // Trigger all relevant attribute changes.\n            if (!silent) {\n                if (changes.length) this._pending = options;\n                for(var i = 0; i < changes.length; i++){\n                    this.trigger(\"change:\" + changes[i], this, current[changes[i]], options);\n                }\n            }\n            // You might be wondering why there's a `while` loop here. Changes can\n            // be recursively nested within `\"change\"` events.\n            if (changing) return this;\n            if (!silent) {\n                while(this._pending){\n                    options = this._pending;\n                    this._pending = false;\n                    this.trigger(\"change\", this, options);\n                }\n            }\n            this._pending = false;\n            this._changing = false;\n            return this;\n        },\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n        // if the attribute doesn't exist.\n        unset: function(attr, options) {\n            return this.set(attr, void 0, _.extend({}, options, {\n                unset: true\n            }));\n        },\n        // Clear all attributes on the model, firing `\"change\"`.\n        clear: function(options) {\n            var attrs = {};\n            for(var key in this.attributes)attrs[key] = void 0;\n            return this.set(attrs, _.extend({}, options, {\n                unset: true\n            }));\n        },\n        // Determine if the model has changed since the last `\"change\"` event.\n        // If you specify an attribute name, determine if that attribute has changed.\n        hasChanged: function(attr) {\n            if (attr == null) return !_.isEmpty(this.changed);\n            return _.has(this.changed, attr);\n        },\n        // Return an object containing all the attributes that have changed, or\n        // false if there are no changed attributes. Useful for determining what\n        // parts of a view need to be updated and/or what attributes need to be\n        // persisted to the server. Unset attributes will be set to undefined.\n        // You can also pass an attributes object to diff against the model,\n        // determining if there *would be* a change.\n        changedAttributes: function(diff) {\n            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n            var old = this._changing ? this._previousAttributes : this.attributes;\n            var changed = {};\n            var hasChanged;\n            for(var attr in diff){\n                var val = diff[attr];\n                if (_.isEqual(old[attr], val)) continue;\n                changed[attr] = val;\n                hasChanged = true;\n            }\n            return hasChanged ? changed : false;\n        },\n        // Get the previous value of an attribute, recorded at the time the last\n        // `\"change\"` event was fired.\n        previous: function(attr) {\n            if (attr == null || !this._previousAttributes) return null;\n            return this._previousAttributes[attr];\n        },\n        // Get all of the attributes of the model at the time of the previous\n        // `\"change\"` event.\n        previousAttributes: function() {\n            return _.clone(this._previousAttributes);\n        },\n        // Fetch the model from the server, merging the response with the model's\n        // local attributes. Any changed attributes will trigger a \"change\" event.\n        fetch: function(options) {\n            options = _.extend({\n                parse: true\n            }, options);\n            var model = this;\n            var success = options.success;\n            options.success = function(resp) {\n                var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n                if (!model.set(serverAttrs, options)) return false;\n                if (success) success.call(options.context, model, resp, options);\n                model.trigger(\"sync\", model, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync(\"read\", this, options);\n        },\n        // Set a hash of model attributes, and sync the model to the server.\n        // If the server returns an attributes hash that differs, the model's\n        // state will be `set` again.\n        save: function(key, val, options) {\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            var attrs;\n            if (key == null || typeof key === \"object\") {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n            options = _.extend({\n                validate: true,\n                parse: true\n            }, options);\n            var wait = options.wait;\n            // If we're not waiting and attributes exist, save acts as\n            // `set(attr).save(null, opts)` with validation. Otherwise, check if\n            // the model will be valid when the attributes, if any, are set.\n            if (attrs && !wait) {\n                if (!this.set(attrs, options)) return false;\n            } else if (!this._validate(attrs, options)) {\n                return false;\n            }\n            // After a successful server-side save, the client is (optionally)\n            // updated with the server-side state.\n            var model = this;\n            var success = options.success;\n            var attributes = this.attributes;\n            options.success = function(resp) {\n                // Ensure attributes are restored during synchronous saves.\n                model.attributes = attributes;\n                var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\n                if (serverAttrs && !model.set(serverAttrs, options)) return false;\n                if (success) success.call(options.context, model, resp, options);\n                model.trigger(\"sync\", model, resp, options);\n            };\n            wrapError(this, options);\n            // Set temporary attributes if `{wait: true}` to properly find new ids.\n            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\n            var method = this.isNew() ? \"create\" : options.patch ? \"patch\" : \"update\";\n            if (method === \"patch\" && !options.attrs) options.attrs = attrs;\n            var xhr = this.sync(method, this, options);\n            // Restore attributes.\n            this.attributes = attributes;\n            return xhr;\n        },\n        // Destroy this model on the server if it was already persisted.\n        // Optimistically removes the model from its collection, if it has one.\n        // If `wait: true` is passed, waits for the server to respond before removal.\n        destroy: function(options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n            var wait = options.wait;\n            var destroy = function() {\n                model.stopListening();\n                model.trigger(\"destroy\", model, model.collection, options);\n            };\n            options.success = function(resp) {\n                if (wait) destroy();\n                if (success) success.call(options.context, model, resp, options);\n                if (!model.isNew()) model.trigger(\"sync\", model, resp, options);\n            };\n            var xhr = false;\n            if (this.isNew()) {\n                _.defer(options.success);\n            } else {\n                wrapError(this, options);\n                xhr = this.sync(\"delete\", this, options);\n            }\n            if (!wait) destroy();\n            return xhr;\n        },\n        // Default URL for the model's representation on the server -- if you're\n        // using Backbone's restful methods, override this to change the endpoint\n        // that will be called.\n        url: function() {\n            var base = _.result(this, \"urlRoot\") || _.result(this.collection, \"url\") || urlError();\n            if (this.isNew()) return base;\n            var id = this.get(this.idAttribute);\n            return base.replace(/[^\\/]$/, \"$&/\") + encodeURIComponent(id);\n        },\n        // **parse** converts a response into the hash of attributes to be `set` on\n        // the model. The default implementation is just to pass the response along.\n        parse: function(resp, options) {\n            return resp;\n        },\n        // Create a new model with identical attributes to this one.\n        clone: function() {\n            return new this.constructor(this.attributes);\n        },\n        // A model is new if it has never been saved to the server, and lacks an id.\n        isNew: function() {\n            return !this.has(this.idAttribute);\n        },\n        // Check if the model is currently in a valid state.\n        isValid: function(options) {\n            return this._validate({}, _.extend({}, options, {\n                validate: true\n            }));\n        },\n        // Run validation against the next complete set of model attributes,\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n        _validate: function(attrs, options) {\n            if (!options.validate || !this.validate) return true;\n            attrs = _.extend({}, this.attributes, attrs);\n            var error = this.validationError = this.validate(attrs, options) || null;\n            if (!error) return true;\n            this.trigger(\"invalid\", this, error, _.extend(options, {\n                validationError: error\n            }));\n            return false;\n        }\n    });\n    // Backbone.Collection\n    // -------------------\n    // If models tend to represent a single row of data, a Backbone Collection is\n    // more analogous to a table full of data ... or a small slice or page of that\n    // table, or a collection of rows that belong together for a particular reason\n    // -- all of the messages in this particular folder, all of the documents\n    // belonging to this particular author, and so on. Collections maintain\n    // indexes of their models, both in order, and for lookup by `id`.\n    // Create a new **Collection**, perhaps to contain a specific type of `model`.\n    // If a `comparator` is specified, the Collection will maintain\n    // its models in sort order, as they're added and removed.\n    var Collection = Backbone.Collection = function(models, options) {\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        if (options.model) this.model = options.model;\n        if (options.comparator !== void 0) this.comparator = options.comparator;\n        this._reset();\n        this.initialize.apply(this, arguments);\n        if (models) this.reset(models, _.extend({\n            silent: true\n        }, options));\n    };\n    // Default options for `Collection#set`.\n    var setOptions = {\n        add: true,\n        remove: true,\n        merge: true\n    };\n    var addOptions = {\n        add: true,\n        remove: false\n    };\n    // Splices `insert` into `array` at index `at`.\n    var splice = function(array, insert, at) {\n        at = Math.min(Math.max(at, 0), array.length);\n        var tail = Array(array.length - at);\n        var length = insert.length;\n        var i;\n        for(i = 0; i < tail.length; i++)tail[i] = array[i + at];\n        for(i = 0; i < length; i++)array[i + at] = insert[i];\n        for(i = 0; i < tail.length; i++)array[i + length + at] = tail[i];\n    };\n    // Define the Collection's inheritable methods.\n    _.extend(Collection.prototype, Events, {\n        // The default model for a collection is just a **Backbone.Model**.\n        // This should be overridden in most cases.\n        model: Model,\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // The JSON representation of a Collection is an array of the\n        // models' attributes.\n        toJSON: function(options) {\n            return this.map(function(model) {\n                return model.toJSON(options);\n            });\n        },\n        // Proxy `Backbone.sync` by default.\n        sync: function() {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Add a model, or list of models to the set. `models` may be Backbone\n        // Models or raw JavaScript objects to be converted to Models, or any\n        // combination of the two.\n        add: function(models, options) {\n            return this.set(models, _.extend({\n                merge: false\n            }, options, addOptions));\n        },\n        // Remove a model, or a list of models from the set.\n        remove: function(models, options) {\n            options = _.extend({}, options);\n            var singular = !_.isArray(models);\n            models = singular ? [\n                models\n            ] : models.slice();\n            var removed = this._removeModels(models, options);\n            if (!options.silent && removed.length) {\n                options.changes = {\n                    added: [],\n                    merged: [],\n                    removed: removed\n                };\n                this.trigger(\"update\", this, options);\n            }\n            return singular ? removed[0] : removed;\n        },\n        // Update a collection by `set`-ing a new list of models, adding new ones,\n        // removing models that are no longer present, and merging models that\n        // already exist in the collection, as necessary. Similar to **Model#set**,\n        // the core operation for updating the data contained by the collection.\n        set: function(models, options) {\n            if (models == null) return;\n            options = _.extend({}, setOptions, options);\n            if (options.parse && !this._isModel(models)) {\n                models = this.parse(models, options) || [];\n            }\n            var singular = !_.isArray(models);\n            models = singular ? [\n                models\n            ] : models.slice();\n            var at = options.at;\n            if (at != null) at = +at;\n            if (at > this.length) at = this.length;\n            if (at < 0) at += this.length + 1;\n            var set = [];\n            var toAdd = [];\n            var toMerge = [];\n            var toRemove = [];\n            var modelMap = {};\n            var add = options.add;\n            var merge = options.merge;\n            var remove = options.remove;\n            var sort = false;\n            var sortable = this.comparator && at == null && options.sort !== false;\n            var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n            // Turn bare objects into model references, and prevent invalid models\n            // from being added.\n            var model, i;\n            for(i = 0; i < models.length; i++){\n                model = models[i];\n                // If a duplicate is found, prevent it from being added and\n                // optionally merge it into the existing model.\n                var existing = this.get(model);\n                if (existing) {\n                    if (merge && model !== existing) {\n                        var attrs = this._isModel(model) ? model.attributes : model;\n                        if (options.parse) attrs = existing.parse(attrs, options);\n                        existing.set(attrs, options);\n                        toMerge.push(existing);\n                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n                    }\n                    if (!modelMap[existing.cid]) {\n                        modelMap[existing.cid] = true;\n                        set.push(existing);\n                    }\n                    models[i] = existing;\n                // If this is a new, valid model, push it to the `toAdd` list.\n                } else if (add) {\n                    model = models[i] = this._prepareModel(model, options);\n                    if (model) {\n                        toAdd.push(model);\n                        this._addReference(model, options);\n                        modelMap[model.cid] = true;\n                        set.push(model);\n                    }\n                }\n            }\n            // Remove stale models.\n            if (remove) {\n                for(i = 0; i < this.length; i++){\n                    model = this.models[i];\n                    if (!modelMap[model.cid]) toRemove.push(model);\n                }\n                if (toRemove.length) this._removeModels(toRemove, options);\n            }\n            // See if sorting is needed, update `length` and splice in new models.\n            var orderChanged = false;\n            var replace = !sortable && add && remove;\n            if (set.length && replace) {\n                orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\n                    return m !== set[index];\n                });\n                this.models.length = 0;\n                splice(this.models, set, 0);\n                this.length = this.models.length;\n            } else if (toAdd.length) {\n                if (sortable) sort = true;\n                splice(this.models, toAdd, at == null ? this.length : at);\n                this.length = this.models.length;\n            }\n            // Silently sort the collection if appropriate.\n            if (sort) this.sort({\n                silent: true\n            });\n            // Unless silenced, it's time to fire all appropriate add/sort/update events.\n            if (!options.silent) {\n                for(i = 0; i < toAdd.length; i++){\n                    if (at != null) options.index = at + i;\n                    model = toAdd[i];\n                    model.trigger(\"add\", model, this, options);\n                }\n                if (sort || orderChanged) this.trigger(\"sort\", this, options);\n                if (toAdd.length || toRemove.length || toMerge.length) {\n                    options.changes = {\n                        added: toAdd,\n                        removed: toRemove,\n                        merged: toMerge\n                    };\n                    this.trigger(\"update\", this, options);\n                }\n            }\n            // Return the added (or merged) model (or models).\n            return singular ? models[0] : models;\n        },\n        // When you have more items than you want to add or remove individually,\n        // you can reset the entire set with a new list of models, without firing\n        // any granular `add` or `remove` events. Fires `reset` when finished.\n        // Useful for bulk operations and optimizations.\n        reset: function(models, options) {\n            options = options ? _.clone(options) : {};\n            for(var i = 0; i < this.models.length; i++){\n                this._removeReference(this.models[i], options);\n            }\n            options.previousModels = this.models;\n            this._reset();\n            models = this.add(models, _.extend({\n                silent: true\n            }, options));\n            if (!options.silent) this.trigger(\"reset\", this, options);\n            return models;\n        },\n        // Add a model to the end of the collection.\n        push: function(model, options) {\n            return this.add(model, _.extend({\n                at: this.length\n            }, options));\n        },\n        // Remove a model from the end of the collection.\n        pop: function(options) {\n            var model = this.at(this.length - 1);\n            return this.remove(model, options);\n        },\n        // Add a model to the beginning of the collection.\n        unshift: function(model, options) {\n            return this.add(model, _.extend({\n                at: 0\n            }, options));\n        },\n        // Remove a model from the beginning of the collection.\n        shift: function(options) {\n            var model = this.at(0);\n            return this.remove(model, options);\n        },\n        // Slice out a sub-array of models from the collection.\n        slice: function() {\n            return slice.apply(this.models, arguments);\n        },\n        // Get a model from the set by id, cid, model object with id or cid\n        // properties, or an attributes object that is transformed through modelId.\n        get: function(obj) {\n            if (obj == null) return void 0;\n            return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] || obj.cid && this._byId[obj.cid];\n        },\n        // Returns `true` if the model is in the collection.\n        has: function(obj) {\n            return this.get(obj) != null;\n        },\n        // Get the model at the given index.\n        at: function(index) {\n            if (index < 0) index += this.length;\n            return this.models[index];\n        },\n        // Return models with matching attributes. Useful for simple cases of\n        // `filter`.\n        where: function(attrs, first) {\n            return this[first ? \"find\" : \"filter\"](attrs);\n        },\n        // Return the first model with matching attributes. Useful for simple cases\n        // of `find`.\n        findWhere: function(attrs) {\n            return this.where(attrs, true);\n        },\n        // Force the collection to re-sort itself. You don't need to call this under\n        // normal circumstances, as the set will maintain sort order as each item\n        // is added.\n        sort: function(options) {\n            var comparator = this.comparator;\n            if (!comparator) throw new Error(\"Cannot sort a set without a comparator\");\n            options || (options = {});\n            var length = comparator.length;\n            if (_.isFunction(comparator)) comparator = comparator.bind(this);\n            // Run sort based on type of `comparator`.\n            if (length === 1 || _.isString(comparator)) {\n                this.models = this.sortBy(comparator);\n            } else {\n                this.models.sort(comparator);\n            }\n            if (!options.silent) this.trigger(\"sort\", this, options);\n            return this;\n        },\n        // Pluck an attribute from each model in the collection.\n        pluck: function(attr) {\n            return this.map(attr + \"\");\n        },\n        // Fetch the default set of models for this collection, resetting the\n        // collection when they arrive. If `reset: true` is passed, the response\n        // data will be passed through the `reset` method instead of `set`.\n        fetch: function(options) {\n            options = _.extend({\n                parse: true\n            }, options);\n            var success = options.success;\n            var collection = this;\n            options.success = function(resp) {\n                var method = options.reset ? \"reset\" : \"set\";\n                collection[method](resp, options);\n                if (success) success.call(options.context, collection, resp, options);\n                collection.trigger(\"sync\", collection, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync(\"read\", this, options);\n        },\n        // Create a new instance of a model in this collection. Add the model to the\n        // collection immediately, unless `wait: true` is passed, in which case we\n        // wait for the server to agree.\n        create: function(model, options) {\n            options = options ? _.clone(options) : {};\n            var wait = options.wait;\n            model = this._prepareModel(model, options);\n            if (!model) return false;\n            if (!wait) this.add(model, options);\n            var collection = this;\n            var success = options.success;\n            options.success = function(m, resp, callbackOpts) {\n                if (wait) collection.add(m, callbackOpts);\n                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\n            };\n            model.save(null, options);\n            return model;\n        },\n        // **parse** converts a response into a list of models to be added to the\n        // collection. The default implementation is just to pass it through.\n        parse: function(resp, options) {\n            return resp;\n        },\n        // Create a new collection with an identical list of models as this one.\n        clone: function() {\n            return new this.constructor(this.models, {\n                model: this.model,\n                comparator: this.comparator\n            });\n        },\n        // Define how to uniquely identify models in the collection.\n        modelId: function(attrs, idAttribute) {\n            return attrs[idAttribute || this.model.prototype.idAttribute || \"id\"];\n        },\n        // Get an iterator of all models in this collection.\n        values: function() {\n            return new CollectionIterator(this, ITERATOR_VALUES);\n        },\n        // Get an iterator of all model IDs in this collection.\n        keys: function() {\n            return new CollectionIterator(this, ITERATOR_KEYS);\n        },\n        // Get an iterator of all [ID, model] tuples in this collection.\n        entries: function() {\n            return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n        },\n        // Private method to reset all internal state. Called when the collection\n        // is first initialized or reset.\n        _reset: function() {\n            this.length = 0;\n            this.models = [];\n            this._byId = {};\n        },\n        // Prepare a hash of attributes (or other model) to be added to this\n        // collection.\n        _prepareModel: function(attrs, options) {\n            if (this._isModel(attrs)) {\n                if (!attrs.collection) attrs.collection = this;\n                return attrs;\n            }\n            options = options ? _.clone(options) : {};\n            options.collection = this;\n            var model;\n            if (this.model.prototype) {\n                model = new this.model(attrs, options);\n            } else {\n                // ES class methods didn't have prototype\n                model = this.model(attrs, options);\n            }\n            if (!model.validationError) return model;\n            this.trigger(\"invalid\", this, model.validationError, options);\n            return false;\n        },\n        // Internal method called by both remove and set.\n        _removeModels: function(models, options) {\n            var removed = [];\n            for(var i = 0; i < models.length; i++){\n                var model = this.get(models[i]);\n                if (!model) continue;\n                var index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                // Remove references before triggering 'remove' event to prevent an\n                // infinite loop. #3693\n                delete this._byId[model.cid];\n                var id = this.modelId(model.attributes, model.idAttribute);\n                if (id != null) delete this._byId[id];\n                if (!options.silent) {\n                    options.index = index;\n                    model.trigger(\"remove\", model, this, options);\n                }\n                removed.push(model);\n                this._removeReference(model, options);\n            }\n            return removed;\n        },\n        // Method for checking whether an object should be considered a model for\n        // the purposes of adding to the collection.\n        _isModel: function(model) {\n            return model instanceof Model;\n        },\n        // Internal method to create a model's ties to a collection.\n        _addReference: function(model, options) {\n            this._byId[model.cid] = model;\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) this._byId[id] = model;\n            model.on(\"all\", this._onModelEvent, this);\n        },\n        // Internal method to sever a model's ties to a collection.\n        _removeReference: function(model, options) {\n            delete this._byId[model.cid];\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) delete this._byId[id];\n            if (this === model.collection) delete model.collection;\n            model.off(\"all\", this._onModelEvent, this);\n        },\n        // Internal method called every time a model in the set fires an event.\n        // Sets need to update their indexes when models change ids. All other\n        // events simply proxy through. \"add\" and \"remove\" events that originate\n        // in other collections are ignored.\n        _onModelEvent: function(event, model, collection, options) {\n            if (model) {\n                if ((event === \"add\" || event === \"remove\") && collection !== this) return;\n                if (event === \"destroy\") this.remove(model, options);\n                if (event === \"changeId\") {\n                    var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n                    var id = this.modelId(model.attributes, model.idAttribute);\n                    if (prevId != null) delete this._byId[prevId];\n                    if (id != null) this._byId[id] = model;\n                }\n            }\n            this.trigger.apply(this, arguments);\n        }\n    });\n    // Defining an @@iterator method implements JavaScript's Iterable protocol.\n    // In modern ES2015 browsers, this value is found at Symbol.iterator.\n    /* global Symbol */ var $$iterator = typeof Symbol === \"function\" && Symbol.iterator;\n    if ($$iterator) {\n        Collection.prototype[$$iterator] = Collection.prototype.values;\n    }\n    // CollectionIterator\n    // ------------------\n    // A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n    // use of `for of` loops in modern browsers and interoperation between\n    // Backbone.Collection and other JavaScript functions and third-party libraries\n    // which can operate on Iterables.\n    var CollectionIterator = function(collection, kind) {\n        this._collection = collection;\n        this._kind = kind;\n        this._index = 0;\n    };\n    // This \"enum\" defines the three possible kinds of values which can be emitted\n    // by a CollectionIterator that correspond to the values(), keys() and entries()\n    // methods on Collection, respectively.\n    var ITERATOR_VALUES = 1;\n    var ITERATOR_KEYS = 2;\n    var ITERATOR_KEYSVALUES = 3;\n    // All Iterators should themselves be Iterable.\n    if ($$iterator) {\n        CollectionIterator.prototype[$$iterator] = function() {\n            return this;\n        };\n    }\n    CollectionIterator.prototype.next = function() {\n        if (this._collection) {\n            // Only continue iterating if the iterated collection is long enough.\n            if (this._index < this._collection.length) {\n                var model = this._collection.at(this._index);\n                this._index++;\n                // Construct a value depending on what kind of values should be iterated.\n                var value;\n                if (this._kind === ITERATOR_VALUES) {\n                    value = model;\n                } else {\n                    var id = this._collection.modelId(model.attributes, model.idAttribute);\n                    if (this._kind === ITERATOR_KEYS) {\n                        value = id;\n                    } else {\n                        value = [\n                            id,\n                            model\n                        ];\n                    }\n                }\n                return {\n                    value: value,\n                    done: false\n                };\n            }\n            // Once exhausted, remove the reference to the collection so future\n            // calls to the next method always return done.\n            this._collection = void 0;\n        }\n        return {\n            value: void 0,\n            done: true\n        };\n    };\n    // Backbone.View\n    // -------------\n    // Backbone Views are almost more convention than they are actual code. A View\n    // is simply a JavaScript object that represents a logical chunk of UI in the\n    // DOM. This might be a single item, an entire list, a sidebar or panel, or\n    // even the surrounding frame which wraps your whole app. Defining a chunk of\n    // UI as a **View** allows you to define your DOM events declaratively, without\n    // having to worry about render order ... and makes it easy for the view to\n    // react to specific changes in the state of your models.\n    // Creating a Backbone.View creates its initial element outside of the DOM,\n    // if an existing element is not provided...\n    var View = Backbone.View = function(options) {\n        this.cid = _.uniqueId(\"view\");\n        this.preinitialize.apply(this, arguments);\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n    };\n    // Cached regex to split keys for `delegate`.\n    var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n    // List of view options to be set as properties.\n    var viewOptions = [\n        \"model\",\n        \"collection\",\n        \"el\",\n        \"id\",\n        \"attributes\",\n        \"className\",\n        \"tagName\",\n        \"events\"\n    ];\n    // Set up all inheritable **Backbone.View** properties and methods.\n    _.extend(View.prototype, Events, {\n        // The default `tagName` of a View's element is `\"div\"`.\n        tagName: \"div\",\n        // jQuery delegate for element lookup, scoped to DOM elements within the\n        // current view. This should be preferred to global lookups where possible.\n        $: function(selector) {\n            return this.$el.find(selector);\n        },\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the View\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // **render** is the core function that your view should override, in order\n        // to populate its element (`this.el`), with the appropriate HTML. The\n        // convention is for **render** to always return `this`.\n        render: function() {\n            return this;\n        },\n        // Remove this view by taking the element out of the DOM, and removing any\n        // applicable Backbone.Events listeners.\n        remove: function() {\n            this._removeElement();\n            this.stopListening();\n            return this;\n        },\n        // Remove this view's element from the document and all event listeners\n        // attached to it. Exposed for subclasses using an alternative DOM\n        // manipulation API.\n        _removeElement: function() {\n            this.$el.remove();\n        },\n        // Change the view's element (`this.el` property) and re-delegate the\n        // view's events on the new element.\n        setElement: function(element) {\n            this.undelegateEvents();\n            this._setElement(element);\n            this.delegateEvents();\n            return this;\n        },\n        // Creates the `this.el` and `this.$el` references for this view using the\n        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n        // context or an element. Subclasses can override this to utilize an\n        // alternative DOM manipulation API and are only required to set the\n        // `this.el` property.\n        _setElement: function(el) {\n            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n            this.el = this.$el[0];\n        },\n        // Set callbacks, where `this.events` is a hash of\n        //\n        // *{\"event selector\": \"callback\"}*\n        //\n        //     {\n        //       'mousedown .title':  'edit',\n        //       'click .button':     'save',\n        //       'click .open':       function(e) { ... }\n        //     }\n        //\n        // pairs. Callbacks will be bound to the view, with `this` set properly.\n        // Uses event delegation for efficiency.\n        // Omitting the selector binds the event to `this.el`.\n        delegateEvents: function(events) {\n            events || (events = _.result(this, \"events\"));\n            if (!events) return this;\n            this.undelegateEvents();\n            for(var key in events){\n                var method = events[key];\n                if (!_.isFunction(method)) method = this[method];\n                if (!method) continue;\n                var match = key.match(delegateEventSplitter);\n                this.delegate(match[1], match[2], method.bind(this));\n            }\n            return this;\n        },\n        // Add a single event listener to the view's element (or a child element\n        // using `selector`). This only works for delegate-able events: not `focus`,\n        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n        delegate: function(eventName, selector, listener) {\n            this.$el.on(eventName + \".delegateEvents\" + this.cid, selector, listener);\n            return this;\n        },\n        // Clears all callbacks previously bound to the view by `delegateEvents`.\n        // You usually don't need to use this, but may wish to if you have multiple\n        // Backbone views attached to the same DOM element.\n        undelegateEvents: function() {\n            if (this.$el) this.$el.off(\".delegateEvents\" + this.cid);\n            return this;\n        },\n        // A finer-grained `undelegateEvents` for removing a single delegated event.\n        // `selector` and `listener` are both optional.\n        undelegate: function(eventName, selector, listener) {\n            this.$el.off(eventName + \".delegateEvents\" + this.cid, selector, listener);\n            return this;\n        },\n        // Produces a DOM element to be assigned to your view. Exposed for\n        // subclasses using an alternative DOM manipulation API.\n        _createElement: function(tagName) {\n            return document.createElement(tagName);\n        },\n        // Ensure that the View has a DOM element to render into.\n        // If `this.el` is a string, pass it through `$()`, take the first\n        // matching element, and re-assign it to `el`. Otherwise, create\n        // an element from the `id`, `className` and `tagName` properties.\n        _ensureElement: function() {\n            if (!this.el) {\n                var attrs = _.extend({}, _.result(this, \"attributes\"));\n                if (this.id) attrs.id = _.result(this, \"id\");\n                if (this.className) attrs[\"class\"] = _.result(this, \"className\");\n                this.setElement(this._createElement(_.result(this, \"tagName\")));\n                this._setAttributes(attrs);\n            } else {\n                this.setElement(_.result(this, \"el\"));\n            }\n        },\n        // Set attributes from a hash on this view's element.  Exposed for\n        // subclasses using an alternative DOM manipulation API.\n        _setAttributes: function(attributes) {\n            this.$el.attr(attributes);\n        }\n    });\n    // Proxy Backbone class methods to Underscore functions, wrapping the model's\n    // `attributes` object or collection's `models` array behind the scenes.\n    //\n    // collection.filter(function(model) { return model.get('age') > 10 });\n    // collection.each(this.addView);\n    //\n    // `Function#apply` can be slow so we use the method's arg count, if we know it.\n    var addMethod = function(base, length, method, attribute) {\n        switch(length){\n            case 1:\n                return function() {\n                    return base[method](this[attribute]);\n                };\n            case 2:\n                return function(value) {\n                    return base[method](this[attribute], value);\n                };\n            case 3:\n                return function(iteratee, context) {\n                    return base[method](this[attribute], cb(iteratee, this), context);\n                };\n            case 4:\n                return function(iteratee, defaultVal, context) {\n                    return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n                };\n            default:\n                return function() {\n                    var args = slice.call(arguments);\n                    args.unshift(this[attribute]);\n                    return base[method].apply(base, args);\n                };\n        }\n    };\n    var addUnderscoreMethods = function(Class, base, methods, attribute) {\n        _.each(methods, function(length, method) {\n            if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n        });\n    };\n    // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\n    var cb = function(iteratee, instance) {\n        if (_.isFunction(iteratee)) return iteratee;\n        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n        if (_.isString(iteratee)) return function(model) {\n            return model.get(iteratee);\n        };\n        return iteratee;\n    };\n    var modelMatcher = function(attrs) {\n        var matcher = _.matches(attrs);\n        return function(model) {\n            return matcher(model.attributes);\n        };\n    };\n    // Underscore methods that we want to implement on the Collection.\n    // 90% of the core usefulness of Backbone Collections is actually implemented\n    // right here:\n    var collectionMethods = {\n        forEach: 3,\n        each: 3,\n        map: 3,\n        collect: 3,\n        reduce: 0,\n        foldl: 0,\n        inject: 0,\n        reduceRight: 0,\n        foldr: 0,\n        find: 3,\n        detect: 3,\n        filter: 3,\n        select: 3,\n        reject: 3,\n        every: 3,\n        all: 3,\n        some: 3,\n        any: 3,\n        include: 3,\n        includes: 3,\n        contains: 3,\n        invoke: 0,\n        max: 3,\n        min: 3,\n        toArray: 1,\n        size: 1,\n        first: 3,\n        head: 3,\n        take: 3,\n        initial: 3,\n        rest: 3,\n        tail: 3,\n        drop: 3,\n        last: 3,\n        without: 0,\n        difference: 0,\n        indexOf: 3,\n        shuffle: 1,\n        lastIndexOf: 3,\n        isEmpty: 1,\n        chain: 1,\n        sample: 3,\n        partition: 3,\n        groupBy: 3,\n        countBy: 3,\n        sortBy: 3,\n        indexBy: 3,\n        findIndex: 3,\n        findLastIndex: 3\n    };\n    // Underscore methods that we want to implement on the Model, mapped to the\n    // number of arguments they take.\n    var modelMethods = {\n        keys: 1,\n        values: 1,\n        pairs: 1,\n        invert: 1,\n        pick: 0,\n        omit: 0,\n        chain: 1,\n        isEmpty: 1\n    };\n    // Mix in each Underscore method as a proxy to `Collection#models`.\n    _.each([\n        [\n            Collection,\n            collectionMethods,\n            \"models\"\n        ],\n        [\n            Model,\n            modelMethods,\n            \"attributes\"\n        ]\n    ], function(config) {\n        var Base = config[0], methods = config[1], attribute = config[2];\n        Base.mixin = function(obj) {\n            var mappings = _.reduce(_.functions(obj), function(memo, name) {\n                memo[name] = 0;\n                return memo;\n            }, {});\n            addUnderscoreMethods(Base, obj, mappings, attribute);\n        };\n        addUnderscoreMethods(Base, _, methods, attribute);\n    });\n    // Backbone.sync\n    // -------------\n    // Override this function to change the manner in which Backbone persists\n    // models to the server. You will be passed the type of request, and the\n    // model in question. By default, makes a RESTful Ajax request\n    // to the model's `url()`. Some possible customizations could be:\n    //\n    // * Use `setTimeout` to batch rapid-fire updates into a single request.\n    // * Send up the models as XML instead of JSON.\n    // * Persist models via WebSockets instead of Ajax.\n    //\n    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n    // as `POST`, with a `_method` parameter containing the true HTTP method,\n    // as well as all requests with the body as `application/x-www-form-urlencoded`\n    // instead of `application/json` with the model in a param named `model`.\n    // Useful when interfacing with server-side languages like **PHP** that make\n    // it difficult to read the body of `PUT` requests.\n    Backbone.sync = function(method, model, options) {\n        var type = methodMap[method];\n        // Default options, unless specified.\n        _.defaults(options || (options = {}), {\n            emulateHTTP: Backbone.emulateHTTP,\n            emulateJSON: Backbone.emulateJSON\n        });\n        // Default JSON-request options.\n        var params = {\n            type: type,\n            dataType: \"json\"\n        };\n        // Ensure that we have a URL.\n        if (!options.url) {\n            params.url = _.result(model, \"url\") || urlError();\n        }\n        // Ensure that we have the appropriate request data.\n        if (options.data == null && model && (method === \"create\" || method === \"update\" || method === \"patch\")) {\n            params.contentType = \"application/json\";\n            params.data = JSON.stringify(options.attrs || model.toJSON(options));\n        }\n        // For older servers, emulate JSON by encoding the request into an HTML-form.\n        if (options.emulateJSON) {\n            params.contentType = \"application/x-www-form-urlencoded\";\n            params.data = params.data ? {\n                model: params.data\n            } : {};\n        }\n        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n        // And an `X-HTTP-Method-Override` header.\n        if (options.emulateHTTP && (type === \"PUT\" || type === \"DELETE\" || type === \"PATCH\")) {\n            params.type = \"POST\";\n            if (options.emulateJSON) params.data._method = type;\n            var beforeSend = options.beforeSend;\n            options.beforeSend = function(xhr) {\n                xhr.setRequestHeader(\"X-HTTP-Method-Override\", type);\n                if (beforeSend) return beforeSend.apply(this, arguments);\n            };\n        }\n        // Don't process data on a non-GET request.\n        if (params.type !== \"GET\" && !options.emulateJSON) {\n            params.processData = false;\n        }\n        // Pass along `textStatus` and `errorThrown` from jQuery.\n        var error = options.error;\n        options.error = function(xhr, textStatus, errorThrown) {\n            options.textStatus = textStatus;\n            options.errorThrown = errorThrown;\n            if (error) error.call(options.context, xhr, textStatus, errorThrown);\n        };\n        // Make the request, allowing the user to override any Ajax options.\n        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n        model.trigger(\"request\", model, xhr, options);\n        return xhr;\n    };\n    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n    var methodMap = {\n        \"create\": \"POST\",\n        \"update\": \"PUT\",\n        \"patch\": \"PATCH\",\n        \"delete\": \"DELETE\",\n        \"read\": \"GET\"\n    };\n    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n    // Override this if you'd like to use a different library.\n    Backbone.ajax = function() {\n        return Backbone.$.ajax.apply(Backbone.$, arguments);\n    };\n    // Backbone.Router\n    // ---------------\n    // Routers map faux-URLs to actions, and fire events when routes are\n    // matched. Creating a new one sets its `routes` hash, if not set statically.\n    var Router = Backbone.Router = function(options) {\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        if (options.routes) this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n    // Cached regular expressions for matching named param parts and splatted\n    // parts of route strings.\n    var optionalParam = /\\((.*?)\\)/g;\n    var namedParam = /(\\(\\?)?:\\w+/g;\n    var splatParam = /\\*\\w+/g;\n    var escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n    // Set up all inheritable **Backbone.Router** properties and methods.\n    _.extend(Router.prototype, Events, {\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Router.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // Manually bind a single named route to a callback. For example:\n        //\n        //     this.route('search/:query/p:num', 'search', function(query, num) {\n        //       ...\n        //     });\n        //\n        route: function(route, name, callback) {\n            if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n            if (_.isFunction(name)) {\n                callback = name;\n                name = \"\";\n            }\n            if (!callback) callback = this[name];\n            var router = this;\n            Backbone.history.route(route, function(fragment) {\n                var args = router._extractParameters(route, fragment);\n                if (router.execute(callback, args, name) !== false) {\n                    router.trigger.apply(router, [\n                        \"route:\" + name\n                    ].concat(args));\n                    router.trigger(\"route\", name, args);\n                    Backbone.history.trigger(\"route\", router, name, args);\n                }\n            });\n            return this;\n        },\n        // Execute a route handler with the provided parameters.  This is an\n        // excellent place to do pre-route setup or post-route cleanup.\n        execute: function(callback, args, name) {\n            if (callback) callback.apply(this, args);\n        },\n        // Simple proxy to `Backbone.history` to save a fragment into the history.\n        navigate: function(fragment, options) {\n            Backbone.history.navigate(fragment, options);\n            return this;\n        },\n        // Bind all defined routes to `Backbone.history`. We have to reverse the\n        // order of the routes here to support behavior where the most general\n        // routes can be defined at the bottom of the route map.\n        _bindRoutes: function() {\n            if (!this.routes) return;\n            this.routes = _.result(this, \"routes\");\n            var route, routes = _.keys(this.routes);\n            while((route = routes.pop()) != null){\n                this.route(route, this.routes[route]);\n            }\n        },\n        // Convert a route string into a regular expression, suitable for matching\n        // against the current location hash.\n        _routeToRegExp: function(route) {\n            route = route.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, function(match, optional) {\n                return optional ? match : \"([^/?]+)\";\n            }).replace(splatParam, \"([^?]*?)\");\n            return new RegExp(\"^\" + route + \"(?:\\\\?([\\\\s\\\\S]*))?$\");\n        },\n        // Given a route, and a URL fragment that it matches, return the array of\n        // extracted decoded parameters. Empty or unmatched parameters will be\n        // treated as `null` to normalize cross-browser behavior.\n        _extractParameters: function(route, fragment) {\n            var params = route.exec(fragment).slice(1);\n            return _.map(params, function(param, i) {\n                // Don't decode the search params.\n                if (i === params.length - 1) return param || null;\n                return param ? decodeURIComponent(param) : null;\n            });\n        }\n    });\n    // Backbone.History\n    // ----------------\n    // Handles cross-browser history management, based on either\n    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n    // and URL fragments. If the browser supports neither (old IE, natch),\n    // falls back to polling.\n    var History = Backbone.History = function() {\n        this.handlers = [];\n        this.checkUrl = this.checkUrl.bind(this);\n        // Ensure that `History` can be used outside of the browser.\n        if (false) {}\n    };\n    // Cached regex for stripping a leading hash/slash and trailing space.\n    var routeStripper = /^[#\\/]|\\s+$/g;\n    // Cached regex for stripping leading and trailing slashes.\n    var rootStripper = /^\\/+|\\/+$/g;\n    // Cached regex for stripping urls of hash.\n    var pathStripper = /#.*$/;\n    // Has the history handling already been started?\n    History.started = false;\n    // Set up all inheritable **Backbone.History** properties and methods.\n    _.extend(History.prototype, Events, {\n        // The default interval to poll for hash changes, if necessary, is\n        // twenty times a second.\n        interval: 50,\n        // Are we at the app root?\n        atRoot: function() {\n            var path = this.location.pathname.replace(/[^\\/]$/, \"$&/\");\n            return path === this.root && !this.getSearch();\n        },\n        // Does the pathname match the root?\n        matchRoot: function() {\n            var path = this.decodeFragment(this.location.pathname);\n            var rootPath = path.slice(0, this.root.length - 1) + \"/\";\n            return rootPath === this.root;\n        },\n        // Unicode characters in `location.pathname` are percent encoded so they're\n        // decoded for comparison. `%25` should not be decoded since it may be part\n        // of an encoded parameter.\n        decodeFragment: function(fragment) {\n            return decodeURI(fragment.replace(/%25/g, \"%2525\"));\n        },\n        // In IE6, the hash fragment and search params are incorrect if the\n        // fragment contains `?`.\n        getSearch: function() {\n            var match = this.location.href.replace(/#.*/, \"\").match(/\\?.+/);\n            return match ? match[0] : \"\";\n        },\n        // Gets the true hash value. Cannot use location.hash directly due to bug\n        // in Firefox where location.hash will always be decoded.\n        getHash: function(window1) {\n            var match = (window1 || this).location.href.match(/#(.*)$/);\n            return match ? match[1] : \"\";\n        },\n        // Get the pathname and search params, without the root.\n        getPath: function() {\n            var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);\n            return path.charAt(0) === \"/\" ? path.slice(1) : path;\n        },\n        // Get the cross-browser normalized URL fragment from the path or hash.\n        getFragment: function(fragment) {\n            if (fragment == null) {\n                if (this._usePushState || !this._wantsHashChange) {\n                    fragment = this.getPath();\n                } else {\n                    fragment = this.getHash();\n                }\n            }\n            return fragment.replace(routeStripper, \"\");\n        },\n        // Start the hash change handling, returning `true` if the current URL matches\n        // an existing route, and `false` otherwise.\n        start: function(options) {\n            if (History.started) throw new Error(\"Backbone.history has already been started\");\n            History.started = true;\n            // Figure out the initial configuration. Do we need an iframe?\n            // Is pushState desired ... is it available?\n            this.options = _.extend({\n                root: \"/\"\n            }, this.options, options);\n            this.root = this.options.root;\n            this._wantsHashChange = this.options.hashChange !== false;\n            this._hasHashChange = \"onhashchange\" in window && (document.documentMode === void 0 || document.documentMode > 7);\n            this._useHashChange = this._wantsHashChange && this._hasHashChange;\n            this._wantsPushState = !!this.options.pushState;\n            this._hasPushState = !!(this.history && this.history.pushState);\n            this._usePushState = this._wantsPushState && this._hasPushState;\n            this.fragment = this.getFragment();\n            // Normalize root to always include a leading and trailing slash.\n            this.root = (\"/\" + this.root + \"/\").replace(rootStripper, \"/\");\n            // Transition from hashChange to pushState or vice versa if both are\n            // requested.\n            if (this._wantsHashChange && this._wantsPushState) {\n                // If we've started off with a route from a `pushState`-enabled\n                // browser, but we're currently in a browser that doesn't support it...\n                if (!this._hasPushState && !this.atRoot()) {\n                    var rootPath = this.root.slice(0, -1) || \"/\";\n                    this.location.replace(rootPath + \"#\" + this.getPath());\n                    // Return immediately as browser will do redirect to new url\n                    return true;\n                // Or if we've started out with a hash-based route, but we're currently\n                // in a browser where it could be `pushState`-based instead...\n                } else if (this._hasPushState && this.atRoot()) {\n                    this.navigate(this.getHash(), {\n                        replace: true\n                    });\n                }\n            }\n            // Proxy an iframe to handle location events if the browser doesn't\n            // support the `hashchange` event, HTML5 history, or the user wants\n            // `hashChange` but not `pushState`.\n            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n                this.iframe = document.createElement(\"iframe\");\n                this.iframe.src = \"javascript:0\";\n                this.iframe.style.display = \"none\";\n                this.iframe.tabIndex = -1;\n                var body = document.body;\n                // Using `appendChild` will throw on IE < 9 if the document is not ready.\n                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n                iWindow.document.open();\n                iWindow.document.close();\n                iWindow.location.hash = \"#\" + this.fragment;\n            }\n            // Add a cross-platform `addEventListener` shim for older browsers.\n            var addEventListener = window.addEventListener || function(eventName, listener) {\n                return attachEvent(\"on\" + eventName, listener);\n            };\n            // Depending on whether we're using pushState or hashes, and whether\n            // 'onhashchange' is supported, determine how we check the URL state.\n            if (this._usePushState) {\n                addEventListener(\"popstate\", this.checkUrl, false);\n            } else if (this._useHashChange && !this.iframe) {\n                addEventListener(\"hashchange\", this.checkUrl, false);\n            } else if (this._wantsHashChange) {\n                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            }\n            if (!this.options.silent) return this.loadUrl();\n        },\n        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n        // but possibly useful for unit testing Routers.\n        stop: function() {\n            // Add a cross-platform `removeEventListener` shim for older browsers.\n            var removeEventListener = window.removeEventListener || function(eventName, listener) {\n                return detachEvent(\"on\" + eventName, listener);\n            };\n            // Remove window listeners.\n            if (this._usePushState) {\n                removeEventListener(\"popstate\", this.checkUrl, false);\n            } else if (this._useHashChange && !this.iframe) {\n                removeEventListener(\"hashchange\", this.checkUrl, false);\n            }\n            // Clean up the iframe if necessary.\n            if (this.iframe) {\n                document.body.removeChild(this.iframe);\n                this.iframe = null;\n            }\n            // Some environments will throw when clearing an undefined interval.\n            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n            History.started = false;\n        },\n        // Add a route to be tested when the fragment changes. Routes added later\n        // may override previous routes.\n        route: function(route, callback) {\n            this.handlers.unshift({\n                route: route,\n                callback: callback\n            });\n        },\n        // Checks the current URL to see if it has changed, and if it has,\n        // calls `loadUrl`, normalizing across the hidden iframe.\n        checkUrl: function(e) {\n            var current = this.getFragment();\n            // If the user pressed the back button, the iframe's hash will have\n            // changed and we should use that for comparison.\n            if (current === this.fragment && this.iframe) {\n                current = this.getHash(this.iframe.contentWindow);\n            }\n            if (current === this.fragment) return false;\n            if (this.iframe) this.navigate(current);\n            this.loadUrl();\n        },\n        // Attempt to load the current URL fragment. If a route succeeds with a\n        // match, returns `true`. If no defined routes matches the fragment,\n        // returns `false`.\n        loadUrl: function(fragment) {\n            // If the root doesn't match, no routes can match either.\n            if (!this.matchRoot()) return false;\n            fragment = this.fragment = this.getFragment(fragment);\n            return _.some(this.handlers, function(handler) {\n                if (handler.route.test(fragment)) {\n                    handler.callback(fragment);\n                    return true;\n                }\n            });\n        },\n        // Save a fragment into the hash history, or replace the URL state if the\n        // 'replace' option is passed. You are responsible for properly URL-encoding\n        // the fragment in advance.\n        //\n        // The options object can contain `trigger: true` if you wish to have the\n        // route callback be fired (not usually desirable), or `replace: true`, if\n        // you wish to modify the current URL without adding an entry to the history.\n        navigate: function(fragment, options) {\n            if (!History.started) return false;\n            if (!options || options === true) options = {\n                trigger: !!options\n            };\n            // Normalize the fragment.\n            fragment = this.getFragment(fragment || \"\");\n            // Don't include a trailing slash on the root.\n            var rootPath = this.root;\n            if (fragment === \"\" || fragment.charAt(0) === \"?\") {\n                rootPath = rootPath.slice(0, -1) || \"/\";\n            }\n            var url = rootPath + fragment;\n            // Strip the fragment of the query and hash for matching.\n            fragment = fragment.replace(pathStripper, \"\");\n            // Decode for matching.\n            var decodedFragment = this.decodeFragment(fragment);\n            if (this.fragment === decodedFragment) return;\n            this.fragment = decodedFragment;\n            // If pushState is available, we use it to set the fragment as a real URL.\n            if (this._usePushState) {\n                this.history[options.replace ? \"replaceState\" : \"pushState\"]({}, document.title, url);\n            // If hash changes haven't been explicitly disabled, update the hash\n            // fragment to store history.\n            } else if (this._wantsHashChange) {\n                this._updateHash(this.location, fragment, options.replace);\n                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n                    var iWindow = this.iframe.contentWindow;\n                    // Opening and closing the iframe tricks IE7 and earlier to push a\n                    // history entry on hash-tag change.  When replace is true, we don't\n                    // want this.\n                    if (!options.replace) {\n                        iWindow.document.open();\n                        iWindow.document.close();\n                    }\n                    this._updateHash(iWindow.location, fragment, options.replace);\n                }\n            // If you've told us that you explicitly don't want fallback hashchange-\n            // based history, then `navigate` becomes a page refresh.\n            } else {\n                return this.location.assign(url);\n            }\n            if (options.trigger) return this.loadUrl(fragment);\n        },\n        // Update the hash location, either replacing the current entry, or adding\n        // a new one to the browser history.\n        _updateHash: function(location, fragment, replace) {\n            if (replace) {\n                var href = location.href.replace(/(javascript:|#).*$/, \"\");\n                location.replace(href + \"#\" + fragment);\n            } else {\n                // Some browsers require that `hash` contains a leading #.\n                location.hash = \"#\" + fragment;\n            }\n        }\n    });\n    // Create the default Backbone.history.\n    Backbone.history = new History;\n    // Helpers\n    // -------\n    // Helper function to correctly set up the prototype chain for subclasses.\n    // Similar to `goog.inherits`, but uses a hash of prototype properties and\n    // class properties to be extended.\n    var extend = function(protoProps, staticProps) {\n        var parent = this;\n        var child;\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent constructor.\n        if (protoProps && _.has(protoProps, \"constructor\")) {\n            child = protoProps.constructor;\n        } else {\n            child = function() {\n                return parent.apply(this, arguments);\n            };\n        }\n        // Add static properties to the constructor function, if supplied.\n        _.extend(child, parent, staticProps);\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function and add the prototype properties.\n        child.prototype = _.create(parent.prototype, protoProps);\n        child.prototype.constructor = child;\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n        return child;\n    };\n    // Set up inheritance for the model, collection, router, view and history.\n    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n    // Throw an error when a URL is needed, and none is supplied.\n    var urlError = function() {\n        throw new Error('A \"url\" property or function must be specified');\n    };\n    // Wrap an optional error callback with a fallback error event.\n    var wrapError = function(model, options) {\n        var error = options.error;\n        options.error = function(resp) {\n            if (error) error.call(options.context, model, resp, options);\n            model.trigger(\"error\", model, resp, options);\n        };\n    };\n    return Backbone;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0ZBQXdCO0FBRXhCLHNEQUFzRDtBQUN0RCxnRUFBZ0U7QUFDaEUseUNBQXlDO0FBQ3pDLDRCQUE0QjtBQUUzQixVQUFTQSxPQUFPO0lBRWYsMEZBQTBGO0lBQzFGLDZEQUE2RDtJQUM3RCxJQUFJQyxPQUFPLE9BQU9DLFFBQVEsWUFBWUEsS0FBS0EsSUFBSSxLQUFLQSxRQUFRQSxRQUNsRCxPQUFPQyxVQUFVLFlBQVlBLE9BQU9BLE1BQU0sS0FBS0EsVUFBVUE7SUFFbkUscUVBQXFFO0lBQ3JFLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztZQUFjO1lBQVU7U0FBVSxtQ0FBRSxTQUFTRSxDQUFDLEVBQUVDLENBQUMsRUFBRUMsUUFBTztZQUNoRSxvRUFBb0U7WUFDcEUsa0RBQWtEO1lBQ2xEUCxLQUFLUSxRQUFRLEdBQUdULFFBQVFDLE1BQU1PLFVBQVNGLEdBQUdDO1FBQzVDLENBQUM7QUFBQSxrR0FBQztJQUVKLHNFQUFzRTtJQUN0RSxPQUFPLGFBUU47QUFFSCxHQUFHLFNBQVNOLElBQUksRUFBRVEsUUFBUSxFQUFFSCxDQUFDLEVBQUVDLENBQUM7SUFFOUIsZ0JBQWdCO0lBQ2hCLGdCQUFnQjtJQUVoQix3RUFBd0U7SUFDeEUsOENBQThDO0lBQzlDLElBQUlRLG1CQUFtQmQsS0FBS1EsUUFBUTtJQUVwQyw2RUFBNkU7SUFDN0UsSUFBSU8sUUFBUUMsTUFBTUMsU0FBUyxDQUFDRixLQUFLO0lBRWpDLG9FQUFvRTtJQUNwRVAsU0FBU1UsT0FBTyxHQUFHO0lBRW5CLDhFQUE4RTtJQUM5RSxvQkFBb0I7SUFDcEJWLFNBQVNGLENBQUMsR0FBR0E7SUFFYiwyRUFBMkU7SUFDM0Usc0VBQXNFO0lBQ3RFRSxTQUFTVyxVQUFVLEdBQUc7UUFDcEJuQixLQUFLUSxRQUFRLEdBQUdNO1FBQ2hCLE9BQU8sSUFBSTtJQUNiO0lBRUEsNEVBQTRFO0lB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UUFBUUgsV0FBV2hRLFdBQVc7UUFDaEMsT0FBTztZQUNMbVEsUUFBUTtnQkFBWSxPQUFPRCxPQUFPdlYsS0FBSyxDQUFDLElBQUksRUFBRUM7WUFBWTtRQUM1RDtRQUVBLGtFQUFrRTtRQUNsRXhFLEVBQUUyRixNQUFNLENBQUNvVSxPQUFPRCxRQUFRRDtRQUV4QixvRUFBb0U7UUFDcEUsb0VBQW9FO1FBQ3BFRSxNQUFNblosU0FBUyxHQUFHWixFQUFFa04sTUFBTSxDQUFDNE0sT0FBT2xaLFNBQVMsRUFBRWdaO1FBQzdDRyxNQUFNblosU0FBUyxDQUFDZ0osV0FBVyxHQUFHbVE7UUFFOUIsc0VBQXNFO1FBQ3RFLFNBQVM7UUFDVEEsTUFBTUMsU0FBUyxHQUFHRixPQUFPbFosU0FBUztRQUVsQyxPQUFPbVo7SUFDVDtJQUVBLDBFQUEwRTtJQUMxRW5VLE1BQU1ELE1BQU0sR0FBR21FLFdBQVduRSxNQUFNLEdBQUdpUCxPQUFPalAsTUFBTSxHQUFHNEksS0FBSzVJLE1BQU0sR0FBR3NRLFFBQVF0USxNQUFNLEdBQUdBO0lBRWxGLDZEQUE2RDtJQUM3RCxJQUFJOEQsV0FBVztRQUNiLE1BQU0sSUFBSXFELE1BQU07SUFDbEI7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSWpFLFlBQVksU0FBU0osS0FBSyxFQUFFdEYsT0FBTztRQUNyQyxJQUFJRixRQUFRRSxRQUFRRixLQUFLO1FBQ3pCRSxRQUFRRixLQUFLLEdBQUcsU0FBUzBGLElBQUk7WUFDM0IsSUFBSTFGLE9BQU9BLE1BQU11QyxJQUFJLENBQUNyQyxRQUFRdkIsT0FBTyxFQUFFNkcsT0FBT0UsTUFBTXhGO1lBQ3BEc0YsTUFBTWhFLE9BQU8sQ0FBQyxTQUFTZ0UsT0FBT0UsTUFBTXhGO1FBQ3RDO0lBQ0Y7SUFFQSxPQUFPaEQ7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL2JhY2tib25lL2JhY2tib25lLmpzP2Q3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIEJhY2tib25lLmpzIDEuNC4xXG5cbi8vICAgICAoYykgMjAxMC0yMDIyIEplcmVteSBBc2hrZW5hcyBhbmQgRG9jdW1lbnRDbG91ZFxuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgLy8gV2UgdXNlIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWw7XG5cbiAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uKF8sICQsIGV4cG9ydHMpIHtcbiAgICAgIC8vIEV4cG9ydCBnbG9iYWwgZXZlbiBpbiBBTUQgY2FzZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxuICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG4gICAgfSk7XG5cbiAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLCAkO1xuICAgIHRyeSB7ICQgPSByZXF1aXJlKCdqcXVlcnknKTsgfSBjYXRjaCAoZSkge31cbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgcm9vdC5qUXVlcnkgfHwgcm9vdC5aZXB0byB8fCByb290LmVuZGVyIHx8IHJvb3QuJCk7XG4gIH1cblxufSkoZnVuY3Rpb24ocm9vdCwgQmFja2JvbmUsIF8sICQpIHtcblxuICAvLyBJbml0aWFsIFNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYEJhY2tib25lYCB2YXJpYWJsZSwgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gcmVzdG9yZWQgbGF0ZXIgb24sIGlmIGBub0NvbmZsaWN0YCBpcyB1c2VkLlxuICB2YXIgcHJldmlvdXNCYWNrYm9uZSA9IHJvb3QuQmFja2JvbmU7XG5cbiAgLy8gQ3JlYXRlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIGEgY29tbW9uIGFycmF5IG1ldGhvZCB3ZSdsbCB3YW50IHRvIHVzZSBsYXRlci5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS40LjEnO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB0aGlzIHdpbGwgZW5jb2RlIHRoZSBib2R5IGFzXG4gIC8vIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIGluc3RlYWQgYW5kIHdpbGwgc2VuZCB0aGUgbW9kZWwgaW4gYVxuICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIEJhY2tib25lLmVtdWxhdGVKU09OID0gZmFsc2U7XG5cbiAgLy8gQmFja2JvbmUuRXZlbnRzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgbW9kdWxlIHRoYXQgY2FuIGJlIG1peGVkIGluIHRvICphbnkgb2JqZWN0KiBpbiBvcmRlciB0byBwcm92aWRlIGl0IHdpdGhcbiAgLy8gYSBjdXN0b20gZXZlbnQgY2hhbm5lbC4gWW91IG1heSBiaW5kIGEgY2FsbGJhY2sgdG8gYW4gZXZlbnQgd2l0aCBgb25gIG9yXG4gIC8vIHJlbW92ZSB3aXRoIGBvZmZgOyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgLy8gc3VjY2Vzc2lvbi5cbiAgLy9cbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgLy8gICAgIF8uZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbiAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAvL1xuICB2YXIgRXZlbnRzID0gQmFja2JvbmUuRXZlbnRzID0ge307XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gc3BsaXQgZXZlbnQgc3RyaW5ncy5cbiAgdmFyIGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbiAgLy8gQSBwcml2YXRlIGdsb2JhbCB2YXJpYWJsZSB0byBzaGFyZSBiZXR3ZWVuIGxpc3RlbmVycyBhbmQgbGlzdGVuZWVzLlxuICB2YXIgX2xpc3RlbmluZztcblxuICAvLyBJdGVyYXRlcyBvdmVyIHRoZSBzdGFuZGFyZCBgZXZlbnQsIGNhbGxiYWNrYCAoYXMgd2VsbCBhcyB0aGUgZmFuY3kgbXVsdGlwbGVcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuICAvLyBtYXBzIGB7ZXZlbnQ6IGNhbGxiYWNrfWApLlxuICB2YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCAmJiAnY29udGV4dCcgaW4gb3B0cyAmJiBvcHRzLmNvbnRleHQgPT09IHZvaWQgMCkgb3B0cy5jb250ZXh0ID0gY2FsbGJhY2s7XG4gICAgICBmb3IgKG5hbWVzID0gXy5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIGV2ZW50cyA9IGV2ZW50c0FwaShpdGVyYXRlZSwgZXZlbnRzLCBuYW1lc1tpXSwgbmFtZVtuYW1lc1tpXV0sIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiBldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXMgYnkgZGVsZWdhdGluZyB0aGVtIGluZGl2aWR1YWxseS5cbiAgICAgIGZvciAobmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gaXRlcmF0ZWUoZXZlbnRzLCBuYW1lc1tpXSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5hbGx5LCBzdGFuZGFyZCBldmVudHMuXG4gICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICBFdmVudHMub24gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvbkFwaSwgdGhpcy5fZXZlbnRzIHx8IHt9LCBuYW1lLCBjYWxsYmFjaywge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGN0eDogdGhpcyxcbiAgICAgIGxpc3RlbmluZzogX2xpc3RlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKF9saXN0ZW5pbmcpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIGxpc3RlbmVyc1tfbGlzdGVuaW5nLmlkXSA9IF9saXN0ZW5pbmc7XG4gICAgICAvLyBBbGxvdyB0aGUgbGlzdGVuaW5nIHRvIHVzZSBhIGNvdW50ZXIsIGluc3RlYWQgb2YgdHJhY2tpbmdcbiAgICAgIC8vIGNhbGxiYWNrcyBmb3IgbGlicmFyeSBpbnRlcm9wXG4gICAgICBfbGlzdGVuaW5nLmludGVyb3AgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gLiBUZWxsICp0aGlzKiBvYmplY3QgdG8gbGlzdGVuIHRvXG4gIC8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuICAvLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbiAgRXZlbnRzLmxpc3RlblRvID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghb2JqKSByZXR1cm4gdGhpcztcbiAgICB2YXIgaWQgPSBvYmouX2xpc3RlbklkIHx8IChvYmouX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XG4gICAgdmFyIGxpc3RlbmluZyA9IF9saXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF07XG5cbiAgICAvLyBUaGlzIG9iamVjdCBpcyBub3QgbGlzdGVuaW5nIHRvIGFueSBvdGhlciBldmVudHMgb24gYG9iamAgeWV0LlxuICAgIC8vIFNldHVwIHRoZSBuZWNlc3NhcnkgcmVmZXJlbmNlcyB0byB0cmFjayB0aGUgbGlzdGVuaW5nIGNhbGxiYWNrcy5cbiAgICBpZiAoIWxpc3RlbmluZykge1xuICAgICAgdGhpcy5fbGlzdGVuSWQgfHwgKHRoaXMuX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmluZyA9IF9saXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF0gPSBuZXcgTGlzdGVuaW5nKHRoaXMsIG9iaik7XG4gICAgfVxuXG4gICAgLy8gQmluZCBjYWxsYmFja3Mgb24gb2JqLlxuICAgIHZhciBlcnJvciA9IHRyeUNhdGNoT24ob2JqLCBuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgX2xpc3RlbmluZyA9IHZvaWQgMDtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgLy8gSWYgdGhlIHRhcmdldCBvYmogaXMgbm90IEJhY2tib25lLkV2ZW50cywgdHJhY2sgZXZlbnRzIG1hbnVhbGx5LlxuICAgIGlmIChsaXN0ZW5pbmcuaW50ZXJvcCkgbGlzdGVuaW5nLm9uKG5hbWUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9uQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdIHx8IChldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLmNvdW50Kys7XG5cbiAgICAgIGhhbmRsZXJzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IGN0eCwgbGlzdGVuaW5nOiBsaXN0ZW5pbmd9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvLyBBbiB0cnktY2F0Y2ggZ3VhcmRlZCAjb24gZnVuY3Rpb24sIHRvIHByZXZlbnQgcG9pc29uaW5nIHRoZSBnbG9iYWxcbiAgLy8gYF9saXN0ZW5pbmdgIHZhcmlhYmxlLlxuICB2YXIgdHJ5Q2F0Y2hPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgb2JqLm9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vZmYgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob2ZmQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRlbGwgdGhpcyBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZWl0aGVyIHNwZWNpZmljIGV2ZW50cyAuLi4gb3JcbiAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgRXZlbnRzLnN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG87XG4gICAgaWYgKCFsaXN0ZW5pbmdUbykgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaWRzID0gb2JqID8gW29iai5fbGlzdGVuSWRdIDogXy5rZXlzKGxpc3RlbmluZ1RvKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkc1tpXV07XG5cbiAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICBpZiAoIWxpc3RlbmluZykgYnJlYWs7XG5cbiAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIGlmIChsaXN0ZW5pbmcuaW50ZXJvcCkgbGlzdGVuaW5nLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkobGlzdGVuaW5nVG8pKSB0aGlzLl9saXN0ZW5pbmdUbyA9IHZvaWQgMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb2ZmQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm47XG5cbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgbGlzdGVuZXJzID0gb3B0aW9ucy5saXN0ZW5lcnM7XG4gICAgdmFyIGkgPSAwLCBuYW1lcztcblxuICAgIC8vIERlbGV0ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjb250ZXh0ICYmICFjYWxsYmFjaykge1xuICAgICAgZm9yIChuYW1lcyA9IF8ua2V5cyhsaXN0ZW5lcnMpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW25hbWVzW2ldXS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKGV2ZW50cyk7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICAvLyBCYWlsIG91dCBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHN0b3JlZC5cbiAgICAgIGlmICghaGFuZGxlcnMpIGJyZWFrO1xuXG4gICAgICAvLyBGaW5kIGFueSByZW1haW5pbmcgZXZlbnRzLlxuICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2pdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrLl9jYWxsYmFjayB8fFxuICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQgIT09IGhhbmRsZXIuY29udGV4dFxuICAgICAgICApIHtcbiAgICAgICAgICByZW1haW5pbmcucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVwbGFjZSBldmVudHMgaWYgdGhlcmUgYXJlIGFueSByZW1haW5pbmcuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGgpIHtcbiAgICAgICAgZXZlbnRzW25hbWVdID0gcmVtYWluaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0cyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuIElmIG11bHRpcGxlIGV2ZW50c1xuICAvLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbiAgLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9uY2UgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIC8vIE1hcCB0aGUgZXZlbnQgaW50byBhIGB7ZXZlbnQ6IG9uY2V9YCBvYmplY3QuXG4gICAgdmFyIGV2ZW50cyA9IGV2ZW50c0FwaShvbmNlTWFwLCB7fSwgbmFtZSwgY2FsbGJhY2ssIHRoaXMub2ZmLmJpbmQodGhpcykpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgY29udGV4dCA9PSBudWxsKSBjYWxsYmFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25jZWAuXG4gIEV2ZW50cy5saXN0ZW5Ub09uY2UgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgdGhpcy5zdG9wTGlzdGVuaW5nLmJpbmQodGhpcywgb2JqKSk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuVG8ob2JqLCBldmVudHMpO1xuICB9O1xuXG4gIC8vIFJlZHVjZXMgdGhlIGV2ZW50IGNhbGxiYWNrcyBpbnRvIGEgbWFwIG9mIGB7ZXZlbnQ6IG9uY2VXcmFwcGVyfWAuXG4gIC8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG4gIHZhciBvbmNlTWFwID0gZnVuY3Rpb24obWFwLCBuYW1lLCBjYWxsYmFjaywgb2ZmZXIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBvbmNlID0gbWFwW25hbWVdID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBvZmZlcihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbiAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gIC8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbiAgRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEEgbGlzdGVuaW5nIGNsYXNzIHRoYXQgdHJhY2tzIGFuZCBjbGVhbnMgdXAgbWVtb3J5IGJpbmRpbmdzXG4gIC8vIHdoZW4gYWxsIGNhbGxiYWNrcyBoYXZlIGJlZW4gb2ZmZWQuXG4gIHZhciBMaXN0ZW5pbmcgPSBmdW5jdGlvbihsaXN0ZW5lciwgb2JqKSB7XG4gICAgdGhpcy5pZCA9IGxpc3RlbmVyLl9saXN0ZW5JZDtcbiAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gICAgdGhpcy5pbnRlcm9wID0gdHJ1ZTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLl9ldmVudHMgPSB2b2lkIDA7XG4gIH07XG5cbiAgTGlzdGVuaW5nLnByb3RvdHlwZS5vbiA9IEV2ZW50cy5vbjtcblxuICAvLyBPZmZzIGEgY2FsbGJhY2sgKG9yIHNldmVyYWwpLlxuICAvLyBVc2VzIGFuIG9wdGltaXplZCBjb3VudGVyIGlmIHRoZSBsaXN0ZW5lZSB1c2VzIEJhY2tib25lLkV2ZW50cy5cbiAgLy8gT3RoZXJ3aXNlLCBmYWxscyBiYWNrIHRvIG1hbnVhbCB0cmFja2luZyB0byBzdXBwb3J0IGV2ZW50c1xuICAvLyBsaWJyYXJ5IGludGVyb3AuXG4gIExpc3RlbmluZy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2xlYW51cDtcbiAgICBpZiAodGhpcy5pbnRlcm9wKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob2ZmQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IHZvaWQgMCxcbiAgICAgICAgbGlzdGVuZXJzOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cCA9ICF0aGlzLl9ldmVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgIGNsZWFudXAgPSB0aGlzLmNvdW50ID09PSAwO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cCkgdGhpcy5jbGVhbnVwKCk7XG4gIH07XG5cbiAgLy8gQ2xlYW5zIHVwIG1lbW9yeSBiaW5kaW5ncyBiZXR3ZWVuIHRoZSBsaXN0ZW5lciBhbmQgdGhlIGxpc3RlbmVlLlxuICBMaXN0ZW5pbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5saXN0ZW5lci5fbGlzdGVuaW5nVG9bdGhpcy5vYmouX2xpc3RlbklkXTtcbiAgICBpZiAoIXRoaXMuaW50ZXJvcCkgZGVsZXRlIHRoaXMub2JqLl9saXN0ZW5lcnNbdGhpcy5pZF07XG4gIH07XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgLy8gd2FudCBnbG9iYWwgXCJwdWJzdWJcIiBpbiBhIGNvbnZlbmllbnQgcGxhY2UuXG4gIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gIC8vIEJhY2tib25lLk1vZGVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4gIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAvLyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgYXNzaWduZWQgZm9yIHlvdS5cbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCh0aGlzLmNpZFByZWZpeCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMuY29sbGVjdGlvbikgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IHRoaXMucGFyc2UoYXR0cnMsIG9wdGlvbnMpIHx8IHt9O1xuICAgIHZhciBkZWZhdWx0cyA9IF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpO1xuICAgIGF0dHJzID0gXy5kZWZhdWx0cyhfLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGF0dHJzKSwgZGVmYXVsdHMpO1xuICAgIHRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBdHRhY2ggYWxsIGluaGVyaXRhYmxlIG1ldGhvZHMgdG8gdGhlIE1vZGVsIHByb3RvdHlwZS5cbiAgXy5leHRlbmQoTW9kZWwucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEEgaGFzaCBvZiBhdHRyaWJ1dGVzIHdob3NlIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZhbHVlIGRpZmZlci5cbiAgICBjaGFuZ2VkOiBudWxsLFxuXG4gICAgLy8gVGhlIHZhbHVlIHJldHVybmVkIGR1cmluZyB0aGUgbGFzdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICB2YWxpZGF0aW9uRXJyb3I6IG51bGwsXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBuYW1lIGZvciB0aGUgSlNPTiBgaWRgIGF0dHJpYnV0ZSBpcyBgXCJpZFwiYC4gTW9uZ29EQiBhbmRcbiAgICAvLyBDb3VjaERCIHVzZXJzIG1heSB3YW50IHRvIHNldCB0aGlzIHRvIGBcIl9pZFwiYC5cbiAgICBpZEF0dHJpYnV0ZTogJ2lkJyxcblxuICAgIC8vIFRoZSBwcmVmaXggaXMgdXNlZCB0byBjcmVhdGUgdGhlIGNsaWVudCBpZCB3aGljaCBpcyB1c2VkIHRvIGlkZW50aWZ5IG1vZGVscyBsb2NhbGx5LlxuICAgIC8vIFlvdSBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGlmIHlvdSdyZSBleHBlcmllbmNpbmcgbmFtZSBjbGFzaGVzIHdpdGggbW9kZWwgaWRzLlxuICAgIGNpZFByZWZpeDogJ2MnLFxuXG4gICAgLy8gcHJlaW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBZb3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggYSBmdW5jdGlvblxuICAgIC8vIG9yIG9iamVjdC4gIHByZWluaXRpYWxpemUgd2lsbCBydW4gYmVmb3JlIGFueSBpbnN0YW50aWF0aW9uIGxvZ2ljIGlzIHJ1biBpbiB0aGUgTW9kZWwuXG4gICAgcHJlaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTcGVjaWFsLWNhc2VkIHByb3h5IHRvIHVuZGVyc2NvcmUncyBgXy5tYXRjaGVzYCBtZXRob2QuXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiAhIV8uaXRlcmF0ZWUoYXR0cnMsIHRoaXMpKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAvLyBSdW4gdmFsaWRhdGlvbi5cbiAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICAgIHZhciB1bnNldCAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHZhciBzaWxlbnQgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICB2YXIgY2hhbmdlcyAgICA9IFtdO1xuICAgICAgdmFyIGNoYW5naW5nICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgICAgdmFyIHByZXYgICAgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB7XG4gICAgICAgIHZhciBwcmV2SWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlSWQnLCB0aGlzLCBwcmV2SWQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICB2YXIgaGFzQ2hhbmdlZDtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICB2YXIgdmFsID0gZGlmZlthdHRyXTtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sIHZhbCkpIGNvbnRpbnVlO1xuICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNDaGFuZ2VkID8gY2hhbmdlZCA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLCBtZXJnaW5nIHRoZSByZXNwb25zZSB3aXRoIHRoZSBtb2RlbCdzXG4gICAgLy8gbG9jYWwgYXR0cmlidXRlcy4gQW55IGNoYW5nZWQgYXR0cmlidXRlcyB3aWxsIHRyaWdnZXIgYSBcImNoYW5nZVwiIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3BhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICghbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWUsIHBhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhd2FpdCkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHNlcnZlci1zaWRlIHNhdmUsIHRoZSBjbGllbnQgaXMgKG9wdGlvbmFsbHkpXG4gICAgICAvLyB1cGRhdGVkIHdpdGggdGhlIHNlcnZlci1zaWRlIHN0YXRlLlxuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBhdHRyaWJ1dGVzIGFyZSByZXN0b3JlZCBkdXJpbmcgc3luY2hyb25vdXMgc2F2ZXMuXG4gICAgICAgIG1vZGVsLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBvcHRpb25zLnBhcnNlID8gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucykgOiByZXNwO1xuICAgICAgICBpZiAod2FpdCkgc2VydmVyQXR0cnMgPSBfLmV4dGVuZCh7fSwgYXR0cnMsIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKHNlcnZlckF0dHJzICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAgdG8gcHJvcGVybHkgZmluZCBuZXcgaWRzLlxuICAgICAgaWYgKGF0dHJzICYmIHdhaXQpIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG5cbiAgICAgIHZhciBtZXRob2QgPSB0aGlzLmlzTmV3KCkgPyAnY3JlYXRlJyA6IG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZSc7XG4gICAgICBpZiAobWV0aG9kID09PSAncGF0Y2gnICYmICFvcHRpb25zLmF0dHJzKSBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcblxuICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc3RvcExpc3RlbmluZygpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdkZXN0cm95JywgbW9kZWwsIG1vZGVsLmNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAod2FpdCkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1vZGVsLmlzTmV3KCkpIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgeGhyID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSB7XG4gICAgICAgIF8uZGVmZXIob3B0aW9ucy5zdWNjZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghd2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICB2YXIgaWQgPSB0aGlzLmdldCh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJykgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cbiAgICAvLyB0aGUgbW9kZWwuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyB0aGUgcmVzcG9uc2UgYWxvbmcuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gQSBtb2RlbCBpcyBuZXcgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2F2ZWQgdG8gdGhlIHNlcnZlciwgYW5kIGxhY2tzIGFuIGlkLlxuICAgIGlzTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXModGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dmFsaWRhdGU6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gIC8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbiAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gIC8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbiAgdmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHRhaWxbaV0gPSBhcnJheVtpICsgYXRdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaSArIGF0XSA9IGluc2VydFtpXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykgYXJyYXlbaSArIGxlbmd0aCArIGF0XSA9IHRhaWxbaV07XG4gIH07XG5cbiAgLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cbiAgXy5leHRlbmQoQ29sbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgbW9kZWwgZm9yIGEgY29sbGVjdGlvbiBpcyBqdXN0IGEgKipCYWNrYm9uZS5Nb2RlbCoqLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gbW9zdCBjYXNlcy5cbiAgICBtb2RlbDogTW9kZWwsXG5cblxuICAgIC8vIHByZWluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gWW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIGEgZnVuY3Rpb25cbiAgICAvLyBvciBvYmplY3QuICBwcmVpbml0aWFsaXplIHdpbGwgcnVuIGJlZm9yZSBhbnkgaW5zdGFudGlhdGlvbiBsb2dpYyBpcyBydW4gaW4gdGhlIENvbGxlY3Rpb24uXG4gICAgcHJlaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC4gYG1vZGVsc2AgbWF5IGJlIEJhY2tib25lXG4gICAgLy8gTW9kZWxzIG9yIHJhdyBKYXZhU2NyaXB0IG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIE1vZGVscywgb3IgYW55XG4gICAgLy8gY29tYmluYXRpb24gb2YgdGhlIHR3by5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IG1vZGVscy5zbGljZSgpO1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVNb2RlbHMobW9kZWxzLCBvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgcmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFuZ2VzID0ge2FkZGVkOiBbXSwgbWVyZ2VkOiBbXSwgcmVtb3ZlZDogcmVtb3ZlZH07XG4gICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2luZ3VsYXIgPyByZW1vdmVkWzBdIDogcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RlbHMgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIHNldE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgJiYgIXRoaXMuX2lzTW9kZWwobW9kZWxzKSkge1xuICAgICAgICBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucykgfHwgW107XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcblxuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIGlmIChhdCAhPSBudWxsKSBhdCA9ICthdDtcbiAgICAgIGlmIChhdCA+IHRoaXMubGVuZ3RoKSBhdCA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKGF0IDwgMCkgYXQgKz0gdGhpcy5sZW5ndGggKyAxO1xuXG4gICAgICB2YXIgc2V0ID0gW107XG4gICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgIHZhciB0b01lcmdlID0gW107XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHZhciBtb2RlbE1hcCA9IHt9O1xuXG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgICB2YXIgbWVyZ2UgPSBvcHRpb25zLm1lcmdlO1xuICAgICAgdmFyIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuXG4gICAgICB2YXIgc29ydCA9IGZhbHNlO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIGF0ID09IG51bGwgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG5cbiAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICB2YXIgbW9kZWwsIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldO1xuXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KG1vZGVsKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgaWYgKG1lcmdlICYmIG1vZGVsICE9PSBleGlzdGluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5faXNNb2RlbChtb2RlbCkgPyBtb2RlbC5hdHRyaWJ1dGVzIDogbW9kZWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdG9NZXJnZS5wdXNoKGV4aXN0aW5nKTtcbiAgICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCkgc29ydCA9IGV4aXN0aW5nLmhhc0NoYW5nZWQoc29ydEF0dHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW2V4aXN0aW5nLmNpZF0pIHtcbiAgICAgICAgICAgIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgc2V0LnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1vZGVsTWFwW21vZGVsLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgc2V0LnB1c2gobW9kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgc3RhbGUgbW9kZWxzLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbHNbaV07XG4gICAgICAgICAgaWYgKCFtb2RlbE1hcFttb2RlbC5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLl9yZW1vdmVNb2RlbHModG9SZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWUgaWYgc29ydGluZyBpcyBuZWVkZWQsIHVwZGF0ZSBgbGVuZ3RoYCBhbmQgc3BsaWNlIGluIG5ldyBtb2RlbHMuXG4gICAgICB2YXIgb3JkZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgcmVwbGFjZSA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlO1xuICAgICAgaWYgKHNldC5sZW5ndGggJiYgcmVwbGFjZSkge1xuICAgICAgICBvcmRlckNoYW5nZWQgPSB0aGlzLmxlbmd0aCAhPT0gc2V0Lmxlbmd0aCB8fCBfLnNvbWUodGhpcy5tb2RlbHMsIGZ1bmN0aW9uKG0sIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG0gIT09IHNldFtpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICBzcGxpY2UodGhpcy5tb2RlbHMsIHNldCwgMCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCB0b0FkZCwgYXQgPT0gbnVsbCA/IHRoaXMubGVuZ3RoIDogYXQpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydC91cGRhdGUgZXZlbnRzLlxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXQgIT0gbnVsbCkgb3B0aW9ucy5pbmRleCA9IGF0ICsgaTtcbiAgICAgICAgICBtb2RlbCA9IHRvQWRkW2ldO1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydCB8fCBvcmRlckNoYW5nZWQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IHRvUmVtb3ZlLmxlbmd0aCB8fCB0b01lcmdlLmxlbmd0aCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhbmdlcyA9IHtcbiAgICAgICAgICAgIGFkZGVkOiB0b0FkZCxcbiAgICAgICAgICAgIHJlbW92ZWQ6IHRvUmVtb3ZlLFxuICAgICAgICAgICAgbWVyZ2VkOiB0b01lcmdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgYWRkZWQgKG9yIG1lcmdlZCkgbW9kZWwgKG9yIG1vZGVscykuXG4gICAgICByZXR1cm4gc2luZ3VsYXIgPyBtb2RlbHNbMF0gOiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIFdoZW4geW91IGhhdmUgbW9yZSBpdGVtcyB0aGFuIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgaW5kaXZpZHVhbGx5LFxuICAgIC8vIHlvdSBjYW4gcmVzZXQgdGhlIGVudGlyZSBzZXQgd2l0aCBhIG5ldyBsaXN0IG9mIG1vZGVscywgd2l0aG91dCBmaXJpbmdcbiAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXG4gICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZSh0aGlzLm1vZGVsc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnByZXZpb3VzTW9kZWxzID0gdGhpcy5tb2RlbHM7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgbW9kZWxzID0gdGhpcy5hZGQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdyZXNldCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwdXNoOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IHRoaXMubGVuZ3RofSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcG9wOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2xpY2Ugb3V0IGEgc3ViLWFycmF5IG9mIG1vZGVscyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLm1vZGVscywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGlkLCBjaWQsIG1vZGVsIG9iamVjdCB3aXRoIGlkIG9yIGNpZFxuICAgIC8vIHByb3BlcnRpZXMsIG9yIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgdGhyb3VnaCBtb2RlbElkLlxuICAgIGdldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8XG4gICAgICAgIHRoaXMuX2J5SWRbdGhpcy5tb2RlbElkKHRoaXMuX2lzTW9kZWwob2JqKSA/IG9iai5hdHRyaWJ1dGVzIDogb2JqLCBvYmouaWRBdHRyaWJ1dGUpXSB8fFxuICAgICAgICBvYmouY2lkICYmIHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBtb2RlbCBpcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBoYXM6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KG9iaikgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgIC8vIGBmaWx0ZXJgLlxuICAgIHdoZXJlOiBmdW5jdGlvbihhdHRycywgZmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGF0dHJzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgIGlmICghY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbXBhcmF0b3IubGVuZ3RoO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb21wYXJhdG9yKSkgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuYmluZCh0aGlzKTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAobGVuZ3RoID09PSAxIHx8IF8uaXNTdHJpbmcoY29tcGFyYXRvcikpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeShjb21wYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvcnQoY29tcGFyYXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQbHVjayBhbiBhdHRyaWJ1dGUgZnJvbSBlYWNoIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBsdWNrOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoYXR0ciArICcnKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgLy8gY29sbGVjdGlvbiB3aGVuIHRoZXkgYXJyaXZlLiBJZiBgcmVzZXQ6IHRydWVgIGlzIHBhc3NlZCwgdGhlIHJlc3BvbnNlXG4gICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3BhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBjb2xsZWN0aW9uLnRyaWdnZXIoJ3N5bmMnLCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcbiAgICAgIG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghd2FpdCkgdGhpcy5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihtLCByZXNwLCBjYWxsYmFja09wdHMpIHtcbiAgICAgICAgaWYgKHdhaXQpIGNvbGxlY3Rpb24uYWRkKG0sIGNhbGxiYWNrT3B0cyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwoY2FsbGJhY2tPcHRzLmNvbnRleHQsIG0sIHJlc3AsIGNhbGxiYWNrT3B0cyk7XG4gICAgICB9O1xuICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyBpdCB0aHJvdWdoLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzLCB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBjb21wYXJhdG9yOiB0aGlzLmNvbXBhcmF0b3JcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEZWZpbmUgaG93IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBtb2RlbElkOiBmdW5jdGlvbihhdHRycywgaWRBdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpZEF0dHJpYnV0ZSB8fCB0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBtb2RlbHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JdGVyYXRvcih0aGlzLCBJVEVSQVRPUl9WQUxVRVMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW4gaXRlcmF0b3Igb2YgYWxsIG1vZGVsIElEcyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JdGVyYXRvcih0aGlzLCBJVEVSQVRPUl9LRVlTKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBbSUQsIG1vZGVsXSB0dXBsZXMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfS0VZU1ZBTFVFUyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2lzTW9kZWwoYXR0cnMpKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcblxuICAgICAgdmFyIG1vZGVsO1xuICAgICAgaWYgKHRoaXMubW9kZWwucHJvdG90eXBlKSB7XG4gICAgICAgIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRVMgY2xhc3MgbWV0aG9kcyBkaWRuJ3QgaGF2ZSBwcm90b3R5cGVcbiAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzIGJlZm9yZSB0cmlnZ2VyaW5nICdyZW1vdmUnIGV2ZW50IHRvIHByZXZlbnQgYW5cbiAgICAgICAgLy8gaW5maW5pdGUgbG9vcC4gIzM2OTNcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZWQucHVzaChtb2RlbCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLy8gTWV0aG9kIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1vZGVsIGZvclxuICAgIC8vIHRoZSBwdXJwb3NlcyBvZiBhZGRpbmcgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgX2lzTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWwgaW5zdGFuY2VvZiBNb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX2FkZFJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX3JlbW92ZVJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcywgbW9kZWwuaWRBdHRyaWJ1dGUpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcbiAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKSBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cbiAgICAvLyBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgLy8gZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgIC8vIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxuICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JykgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2VJZCcpIHtcbiAgICAgICAgICB2YXIgcHJldklkID0gdGhpcy5tb2RlbElkKG1vZGVsLnByZXZpb3VzQXR0cmlidXRlcygpLCBtb2RlbC5pZEF0dHJpYnV0ZSk7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBEZWZpbmluZyBhbiBAQGl0ZXJhdG9yIG1ldGhvZCBpbXBsZW1lbnRzIEphdmFTY3JpcHQncyBJdGVyYWJsZSBwcm90b2NvbC5cbiAgLy8gSW4gbW9kZXJuIEVTMjAxNSBicm93c2VycywgdGhpcyB2YWx1ZSBpcyBmb3VuZCBhdCBTeW1ib2wuaXRlcmF0b3IuXG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyICQkaXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgaWYgKCQkaXRlcmF0b3IpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVskJGl0ZXJhdG9yXSA9IENvbGxlY3Rpb24ucHJvdG90eXBlLnZhbHVlcztcbiAgfVxuXG4gIC8vIENvbGxlY3Rpb25JdGVyYXRvclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIENvbGxlY3Rpb25JdGVyYXRvciBpbXBsZW1lbnRzIEphdmFTY3JpcHQncyBJdGVyYXRvciBwcm90b2NvbCwgYWxsb3dpbmcgdGhlXG4gIC8vIHVzZSBvZiBgZm9yIG9mYCBsb29wcyBpbiBtb2Rlcm4gYnJvd3NlcnMgYW5kIGludGVyb3BlcmF0aW9uIGJldHdlZW5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvbiBhbmQgb3RoZXIgSmF2YVNjcmlwdCBmdW5jdGlvbnMgYW5kIHRoaXJkLXBhcnR5IGxpYnJhcmllc1xuICAvLyB3aGljaCBjYW4gb3BlcmF0ZSBvbiBJdGVyYWJsZXMuXG4gIHZhciBDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBraW5kKSB7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgdGhpcy5fa2luZCA9IGtpbmQ7XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICB9O1xuXG4gIC8vIFRoaXMgXCJlbnVtXCIgZGVmaW5lcyB0aGUgdGhyZWUgcG9zc2libGUga2luZHMgb2YgdmFsdWVzIHdoaWNoIGNhbiBiZSBlbWl0dGVkXG4gIC8vIGJ5IGEgQ29sbGVjdGlvbkl0ZXJhdG9yIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgdmFsdWVzKCksIGtleXMoKSBhbmQgZW50cmllcygpXG4gIC8vIG1ldGhvZHMgb24gQ29sbGVjdGlvbiwgcmVzcGVjdGl2ZWx5LlxuICB2YXIgSVRFUkFUT1JfVkFMVUVTID0gMTtcbiAgdmFyIElURVJBVE9SX0tFWVMgPSAyO1xuICB2YXIgSVRFUkFUT1JfS0VZU1ZBTFVFUyA9IDM7XG5cbiAgLy8gQWxsIEl0ZXJhdG9ycyBzaG91bGQgdGhlbXNlbHZlcyBiZSBJdGVyYWJsZS5cbiAgaWYgKCQkaXRlcmF0b3IpIHtcbiAgICBDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlWyQkaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG5cbiAgQ29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24pIHtcblxuICAgICAgLy8gT25seSBjb250aW51ZSBpdGVyYXRpbmcgaWYgdGhlIGl0ZXJhdGVkIGNvbGxlY3Rpb24gaXMgbG9uZyBlbm91Z2guXG4gICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLl9jb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLl9jb2xsZWN0aW9uLmF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgdGhpcy5faW5kZXgrKztcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSB2YWx1ZSBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIHZhbHVlcyBzaG91bGQgYmUgaXRlcmF0ZWQuXG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2tpbmQgPT09IElURVJBVE9SX1ZBTFVFUykge1xuICAgICAgICAgIHZhbHVlID0gbW9kZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5fY29sbGVjdGlvbi5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgICBpZiAodGhpcy5fa2luZCA9PT0gSVRFUkFUT1JfS0VZUykge1xuICAgICAgICAgICAgdmFsdWUgPSBpZDtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBJVEVSQVRPUl9LRVlTVkFMVUVTXG4gICAgICAgICAgICB2YWx1ZSA9IFtpZCwgbW9kZWxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2V9O1xuICAgICAgfVxuXG4gICAgICAvLyBPbmNlIGV4aGF1c3RlZCwgcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gc28gZnV0dXJlXG4gICAgICAvLyBjYWxscyB0byB0aGUgbmV4dCBtZXRob2QgYWx3YXlzIHJldHVybiBkb25lLlxuICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZhbHVlOiB2b2lkIDAsIGRvbmU6IHRydWV9O1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lIFZpZXdzIGFyZSBhbG1vc3QgbW9yZSBjb252ZW50aW9uIHRoYW4gdGhleSBhcmUgYWN0dWFsIGNvZGUuIEEgVmlld1xuICAvLyBpcyBzaW1wbHkgYSBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBsb2dpY2FsIGNodW5rIG9mIFVJIGluIHRoZVxuICAvLyBET00uIFRoaXMgbWlnaHQgYmUgYSBzaW5nbGUgaXRlbSwgYW4gZW50aXJlIGxpc3QsIGEgc2lkZWJhciBvciBwYW5lbCwgb3JcbiAgLy8gZXZlbiB0aGUgc3Vycm91bmRpbmcgZnJhbWUgd2hpY2ggd3JhcHMgeW91ciB3aG9sZSBhcHAuIERlZmluaW5nIGEgY2h1bmsgb2ZcbiAgLy8gVUkgYXMgYSAqKlZpZXcqKiBhbGxvd3MgeW91IHRvIGRlZmluZSB5b3VyIERPTSBldmVudHMgZGVjbGFyYXRpdmVseSwgd2l0aG91dFxuICAvLyBoYXZpbmcgdG8gd29ycnkgYWJvdXQgcmVuZGVyIG9yZGVyIC4uLiBhbmQgbWFrZXMgaXQgZWFzeSBmb3IgdGhlIHZpZXcgdG9cbiAgLy8gcmVhY3QgdG8gc3BlY2lmaWMgY2hhbmdlcyBpbiB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbHMuXG5cbiAgLy8gQ3JlYXRpbmcgYSBCYWNrYm9uZS5WaWV3IGNyZWF0ZXMgaXRzIGluaXRpYWwgZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBET00sXG4gIC8vIGlmIGFuIGV4aXN0aW5nIGVsZW1lbnQgaXMgbm90IHByb3ZpZGVkLi4uXG4gIHZhciBWaWV3ID0gQmFja2JvbmUuVmlldyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ3ZpZXcnKTtcbiAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgdmlld09wdGlvbnMpKTtcbiAgICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IHRvIHNwbGl0IGtleXMgZm9yIGBkZWxlZ2F0ZWAuXG4gIHZhciBkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIgPSAvXihcXFMrKVxccyooLiopJC87XG5cbiAgLy8gTGlzdCBvZiB2aWV3IG9wdGlvbnMgdG8gYmUgc2V0IGFzIHByb3BlcnRpZXMuXG4gIHZhciB2aWV3T3B0aW9ucyA9IFsnbW9kZWwnLCAnY29sbGVjdGlvbicsICdlbCcsICdpZCcsICdhdHRyaWJ1dGVzJywgJ2NsYXNzTmFtZScsICd0YWdOYW1lJywgJ2V2ZW50cyddO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5WaWV3KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoVmlldy5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgYHRhZ05hbWVgIG9mIGEgVmlldydzIGVsZW1lbnQgaXMgYFwiZGl2XCJgLlxuICAgIHRhZ05hbWU6ICdkaXYnLFxuXG4gICAgLy8galF1ZXJ5IGRlbGVnYXRlIGZvciBlbGVtZW50IGxvb2t1cCwgc2NvcGVkIHRvIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlXG4gICAgLy8gY3VycmVudCB2aWV3LiBUaGlzIHNob3VsZCBiZSBwcmVmZXJyZWQgdG8gZ2xvYmFsIGxvb2t1cHMgd2hlcmUgcG9zc2libGUuXG4gICAgJDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gcHJlaW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBZb3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggYSBmdW5jdGlvblxuICAgIC8vIG9yIG9iamVjdC4gIHByZWluaXRpYWxpemUgd2lsbCBydW4gYmVmb3JlIGFueSBpbnN0YW50aWF0aW9uIGxvZ2ljIGlzIHJ1biBpbiB0aGUgVmlld1xuICAgIHByZWluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIG1ldGhvZC5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gUHJveHkgQmFja2JvbmUgY2xhc3MgbWV0aG9kcyB0byBVbmRlcnNjb3JlIGZ1bmN0aW9ucywgd3JhcHBpbmcgdGhlIG1vZGVsJ3NcbiAgLy8gYGF0dHJpYnV0ZXNgIG9iamVjdCBvciBjb2xsZWN0aW9uJ3MgYG1vZGVsc2AgYXJyYXkgYmVoaW5kIHRoZSBzY2VuZXMuXG4gIC8vXG4gIC8vIGNvbGxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC5nZXQoJ2FnZScpID4gMTAgfSk7XG4gIC8vIGNvbGxlY3Rpb24uZWFjaCh0aGlzLmFkZFZpZXcpO1xuICAvL1xuICAvLyBgRnVuY3Rpb24jYXBwbHlgIGNhbiBiZSBzbG93IHNvIHdlIHVzZSB0aGUgbWV0aG9kJ3MgYXJnIGNvdW50LCBpZiB3ZSBrbm93IGl0LlxuICB2YXIgYWRkTWV0aG9kID0gZnVuY3Rpb24oYmFzZSwgbGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIGNiKGl0ZXJhdGVlLCB0aGlzKSwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGRlZmF1bHRWYWwsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIGNiKGl0ZXJhdGVlLCB0aGlzKSwgZGVmYXVsdFZhbCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0uYXBwbHkoYmFzZSwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgYWRkVW5kZXJzY29yZU1ldGhvZHMgPSBmdW5jdGlvbihDbGFzcywgYmFzZSwgbWV0aG9kcywgYXR0cmlidXRlKSB7XG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICBpZiAoYmFzZVttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChiYXNlLCBsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGBjb2xsZWN0aW9uLnNvcnRCeSgnYXR0cicpYCBhbmQgYGNvbGxlY3Rpb24uZmluZFdoZXJlKHtpZDogMX0pYC5cbiAgdmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoXy5pc09iamVjdChpdGVyYXRlZSkgJiYgIWluc3RhbmNlLl9pc01vZGVsKGl0ZXJhdGVlKSkgcmV0dXJuIG1vZGVsTWF0Y2hlcihpdGVyYXRlZSk7XG4gICAgaWYgKF8uaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xuICB9O1xuICB2YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7Zm9yRWFjaDogMywgZWFjaDogMywgbWFwOiAzLCBjb2xsZWN0OiAzLCByZWR1Y2U6IDAsXG4gICAgZm9sZGw6IDAsIGluamVjdDogMCwgcmVkdWNlUmlnaHQ6IDAsIGZvbGRyOiAwLCBmaW5kOiAzLCBkZXRlY3Q6IDMsIGZpbHRlcjogMyxcbiAgICBzZWxlY3Q6IDMsIHJlamVjdDogMywgZXZlcnk6IDMsIGFsbDogMywgc29tZTogMywgYW55OiAzLCBpbmNsdWRlOiAzLCBpbmNsdWRlczogMyxcbiAgICBjb250YWluczogMywgaW52b2tlOiAwLCBtYXg6IDMsIG1pbjogMywgdG9BcnJheTogMSwgc2l6ZTogMSwgZmlyc3Q6IDMsXG4gICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICB3aXRob3V0OiAwLCBkaWZmZXJlbmNlOiAwLCBpbmRleE9mOiAzLCBzaHVmZmxlOiAxLCBsYXN0SW5kZXhPZjogMyxcbiAgICBpc0VtcHR5OiAxLCBjaGFpbjogMSwgc2FtcGxlOiAzLCBwYXJ0aXRpb246IDMsIGdyb3VwQnk6IDMsIGNvdW50Qnk6IDMsXG4gICAgc29ydEJ5OiAzLCBpbmRleEJ5OiAzLCBmaW5kSW5kZXg6IDMsIGZpbmRMYXN0SW5kZXg6IDN9O1xuXG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLCBtYXBwZWQgdG8gdGhlXG4gIC8vIG51bWJlciBvZiBhcmd1bWVudHMgdGhleSB0YWtlLlxuICB2YXIgbW9kZWxNZXRob2RzID0ge2tleXM6IDEsIHZhbHVlczogMSwgcGFpcnM6IDEsIGludmVydDogMSwgcGljazogMCxcbiAgICBvbWl0OiAwLCBjaGFpbjogMSwgaXNFbXB0eTogMX07XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuXG4gIF8uZWFjaChbXG4gICAgW0NvbGxlY3Rpb24sIGNvbGxlY3Rpb25NZXRob2RzLCAnbW9kZWxzJ10sXG4gICAgW01vZGVsLCBtb2RlbE1ldGhvZHMsICdhdHRyaWJ1dGVzJ11cbiAgXSwgZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIEJhc2UgPSBjb25maWdbMF0sXG4gICAgICAgIG1ldGhvZHMgPSBjb25maWdbMV0sXG4gICAgICAgIGF0dHJpYnV0ZSA9IGNvbmZpZ1syXTtcblxuICAgIEJhc2UubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBtYXBwaW5ncyA9IF8ucmVkdWNlKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG1lbW8sIG5hbWUpIHtcbiAgICAgICAgbWVtb1tuYW1lXSA9IDA7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwge30pO1xuICAgICAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQmFzZSwgb2JqLCBtYXBwaW5ncywgYXR0cmlidXRlKTtcbiAgICB9O1xuXG4gICAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQmFzZSwgXywgbWV0aG9kcywgYXR0cmlidXRlKTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIHByZWluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gWW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIGEgZnVuY3Rpb25cbiAgICAvLyBvciBvYmplY3QuICBwcmVpbml0aWFsaXplIHdpbGwgcnVuIGJlZm9yZSBhbnkgaW5zdGFudGlhdGlvbiBsb2dpYyBpcyBydW4gaW4gdGhlIFJvdXRlci5cbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgIC8vICAgICAgIC4uLlxuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghXy5pc1JlZ0V4cChyb3V0ZSkpIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzLCBuYW1lKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlci5hcHBseShyb3V0ZXIsIFsncm91dGU6JyArIG5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgcm91dGVyLnRyaWdnZXIoJ3JvdXRlJywgbmFtZSwgYXJncyk7XG4gICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGUgYSByb3V0ZSBoYW5kbGVyIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuICBUaGlzIGlzIGFuXG4gICAgLy8gZXhjZWxsZW50IHBsYWNlIHRvIGRvIHByZS1yb3V0ZSBzZXR1cCBvciBwb3N0LXJvdXRlIGNsZWFudXAuXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIG5hbWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIFNpbXBsZSBwcm94eSB0byBgQmFja2JvbmUuaGlzdG9yeWAgdG8gc2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFsbCBkZWZpbmVkIHJvdXRlcyB0byBgQmFja2JvbmUuaGlzdG9yeWAuIFdlIGhhdmUgdG8gcmV2ZXJzZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgcm91dGVzIGhlcmUgdG8gc3VwcG9ydCBiZWhhdmlvciB3aGVyZSB0aGUgbW9zdCBnZW5lcmFsXG4gICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cbiAgICBfYmluZFJvdXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucm91dGVzKSByZXR1cm47XG4gICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcbiAgICAgIHZhciByb3V0ZSwgcm91dGVzID0gXy5rZXlzKHRoaXMucm91dGVzKTtcbiAgICAgIHdoaWxlICgocm91dGUgPSByb3V0ZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIHJvdXRlIHN0cmluZyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLCBzdWl0YWJsZSBmb3IgbWF0Y2hpbmdcbiAgICAvLyBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2guXG4gICAgX3JvdXRlVG9SZWdFeHA6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW14vP10rKSc7XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyhbXj9dKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICcoPzpcXFxcPyhbXFxcXHNcXFxcU10qKSk/JCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcbiAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLmNoZWNrVXJsID0gdGhpcy5jaGVja1VybC5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYEhpc3RvcnlgIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cbiAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gIHZhciByb290U3RyaXBwZXIgPSAvXlxcLyt8XFwvKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKTtcbiAgICAgIHJldHVybiBwYXRoID09PSB0aGlzLnJvb3QgJiYgIXRoaXMuZ2V0U2VhcmNoKCk7XG4gICAgfSxcblxuICAgIC8vIERvZXMgdGhlIHBhdGhuYW1lIG1hdGNoIHRoZSByb290P1xuICAgIG1hdGNoUm9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQodGhpcy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB2YXIgcm9vdFBhdGggPSBwYXRoLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGggLSAxKSArICcvJztcbiAgICAgIHJldHVybiByb290UGF0aCA9PT0gdGhpcy5yb290O1xuICAgIH0sXG5cbiAgICAvLyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gYGxvY2F0aW9uLnBhdGhuYW1lYCBhcmUgcGVyY2VudCBlbmNvZGVkIHNvIHRoZXkncmVcbiAgICAvLyBkZWNvZGVkIGZvciBjb21wYXJpc29uLiBgJTI1YCBzaG91bGQgbm90IGJlIGRlY29kZWQgc2luY2UgaXQgbWF5IGJlIHBhcnRcbiAgICAvLyBvZiBhbiBlbmNvZGVkIHBhcmFtZXRlci5cbiAgICBkZWNvZGVGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUkkoZnJhZ21lbnQucmVwbGFjZSgvJTI1L2csICclMjUyNScpKTtcbiAgICB9LFxuXG4gICAgLy8gSW4gSUU2LCB0aGUgaGFzaCBmcmFnbWVudCBhbmQgc2VhcmNoIHBhcmFtcyBhcmUgaW5jb3JyZWN0IGlmIHRoZVxuICAgIC8vIGZyYWdtZW50IGNvbnRhaW5zIGA/YC5cbiAgICBnZXRTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKi8sICcnKS5tYXRjaCgvXFw/LisvKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHBhdGhuYW1lIGFuZCBzZWFyY2ggcGFyYW1zLCB3aXRob3V0IHRoZSByb290LlxuICAgIGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KFxuICAgICAgICB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5nZXRTZWFyY2goKVxuICAgICAgKS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc2xpY2UoMSkgOiBwYXRoO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQgZnJvbSB0aGUgcGF0aCBvciBoYXNoLlxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgaWYgKGZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSB8fCAhdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgIC8vIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChIaXN0b3J5LnN0YXJ0ZWQpIHRocm93IG5ldyBFcnJvcignQmFja2JvbmUuaGlzdG9yeSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhc0hhc2hDaGFuZ2UgICA9ICdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdyAmJiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSB2b2lkIDAgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gNyk7XG4gICAgICB0aGlzLl91c2VIYXNoQ2hhbmdlICAgPSB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5faGFzSGFzaENoYW5nZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKTtcbiAgICAgIHRoaXMuX3VzZVB1c2hTdGF0ZSAgICA9IHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmIHRoaXMuX2hhc1B1c2hTdGF0ZTtcbiAgICAgIHRoaXMuZnJhZ21lbnQgICAgICAgICA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHZhciByb290UGF0aCA9IHRoaXMucm9vdC5zbGljZSgwLCAtMSkgfHwgJy8nO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZShyb290UGF0aCArICcjJyArIHRoaXMuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0ZSh0aGlzLmdldEhhc2goKSwge3JlcGxhY2U6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFByb3h5IGFuIGlmcmFtZSB0byBoYW5kbGUgbG9jYXRpb24gZXZlbnRzIGlmIHRoZSBicm93c2VyIGRvZXNuJ3RcbiAgICAgIC8vIHN1cHBvcnQgdGhlIGBoYXNoY2hhbmdlYCBldmVudCwgSFRNTDUgaGlzdG9yeSwgb3IgdGhlIHVzZXIgd2FudHNcbiAgICAgIC8vIGBoYXNoQ2hhbmdlYCBidXQgbm90IGBwdXNoU3RhdGVgLlxuICAgICAgaWYgKCF0aGlzLl9oYXNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiAhdGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIHRoaXMuaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIC8vIFVzaW5nIGBhcHBlbmRDaGlsZGAgd2lsbCB0aHJvdyBvbiBJRSA8IDkgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCByZWFkeS5cbiAgICAgICAgdmFyIGlXaW5kb3cgPSBib2R5Lmluc2VydEJlZm9yZSh0aGlzLmlmcmFtZSwgYm9keS5maXJzdENoaWxkKS5jb250ZW50V2luZG93O1xuICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICBpV2luZG93LmxvY2F0aW9uLmhhc2ggPSAnIycgKyB0aGlzLmZyYWdtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgYWRkRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIHVzaW5nIHB1c2hTdGF0ZSBvciBoYXNoZXMsIGFuZCB3aGV0aGVyXG4gICAgICAvLyAnb25oYXNoY2hhbmdlJyBpcyBzdXBwb3J0ZWQsIGRldGVybWluZSBob3cgd2UgY2hlY2sgdGhlIFVSTCBzdGF0ZS5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZUhhc2hDaGFuZ2UgJiYgIXRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9jaGVja1VybEludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja1VybCwgdGhpcy5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEFkZCBhIGNyb3NzLXBsYXRmb3JtIGByZW1vdmVFdmVudExpc3RlbmVyYCBzaGltIGZvciBvbGRlciBicm93c2Vycy5cbiAgICAgIHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIHdpbmRvdyBsaXN0ZW5lcnMuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgaWZyYW1lIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmICh0aGlzLmlmcmFtZSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyB3aWxsIHRocm93IHdoZW4gY2xlYXJpbmcgYW4gdW5kZWZpbmVkIGludGVydmFsLlxuICAgICAgaWYgKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgcm91dGUgdG8gYmUgdGVzdGVkIHdoZW4gdGhlIGZyYWdtZW50IGNoYW5nZXMuIFJvdXRlcyBhZGRlZCBsYXRlclxuICAgIC8vIG1heSBvdmVycmlkZSBwcmV2aW91cyByb3V0ZXMuXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KHtyb3V0ZTogcm91dGUsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcyxcbiAgICAvLyBjYWxscyBgbG9hZFVybGAsIG5vcm1hbGl6aW5nIGFjcm9zcyB0aGUgaGlkZGVuIGlmcmFtZS5cbiAgICBjaGVja1VybDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHByZXNzZWQgdGhlIGJhY2sgYnV0dG9uLCB0aGUgaWZyYW1lJ3MgaGFzaCB3aWxsIGhhdmVcbiAgICAgIC8vIGNoYW5nZWQgYW5kIHdlIHNob3VsZCB1c2UgdGhhdCBmb3IgY29tcGFyaXNvbi5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxuICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICBsb2FkVXJsOiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgZG9lc24ndCBtYXRjaCwgbm8gcm91dGVzIGNhbiBtYXRjaCBlaXRoZXIuXG4gICAgICBpZiAoIXRoaXMubWF0Y2hSb290KCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uc29tZSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGZyYWdtZW50LlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50IHx8ICcnKTtcblxuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBhIHRyYWlsaW5nIHNsYXNoIG9uIHRoZSByb290LlxuICAgICAgdmFyIHJvb3RQYXRoID0gdGhpcy5yb290O1xuICAgICAgaWYgKGZyYWdtZW50ID09PSAnJyB8fCBmcmFnbWVudC5jaGFyQXQoMCkgPT09ICc/Jykge1xuICAgICAgICByb290UGF0aCA9IHJvb3RQYXRoLnNsaWNlKDAsIC0xKSB8fCAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgdXJsID0gcm9vdFBhdGggKyBmcmFnbWVudDtcblxuICAgICAgLy8gU3RyaXAgdGhlIGZyYWdtZW50IG9mIHRoZSBxdWVyeSBhbmQgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgIC8vIERlY29kZSBmb3IgbWF0Y2hpbmcuXG4gICAgICB2YXIgZGVjb2RlZEZyYWdtZW50ID0gdGhpcy5kZWNvZGVGcmFnbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBkZWNvZGVkRnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBkZWNvZGVkRnJhZ21lbnQ7XG5cbiAgICAgIC8vIElmIHB1c2hTdGF0ZSBpcyBhdmFpbGFibGUsIHdlIHVzZSBpdCB0byBzZXQgdGhlIGZyYWdtZW50IGFzIGEgcmVhbCBVUkwuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVtvcHRpb25zLnJlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSh7fSwgZG9jdW1lbnQudGl0bGUsIHVybCk7XG5cbiAgICAgIC8vIElmIGhhc2ggY2hhbmdlcyBoYXZlbid0IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCwgdXBkYXRlIHRoZSBoYXNoXG4gICAgICAvLyBmcmFnbWVudCB0byBzdG9yZSBoaXN0b3J5LlxuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgaWYgKHRoaXMuaWZyYW1lICYmIGZyYWdtZW50ICE9PSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykpIHtcbiAgICAgICAgICB2YXIgaVdpbmRvdyA9IHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cbiAgICAgICAgICAvLyBPcGVuaW5nIGFuZCBjbG9zaW5nIHRoZSBpZnJhbWUgdHJpY2tzIElFNyBhbmQgZWFybGllciB0byBwdXNoIGFcbiAgICAgICAgICAvLyBoaXN0b3J5IGVudHJ5IG9uIGhhc2gtdGFnIGNoYW5nZS4gIFdoZW4gcmVwbGFjZSBpcyB0cnVlLCB3ZSBkb24ndFxuICAgICAgICAgIC8vIHdhbnQgdGhpcy5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgICAgICBpV2luZG93LmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaChpV2luZG93LmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBJZiB5b3UndmUgdG9sZCB1cyB0aGF0IHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgZmFsbGJhY2sgaGFzaGNoYW5nZS1cbiAgICAgIC8vIGJhc2VkIGhpc3RvcnksIHRoZW4gYG5hdmlnYXRlYCBiZWNvbWVzIGEgcGFnZSByZWZyZXNoLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50cmlnZ2VyKSByZXR1cm4gdGhpcy5sb2FkVXJsKGZyYWdtZW50KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIHRoZSBoYXNoIGxvY2F0aW9uLCBlaXRoZXIgcmVwbGFjaW5nIHRoZSBjdXJyZW50IGVudHJ5LCBvciBhZGRpbmdcbiAgICAvLyBhIG5ldyBvbmUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24obG9jYXRpb24sIGZyYWdtZW50LCByZXBsYWNlKSB7XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICB2YXIgaHJlZiA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKGphdmFzY3JpcHQ6fCMpLiokLywgJycpO1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGhyZWYgKyAnIycgKyBmcmFnbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJlcXVpcmUgdGhhdCBgaGFzaGAgY29udGFpbnMgYSBsZWFkaW5nICMuXG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBmcmFnbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IEJhY2tib25lLmhpc3RvcnkuXG4gIEJhY2tib25lLmhpc3RvcnkgPSBuZXcgSGlzdG9yeTtcblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGZvciBzdWJjbGFzc2VzLlxuICAvLyBTaW1pbGFyIHRvIGBnb29nLmluaGVyaXRzYCwgYnV0IHVzZXMgYSBoYXNoIG9mIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFuZFxuICAvLyBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGV4dGVuZGVkLlxuICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3Rvci5cbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xuICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICB9XG5cbiAgICAvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cbiAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XG5cbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xuICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24gYW5kIGFkZCB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgY2hpbGQucHJvdG90eXBlID0gXy5jcmVhdGUocGFyZW50LnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG5cbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBTZXQgdXAgaW5oZXJpdGFuY2UgZm9yIHRoZSBtb2RlbCwgY29sbGVjdGlvbiwgcm91dGVyLCB2aWV3IGFuZCBoaXN0b3J5LlxuICBNb2RlbC5leHRlbmQgPSBDb2xsZWN0aW9uLmV4dGVuZCA9IFJvdXRlci5leHRlbmQgPSBWaWV3LmV4dGVuZCA9IEhpc3RvcnkuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gIC8vIFRocm93IGFuIGVycm9yIHdoZW4gYSBVUkwgaXMgbmVlZGVkLCBhbmQgbm9uZSBpcyBzdXBwbGllZC5cbiAgdmFyIHVybEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFwidXJsXCIgcHJvcGVydHkgb3IgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgfTtcblxuICAvLyBXcmFwIGFuIG9wdGlvbmFsIGVycm9yIGNhbGxiYWNrIHdpdGggYSBmYWxsYmFjayBlcnJvciBldmVudC5cbiAgdmFyIHdyYXBFcnJvciA9IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgaWYgKGVycm9yKSBlcnJvci5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG59KTtcbiJdLCJuYW1lcyI6WyJmYWN0b3J5Iiwicm9vdCIsInNlbGYiLCJnbG9iYWwiLCJkZWZpbmUiLCJhbWQiLCJfIiwiJCIsImV4cG9ydHMiLCJCYWNrYm9uZSIsInJlcXVpcmUiLCJlIiwialF1ZXJ5IiwiWmVwdG8iLCJlbmRlciIsInByZXZpb3VzQmFja2JvbmUiLCJzbGljZSIsIkFycmF5IiwicHJvdG90eXBlIiwiVkVSU0lPTiIsIm5vQ29uZmxpY3QiLCJlbXVsYXRlSFRUUCIsImVtdWxhdGVKU09OIiwiRXZlbnRzIiwiZXZlbnRTcGxpdHRlciIsIl9saXN0ZW5pbmciLCJldmVudHNBcGkiLCJpdGVyYXRlZSIsImV2ZW50cyIsIm5hbWUiLCJjYWxsYmFjayIsIm9wdHMiLCJpIiwibmFtZXMiLCJjb250ZXh0Iiwia2V5cyIsImxlbmd0aCIsInRlc3QiLCJzcGxpdCIsIm9uIiwiX2V2ZW50cyIsIm9uQXBpIiwiY3R4IiwibGlzdGVuaW5nIiwibGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsImlkIiwiaW50ZXJvcCIsImxpc3RlblRvIiwib2JqIiwiX2xpc3RlbklkIiwidW5pcXVlSWQiLCJsaXN0ZW5pbmdUbyIsIl9saXN0ZW5pbmdUbyIsIkxpc3RlbmluZyIsImVycm9yIiwidHJ5Q2F0Y2hPbiIsIm9wdGlvbnMiLCJoYW5kbGVycyIsImNvdW50IiwicHVzaCIsIm9mZiIsIm9mZkFwaSIsInN0b3BMaXN0ZW5pbmciLCJpZHMiLCJpc0VtcHR5IiwiY2xlYW51cCIsInJlbWFpbmluZyIsImoiLCJoYW5kbGVyIiwiX2NhbGxiYWNrIiwib25jZSIsIm9uY2VNYXAiLCJiaW5kIiwibGlzdGVuVG9PbmNlIiwibWFwIiwib2ZmZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyaWdnZXIiLCJNYXRoIiwibWF4IiwiYXJncyIsInRyaWdnZXJBcGkiLCJvYmpFdmVudHMiLCJhbGxFdmVudHMiLCJhbGwiLCJ0cmlnZ2VyRXZlbnRzIiwiY29uY2F0IiwiZXYiLCJsIiwiYTEiLCJhMiIsImEzIiwiY2FsbCIsImxpc3RlbmVyIiwidW5iaW5kIiwiZXh0ZW5kIiwiTW9kZWwiLCJhdHRyaWJ1dGVzIiwiYXR0cnMiLCJwcmVpbml0aWFsaXplIiwiY2lkIiwiY2lkUHJlZml4IiwiY29sbGVjdGlvbiIsInBhcnNlIiwiZGVmYXVsdHMiLCJyZXN1bHQiLCJzZXQiLCJjaGFuZ2VkIiwiaW5pdGlhbGl6ZSIsInZhbGlkYXRpb25FcnJvciIsImlkQXR0cmlidXRlIiwidG9KU09OIiwiY2xvbmUiLCJzeW5jIiwiZ2V0IiwiYXR0ciIsImVzY2FwZSIsImhhcyIsIm1hdGNoZXMiLCJrZXkiLCJ2YWwiLCJfdmFsaWRhdGUiLCJ1bnNldCIsInNpbGVudCIsImNoYW5nZXMiLCJjaGFuZ2luZyIsIl9jaGFuZ2luZyIsIl9wcmV2aW91c0F0dHJpYnV0ZXMiLCJjdXJyZW50IiwicHJldiIsImlzRXF1YWwiLCJwcmV2SWQiLCJfcGVuZGluZyIsImNsZWFyIiwiaGFzQ2hhbmdlZCIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiZGlmZiIsIm9sZCIsInByZXZpb3VzIiwicHJldmlvdXNBdHRyaWJ1dGVzIiwiZmV0Y2giLCJtb2RlbCIsInN1Y2Nlc3MiLCJyZXNwIiwic2VydmVyQXR0cnMiLCJ3cmFwRXJyb3IiLCJzYXZlIiwidmFsaWRhdGUiLCJ3YWl0IiwibWV0aG9kIiwiaXNOZXciLCJwYXRjaCIsInhociIsImRlc3Ryb3kiLCJkZWZlciIsInVybCIsImJhc2UiLCJ1cmxFcnJvciIsInJlcGxhY2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsImlzVmFsaWQiLCJDb2xsZWN0aW9uIiwibW9kZWxzIiwiY29tcGFyYXRvciIsIl9yZXNldCIsInJlc2V0Iiwic2V0T3B0aW9ucyIsImFkZCIsInJlbW92ZSIsIm1lcmdlIiwiYWRkT3B0aW9ucyIsInNwbGljZSIsImFycmF5IiwiaW5zZXJ0IiwiYXQiLCJtaW4iLCJ0YWlsIiwic2luZ3VsYXIiLCJpc0FycmF5IiwicmVtb3ZlZCIsIl9yZW1vdmVNb2RlbHMiLCJhZGRlZCIsIm1lcmdlZCIsIl9pc01vZGVsIiwidG9BZGQiLCJ0b01lcmdlIiwidG9SZW1vdmUiLCJtb2RlbE1hcCIsInNvcnQiLCJzb3J0YWJsZSIsInNvcnRBdHRyIiwiaXNTdHJpbmciLCJleGlzdGluZyIsIl9wcmVwYXJlTW9kZWwiLCJfYWRkUmVmZXJlbmNlIiwib3JkZXJDaGFuZ2VkIiwic29tZSIsIm0iLCJpbmRleCIsIl9yZW1vdmVSZWZlcmVuY2UiLCJwcmV2aW91c01vZGVscyIsInBvcCIsInVuc2hpZnQiLCJzaGlmdCIsIl9ieUlkIiwibW9kZWxJZCIsIndoZXJlIiwiZmlyc3QiLCJmaW5kV2hlcmUiLCJFcnJvciIsImlzRnVuY3Rpb24iLCJzb3J0QnkiLCJwbHVjayIsImNyZWF0ZSIsImNhbGxiYWNrT3B0cyIsInZhbHVlcyIsIkNvbGxlY3Rpb25JdGVyYXRvciIsIklURVJBVE9SX1ZBTFVFUyIsIklURVJBVE9SX0tFWVMiLCJlbnRyaWVzIiwiSVRFUkFUT1JfS0VZU1ZBTFVFUyIsImluZGV4T2YiLCJfb25Nb2RlbEV2ZW50IiwiZXZlbnQiLCIkJGl0ZXJhdG9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJraW5kIiwiX2NvbGxlY3Rpb24iLCJfa2luZCIsIl9pbmRleCIsIm5leHQiLCJ2YWx1ZSIsImRvbmUiLCJWaWV3IiwicGljayIsInZpZXdPcHRpb25zIiwiX2Vuc3VyZUVsZW1lbnQiLCJkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIiLCJ0YWdOYW1lIiwic2VsZWN0b3IiLCIkZWwiLCJmaW5kIiwicmVuZGVyIiwiX3JlbW92ZUVsZW1lbnQiLCJzZXRFbGVtZW50IiwiZWxlbWVudCIsInVuZGVsZWdhdGVFdmVudHMiLCJfc2V0RWxlbWVudCIsImRlbGVnYXRlRXZlbnRzIiwiZWwiLCJtYXRjaCIsImRlbGVnYXRlIiwiZXZlbnROYW1lIiwidW5kZWxlZ2F0ZSIsIl9jcmVhdGVFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiX3NldEF0dHJpYnV0ZXMiLCJhZGRNZXRob2QiLCJhdHRyaWJ1dGUiLCJjYiIsImRlZmF1bHRWYWwiLCJhZGRVbmRlcnNjb3JlTWV0aG9kcyIsIkNsYXNzIiwibWV0aG9kcyIsImVhY2giLCJpbnN0YW5jZSIsImlzT2JqZWN0IiwibW9kZWxNYXRjaGVyIiwibWF0Y2hlciIsImNvbGxlY3Rpb25NZXRob2RzIiwiZm9yRWFjaCIsImNvbGxlY3QiLCJyZWR1Y2UiLCJmb2xkbCIsImluamVjdCIsInJlZHVjZVJpZ2h0IiwiZm9sZHIiLCJkZXRlY3QiLCJmaWx0ZXIiLCJzZWxlY3QiLCJyZWplY3QiLCJldmVyeSIsImFueSIsImluY2x1ZGUiLCJpbmNsdWRlcyIsImNvbnRhaW5zIiwiaW52b2tlIiwidG9BcnJheSIsInNpemUiLCJoZWFkIiwidGFrZSIsImluaXRpYWwiLCJyZXN0IiwiZHJvcCIsImxhc3QiLCJ3aXRob3V0IiwiZGlmZmVyZW5jZSIsInNodWZmbGUiLCJsYXN0SW5kZXhPZiIsImNoYWluIiwic2FtcGxlIiwicGFydGl0aW9uIiwiZ3JvdXBCeSIsImNvdW50QnkiLCJpbmRleEJ5IiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsIm1vZGVsTWV0aG9kcyIsInBhaXJzIiwiaW52ZXJ0Iiwib21pdCIsImNvbmZpZyIsIkJhc2UiLCJtaXhpbiIsIm1hcHBpbmdzIiwiZnVuY3Rpb25zIiwibWVtbyIsInR5cGUiLCJtZXRob2RNYXAiLCJwYXJhbXMiLCJkYXRhVHlwZSIsImRhdGEiLCJjb250ZW50VHlwZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJfbWV0aG9kIiwiYmVmb3JlU2VuZCIsInNldFJlcXVlc3RIZWFkZXIiLCJwcm9jZXNzRGF0YSIsInRleHRTdGF0dXMiLCJlcnJvclRocm93biIsImFqYXgiLCJSb3V0ZXIiLCJyb3V0ZXMiLCJfYmluZFJvdXRlcyIsIm9wdGlvbmFsUGFyYW0iLCJuYW1lZFBhcmFtIiwic3BsYXRQYXJhbSIsImVzY2FwZVJlZ0V4cCIsInJvdXRlIiwiaXNSZWdFeHAiLCJfcm91dGVUb1JlZ0V4cCIsInJvdXRlciIsImhpc3RvcnkiLCJmcmFnbWVudCIsIl9leHRyYWN0UGFyYW1ldGVycyIsImV4ZWN1dGUiLCJuYXZpZ2F0ZSIsIm9wdGlvbmFsIiwiUmVnRXhwIiwiZXhlYyIsInBhcmFtIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiSGlzdG9yeSIsImNoZWNrVXJsIiwibG9jYXRpb24iLCJ3aW5kb3ciLCJyb3V0ZVN0cmlwcGVyIiwicm9vdFN0cmlwcGVyIiwicGF0aFN0cmlwcGVyIiwic3RhcnRlZCIsImludGVydmFsIiwiYXRSb290IiwicGF0aCIsInBhdGhuYW1lIiwiZ2V0U2VhcmNoIiwibWF0Y2hSb290IiwiZGVjb2RlRnJhZ21lbnQiLCJyb290UGF0aCIsImRlY29kZVVSSSIsImhyZWYiLCJnZXRIYXNoIiwiZ2V0UGF0aCIsImNoYXJBdCIsImdldEZyYWdtZW50IiwiX3VzZVB1c2hTdGF0ZSIsIl93YW50c0hhc2hDaGFuZ2UiLCJzdGFydCIsImhhc2hDaGFuZ2UiLCJfaGFzSGFzaENoYW5nZSIsImRvY3VtZW50TW9kZSIsIl91c2VIYXNoQ2hhbmdlIiwiX3dhbnRzUHVzaFN0YXRlIiwicHVzaFN0YXRlIiwiX2hhc1B1c2hTdGF0ZSIsImlmcmFtZSIsInNyYyIsInN0eWxlIiwiZGlzcGxheSIsInRhYkluZGV4IiwiYm9keSIsImlXaW5kb3ciLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJjbG9zZSIsImhhc2giLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJfY2hlY2tVcmxJbnRlcnZhbCIsInNldEludGVydmFsIiwibG9hZFVybCIsInN0b3AiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJyZW1vdmVDaGlsZCIsImNsZWFySW50ZXJ2YWwiLCJkZWNvZGVkRnJhZ21lbnQiLCJ0aXRsZSIsIl91cGRhdGVIYXNoIiwiYXNzaWduIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicGFyZW50IiwiY2hpbGQiLCJfX3N1cGVyX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/backbone/backbone.js\n");

/***/ })

};
;